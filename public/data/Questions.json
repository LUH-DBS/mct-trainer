[{"id": 414, "category": 1, "difficulty": 1, "text": "ANSI-3-Ebenen-Modell: Die Organisation der physischen Speicherung wird ge\u00e4ndert.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft keine Ebene.", "solution": "false"}]}, {"id": 685, "category": 1, "difficulty": 1, "text": "Das konzeptionelles Schema ist", "explanation": "Das konzeptionelle Schema ist Bestandteil der konzeptionenn Ebene des ANSI-3-Ebenen-Modells und daher unabh\u00e4ngig vom eingesetzten konkreten Datenbanksystem.", "type": "multiple-choice", "answers": [{"text": "unabh\u00e4ngig vom eingesetzten Datenbanksystem", "solution": "true"}, {"text": "abh\u00e4ngig vom eingesetzten Datenbanksystem", "solution": "false"}]}, {"id": 406, "category": 1, "difficulty": 2, "text": "In einer Datenbank sollen alle Daten widerspruchsfrei gespeichert werden.", "explanation": "Das ist die Definition von konsistenten Daten.", "type": "text", "answers": [{"text": "Diese Eigenschaft nennt man:", "solution": "Konsistenz"}]}, {"id": 407, "category": 1, "difficulty": 1, "text": "Bei welchem Datenmodell werden die Daten in einem Baum gespeichert?", "explanation": "Ein hierarchisches Datenbankmodell ist historisch gesehen das \u00e4lteste Datenbankmodell, es bildet die reale Welt durch eine hierarchische Baumstruktur ab und wurde sp\u00e4ter Grundlage des Netzwerkdatenmodells. Es entstand schon in den 50er Jahren und wurde Grundlage des Systems IMS/DB der Firma IBM. \nHeutzutage erlebt die hierarchische Datenspeicherung eine Renaissance in Verbindung mit XML-Datenbanken.", "type": "multiple-choice", "answers": [{"text": "Relationales Datenmodell", "solution": "false"}, {"text": "Hierarchisches Datenmodell", "solution": "true"}, {"text": "Netzwerkdatenmodell", "solution": "false"}]}, {"id": 511, "category": 1, "difficulty": 2, "text": "Daten sollen in einer Datenbank nicht mehrfach gespeichert werden.", "explanation": "Unter Redundanz versteht man die Mehrfachspeicherung von Daten in unterschiedlichen Dateien. Werden an unterschiedlichen Stellen in einem Unternehmen entsprechende Daten dezentral erfasst und verarbeitet, lassen sich diese Anspr\u00fcche ohne zus\u00e4tzliche Logistik kaum realisieren.", "type": "text", "answers": [{"text": "Diese Eigenschaft nennt man:", "solution": "redundanzfrei"}]}, {"id": 512, "category": 1, "difficulty": 3, "text": "Ein Datenbanksystem besteht aus", "explanation": "Ein Datenbanksystem (DBS) ist eine Ansammlung von Daten, die allen Benutzern bzw. Anwendungen zur Verf\u00fcgung steht und in der die Daten nach einheitlichen Regeln abgespeichert werden. Ein Datenbanksystem besteht aus einer Datenbasis und einem Datenbankmanagementsystem. Der Begriff der Datenbank wird synonym verwendet.", "type": "multiple-choice", "answers": [{"text": "Datenbasis", "solution": "true"}, {"text": "Datenmodell", "solution": "false"}, {"text": "Anwendungsprogrammen", "solution": "false"}, {"text": "Data Dictionary", "solution": "true"}, {"text": "Verwaltungssoftware f\u00fcr die Datenbasis (DBMS)", "solution": "true"}, {"text": "Metadaten", "solution": "true"}]}, {"id": 515, "category": 1, "difficulty": 1, "text": "Welches Datenmodell ist in einer Baumstruktur organisiert?", "explanation": "Das hierarchisches Datenbankmodell ist das \u00e4lteste Datenbankmodell, es bildet die reale Welt durch eine hierarchische Baumstruktur ab und wurde sp\u00e4ter Grundlage des Netzwerkdatenmodells. Es entstand schon in den 60erJahren und wurde Grundlage des Systems IMS/DB der Firma IBM. Heutzutage erlebt die hierarchische Datenspeicherung eine Renaissance in Verbindung mit XML.", "type": "multiple-choice", "answers": [{"text": "Relationales Modell", "solution": "false"}, {"text": "Netzwerkdatenmodell", "solution": "false"}, {"text": "Hierarchisches Datenmodell", "solution": "true"}, {"text": "B-Baum-Modell", "solution": "false"}]}, {"id": 530, "category": 1, "difficulty": 2, "text": "Die Programme sind von der internen Organisation der Daten und den Zugriffsm\u00f6glichkeiten \u00fcber Zugriffspfade unabh\u00e4ngig.", "explanation": "Das ist die Definition der physische Datenunabh\u00e4ngigkeit.", "type": "multiple-choice", "answers": [{"text": "Diese Eigenschaft nennt man vertikale, logische  Datenunabh\u00e4ngigkeit.", "solution": "false"}, {"text": "Diese Eigenschaft nennt man horizontale, logische Datenunabh\u00e4ngigkeit.", "solution": "false"}, {"text": "Diese Eigenschaft nennt man physische Datenunabh\u00e4ngigkeit.", "solution": "true"}]}, {"id": 517, "category": 1, "difficulty": 2, "text": "Bei welchem Datenmodell werden Adressverweise in der Datenbank gespeichert?", "explanation": "Bis auf die relationalen Datenbanken war es bei \u00e4lteren Systemen, also den Netzwerkdatenbanken und den hierachischen Datenbanken, \u00fcblich, neben den Daten selber auch phyikalische Adressverweise in der Datenbank zu speichern.", "type": "multiple-choice", "answers": [{"text": "Hierarchisches Modell", "solution": "true"}, {"text": "Objektorientiertes Modell", "solution": "false"}, {"text": "Relationales Modell", "solution": "false"}, {"text": "Netzwerk-Datenmodell", "solution": "true"}]}, {"id": 529, "category": 1, "difficulty": 1, "text": "Programme sind stabil gegen\u00fcber \u00c4nderungen in anderen Programmen, die Anwendungsprogramme sind untereinander unabh\u00e4ngig.", "explanation": "Diese Eigenschaft ist die Definition der horizontalen, logischen Datenunabh\u00e4ngigkeit.", "type": "multiple-choice", "answers": [{"text": "Diese Eigenschaft nennt man vertikale, logische  Datenunabh\u00e4ngigkeit.", "solution": "false"}, {"text": "Diese Eigenschaft nennt man horizontale, logische  Datenunabh\u00e4ngigkeit.", "solution": "true"}, {"text": "Diese Eigenschaft nennt man physische Datenunabh\u00e4ngigkeit.", "solution": "false"}]}, {"id": 629, "category": 1, "difficulty": 3, "text": "Welche Datenbanksysteme sind auf das Suchen in unformatierten Datenbest\u00e4nden spezialisiert?", "explanation": "Information Retrieval ist ein Fachgebiet, das sich mit computergest\u00fctztem inhaltsorientiertem Suchen in unfomatierten Daten besch\u00e4ftigt. \nEs ist ein Teilgebiet der Informationswissenschaft, der Computerlinguistik wie auch der Informatik.", "type": "text", "answers": [{"text": "Das ist ein (englischer Begriff)", "solution": "Information Retrieval System"}]}, {"id": 1767, "category": 1, "difficulty": 1, "text": "In einer Datenbank sollen die Daten auch nach Beendigung aller Programme dauerhaft gespeichert werden. Diese Eigenschaft einer Datenbank nennt man:", "explanation": "Das ist die Definition der Datenbankpersistenz.", "type": "multiple-choice", "answers": [{"text": "Persistenz", "solution": "true"}, {"text": "Konsistenz", "solution": "false"}]}, {"id": 1074, "category": 1, "difficulty": 1, "text": "Wie nennt man ein Softwaresystem zur Verwaltung einer Datenbasis?", "explanation": "Ein DBS (Datenbanksystem) besteht aus zwei Teilen: dem Datenbankmanagementsystem (DBMS) und der Menge der zu verwaltenden Daten, der eigentlichen Datenbank. \nDas DBMS organisiert intern die strukturierte Speicherung der Daten und kontrolliert alle lesenden und schreibenden Zugriffe auf die Datenbank. \nZur Abfrage und Verwaltung der Daten bietet ein Datenbanksystem eine Datenbanksprache an.", "type": "text", "answers": [{"text": "Das ist ein (Abk\u00fcrzung)", "solution": "DBMS"}]}, {"id": 1075, "category": 1, "difficulty": 1, "text": "Welche Typen von Datenbanken gibt es?", "explanation": "Eine m\u00f6gliche Einteilung der Datenbanken basiert auf der Art der Anwendung. Datenbanken werden in kommerzielle, betriebswirtschaftlich/administrativ ausgerichtete Standardsysteme und neuartige Systeme unterschieden. Kommerzielle Datenbanken sind durch gut formatierte Datenbest\u00e4nde und die Verwendung von Standardsystemen gekennzeichnet. Neben diesen Datenverwaltungssystemen geh\u00f6ren auch noch Recherchesysteme zur Suche in gro\u00dfen, unformatierten Datenbest\u00e4nden zu den kommerziellen Datenbanksystemen.\n\nNeuartige Anwendungen sind durch komplexe Datentypen, Multimediadatentypen und die Anforderungen, die sich aus einer objektorientierten Analyse ergeben (z.B. Vererbung, Kapselung von Methoden), gekennzeichnet. Typische Anwendungsfelder\nsind Geoinformationssysteme, Multimediadatenbanken oder die Unterst\u00fctzung technischer\nAnwendungen. \n\nEine andere Einteilung ist die Typisierung von Datenbanksystemen \u00fcber das Datenmodell. Ein Datenmodell ist eine festgelegte Struktur mit eigenen Begriffen, nach der Daten und ihre Beziehungen untereinander gespeichert werden. Man unterscheidet historisch gesehen zwischen hierarchischen Datenmodellen, Netzwerkdatenmodellen, relationalen Datenmodellen und objektorientierten Datenmodellen.", "type": "multiple-choice", "answers": [{"text": "Hierarchische Datenbanken", "solution": "true"}, {"text": "Grafische Datenbanken", "solution": "false"}, {"text": "Relationale Datenbanken", "solution": "true"}, {"text": "Objektorientierte Datenbanken", "solution": "true"}, {"text": "Parse-Datenbanken", "solution": "false"}, {"text": "Netzwerkdatenbanken", "solution": "true"}]}, {"id": 2101, "category": 1, "difficulty": 3, "text": "Welche Aussagen \u00fcber ein Datenmodell sind wahr?", "explanation": "Ein Datenmodell stellt einen allgemeinen Begriffsapparat zur Verf\u00fcgung, der es gestattet, Realit\u00e4tsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren. Mit dem Datenmodell werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, \u00e4hnlich wie bei einer Programmiersprache, in der auch Ausdr\u00fccke und Regeln festgelegt sind, die in der Programmiersprache\nbenutzt werden d\u00fcrfen.  \n\nEin Datenmodell hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.", "type": "multiple-choice", "answers": [{"text": "Ein Datenmodell stellt einen allgemeinen Begriffsapparat zur Verf\u00fcgung, der es gestattet, Realit\u00e4tsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren.", "solution": "true"}, {"text": "Mit dem Datenmodell werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, \u00e4hnlich wie bei einer Programmiersprache, in der auch Ausdr\u00fccke und Regeln festgelegt sind, die in der Programmiersprache benutzt werden d\u00fcrfen.", "solution": "true"}, {"text": "Ein Datenmodell ist die konkrete Auspr\u00e4gung eines bestimmten Datenbankschemas mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.", "solution": "false"}, {"text": "Ein Datenmodell hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.", "solution": "true"}, {"text": "Bei einem Datenmodell werden die Daten in Dateien gespeichert, die nur von einem Programm genutzt werden.", "solution": "false"}]}, {"id": 2098, "category": 1, "difficulty": 2, "text": "ANSI-3-Ebenen-Modell: Was geh\u00f6rt zur externen Ebene?", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "physische Datenstruktur", "solution": "false"}, {"text": "konzeptionelles Schema", "solution": "false"}, {"text": "Anwendungen", "solution": "true"}, {"text": "Datenbankschema", "solution": "false"}]}, {"id": 2099, "category": 1, "difficulty": 1, "text": "ANSI-3-Ebenen-Modell: Was geh\u00f6rt zur internen Ebene?", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "externe Datenstruktur", "solution": "false"}, {"text": "physische Datenstruktur", "solution": "true"}, {"text": "konzeptionelles Schema", "solution": "false"}, {"text": "Anwendungen", "solution": "false"}, {"text": "Datenbankschema", "solution": "false"}]}, {"id": 2100, "category": 1, "difficulty": 1, "text": "ANSI-3-Ebenen-Modell: Was geh\u00f6rt zur konzeptionellen Ebene?", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "externe Datenstruktur", "solution": "false"}, {"text": "physische Datenstruktur", "solution": "false"}, {"text": "konzeptionelles Schema", "solution": "true"}, {"text": "Anwendungen", "solution": "false"}, {"text": "Datenbankschema", "solution": "true"}]}, {"id": 1744, "category": 1, "difficulty": 3, "text": "ANSI-3-Ebenen-Modell: Ein Anwendungsprogramm wird entwickelt, das neue, zus\u00e4tzliche Datenstrukturen ben\u00f6tigt.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft keine Ebene.", "solution": "false"}]}, {"id": 1658, "category": 1, "difficulty": 1, "text": "Die Anwenderprogramme sind nicht von den Daten abh\u00e4ngig. Programme sollen anwendungsstabil gegen\u00fcber der \u00c4nderung der Datenstrukturen sein.", "explanation": "Das ist die Definition der vertikalen, logischen Datenunabh\u00e4ngigkeit.", "type": "multiple-choice", "answers": [{"text": "Diese Eigenschaft nennt man vertikale, logische Datenunabh\u00e4ngigkeit.", "solution": "true"}, {"text": "Diese Eigenschaft nennt man physische Datenunabh\u00e4ngigkeit.", "solution": "false"}, {"text": "Diese Eigenschaft nennt man horizontale, logische Datenunabh\u00e4ngigkeit.", "solution": "false"}]}, {"id": 1791, "category": 1, "difficulty": 2, "text": "Welche Aussagen \u00fcber eine Datenbank sind richtig?", "explanation": "Ein DBS (Datenbanksystem) besteht aus zwei Teilen: dem Datenbankmanagementsystem (DBMS) und der Menge der zu verwaltenden Daten, der eigentlichen Datenbank. \nDas DBMS organisiert intern die strukturierte Speicherung der Daten und kontrolliert alle lesenden und schreibenden Zugriffe auf die Datenbank. \nZur Abfrage und Verwaltung der Daten bietet ein Datenbanksystem eine Datenbanksprache an. Daher ist DBS = Datenbasi + DBMS richtig.", "type": "multiple-choice", "answers": [{"text": "DBS = Datenbasis + DBMS", "solution": "true"}, {"text": "DBS ist die Abk\u00fcrzung f\u00fcr Datenbasis", "solution": "false"}, {"text": "Als Datenbasis werden die nach einheitlichen Regeln in einem DBS persistent gespeicherten Daten bezeichnet", "solution": "true"}, {"text": "DBMS = DBS + Datenbasis", "solution": "false"}, {"text": "Das DBMS liegt in der Funktionalit\u00e4t zwischen Anwendungsprogrammen und Betriebssystem", "solution": "true"}]}, {"id": 1684, "category": 1, "difficulty": 1, "text": "Welche Aufgabe hat ein SQL-Parser?", "explanation": "Ein SQL-Parser verarbeitet die Eingaben des Benutzers, indem er die Syntax, z.B. Verwendung von Schl\u00fcsselw\u00f6rtern anlysiert.\nSo w\u00fcrde z.B. \"SLECT\" anstelle von \"SELECT\" zur\u00fcckgewiesen.", "type": "multiple-choice", "answers": [{"text": "Ein SQL-Parser \u00fcbersetzt SQL-Anteile in eine Programmiersprache, wie z.B. C.", "solution": "false"}, {"text": "Der SQL-Parser analysiert die Syntax, z.B. die korrekte Verwendung von Schl\u00fcsselw\u00f6rtern.", "solution": "true"}]}, {"id": 2947, "category": 1, "difficulty": 1, "text": "In einer Datenbank sollen alle Daten widerspruchsfrei gespeichert werden. Diese Eigenschaft nennt man:", "explanation": "Das ist die Definition von konsistenten Daten.", "type": "multiple-choice", "answers": [{"text": "Konsistenz", "solution": "true"}, {"text": "Persistenz", "solution": "false"}, {"text": "Renitenz", "solution": "false"}]}, {"id": 2102, "category": 1, "difficulty": 2, "text": "Welche Aussagen \u00fcber ein Datenbankschema sind wahr?", "explanation": "Ein Datenbankschema ist die konkrete Auspr\u00e4gung eines bestimmten Datenmodells mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.", "type": "multiple-choice", "answers": [{"text": "Ein Datenbankschema stellt einen allgemeinen Begriffsapparat zur Verf\u00fcgung, der es gestattet, Realit\u00e4tsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren.", "solution": "false"}, {"text": "Mit dem Datenbankschema werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, \u00e4hnlich wie bei einer Programmiersprache, in der auch Ausdr\u00fccke und Regeln festgelegt sind, die in der Programmiersprache benutzt werden d\u00fcrfen.", "solution": "false"}, {"text": "Ein Datenbankschema ist die konkrete Auspr\u00e4gung eines bestimmten Datenmodells mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.", "solution": "true"}, {"text": "Ein Datenbankschema hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.", "solution": "false"}, {"text": "Bei einem Datenbankschema werden die Daten in Dateien gespeichert, die nur von einem Programm genutzt werden.", "solution": "false"}]}, {"id": 1789, "category": 1, "difficulty": 2, "text": "ANSI-3-Ebenen-Modell: In einem Anwendungssystem werden neue Daten gespeichert oder bestehende gel\u00f6scht.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Keine Ebene ist betroffen.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "false"}]}, {"id": 1766, "category": 1, "difficulty": 1, "text": "Wann entstand das relationale Datenmodell?", "explanation": "Grundlagen des relationalen Datenmodells wurden vor allem mit den klassischen Arbeiten von E.F. Codd (1970 und 1972) gelegt. Daf\u00fcr wurde er 1999 mit dem Turing-Award ausgezeichnet. Das Entity-Relationship- Modell basiert auf einer Arbeit von P.P. Chen aus dem Jahre 1976. Die heute als B-B\u00e4ume relevanten Speicherstrukturen wurden von Bayer 1972 eingef\u00fchrt. Das Transaktionskonzept ist erstmals in Arbeiten zum System R3, einem Vorl\u00e4ufer von SQL (1976), beschrieben. Eine erste Analyse und systematische Darstellung von Transaktionen findet man in der Arbeit von Gray von 1981. Die 1970er Jahre kann man daher als eine Phase der wissenschaftlichen Formulierung der relationalen Datenbanktheorie bezeichnen, deren Umsetzung in die breite Anwendung erst in den 1980er Jahren erfolgte.", "type": "multiple-choice", "answers": [{"text": "50er Jahre", "solution": "false"}, {"text": "60er Jahre", "solution": "false"}, {"text": "70er Jahre", "solution": "true"}]}, {"id": 1076, "category": 1, "difficulty": 2, "text": "ANSI-3-Ebenen-Modell: In einer Datenbank werden neue Masken auf dem bestehenden Datenbestand entwickelt.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft keine Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "true"}]}, {"id": 1077, "category": 1, "difficulty": 1, "text": "Wie viele Ebenen hat das ANSI-Modell der Datenmodellierung?", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "drei", "solution": "true"}, {"text": "zwei", "solution": "false"}, {"text": "vier", "solution": "false"}]}, {"id": 2687, "category": 1, "difficulty": 1, "text": "ANSI-3-Ebenen-Modell: Die Organisation der physischen Speicherung wird ge\u00e4ndert.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft keine Ebene.", "solution": "false"}]}, {"id": 637, "category": 4, "difficulty": 3, "text": "Welche Komponenten geh\u00f6ren zu einem Datenbankschema?", "explanation": "In der Entwurfsphase wird das konzeptionelle Schema auf ein relationales Datenbankschema abgebildet und eine Normalisierung durchgef\u00fchrt. Das Datenbankschema ist ein auf den Datenbanktyp abgestimmtes Datenmodell, im relationalen Fall also ein relationales Schema, bestehend aus miteinander verkn\u00fcpften Relationen.\n\n    \n\n    Ferner wird das Schema erg\u00e4nzt um einzelne Benutzersichten, Indexangaben zur Zugriffsoptimierung und Speicherstrukturen, wie B-Baum, oder HASH- Verfahren sowie die Zugriffsrechte der Benutzer im Multiuser-System.", "type": "multiple-choice", "answers": [{"text": "Normalisierte Relationen", "solution": "true"}, {"text": "Prim\u00e4rschl\u00fcssel", "solution": "true"}, {"text": "Fremdschl\u00fcssel", "solution": "true"}, {"text": "Beziehungen", "solution": "false"}, {"text": "Wertebereiche der Attribute", "solution": "true"}, {"text": "Indizes", "solution": "true"}, {"text": "\u00dcberblick \u00fcber Zugriffsrechte", "solution": "true"}, {"text": "Spezielle Benutzersichten (Views)", "solution": "true"}, {"text": "SQL-Skripte", "solution": "false"}]}, {"id": 2017, "category": 5, "difficulty": 1, "text": "Welche Aussagen \u00fcber Beziehungen in ER-Modellen sind wahr?", "explanation": "In ERM ist eine Beziehung als Teilmenge des kartesischen Produkts der beteiligten Entity-Mengen definiert.", "type": "multiple-choice", "answers": [{"text": "Eine Beziehung ist eine Obermenge des kartesischen Produkts von Entity-Mengen.", "solution": "false"}, {"text": "Eine Beziehung ist eine Teilmenge des kartesischen Produkts von Entity-Mengen.", "solution": "true"}, {"text": "Eine Beziehung ist das kartesischen Produkts von Entity-Mengen.", "solution": "false"}]}, {"id": 1927, "category": 5, "difficulty": 1, "text": "Rekursive Beziehungen sind immer un\u00e4r.", "explanation": "Da rekursive Beziehungen von einer Entity-Menge auf sich selber definiert sind, sind sie un\u00e4r, d.h. nur eine Entity-Menge ist beteiligt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 422, "category": 5, "difficulty": 1, "text": "Rekursive Beziehungen sind in ER-Diagrammen erlaubt.", "explanation": "Im ER-Modell sind auch rekursive Beziehungen erlaubt, d.h. Beziehungen einer Entity-Menge auf sich selbst. Rekursive Beziehungen sind also immer un\u00e4r, da nur eine Entity-Menge beteiligt ist.  Mittels der Rekursion lassen sich z.B. Vorgesetzte, St\u00fccklisten oder Stammb\u00e4ume mit unbekannter Tiefe modellieren.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1119, "category": 5, "difficulty": 1, "text": "In obligatorischen Attributen (ER-Modell) sind NULL-Werte erlaubt.", "explanation": "Obligatorisch bedeutet, dass das Attribut einen Wert haben muss, also nicht NULL sein darf.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 544, "category": 5, "difficulty": 1, "text": "Von welchem Grad sind bin\u00e4re Beziehungen?", "explanation": "Das ist eine schwierige Frage :-), die an die  philosophische Fakult\u00e4t weitergegeben wurde.", "type": "text", "answers": [{"text": "Sie sind vom Grad (als Zahl eintragen):", "solution": "2"}]}, {"id": 450, "category": 5, "difficulty": 1, "text": "In ER-Diagrammen k\u00f6nnen Beziehungen auch Attribute haben.", "explanation": "Beziehungen in ER-Modellen k\u00f6nnen Attribute haben, auch wenn das viele grafische ER-Zeichentools leider nicht unterst\u00fctzen", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1131, "category": 5, "difficulty": 1, "text": "Welche Vorteile haben k\u00fcnstliche Schl\u00fcssel?", "explanation": "K\u00fcnstliche Schl\u00fcssel werden zum schnelleren Suchen benutzt und sind kein Abbild eines realen Attributs.", "type": "multiple-choice", "answers": [{"text": "Einfacher Indexaufbau", "solution": "true"}, {"text": "Besseres Abbild der Realit\u00e4t", "solution": "false"}, {"text": "Schnelleres Suchen", "solution": "true"}]}, {"id": 2040, "category": 5, "difficulty": 1, "text": "Ein Fremdschl\u00fcssel kann auch rekursiv definiert werden, d.h. der Prim\u00e4rschl\u00fcssel einer Entity-Menge kann als Fremdschl\u00fcssel in der gleichen Entity-Menge verwendet werden.", "explanation": "Diese Rekursivit\u00e4t ist im ER-Modell vorgesehen, auch wenn hier die Frage nach Henne und Ei ungel\u00f6st bleibt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2018, "category": 5, "difficulty": 3, "text": "Ein EERM enth\u00e4lt zus\u00e4tzlich zu den klassischen Beziehungsarten und Dom\u00e4nen", "explanation": "Ein ER-Modell, das zus\u00e4tzlich zu den klassischen Beziehungsarten IS-A-Beziehungen und Aggregation sowie mehrwertige und zusammengesetzte Attribute vorsieht, bezeichnen wir als EERM.", "type": "multiple-choice", "answers": [{"text": "Assoziationen", "solution": "false"}, {"text": "Aggregationen", "solution": "true"}, {"text": "IS-A-Beziehungen", "solution": "true"}, {"text": "mehrwertige Attribute", "solution": "true"}, {"text": "zusammengesetzte Attribute", "solution": "true"}, {"text": "zeitabh\u00e4ngige Attribute", "solution": "false"}, {"text": "IST-Teil-von-Beziehungen", "solution": "true"}]}, {"id": 2009, "category": 5, "difficulty": 3, "text": "Welche Aussagen \u00fcber schwache Entity-Mengen sind wahr?", "explanation": "Schwache Entity-Mengen h\u00e4ngen in ihrer Existenz von einer \u00fcbergeordneten Entity-Menge ab und haben einen (zusammengesetzten) Schl\u00fcssel, der den Prim\u00e4rschl\u00fcssel der \u00fcbergeordneten Entity-Menge als Teilschl\u00fcssel hat. Grafisch werden sie durch ein doppelt gezeichnetes Rechteck dargestellt. Da der Schl\u00fcssel der schwachen Entity-Mengen den \u00fcbergeordneten Prim\u00e4rschl\u00fcssel als Teilschl\u00fcssel enth\u00e4lt, ist die Beziehung zu Master-Entity-Menge immer identifizierend.", "type": "multiple-choice", "answers": [{"text": "Bei schwachen Entity-Mengen ist die Beziehung zur Master-Entity-Menge immer identifizierend.", "solution": "true"}, {"text": "Bei schwachen Entity-Mengen ist die Beziehung zur Master-Entity-Menge nie identifizierend.", "solution": "false"}, {"text": "Jede identifizierende Beziehung erzeugt eine schwache Entity-Menge.", "solution": "false"}, {"text": "Jede nicht identifizierende Beziehung erzeugt eine schwache Entity-Menge.", "solution": "false"}, {"text": "Jede schwache Entity-Menge hat einen zusammengesetzten Prim\u00e4rschl\u00fcssel.", "solution": "true"}]}, {"id": 1624, "category": 5, "difficulty": 1, "text": "Welche Aussagen \u00fcber Prim\u00e4rschl\u00fcssel sind wahr?", "explanation": "Prim\u00e4rschl\u00fcssel k\u00f6nnen aus einem oder mehreren Attributen bestehen und sind minimal in dem Sinne, dass sie aus einer minimalen Menge von Attributen bestehen, die eine Entit\u00e4t eindeutig identifizieren.", "type": "multiple-choice", "answers": [{"text": "Prim\u00e4rschl\u00fcssel bestehen immer aus einem einzelnen Attribut, z.B. einer fortlaufenden Nummer.", "solution": "false"}, {"text": "Prim\u00e4rschl\u00fcssel k\u00f6nnen auch aus mehreren Attributen zusammengesetzt sein.", "solution": "true"}, {"text": "Prim\u00e4rschl\u00fcssel sind eine minimale Menge von Attributen, die die zugeordnete Entit\u00e4t eindeutig identifizieren.", "solution": "true"}, {"text": "Prim\u00e4rschl\u00fcssel sind eine maximale Menge von Attributen, die die zugeordnete Entit\u00e4t eindeutig identifizieren.", "solution": "false"}, {"text": "Schl\u00fcsselattribute sind nicht obligatorisch, d.h. k\u00f6nnen auch einen NULL-Wert enthalten.", "solution": "false"}]}, {"id": 1743, "category": 5, "difficulty": 2, "text": "Welches/welche der folgenden Attribute einer Entitymenge \"Spiele (Heimmannschaft_id, Gastmannschaft_id, Spieltag, Ergebnis, Anzahl_Zuschauer,  Starttermin) sind notwendig f\u00fcr die Definition des Prim\u00e4rschl\u00fcssels, wenn die Daten der Fu\u00dfball-Bundesliga f\u00fcr mehrere Saisons gespeichert werden sollen? Gehen Sie dabei davon aus, dass eine Heimmannschaft nur einmal an einem Tag spielen kann. Kreuzen Sie aus den angegebene Attributen die Prim\u00e4rschl\u00fcsselattribute an!", "explanation": "Da eine Heimmannschaft nur einmal an einem Tag spielen kann, sind die Heimmannschaft und der Starttermin  ausreichend f\u00fcr den Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Spieltag (Wert: 1-34)", "solution": "false"}, {"text": "Heimmannschaft_ID", "solution": "true"}, {"text": "Ergebnis", "solution": "false"}, {"text": "Gastmannschaft_ID", "solution": "false"}, {"text": "Anzahl_Zuschauer", "solution": "false"}, {"text": "Starttermin (Datum und Uhrzeit des Anpfiffs)", "solution": "true"}]}, {"id": 1674, "category": 5, "difficulty": 2, "text": "K\u00fcnstliche Schl\u00fcssel haben folgende Vorteile:", "explanation": "Schl\u00fcssel sind definiert als Menge von Attributen einer Entity-Menge, die eine Entit\u00e4t eindeutig identifizieren. Eine Entity-Menge kann auch mehrere Schl\u00fcssel haben. Ein Angestellter z.B. l\u00e4sst sich \u00fcber seine Personalnummer wie auch \u00fcber die Attributkombination Name, Vorname, Adresse, Geburtsdatum identifizieren. Der letztgenannte Schl\u00fcssel ist ein Beispiel f\u00fcr einen zusammengesetzten Schl\u00fcssel. Bei der Modellierung wird ein Schl\u00fcssel als Prim\u00e4rschl\u00fcssel ausgezeichnet.\n\nZusammengesetzte Prim\u00e4rschl\u00fcssel sind in der Praxis schwer zu handhaben. Sobald sie als Fremdschl\u00fcssel in anderen Entity-Mengen auftreten, m\u00fcssen bei lesendem Zugriff \u00fcber diese Entitymenge und die Master-Entitymenge  immer alle Schl\u00fcsselattribute aufgef\u00fchrt werden. Werden Teile des Schl\u00fcssels bei der Programmierung vergessen, kann das schwerwiegende Folgen f\u00fcr die Korrektheit der L\u00f6sung haben. Ein Index \u00fcber mehrere Attribute hat au\u00dferdem den Nachteil, dass der Zugriff bei alternativen Attributreihenfolgen, die nicht dem Index entsprechen, langsamer ist. \nDaher werden in der Praxis h\u00e4ufig sogenannte k\u00fcnstliche Schl\u00fcssel (surrogate keys) verwendet. Ein k\u00fcnstlicher Schl\u00fcssel ist ein zus\u00e4tzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Z\u00e4hler vom\nDatentyp Integer, der systemintern verwaltet wird, nach au\u00dfen nicht sichtbar ist und ausschlie\u00dflich f\u00fcr die Prim\u00e4r- und Fremdschl\u00fcsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und \u00c4hnlichem zu unterscheiden, die nach au\u00dfen sichtbar sind und im Schriftverkehr verwendet oder zur\nIdentifikation beim Kunden erfragt werden. Wenn man sich f\u00fcr die Verwendung von k\u00fcnstlichen Prim\u00e4rschl\u00fcsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen f\u00fcr das gesamte Modell, unabh\u00e4ngig von den sonstigen Schl\u00fcsseln der Entity-Mengen.", "type": "multiple-choice", "answers": [{"text": "Sie reduzieren die Gr\u00f6\u00dfe von Fremdschl\u00fcsseln", "solution": "true"}, {"text": "Sie erm\u00f6glichen eine schnelle Suche", "solution": "true"}, {"text": "Sie sind Abbild eines Attributs der realen Welt.", "solution": "false"}, {"text": "Sie dienen der Objektorientierung der Datenbank.", "solution": "false"}]}, {"id": 1793, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber Attribute einer Entity-Menge sind wahr?", "explanation": "In ER-Modellen sind Entity-Mengen mit Attributen, die NULL-Werte zulassen, vorgesehen, aber keine mengenwertigen Attribute.", "type": "multiple-choice", "answers": [{"text": "Ein Attribut ist eine Eigenschaft, die allen Entit\u00e4ten einer Entity-Menge gemeinsam ist.", "solution": "true"}, {"text": "Attribute sind die Spalten der Entity-Mengen.", "solution": "true"}, {"text": "Attribute sind immer optional.", "solution": "false"}, {"text": "Ein Schl\u00fcssel kann aus einem oder mehreren Attributen bestehen.", "solution": "true"}, {"text": "Attribute k\u00f6nnen Mengen von Werten enthalten (nicht atomar).", "solution": "false"}]}, {"id": 3362, "category": 5, "difficulty": 1, "text": "Um welchen Attributtyp handelt es sich hier?\n\n    Studiendauer eines Studenten", "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zus\u00e4tzlich der Gr\u00f6\u00dfe nach ordnen und k\u00f6nnen verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zus\u00e4tzlich auch Multiplikation und  Division,  zulassen.", "type": "multiple-choice", "answers": [{"text": "Intervall", "solution": "true"}, {"text": "Ordinal", "solution": "false"}, {"text": "Nominal", "solution": "false"}, {"text": "Zahl", "solution": "true"}]}, {"id": 2451, "category": 5, "difficulty": 2, "text": "\u00dcber einen k\u00fcnstlichen Prim\u00e4rschl\u00fcssel sind folgende Aussagen wahr:", "explanation": "In der Praxis h\u00e4ufig sogenannte k\u00fcnstliche Schl\u00fcssel (surrogate keys) verwendet. Ein k\u00fcnstlicher Schl\u00fcssel ist ein zus\u00e4tzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Z\u00e4hler vom Datentyp Integer, der systemintern verwaltet wird, nach au\u00dfen nicht sichtbar ist und ausschlie\u00dflich f\u00fcr die Prim\u00e4r- und Fremdschl\u00fcsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und \u00c4hnlichem zu unterscheiden, die nach au\u00dfen sichtbar sind und im Schriftverkehr verwendet oder zur Identifikation beim Kunden erfragt werden. Wenn man sich f\u00fcr die Verwendung von k\u00fcnstlichen Prim\u00e4rschl\u00fcsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen f\u00fcr das gesamte Modell, unabh\u00e4ngig von den sonstigen Schl\u00fcsseln der Entity-Mengen.", "type": "multiple-choice", "answers": [{"text": "Er besteht aus nur einem Attribut.", "solution": "true"}, {"text": "Er besteht aus einem oder mehreren Attributen.", "solution": "false"}, {"text": "Sein Datentyp ist numerisch.", "solution": "true"}, {"text": "Er enth\u00e4lt Schl\u00fcsselwerte, die aus verschiedenen Komponenten zusammengesetzt sind, z.B. wie bei einer EAN (Eurepean Article Number), wo man anhand der Nummer das Herkunftsland, den herstellenden Betrieb und die Artikelnummer ablesen kann.", "solution": "false"}]}, {"id": 2959, "category": 5, "difficulty": 2, "text": "Wie hei\u00dft eine Beziehung, die mit beiden Enden die gleiche Entity-Menge verbindet?", "explanation": "Eine rekursive Beziehung ist eine Beziehung, die mit beiden Enden auf die gleiche Entity-Menge verweist.", "type": "text", "answers": [{"text": "So eine Beziehung hei\u00dft:", "solution": "rekursiv"}]}, {"id": 2937, "category": 5, "difficulty": 1, "text": "In obligatorischen Attributen (ER-Modell) sind NULL-Werte erlaubt.", "explanation": "Obligatorisch bedeutet, dass das Attribut einen Wert haben muss, also nicht NULL sein darf.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3360, "category": 5, "difficulty": 1, "text": "Um welchen Attributtyp handelt es sich hier prim\u00e4r?\n\n    Die Noten einer Hochschule k\u00f6nnen die Werte 1.0, 1.3, 1,7, ... ,5.0 annehmen.", "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zus\u00e4tzlich der Gr\u00f6\u00dfe nach ordnen und k\u00f6nnen verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zus\u00e4tzlich auch Multiplikation und  Division,  zulassen.", "type": "multiple-choice", "answers": [{"text": "Zahl", "solution": "false"}, {"text": "Intervall", "solution": "false"}, {"text": "Ordinal", "solution": "true"}, {"text": "Nominal", "solution": "false"}]}, {"id": 3361, "category": 5, "difficulty": 1, "text": "Um welchen Attributtyp handelt es sich hier prim\u00e4r?\n\n    L\u00e4nderk\u00fcrzel weltweit, wie \"D\" f\u00fcr Deutschland", "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zus\u00e4tzlich der Gr\u00f6\u00dfe nach ordnen und k\u00f6nnen verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zus\u00e4tzlich auch Multiplikation und  Division,  zulassen.", "type": "multiple-choice", "answers": [{"text": "Intervall", "solution": "false"}, {"text": "Ordinal", "solution": "false"}, {"text": "Nominal", "solution": "true"}, {"text": "Zahl", "solution": "false"}]}, {"id": 2957, "category": 5, "difficulty": 2, "text": "\u00dcber einen k\u00fcnstlichen Prim\u00e4rschl\u00fcssel sind folgende Aussagen wahr:", "explanation": "In der Praxis h\u00e4ufig sogenannte k\u00fcnstliche Schl\u00fcssel (surrogate keys) verwendet. Ein k\u00fcnstlicher Schl\u00fcssel ist ein zus\u00e4tzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Z\u00e4hler vom Datentyp Integer, der systemintern verwaltet wird, nach au\u00dfen nicht sichtbar ist und ausschlie\u00dflich f\u00fcr die Prim\u00e4r- und Fremdschl\u00fcsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und \u00c4hnlichem zu unterscheiden, die nach au\u00dfen sichtbar sind und im Schriftverkehr verwendet oder zur Identifikation beim Kunden erfragt werden. Wenn man sich f\u00fcr die Verwendung von k\u00fcnstlichen Prim\u00e4rschl\u00fcsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen f\u00fcr das gesamte Modell, unabh\u00e4ngig von den sonstigen Schl\u00fcsseln der Entity-Mengen.\nUnd da Prim\u00e4rschl\u00fcssel Pflichteingabespalten sind, sind es auch die k\u00fcnstlichen Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Er ist Pflichteingabeattribut.", "solution": "true"}, {"text": "Er besteht aus einem oder mehreren Attributen.", "solution": "false"}, {"text": "Sein Datentyp ist beliebig (numerisch oder alphanumerisch oder ).", "solution": "false"}, {"text": "Er enth\u00e4lt eine fortlaufende Nummer.", "solution": "true"}, {"text": "Anfragen k\u00f6nnen mit seiner Hilfe schneller beantwortet werden.", "solution": "true"}, {"text": "Fremdschl\u00fcssel k\u00f6nnen keine k\u00fcnstlichen Prim\u00e4rschl\u00fcssel referenzieren.", "solution": "false"}]}, {"id": 3643, "category": 5, "difficulty": 1, "text": "Welche Einschr\u00e4nkungen hat das klassische ER-Modell?", "explanation": "Die Anzahl der Attribute sind weder in UML noch im ER-Modell beschr\u00e4nkt, nur in manchen konkreten Datenbanksystemen. Die anderen Eigenschaften sind gerade die wesentlichen n Einschr\u00e4nkungren des klasischen ER-Modells.", "type": "multiple-choice", "answers": [{"text": "Mehrwertige Attribute fehlen", "solution": "true"}, {"text": "Die Anzahl der Attribute ist beschr\u00e4nkt.", "solution": "false"}, {"text": "Zusammengesetzte Attribute fehlen", "solution": "true"}, {"text": "Es gibt keine Vererbung", "solution": "true"}]}, {"id": 3640, "category": 5, "difficulty": 1, "text": "Welche Beziehungstypen sieht das EERM (Erweitertes Entity-Relationship-Modell) vor?", "explanation": "Das ist die Definition des EERM!\n\n    Ein ER-Modell, das zus\u00e4tzlich zu den klassischen Beziehungsarten und Attributen, IS-A-Beziehungen und Aggregation sowie, mehrwertige und zusammengesetzte Attribute vorsieht,  bezeichnen wir als EERM. \n\n    (min-max) Beziehungen mit numerisch exakter Kardinalit\u00e4t, wie z.B. 1-10-Beziehungen,. sind nur in UML vorgesehen.", "type": "multiple-choice", "answers": [{"text": "Alle Beziehungstypen des klassischen ER-Modells k\u00f6nnen verwendet werden.", "solution": "true"}, {"text": "IS-A-Beziehungen", "solution": "true"}, {"text": "(Min-Max)-Beziehungen, bei denen die Kardinalit\u00e4t numerisch festgelegt werden kann, z.B- 1-10-Beziehungen", "solution": "false"}, {"text": "Aggregationen", "solution": "true"}]}, {"id": 3645, "category": 5, "difficulty": 1, "text": "Was versteht man unter Spezialisierung im EERM?", "explanation": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.\n\n\n    Die abgeleiteten Typen haben dann neben den vom Supertyp ererbten Attributen eigene Attribute, die nur den Subtyp beschreiben.\n\n\n \n\nUnter Generalisierung versteht man den Prozess der Gewinnung eines Supertyps aus mehreren \u00e4hnlichen Subtypen.\n\n\n    Der neue Supertyp wird dann durch diejenigen Attribute beschrieben, die den \u00e4hnlichen Subtypen gemeinsam sind.", "type": "multiple-choice", "answers": [{"text": "Das ist der Prozess der Gewinnung eines Supertyps aus mehreren \u00e4hnlichen Subtypen.", "solution": "false"}, {"text": "Keine von beiden Antworten ist korrekt.", "solution": "false"}, {"text": "Das ist der Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.", "solution": "true"}]}, {"id": 3646, "category": 5, "difficulty": 1, "text": "Was versteht man unter Generalisierung im EERM?", "explanation": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.\n\n    \u2013Die abgeleiteten Typen haben dann neben den vom Supertyp ererbten Attributen eigene Attribute, die nur den Subtyp beschreiben.\n\n     \n\n    Unter Generalisierung versteht man den Prozess der Gewinnung eines Supertyps aus mehreren \u00e4hnlichen Subtypen.\n\n    \u2013Der neue Supertyp wird dann durch diejenigen Attribute beschrieben, die den \u00e4hnlichen Subtypen gemeinsam sind.", "type": "multiple-choice", "answers": [{"text": "Das ist der Prozess der Gewinnung eines Supertyps aus mehreren \u00e4hnlichen Subtypen.", "solution": "true"}, {"text": "Keine von beiden Antworten ist korrekt.", "solution": "false"}, {"text": "Das ist der Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.", "solution": "false"}]}, {"id": 548, "category": 8, "difficulty": 1, "text": "In einer Relation ist die Tupelreihenfolge definiert.", "explanation": "Dies ist ein sehr zentraler Grundsatz des relationalen Modells: die Reihenfolgeunabh\u00e4ngigkeit. \nAngewendet auf relationale Datenbanksysteme hei\u00dft das u.a. dass das Ergebnis einer Datenverarbeitung unabh\u00e4ngig davon ist, in welcher Reihenfolge die Tupel/Datens\u00e4tze auf der Platte gespeichert sind. Stellen Sie sich vor, dem w\u00e4re nicht so:  das System w\u00e4re \u00fcberhaupt nicht beherrschbar, wenn der Entwickler wissen m\u00fcsste, in welcher Reihenfolge Tupel/Datens\u00e4tze gespeichert sind. Diese Annahme widerspricht auch dem ANSI-3-Ebenen Modell und der physischen Datenunabh\u00e4ngigkeit.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 550, "category": 8, "difficulty": 2, "text": "Bei einer Selektion wird eine n-stellige Relation auf eine n-stellige Relation abgebildet.", "explanation": "Mit Hilfe der Selektion werden einzelne Tupel ausgew\u00e4hlt, die Attributstruktur der Relation bleibt jedoch unver\u00e4ndert. Es ist die Projektion, die einzelne Attribute ausw\u00e4hlt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2813, "category": 8, "difficulty": 3, "text": "Es ist ein Datenmodell einer Auto-Vermietung gegeben mit einer Kunden-Relation (Prim\u00e4rschl\u00fcssel: Kunden_Nr), einer Fahrzeuge-Relation  (Prim\u00e4rschl\u00fcssel: KFZ-Nr) und einer Ausleihen-Relation, in der alle get\u00e4tigten Ausleihen erfa\u00dft werden. \nDie Ausleihen-Relation hat nun folgenden Prim\u00e4rschl\u00fcssel: \nKFZ_Nr, Kunden_Nr, ausgeliehen_am. \n\nEs ist nun angedacht, das Datum \"ausgeliehen_am\" aus dem Prim\u00e4rschl\u00fcssel herauszunehmen. Welche Konsequenzen h\u00e4tte dies.", "explanation": "Die beiden richtigen Antworten beschreiben den gleichen Sachverhalt nur mal anders herum ausgedr\u00fcckt. \n\nMit einem Prim\u00e4rschl\u00fcssel KFZ_Nr, Kunden_Nr, ausgeliehen_am \nsind folgende Daten m\u00f6glich: \nKFZ_NR(PK), Kunden_Nr(PK), ausgeliehen_am(PK)\n1234,        4000,   14.09.2011\n1234,        4000,   06.10.2011\n\nSomit kann ein Fahrzeug von einem Kunden mehrfach zu verschiedenen Zeitpunkten gebucht werden. \n\nMit dem ge\u00e4nderten Prim\u00e4rschl\u00fcssel KFZ_Nr, Kunden_Nr \nsieht das schon ganz anders aus. Die folgenden Daten gehen dann nicht mehr, weil der Prim\u00e4rschl\u00fcssel nicht eindeutig ist: \nKFZ_NR(PK), Kunden_Nr(PK), ausgeliehen_am\n1234,        4000,   14.09.2011\n1234,        4000,   06.10.2011\n\nF\u00fcr die Werte 1234, 4000, gibt es dann nur noch einen Datensatz und damit kann ein Kunde ein Fahrzeug nur noch einmal ausleihen. Andere Fahrzeuge kann er ruhig mehrfach ausleichen.", "type": "multiple-choice", "answers": [{"text": "Ein Fahrzeug (KFZ_Nr) kann nur einmal ausgeliehen werden.", "solution": "false"}, {"text": "Ein Kunde (Kunden_Nr) kann nur einmal ausleihen.", "solution": "false"}, {"text": "Ein Kunde kann nur einmal ein bestimmtes Fahrzeug ausleihen.", "solution": "true"}, {"text": "Ein Fahrzeug kann nur einmal von einem bestimmten Kunden ausgeliehen werden.", "solution": "true"}, {"text": "Diese \u00c4nderung hat gar keine Auswirkungen. Sie minimiert nur die Anzahl der Attribute des Prim\u00e4rschl\u00fcssels.", "solution": "false"}]}, {"id": 3409, "category": 8, "difficulty": 1, "text": "Der Natural Join ist in der relationalen Algebra der einzige Join-Operator, der die Join-Spalten nur einmal ausgibt", "explanation": "Der Theta Join hat immer eine Bedingung und unterdr\u00fcckt keine doppelten Spalten. Equi-Join und Outer-Joins bauen auf der Definition des Theta-Joins auf.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "false"}, {"text": "stimmt", "solution": "true"}]}, {"id": 3182, "category": 8, "difficulty": 1, "text": "Welcher Join-Operator ist immer verlustfrei?", "explanation": "Eine Join-Operation zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis. Bei allen Join-Operatoren bis auf den Full-Outer-Join k\u00f6nnen Tupel, die in der verkn\u00fcpften Operation kein Gegen\u00fcber haben, wegfallen.", "type": "text", "answers": [{"text": "Das ist der:", "solution": "Full Outer Join"}]}, {"id": 2596, "category": 8, "difficulty": 1, "text": "Einen Operatorbaum liest man", "explanation": "Um Anfragen an einen Datenbestand zu formulieren, k\u00f6nnen Operationen der relationalen Algebra beliebig ineinander geschachtelt werden. Bei komplexen Anfragen ist daher die oben verwendete sogenannte \"Inline-Notation\" schwer lesbar. F\u00fcr diesen Zweck verwendet man Operatorb\u00e4ume statt der Inline-Notation. Bei dieser grafischen Darstellung erstellt und liest man die Abfrage von unten nach oben. Operationen, die miteinander verkn\u00fcpft sind, sind durch Kanten im Graphen miteinander verbunden. Gestartet wird mit den relvanten Relationen als unterster Teil des OP-Baumes.", "type": "multiple-choice", "answers": [{"text": "von unten nach oben", "solution": "true"}, {"text": "von oben nach unten", "solution": "false"}]}, {"id": 2575, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS1  S4 \nC    Y\nD    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "text", "answers": [{"text": "Geben Sie die Attributwerte in Gro\u00dfbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.", "solution": "C Y Y"}]}, {"id": 2568, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren aus der relationalen Algebra l\u00e4sst sich der Divisions-Operator simulieren?", "explanation": "Die Division l\u00e4sst sich aus den relationalen Grundoperationen Selektion, Projektion, kartesisches Produkt und Differenz ableiten.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "true"}, {"text": "Theta-Join", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Outer Join (Left, Right, Full)", "solution": "false"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Durchschnitt", "solution": "false"}, {"text": "Differenz", "solution": "true"}]}, {"id": 2585, "category": 8, "difficulty": 1, "text": "Welcher Programmiersprachen sind deklarativ?", "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.", "type": "multiple-choice", "answers": [{"text": "Java", "solution": "false"}, {"text": "C++", "solution": "false"}, {"text": "SQL", "solution": "true"}]}, {"id": 2581, "category": 8, "difficulty": 2, "text": "Es sind die folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4 gegeben: \n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "text", "answers": [{"text": "Welche Operation der Relationalen Algebra hat folgende Ergebnismenge? \n(englischsprachige Bezeichnung, nur Kleinbuchstaben, W\u00f6rter durch ein Leerzeichen getrennt, keine Bindestriche etc.)\n\nS1 S2 S3 S4\nA  W  D  Z", "solution": "natural join"}]}, {"id": 2577, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS1  S4 \nC    Y\nD    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. Hei\u00dfen keine Attribute gleich, so wird die leere Menge zur\u00fcck geliefert.", "type": "text", "answers": [{"text": "Geben Sie die Attributwerte in Gro\u00dfbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.", "solution": "C Y Y"}]}, {"id": 2574, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4!\n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. Hei\u00dfen keine Attribute gleich, so wird die leere Menge zur\u00fcckgeliefert.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S2 S3 S4\nC  Y  ?  ?  ?\nA  W  W  D  Z\n?  ?  V  C  Y", "solution": "false"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "false"}, {"text": "S1 S2 S2 S3 S4\nC  Y  W  D  Z\nC  Y  V  C  Y\nA  W  W  D  Z\nA  W  V  C  Y", "solution": "false"}, {"text": "S1 S2 S2 S3 S4\nA  W  W  D  Z", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  D  Z", "solution": "true"}]}, {"id": 2583, "category": 8, "difficulty": 3, "text": "Wie hei\u00dfen Programmiersprachen, bei denen der Programmierer die L\u00f6sung beschreibt, aber nicht den L\u00f6sungsweg im Detail programmieren muss?", "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.", "type": "text", "answers": [{"text": "Die Programmiersprachen hei\u00dfen: (Kleinbuchstaben)", "solution": "deklarativ"}]}, {"id": 2578, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attriguten S1, S2, S3, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z", "explanation": "Keine dieser Ergebnismengen ist richtig, weil bei R1 und R2 keine Attribute gleich hei\u00dfen. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. Hei\u00dfen keine Attribute gleich, so wird die leere Menge zur\u00fcck geliefert.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "true"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}]}, {"id": 2576, "category": 8, "difficulty": 1, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2!\n\nR1:\nS1  S2     \nA    W\nC    Y\n\nR2:\nS1  S2\nC    Y\nD    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "text", "answers": [{"text": "Geben Sie die Attributwerte in Gro\u00dfbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.", "solution": "C Y"}]}, {"id": 2528, "category": 8, "difficulty": 1, "text": "Welche Join-Operatoren gibt es in der relationalen Algebra nicht?", "explanation": "Au\u00dfer Flat Join und Blank Join sind alle Join-Typen in der relationalen Algebra vorgesehen.", "type": "multiple-choice", "answers": [{"text": "Theta-Join", "solution": "false"}, {"text": "Equi-Join", "solution": "false"}, {"text": "Left Outer Join", "solution": "false"}, {"text": "Right Outer Join", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Full Outer Join", "solution": "false"}, {"text": "Flat Join", "solution": "true"}, {"text": "Blank Join", "solution": "true"}]}, {"id": 2527, "category": 8, "difficulty": 2, "text": "Welche Join-Operatoren sind immer verlustfrei?", "explanation": "Eine Join-Operation zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis. Bei allen Join-Operatoren bis auf den Full-Outer -Join k\u00f6nnen Tupel, die  in der verkn\u00fcpften Operation kein Gegen\u00fcber haben, wegfallen.", "type": "multiple-choice", "answers": [{"text": "Theta-Join", "solution": "false"}, {"text": "Equi-Join", "solution": "false"}, {"text": "Left Outer Join", "solution": "false"}, {"text": "Right Outer Join", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Full Outer Join", "solution": "true"}, {"text": "Keiner von allen", "solution": "false"}]}, {"id": 2564, "category": 8, "difficulty": 3, "text": "Welche Priorit\u00e4tenreihenfolge habe die logischen Operatorn der Relationalen Algebra? \nTragen Sie bitte 1, 2, 3 oder 4 ein!", "explanation": "Priorit\u00e4tenreihenfolge der Operatoren (es ist die gleiche wie bei SQL)\nPriorit\u00e4t Operator\n1         Alle Vergleichsoperatoren\n2         NOT\n3         AND\n4         OR", "type": "text", "answers": [{"text": "OR", "solution": "4"}, {"text": "Vergleichssoperatoren", "solution": "1"}, {"text": "AND", "solution": "3"}, {"text": "NOT", "solution": "2"}]}, {"id": 2563, "category": 8, "difficulty": 1, "text": "Die Relationale Algebra basiert auf einem", "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen, diese automatisch eliminiert werden. Zu diesen Operatoren geh\u00f6ren Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA.", "type": "multiple-choice", "answers": [{"text": "Mengenverst\u00e4ndnis f\u00fcr Relationen (Duplikate nicht erlaubt).", "solution": "true"}, {"text": "Multimengenverst\u00e4ndnis f\u00fcr Relationen (Duplikate erlaubt).", "solution": "false"}]}, {"id": 2562, "category": 8, "difficulty": 3, "text": "Welche Aussagen \u00fcber die relationalen Algebra sind wahr?", "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen, diese automatisch eliminiert werden. Zu diesen Operatoren geh\u00f6ren Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA. In SQL hei\u00dft das Schl\u00fcsselwort zur Duplikatelimination in SELECT-Anfragen DISTICNT.", "type": "multiple-choice", "answers": [{"text": "Relationen und Ergebnisdatenmengen sind Multimengen, was hei\u00dft, dass doppelte Tupel erlaubt sind.", "solution": "false"}, {"text": "Relationen und Ergebnisdatenmengen sind Mengen, was hei\u00dft, dass doppelte Tupel nicht erlaubt sind.", "solution": "true"}, {"text": "Zur Unterdr\u00fcckung doppelter Tupel gibt es eine eigene Operation: DISTINCT.", "solution": "false"}, {"text": "Die Unterdr\u00fcckung doppelter Tupel erfolgt automatisch. Bei den Operatoren, bei denen Duplikate auftreten k\u00f6nnen (Projektion, Vereinigung, Durchschnitt, Division) werden diese automatisch eliminiert.", "solution": "true"}, {"text": "Es gibt keine Operatoren, bei denen Duplikate auftreten k\u00f6nnen.", "solution": "false"}]}, {"id": 2554, "category": 8, "difficulty": 1, "text": "Bei einer Projektion wird eine n-stellige Relation auf eine n+m-stellige Relation abgebildet, mit m>0.", "explanation": "Die Projektion kann die Anzahl der Attribute nicht vergr\u00f6\u00dfern, also keine Attribute hinzuf\u00fcgen. Sie kann lediglich die Ergebnismenge auf einzelne Attribute aus einer Relation beschr\u00e4nken.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2553, "category": 8, "difficulty": 2, "text": "Jemand schl\u00e4gt vor, als Prim\u00e4rschl\u00fcssel einer Auftragspositionen-Relation nicht die Kombination von AuftragsNr und und ArtikelNr (wie bisher) zu w\u00e4hlen, sondern nur die ArtikelNr. Was w\u00fcrde das bedeuten?", "explanation": "Ist nur die ArtikelNr Prim\u00e4rschl\u00fcsselattribut, so kann in der Auftragspositionen-Relation jede ArtikelNr nur einmal vorkommen, mit der Konsequenz, dass jeder Artikel nur einmal verkauft werden kann.\nGrund daf\u00fcr ist die Eigenschaft der Eindeutigkeit der (Prim\u00e4r-)Schl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Ein Auftrag besteht h\u00f6chsten aus einem Artikel.", "solution": "false"}, {"text": "Ein Artikel kann insgesamt nur einmal bestellt werden.", "solution": "true"}, {"text": "Es macht keinen Unterschied zur anderen L\u00f6sung.", "solution": "false"}, {"text": "Keine dieser Antworten ist korrekt.", "solution": "false"}]}, {"id": 2573, "category": 8, "difficulty": 1, "text": "Bestimmen Sie den Full Outer-Join der folgenden beiden Relationen \u00fcber R1.S1 = R2.S3!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z", "explanation": "Der Full Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgef\u00fcllt werden, die beim nat\u00fcrlichen Join herausfallen w\u00fcrden.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z", "solution": "true"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}]}, {"id": 3408, "category": 8, "difficulty": 1, "text": "Der Natural Join ist in der relationalen Algebra der einzige Join-Operator, der ohne Bedingung auskommt", "explanation": "Der Theta Join hat immer eine Bedingung und unterdr\u00fcckt keine doppelten Spalten. Equi-Join und Outer-Joins bauen auf der Definition des Theta-Joins auf.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "false"}, {"text": "stimmt", "solution": "true"}]}, {"id": 2582, "category": 8, "difficulty": 1, "text": "Es sind die folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4 gegeben: \n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z\n\nDie folgende Menge ist das Ergebnis der Anwwendung des Natural Joins auf R1 und R2. \n\nS1 S2 S2 S3 S4\nA  W  W  D  Z", "explanation": "Diese Ergebnismenge passt nicht, weil die Projektion auf nur eines der doppelten Attribute S2 fehlt. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 2580, "category": 8, "difficulty": 2, "text": "Es sind die folgenden beiden Relationen R1, R2 gegeben:\n\n    R1: S1 S2 C Y A W\n\n    R2: S2 S3 S4 V C Y W D Z", "explanation": "Seien zwei Relationen R1(A1,...,An) und R2(B1,...,Bm) gegeben. Das kartesische Produkt ist die Menge aller Paare aus Tupeln der ersten Relation R1 verkn\u00fcpft mit Tupeln der zweiten Relation R2 unabh\u00e4ngig von irgenwelchen gleichen oder ungleichen Attributwerten f\u00fcr die einzelnen Attribute.", "type": "text", "answers": [{"text": "Welche Operation der Relationalen Algebra hat folgende Ergebnismenge? \n(deutschsprachige Bezeichnung, nur Kleinbuchstaben, W\u00f6rter durch ein Leerzeichen getrennt, keine Bindestriche etc.)\n\nS1 S2 S2 S3 S4\nC  Y  W  D  Z\nC  Y  V  C  Y\nA  W  W  D  Z\nA  W  V  C  Y", "solution": "kartesisches produkt"}]}, {"id": 2572, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den rechten Outer-Join der folgenden beiden Relationen \u00fcber R1.S1 = R2.S3!\n\nR1: </br\nS1  S2    \nA    W \nC    Y </br\n\nR2: </br\nS3  S4 \nC    Y \nD    Z", "explanation": "Der rechte Outer-Join (rechter \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R1 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z", "solution": "true"}]}, {"id": 2570, "category": 8, "difficulty": 1, "text": "Der Left Outer Join ist kommutativ.", "explanation": "Der linke Outer-Join (linker \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit\naufgef\u00fchrt und in den Attributen, die zu R2 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden. \nDie rechten und linken Outer-Joins sind nicht kommutativ, da entweder nur die rechte oder nur die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden. \nDer Full-Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ist jedoch kommutativ, da bei ihn sowohl die rechte als aich die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2557, "category": 8, "difficulty": 2, "text": "Wie viele Attribute hat die Ergebnismenge des Natural Joins von zwei Relationen, die \u00fcber 15 bzw. 25 Attribute verf\u00fcgen, wobei es in der einen Relation drei Attribute gibt, die gleich hei\u00dfen wie in der anderen?", "explanation": "Die Struktur der Ergebnismenge des Natural Joins verf\u00fcgt \u00fcber alle Attribute aus beiden beteiligten Relationen, wobei die doppelten Attribute nur einmal vertreten sind: 15+25-3= 37 Attribute.", "type": "text", "answers": [{"text": "Der Natural Join hat ... Attribute.", "solution": "37"}]}, {"id": 2161, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren aus der relationalen Algebra l\u00e4sst sich der Durchschnittsoperator simulieren?", "explanation": "Die Simulation sieht wie folgt aus: \n(A Durchschnitt B)  =  ( A ohne (A ohne B) ) \n\n(A Durchschnitt B)  =  ( A Differenz (A Differenz B) ) \n\nPS: Zeichnen Sie sich ruhig die Venn-Diagramme auf - es hilft ;-) \nPS: War mal Klausuraufgabe :-)", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Division", "solution": "false"}, {"text": "Mit keinem Operator aus der relationalen Algebra", "solution": "false"}, {"text": "Differenz", "solution": "true"}]}, {"id": 1749, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den linken Outer-Join der folgenden beiden Relationen \u00fcber R1.S1 = R2.S3!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z", "explanation": "Der linke Outer-Join (linker \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R2 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y", "solution": "true"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}]}, {"id": 2104, "category": 8, "difficulty": 3, "text": "Welche der genannten Operatoren sind abgeleitete Operatoren der Relationalen Algebra, die mittels der Basisoperatoren simuliert werden k\u00f6nnen?", "explanation": "Basisoperatoren sind: Selektion, Projektion, Differenz, kartesisches Produkt, Vereinigung. \nTheta-, Equi- und die Outer Joins lassen sich mittels kartesischem Produkt und Selektion simulieren. \nNatural Join l\u00e4sst sich mittels kartesischem Produkt Selektion und Pojektion simulieren. \nDie Division l\u00e4sst sich mittels Selektion, Projektion, kartesischem Produkt und Differenz ableiten.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Division", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Theta-Join", "solution": "true"}, {"text": "Natural Join", "solution": "true"}, {"text": "Equi-Join", "solution": "true"}, {"text": "Outer Join (Left, Full, Right)", "solution": "true"}]}, {"id": 2103, "category": 8, "difficulty": 2, "text": "Welche der genannten Operatoren sind Operatoren der Relationalen Algebra?", "explanation": "Die Konkatenation bezeichnet das Zusammenf\u00fcgen z.B. von zwei Zeichenketten und ist als separate Funktion bei SQL verf\u00fcgbar, es ist aber kein Operator der RA.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "true"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Division", "solution": "true"}, {"text": "Differenz", "solution": "true"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Theta-Join", "solution": "true"}, {"text": "Natural Join", "solution": "true"}, {"text": "Equi-Join", "solution": "true"}, {"text": "Outer Join (Left, Full, Right)", "solution": "true"}, {"text": "Konkatenation", "solution": "false"}]}, {"id": 2032, "category": 8, "difficulty": 1, "text": "Ein vollst\u00e4ndiger Outer-Join ist immer verlustfrei.", "explanation": "Eine Join-Operation  zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.", "type": "multiple-choice", "answers": [{"text": "Stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2031, "category": 8, "difficulty": 1, "text": "Ein Outer-Join ist eine Spezialform des Natural-Joins", "explanation": "Ein Natural Join liefert nur eine Teilmenge der Tupel, die ein Outer-Join liefern w\u00fcrde, namlich die Tupel, die in beiden Relationen enthalten sind.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2030, "category": 8, "difficulty": 1, "text": "Welche Outer-Join-Operatoren gibt es in der relationalen Algebra?", "explanation": "Der linke Outer-Join (linker \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit\naufgef\u00fchrt und in den Attributen, die zu R2 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden. \nDer rechte Outer-Join (rechter \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R1 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.  \nDer Full Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgef\u00fcllt\nwerden, die beim nat\u00fcrlichen Join herausfallen w\u00fcrden.", "type": "multiple-choice", "answers": [{"text": "Vollst\u00e4ndiger Outer-Join", "solution": "true"}, {"text": "Rechter Outer-Join", "solution": "true"}, {"text": "Halber Outer-Join", "solution": "false"}, {"text": "Linker Outer Join", "solution": "true"}, {"text": "Super Outer-Join", "solution": "false"}]}, {"id": 1977, "category": 8, "difficulty": 1, "text": "Ein nat\u00fcrlicher Join (Natural Join) unterdr\u00fcckt", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "multiple-choice", "answers": [{"text": "doppelte Attribute (gleicher Attributname)", "solution": "true"}, {"text": "doppelte Tupel", "solution": "false"}, {"text": "keins von beiden", "solution": "false"}]}, {"id": 823, "category": 8, "difficulty": 2, "text": "Welche Schl\u00fcsselbegriffe gibt es nicht in der relationalen Algebra?", "explanation": "Eine Attributkombination L wird eindeutiger Schl\u00fcssel der Relation R1(A1,...An) genannt, wenn \n1. L \u2192 (A1,...,An) und \n2. (A1,...,An) von keiner echten Teilmenge von L funktional abh\u00e4ngig ist. \nIn jeder Relation wird genau ein eindeutiger Schl\u00fcssel zum Prim\u00e4rschl\u00fcssel (primary key, Hauptschl\u00fcssel) erkl\u00e4rt, \u00fcber den die Tupel der Relation eindeutig identifiziert werden k\u00f6nnen. Ein Prim\u00e4rschl\u00fcssel ist immer obligatorisch und darf keine NULL-Werte haben. \nZus\u00e4tzlich k\u00f6nnen in einer Relation zur Beschleunigung des Zugriffs bestimmte Attribute zu Zweitschl\u00fcsseln ernannt werden. Anders als beim Prim\u00e4rschl\u00fcssel m\u00fcssen die Zweitschl\u00fcssel weder eindeutig sein noch sind NULL-Werte verboten. Es werden Indizes in Hilfstabellen erstellt, \u00fcber die der schnellere Zugriff auf die Attribute des Zweitschl\u00fcssels m\u00f6glich ist.  \n\nDie \u00fcbrigen Schl\u00fcsselbegriffe gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "Indexschl\u00fcssel", "solution": "true"}, {"text": "Prim\u00e4rschl\u00fcssel", "solution": "false"}, {"text": "Eindeutiger Schl\u00fcssel", "solution": "false"}, {"text": "Zweitschl\u00fcssel", "solution": "false"}, {"text": "Fremdschl\u00fcssel", "solution": "false"}, {"text": "Drittschl\u00fcssel", "solution": "true"}]}, {"id": 1790, "category": 8, "difficulty": 1, "text": "Der Vereinigung als Mengenoperation der relationalen Algebra entspricht unter SQL", "explanation": "Die Mengenoperatoren der Relationalen Algebra lassen sich mit folgenden SQL-Operatoren implementieren: \n\nRA -SQL:\nVereinigung - UNION\nDifferenz - EXCEPT / MINUS\nDurchschnitt - INTERSECTION", "type": "multiple-choice", "answers": [{"text": "INTERSECT", "solution": "false"}, {"text": "UNION", "solution": "true"}, {"text": "MINUS", "solution": "false"}]}, {"id": 1134, "category": 8, "difficulty": 2, "text": "Bei welcher Join-Operation m\u00fcssen die Join-Attribute vom Namen her \u00fcbereinstimmen?", "explanation": "Die Join-Attribute der beiden betroffenen Relationen m\u00fcssen nicht den gleichen Namen haben, au\u00dfer beim Natural-Join: In diesem Fall m\u00fcssen die Join-Attribute den gleichen Namen haben.", "type": "multiple-choice", "answers": [{"text": "Theta-Join", "solution": "false"}, {"text": "Equi-Join", "solution": "false"}, {"text": "Natural Join", "solution": "true"}, {"text": "Outer Join", "solution": "false"}]}, {"id": 1078, "category": 8, "difficulty": 3, "text": "Mit welchem Operator der relationalen Algebra l\u00e4\u00dft sich der Theta-Join simulieren?", "explanation": "Alle Join-Operationen sind aus kartesischem Produkt, Selektion und ggf. Projektion ableitbar. \nWobei f\u00fcr den Theta-Join das kartesische Produkt mit einer anschlie\u00dfenden Selektion ausreichend ist. \nEine zus\u00e4tzliche Projektion wird nur noch beim Natural Join ben\u00f6tigt. \nDer Theta-Join ist der Join mit der allgemeinsten Bedingung, so dass er durch andere Joins (Equi, Natural, Left, Right, Full Outer) nicht simuliert werden kann.", "type": "multiple-choice", "answers": [{"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "mit keinem anderen Operator der relationalen Algebra", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Selektion", "solution": "true"}, {"text": "Natural Join", "solution": "false"}]}, {"id": 1055, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren aus der relationalen Algebra l\u00e4sst sich der Differenz-Operator simulieren?", "explanation": "Die Differenz geh\u00f6rt zu den Grund-/Basisoperatoren und kann somit nicht simuliert werden mittels anderer RA-Operatoren. Mit ihrer Hilfe kann jedoch z.B. die Division abgeleitet werden.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Theta-Join", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Outer Join (Left, Right, Full)", "solution": "false"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Durchschnitt", "solution": "false"}, {"text": "Division", "solution": "false"}, {"text": "keine der aufgef\u00fchrten Antworten", "solution": "true"}]}, {"id": 1054, "category": 8, "difficulty": 1, "text": "Welcher Join-Operator ist der allgemeinste Operator, von dem sich die anderen Join-Operatoren ableiten lassen?", "explanation": "Den Super-Join gibt es nicht. \nDer Theta_Join ist der Join, dessen Selektionspr\u00e4dikat (Bedingung) keinen Restriktionen unterliegt. \nBeim Equi-Join sind nur Gleichheitsvergleiche (Vergleichsoperator \"=\") im Selektionspr\u00e4dikat zugelassen. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "multiple-choice", "answers": [{"text": "Equi-Join", "solution": "false"}, {"text": "Natural-Join", "solution": "false"}, {"text": "Theta-Join", "solution": "true"}, {"text": "Super-Join", "solution": "false"}]}, {"id": 1559, "category": 8, "difficulty": 2, "text": "Welche Operation aus der relationalen Algebra hat die folgende Eigenschaft: Sie extrahiert bestimmte Attribute aus einer Relation und vertauscht eventuell die Reihenfolge der Attribute.", "explanation": "Die Projektion extrahiert bestimmte Attribute aus einer Relation und vertauscht eventuell die Reihenfolge:\n\n    Sei R(A1,...,An) eine Relation und L = (B1,...,Bj) mit 1 \u2264 j \u2264 n eine Attributkombination, d.h. eine geordnete Teilmenge von (A1,...,An).\n\n    B1 entspricht hier dem Attribut Ai1 und Bj entspricht dem Attribut Aij.\n\n    Die Projektion ist definiert durch: Projektion L (R) Projektion B1...Bj (R) := {(ai1,...,aij)|(a1,...,an)\u2208R}.", "type": "multiple-choice", "answers": [{"text": "Das ist die Selektion.", "solution": "false"}, {"text": "Das ist die Projektion.", "solution": "true"}, {"text": "Das ist die Division.", "solution": "false"}, {"text": "Das sind die Mengenoperatoren.", "solution": "false"}, {"text": "Das sind das kartesische Produkt und die Join-Operatoren.", "solution": "false"}]}, {"id": 1487, "category": 8, "difficulty": 1, "text": "Wie viele Relationen gehen in eine Selektion ein?", "explanation": "Eine n-stellige Relation wird mittels der Selektion R \u2192 SelektionB(R) auf eine n-stellige Relation abgebildet: Rn \u2192 Rn. \nEs ist also neben der Projektion der zweite un\u00e4re Operator.", "type": "multiple-choice", "answers": [{"text": "1", "solution": "true"}, {"text": "2", "solution": "false"}, {"text": "3", "solution": "false"}, {"text": "0", "solution": "false"}]}, {"id": 1351, "category": 8, "difficulty": 2, "text": "Bei welcher Operation der relationalen Algebra wird die Anzahl der Attribute nicht ver\u00e4ndert?", "explanation": "Eine n-stellige Relation wird mittels der Selektion auf eine n-stellige Relation abgebildet, denn damit werden nur die Tupel einer Relation ausgew\u00e4hlt und alle Attribute beibehalten. \nDie Projektion schr\u00e4nkt die Attribute der Ergebnisrelation auf eine Teilmenge der urspr\u00fcnglichen Attribute ein. \nDie Attributsstruktur der Ergebnismenge des Natural Joins besteht aus der Summe der Attribute beider Relationen abz\u00fcglich der Attribute, die mehrfach in den beiden Relationen auftreten.", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Selektion", "solution": "true"}]}, {"id": 557, "category": 8, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber Join-Operatoren sind wahr?", "explanation": "Die drei Grundoperatoren, die man f\u00fcr die Simulation von Join-Operatoren ben\u00f6tigt, sind:  Selektion, Projektion und kartesisches Produkt. \nJede Relation kann mit einer anderen Relation gejoint werden (auch mit sich selber). \nDie Restriktion: \"Alle Attribute der beiden betroffenen Relationen m\u00fcssen \u00fcber die gleichen Namen verf\u00fcgen.\" gilt nur f\u00fcr die Mengenoperatoren Differenz, Durchschnitt, Vereinigung und ist eine Teilbedingung der \"Vereinigungskonformit\u00e4t\". \nEs kann in der Relationalen Algebra \u00fcber jedes beliebige Attribut \"gejoint\" werden, es muss kein Schl\u00fcsselattribut sein. In relationalen Datenbanksystemen dienen Schl\u00fcssel lediglich zur Beschleunigung des Zugriffs, aber nicht zur Einschr\u00e4nkung der Verkn\u00fcpfungsm\u00f6glichkeiten.", "type": "multiple-choice", "answers": [{"text": "Der Join-Operationen lassen sich nicht aus Selektion, Projektion und kartesischem Produkt ableiten.", "solution": "false"}, {"text": "Jede Relation kann mit einer anderen Relation gejoint werden (auch mit sich selber).", "solution": "true"}, {"text": "Alle Attribute der beiden betroffenen Relationen m\u00fcssen f\u00fcr eine Join-Operation \u00fcber die gleichen Namen verf\u00fcgen.", "solution": "false"}, {"text": "Die Attribute, \u00fcber die der Join ausgef\u00fchrt wird m\u00fcssen eine Schl\u00fcsselattribute sein.", "solution": "false"}]}, {"id": 560, "category": 8, "difficulty": 1, "text": "Wie hei\u00dft eine Attributkombination, die Prim\u00e4rschl\u00fcssel einer anderen Relation ist?", "explanation": "Eine Attributkombination einer Relation hei\u00dft Fremdschl\u00fcssel (foreign key), wenn diese Kombination Prim\u00e4rschl\u00fcssel in einer anderen Relation ist. Ein Fremdschl\u00fcssel darf Null-Werte besitzen.", "type": "text", "answers": [{"text": "Sie hei\u00dft  (deutscher Begriff):", "solution": "Fremdschl\u00fcssel"}]}, {"id": 1124, "category": 8, "difficulty": 1, "text": "Alle Natural-Joins sind verlustfrei.", "explanation": "Eine Join-Operation zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 496, "category": 8, "difficulty": 3, "text": "Bei welchen Operatoren der relationalen Algebra m\u00fcssen alle Attribute der beteiligten Relationen \u00fcbereinstimmen, d.h. die gleiche Anzahl an Attributen, die gleiche Reihenfolge der Attribute, gleicher Datentyp/vergleichbarer Inhalt sowie gleicher Attributname? (vereinigungskonform)", "explanation": "Die Bedingung der \"Vereinigungskonformit\u00e4t\" gilt f\u00fcr alle drei Mengenoperatoren, nicht aber f\u00fcr die Join-Operatoren, die ja auf dem Kartesischen Produkt basieren und auch nicht f\u00fcr die Division. Bei der Division gilt die syntaktische Restriktion, dass die Attribute der Relation, durch die geteilt wird, eine echte Teilmenge der Attribute der Relation sein m\u00fcssen, die dividiert wird.", "type": "multiple-choice", "answers": [{"text": "UNION", "solution": "true"}, {"text": "JOIN", "solution": "false"}, {"text": "DIFFERENZ", "solution": "true"}, {"text": "DURCHSCHNITT", "solution": "true"}, {"text": "DIVISION", "solution": "false"}]}, {"id": 497, "category": 8, "difficulty": 1, "text": "Welcher Join-Operator unterdr\u00fcckt doppelte Join-Attribute?", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit gepr\u00fcft und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "multiple-choice", "answers": [{"text": "EQUI-Join", "solution": "false"}, {"text": "Natural-Join", "solution": "true"}, {"text": "Outer-Join", "solution": "false"}, {"text": "Theta-Join", "solution": "false"}]}, {"id": 499, "category": 8, "difficulty": 1, "text": "Welcher Join-Operator kommt in der relationalen Algebra nicht vor?", "explanation": "Den SuperJoin gibt es nicht. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. \nEin Equi-Join ist ein Theta-Join, der im Selektionspr\u00e4dikat nur den Vergleichsoperator \"=\" zul\u00e4sst. \nDer Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgef\u00fcllt\nwerden, die beim nat\u00fcrlichen Join herausfallen w\u00fcrden.   \nZudem gibt es noch die linken und rechten Outer Join-Operatoren. Der linke Outer-Join (linker \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R2 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden. \nDer rechte Outer-Join (rechter \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R1 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "Natural Join", "solution": "false"}, {"text": "Equi Join", "solution": "false"}, {"text": "Super Join", "solution": "true"}, {"text": "Outer Join", "solution": "false"}]}, {"id": 553, "category": 8, "difficulty": 3, "text": "Wie hei\u00dft die Mengenoperation, die mit Einschr\u00e4nkungen die gleiche Ergebnismenge liefert wie der Natural Join?", "explanation": "Natural Join und Intersection (Durchschnitt) sind beides Operationen, die nur die Tupel zur\u00fcckliefern, die in beiden Relationen vorhanden sind. \nZu den Unterschieden zwischen beiden Operationen geh\u00f6rt, dass beim Natural Join die Ergebnisdatenmenge aus den Attributen beider Relationen besteht, w\u00e4hrend beim Intersection die Attributstrukturen der beiden Relationen <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  sein m\u00fcssen.", "type": "text", "answers": [{"text": "Die Operation hei\u00dft (englische Bezeichung)", "solution": "Intersection"}]}, {"id": 2488, "category": 8, "difficulty": 3, "text": "Bei der Ausf\u00fchrung welcher Operatoren k\u00f6nnen Duplikate (doppelte Tupel) auftreten, die aber in der RA automatisch unterdr\u00fcckt werden (automatische Duplikatelimination)?", "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen, diese automatisch eliminiert werden. Zu diesen Operatoren geh\u00f6ren Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA.", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "true"}, {"text": "Selektion", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Join (NATURAL, THETA, EQUI, )", "solution": "false"}, {"text": "OUTER JOIN (LEFT, RIGHT, FULL)", "solution": "false"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Division", "solution": "true"}, {"text": "Es gibt keinen solchen Operator in der RA.", "solution": "false"}]}, {"id": 458, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren der relationalen Algebra l\u00e4sst sich der Natural-Join-Operator simulieren?", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. \n \nDas erreicht man damit, dass zuerst ein Kartesisches Produkt ausgef\u00fchrt wird (damit hat man alle Attribute beider Relationen nebeneinander stehen), dann werden nur die Tupel in die Ergebnismenge \u00fcbernommen f\u00fcr die die Join-Bedingung zu \"wahr\" ausgewertet wird (die Inhalte aller gleichlautenden Attribute werden auf Gleichheit gepr\u00fcft). Abschlie\u00dfend m\u00fcssen noch die doppelten gleichlautenden Attribute entfernt werden aus der Ergebnismenge und das kann mit einer Projektion erreichen.", "type": "multiple-choice", "answers": [{"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "true"}]}, {"id": 462, "category": 8, "difficulty": 2, "text": "Jemand schl\u00e4gt vor, als Prim\u00e4rschl\u00fcssel einer Auftragspositionen-Relation nicht die Kombination von AuftragsNr und und ArtikelNr (wie bisher) zu w\u00e4hlen, sondern nur die AuftragsNr. Was w\u00fcrde das bedeuten?", "explanation": "Ist nur die AuftragsNr Prim\u00e4rschl\u00fcsselattribut, so kann in der Auftragspositionen-Relation jede Auftragsnummer nur einmal vorkommen, mit der Konsequenz, dass es je Auftrag nur einen Artikel geben kann. \nGrund daf\u00fcr ist die Eigenschaft der Eindeutigkeit bei (Prim\u00e4r-)Schl\u00fcsseln.", "type": "multiple-choice", "answers": [{"text": "Ein Auftrag besteht h\u00f6chsten aus einem Artikel.", "solution": "true"}, {"text": "Ein Artikel kann insgesamt nur einmal bestellt werden.", "solution": "false"}, {"text": "Es macht keinen Unterschied zur anderen L\u00f6sung.", "solution": "false"}, {"text": "Keine dieser Antworten ist korrekt.", "solution": "false"}]}, {"id": 647, "category": 8, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber Zweitschl\u00fcssel treffen zu?", "explanation": "Zweitschl\u00fcssel werden als separate Speicherstrukturen (Index) gespeichert, um das Auffinden von Informationen und damit das Lesen zu beschleunigen. Beim Einf\u00fcgen von Tupeln bzw. \u00c4ndern von Schl\u00fcsselwerten dauert es dann nat\u00fcrlich l\u00e4nger, weil die Werte im Tupel und in der separaten Speicherstruktur eingef\u00fcgt bzw. gepflegt werden muss.", "type": "multiple-choice", "answers": [{"text": "Zweitschl\u00fcssel erzeugen Zeitgewinn beim Schreiben.", "solution": "false"}, {"text": "Zweitschl\u00fcssel erzeugen Zeitverlust beim Schreiben.", "solution": "true"}, {"text": "Zweitschl\u00fcssel erzeugen Zeitgewinn beim Lesen.", "solution": "true"}, {"text": "Zweitschl\u00fcssel erzeugen Zeitverlust beim Lesen.", "solution": "false"}, {"text": "Zweitschl\u00fcssel haben gar keinen Einfluss auf die Zugriffszeiten beim Lesen/Schreiben.", "solution": "false"}]}, {"id": 630, "category": 8, "difficulty": 1, "text": "Welche der folgenden Operationen geh\u00f6rt nicht zur relationalen Algebra?", "explanation": "Projektion (attributweise Auswahl), Division (Allquantor) und Differenz (Anfragen mit \"Keine\"/\"Ohne-Aussagen\") geh\u00f6ren zur Relationalen Algebra, die Addition aber nicht.", "type": "multiple-choice", "answers": [{"text": "Division", "solution": "false"}, {"text": "Addition", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Projektion", "solution": "false"}]}, {"id": 783, "category": 8, "difficulty": 3, "text": "Aus welchen Operatoren l\u00e4sst sich der Theta-Join ableiten?", "explanation": "Der Theta-Join ist gem\u00e4\u00df seiner Definition eine Operation, die sich aus Selektion und kartesischem Produkt ableiten l\u00e4sst. Wird zuerst das kartesische Produkt R1 \u00d7 R2 ausgef\u00fchrt und auf dieser Zwischenergebnismenge die Selektion der Bedingung B, dann erh\u00e4lt man das gleiche Ergebnis wie beim Theta-Join(R1, R2, B).", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Selektion", "solution": "true"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Division", "solution": "false"}]}, {"id": 781, "category": 8, "difficulty": 3, "text": "Selektionspr\u00e4dikate k\u00f6nnen in der relationalen Algebra enthalten:", "explanation": "Bestandteile eines Selektionspr\u00e4dikats sind: \n1. Attribute einer Relation und Konstanten als Operanden, \n2. Vergleichsoperatoren = <, \u2264, >, \u2265 , <> und != (ungleich), \n3. die logischen Operatoren UND, ODER und NICHT und \n4. Berechnungen mit Konstanten und Spaltenwerten (z.B. Gehalt*1,.045)  \n5. eine beliebige Kombination aus den oben genannten M\u00f6glichkeiten, die durch Klammerung (..) erzeugt wird.", "type": "multiple-choice", "answers": [{"text": "Konstante Werte", "solution": "true"}, {"text": "Klammern ()", "solution": "true"}, {"text": "Attributnamen einer Relation", "solution": "true"}, {"text": "Vergleichsoperatoren", "solution": "true"}, {"text": "logische Operatoren", "solution": "true"}, {"text": "Berechnungen", "solution": "true"}]}, {"id": 767, "category": 8, "difficulty": 1, "text": "Welcher Operator der relationalen Algebra w\u00e4hlt Tupel aus einer Relation aus?", "explanation": "Die Selektion erzeugt eine n-stellige Relation mit der gleichen Attributanzahl, aber mit weniger oder gleich viel Tupeln als die urspr\u00fcngliche Relation. Sie extrahiert aufgrund des Selektionspr\u00e4dikats Tupel aus einer vorgegebenen Relation.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "false"}]}, {"id": 782, "category": 8, "difficulty": 2, "text": "Welche Eigenschaften haben Relationen in der relationalen Algebra resp. dem relationalen Modell? Kreuzen Sie die korrekten Antworten an!", "explanation": "Eine zentrale Eigenschaft der RA ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen (Projektion, Vereinigung, Durchschnitt und Division), diese Duplikate automatisch eliminiert werden. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA. \n \nEine zweite zentrale Eigenschaft des relationalen Modells ist die Reihenfolgeunabh\u00e4ngigkeit. Sie bedeutet, dass das Ergebnis der\ndeklarativ formulierten Anweisungen (RA: Anfrageausdr\u00fccke / SQL: SELECT, INSERT, UPDATE, DELETE), immer gleich sein muss, unabh\u00e4ngig davon, in welcher Reihenfolge die Tupel gelesen oder verarbeitet wurden. \n,   \nDie Wertebereiche Mi hei\u00dfen Dom\u00e4nen. Dom\u00e4nen sind atomar, d.h. keine zusammengesetzten Datentypen. Bei der Definition von Dom\u00e4nen muss angegeben werden, ob NULL-Werte, also einzelne Attribute ohne Werteintrag, zugelassen sind.\n \nDie zusammengesetzten Datentypen sind nicht Bestandteil des relationalen Modells. Sie werden erst mit den objektrelationalen Erweiterungen eingef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "F\u00fcr die Attribute sind NULL-Werte erlaubt.", "solution": "true"}, {"text": "Eine Relation hat keine doppelten Tupel, d.h. Zeilen mit komplett den gleichen Werten werden unterdr\u00fcckt.", "solution": "true"}, {"text": "Die Tupelreihenfolge ist fest definiert.", "solution": "false"}, {"text": "Neben atomaren Attributen sind auch selbstdefinierte zusammengesetzte Datentypen zugelassen.", "solution": "false"}]}, {"id": 769, "category": 8, "difficulty": 2, "text": "Bei der Projektion werden identische Tupel automatisch eliminiert.", "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen, diese Duplikate automatisch eliminiert werden. Zu diesen Operatoren geh\u00f6ren Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 784, "category": 8, "difficulty": 2, "text": "Wie hei\u00dft ein Theta-Join, bei dem nur der Gleichheitsoperator als Vergleichsoperator zugelassen ist?", "explanation": "Ein Equi-Join ist ein Theta-Join, der im Selektionspr\u00e4dikat nur den Vergleichsoperator \"=\"\nzul\u00e4sst.\nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "text", "answers": [{"text": "Das ist ein", "solution": "Equi-Join"}]}, {"id": 773, "category": 8, "difficulty": 1, "text": "Ein Outer-Join ist immer verlustfrei.", "explanation": "Eine Join-Operation zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.", "type": "multiple-choice", "answers": [{"text": "Stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1780, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren der relationalen Algebra l\u00e4sst sich der Vereinigungsoperator (UNION) simulieren?", "explanation": "Die Vereinigung (UNION) geh\u00f6rt zu den Grund-/Basisoperatoren, die sich nicht ableiten lassen, wie auch Selektion, Projektion, Kartesisches Produkt und Differenz.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Mit keinen anderen Operator der relationalen Algebra.", "solution": "true"}]}, {"id": 2467, "category": 7, "difficulty": 1, "text": "Welche der folgenden Aussagen \u00fcber Normalformen sind wahr?", "explanation": "FALSCH ist:\n\n    Die 1NF ist immer verschieden von der 2NF.\n\n    Wenn es keine partiellen funktionalen Abh\u00e4ngigkeiten gibt vom Prim\u00e4rschl\u00fcssel in der 1.NF, dann gilt: 1.NF = 2.NF.\n\n    FALSCH ist:\n\n    Die 2NF ist immer verschieden von der 3NF.\n\n    Wenn es keine transitiven funktionalen Abh\u00e4ngigkeiten gibt, dann gilt: 2.NF = 3.NF.", "type": "multiple-choice", "answers": [{"text": "Die 1NF ist immer verschieden von der 2NF.", "solution": "false"}, {"text": "keine von beiden", "solution": "true"}, {"text": "Die 2NF ist immer verschieden von der 3NF.", "solution": "false"}]}, {"id": 3779, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abh\u00e4ngigkeiten:  A-> B, C, E     C -> E  und   D -> F  \n\nWelche Attributkombination ist ein (minimaler) eindeutiger Schl\u00fcssel?", "explanation": "Von A h\u00e4ngen alle Attribute au\u00dfer F ab. Daher braucht man neben A noch D f\u00fcr den Prim\u00e4rschl\u00fcssel.", "type": "text", "answers": [{"text": "Der Prim\u00e4rschl\u00fcssel ist:", "solution": "AD\r"}]}, {"id": 3773, "category": 7, "difficulty": 2, "text": "Gegeben sei eine Relation R(V, W, X, Y, Z) mit funktionalen Abh\u00e4ngigkeiten V -> W und Y -> X und\n\nV, Y -> Z.   Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 3NF?", "explanation": "V und Y sind schon der Prim\u00e4rschl\u00fcssel der Relation, da alle anderen Attribute von ihnen abh\u00e4ngen und die ersten zwei FDs sind partielle bzw. die letzte eine volle Abh\u00e4ngikeit vom zusammengestzten Prim\u00e4rschl\u00fcssel. Da transitive Abh\u00e4ngigkeiten fehlen, gilt hier 2.NF = 3.NF.", "type": "multiple-choice", "answers": [{"text": "R={V,W,X,Y, Z}", "solution": "false"}, {"text": "R1(V, W),   R2(Y,X),   R3(V,Y,Z)", "solution": "true"}, {"text": "R1(V,Y,Z) und R2(V,W,Y,X)", "solution": "false"}]}, {"id": 3770, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine Relation R(X, Y, Z, V, W, T) mit den funktionalen Abh\u00e4ngigkeiten\n\nX, V -> Z   und   Z, Y-> W   und   Y -> V, T.    Welche Attributkombination ist ein (minimaler) eindeutiger Schl\u00fcssel?\n\nBitte die Attribute in alphabetischer Reihenfolge durch Kommas getrennt und ohne Klammern aufschreiben!", "explanation": "Alle anderen Attribute lassen sich von X und Y ableiten!", "type": "text", "answers": [{"text": "Das sind die Attribute:", "solution": "X , Y\r"}]}, {"id": 3758, "category": 7, "difficulty": 1, "text": "Es sei eine Relation R(X, Y, Z) gegeben mit einem zusammengesetzten Prim\u00e4rschl\u00fcssel auf X, Y und einem eindeutigen Zweitschl\u00fcssel auf Z sowie einem gespeicherten Datensatz : (2, \"a\", 9).\n\nWelche weiteren Datens\u00e4tze lassen sich zu diesem hinzuf\u00fcgen?", "explanation": "Bitte beachten Sie die Eindeutigkeit des Prim\u00e4rschl\u00fcssels und des Zweitschl\u00fcssels! (Unique Key)", "type": "multiple-choice", "answers": [{"text": "(5, \"d\", 3)", "solution": "true"}, {"text": "(2, \"a\", 5)", "solution": "false"}, {"text": "(2, \"a\", 9)", "solution": "false"}, {"text": "(2, \"s\", 4)", "solution": "true"}, {"text": "(9, \"a\", 2)", "solution": "true"}, {"text": "(4, \"s\", 9)", "solution": "false"}]}, {"id": 3769, "category": 7, "difficulty": 1, "text": "Gegeben sei eine Relation R(V, W, X, Y) mit funktionalen Abh\u00e4ngigkeiten V, Y -> W, X und\n\nW -> X.   Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 3NF?", "explanation": "V und Y sind schon der Prim\u00e4rschl\u00fcssel der Relation, da alle anderen Attribute von ihnen abh\u00e4ngen. Au\u00dferdem gibt es eine transitive Abh\u00e4ngikeit W -> X.", "type": "multiple-choice", "answers": [{"text": "R={V,W,X,Y}", "solution": "false"}, {"text": "R12(V, Y) und R2(W,X)", "solution": "false"}, {"text": "R12(V, W,Y) und R2(W,X)", "solution": "true"}]}, {"id": 649, "category": 7, "difficulty": 1, "text": "Bei der Abbildung eines ER-Diagramms auf ein relationales Datenbankschema werden generell alle Entit\u00e4ten auf Relationen abgebildet.", "explanation": "Bei der Transformation, die auch maschinell erfolgen kann, gibt es zwei Hauptregeln: \nRegel 1: Die Entity-Mengen des ER-Modells werden auf Relationen abgebildet. \nRegel 2: Beziehungen werden auf Fremdschl\u00fcsselattribute oder Relationen abgebildet.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 789, "category": 7, "difficulty": 3, "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass jede Relation einen Prim\u00e4rschl\u00fcssel besitzt.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt.", "type": "text", "answers": [{"text": "Diese Eigenschaft hei\u00dft", "solution": "Entity-Integrit\u00e4t"}]}, {"id": 898, "category": 7, "difficulty": 1, "text": "Eine Relation, deren Prim\u00e4rschl\u00fcssel nur aus einem Attribut besteht, ist immer in der dritten Normalform.", "explanation": "Der Sachverhalt aus der Fragestellung hat nichts mit der 3. NF zu tun.\n\nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist. \nMit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist. \nAlso X ->Y \u2192Z, aber nicht Y \u2192X.  \n\nDamit eine Relation \u00fcberhaupt die 3. NF verletzen kann, muss sie \u00fcber wenigstens 3 Attribute verf\u00fcgen, von denen ein Attribut zum Prim\u00e4rschl\u00fcssel geh\u00f6rt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 899, "category": 7, "difficulty": 1, "text": "Eine Relation, deren Prim\u00e4rschl\u00fcssel nur aus einem Attribut besteht, ist immer in der ersten Normalform.", "explanation": "Wenn das Atrribut nicht atomar ist, ist die 1. NF trotzdem verletzt. \nEine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 900, "category": 7, "difficulty": 3, "text": "In einer Menge von Relationen besitzt jede Relation einen Prim\u00e4rschl\u00fcssel.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt.", "type": "text", "answers": [{"text": "Das ist die ...", "solution": "Entity-Integrit\u00e4t"}]}, {"id": 1130, "category": 7, "difficulty": 1, "text": "Eine Relation, die die Entity-Integrit\u00e4t besitzt, hat", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt.", "type": "multiple-choice", "answers": [{"text": "einen oder keinen Prim\u00e4rschl\u00fcssel.", "solution": "false"}, {"text": "genau einen Prim\u00e4rschl\u00fcssel.", "solution": "true"}, {"text": "einen oder mehrere Prim\u00e4rschl\u00fcssel.", "solution": "false"}]}, {"id": 2796, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C und den folgenden funktionalen Abh\u00e4ngigkeiten Welche Arten funktionaler Abh\u00e4ngigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abh\u00e4ngigkeit als Antwort eintragen, also volle, partielle oder transitive.", "explanation": "D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig.\n\n    B ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von C.\n\n    E ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von A.", "type": "text", "answers": [{"text": "A, C -> D, E, F", "solution": "volle"}, {"text": "A -> E", "solution": "partielle"}, {"text": "C -> B", "solution": "partielle"}]}, {"id": 807, "category": 7, "difficulty": 3, "text": "Welche Vorteile hat eine Normalisierung von Relationen?", "explanation": "Es soll insgesamt ein \"gutes\" Datenbankschema entstehen, wobei sich die G\u00fcte misst in \nleichterer Handhabbarkeit, m\u00f6glichst wenig Redundanzen und  \u00dcbersichtlichkeit. \nDemgegen\u00fcber kennzeichnen sich schlechte Datenbankschemata durch: Redundanzen, die zu unn\u00f6tigem Speicherplatzverbrauch f\u00fchren.\u00c4nderungsanomalien: Bei \u00c4nderungen muss der gleiche Wert an mehreren Stellen aktualisiert werden.Einf\u00fcgeanomalien: Bereits vorhandene Daten werden an anderer Stelle wiederholt eingef\u00fcgt.L\u00f6schanomalien: Die Daten m\u00fcssen an mehreren Stellen gel\u00f6scht werden.Hohe Fehleranf\u00e4lligkeit: Die Fehlerh\u00e4ufigkeit ist erh\u00f6ht, da bei diesen \u00c4nderungen Daten anfallen k\u00f6nnen, die nicht alle auf den gleichen Stand gebracht wurden.", "type": "multiple-choice", "answers": [{"text": "Einf\u00fcgeanomalien werden vermieden", "solution": "true"}, {"text": "Inkonsistenzen treten nicht auf", "solution": "true"}, {"text": "\u00c4nderungsanomalien werden vermieden", "solution": "true"}, {"text": "Speicherplatzverbrauch wird reduziert.", "solution": "true"}, {"text": "Das Konzept der Objektorientierung wird umgesetzt.", "solution": "false"}]}, {"id": 808, "category": 7, "difficulty": 1, "text": "Eine vollst\u00e4ndige Normalisierung hat den Nachteil, dass es Performanceverluste beim Lesen durch eine gro\u00dfe Anzahl von Relationen geben kann.", "explanation": "Durch die Normalisierung ergibt sich bei gr\u00f6\u00dferen Projekten eine Vielzahl von mit Fremdschl\u00fcsselbeziehungen verbundenen Relationen. Informationen, die inhaltlich im Sinne der Objektorientierung zusammengeh\u00f6ren, werden unter Umst\u00e4nden auf viele Relationen verteilt. Bei Abfragen kann es zu erheblichen Performanceverlusten kommen, da oft viele Relationen aufw\u00e4ndig miteinander verkn\u00fcpft werden m\u00fcssen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 819, "category": 7, "difficulty": 3, "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass die Korrektheit der Eingaben der Benutzer gew\u00e4hrleistet ist.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die semantische Integrit\u00e4t, wenn die Korrektheit der Eingaben der Benutzer gew\u00e4hrleistet ist.", "type": "text", "answers": [{"text": "Das ist die ...", "solution": "semantische Integrit\u00e4t"}]}, {"id": 1807, "category": 7, "difficulty": 2, "text": "Jede Relation, die die Entity-Integrit\u00e4t besitzt hat, hat neben einem Prim\u00e4rschl\u00fcssel auch immer mindestens einen Fremdschl\u00fcssel, wenn mehr als zwei Relationen in der Datenbank vorhanden sind.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrit\u00e4t, wenn jeder Wert eines Fremdschl\u00fcssels einer Relation Ri Wert eines Prim\u00e4rschl\u00fcssels in einer anderen Relation Rj ist.  \nEine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt. \nDas Konzept Prim\u00e4rschl\u00fcssels ist unabh\u00e4ngig von den Fremdschl\u00fcsseln. Es kann Relationen mit Prim\u00e4rschl\u00fcsseln geben (Entity-intregrit\u00e4t) ohne das es Fremdschl\u00fcssel (referentielle Integrit\u00e4t) gibt. Andersherum k\u00f6nnen Fremdschl\u00fcssel nur definiert werden, wenn es Prim\u00e4rschl\u00fcssel gibt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2791, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C und den folgenden funktionalen Abh\u00e4ngigkeiten Welche Arten funktionaler Abh\u00e4ngigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abh\u00e4ngigkeit als Antwort eintragen, also volle, partielle oder transitive.", "explanation": "D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig.\n\n    B ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von C.\n\n    E ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig.", "type": "text", "answers": [{"text": "A, C -> D, E, F", "solution": "volle"}, {"text": "D-> E", "solution": "transitive"}, {"text": "C -> B", "solution": "partielle"}]}, {"id": 3070, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C und den folgenden funktionalen Abh\u00e4ngigkeiten. Welche Arten funktionaler Abh\u00e4ngigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abh\u00e4ngigkeit als Antwort eintragen, also volle, partielle oder transitive.", "explanation": "B, D, E sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig.\n\n    F ist von C abh\u00e4ngig, also nur von einem Teil des Prim\u00e4rschl\u00fcssels und damit ist F partiell von A,C abh\u00e4ngig.\n\n    E ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig.", "type": "text", "answers": [{"text": "A, C -> B, D, E", "solution": "volle"}, {"text": "D -> E", "solution": "transitive"}, {"text": "C -> F", "solution": "partielle"}]}, {"id": 2477, "category": 7, "difficulty": 3, "text": "Welche Aussagen hinsichtlich Normalisierung und Normalformen sind wahr?", "explanation": "1. Die Normalisierung geht von einem Datenvolumen aus, bei dem die in den Relationen enthaltenen Daten schon vorhanden sind und sich nicht ver\u00e4ndern. Auf diesen Relationen werden aufgrund funktionaler Abh\u00e4ngigkeiten Ma\u00dfnahmen zur besseren Strukturierung durchgef\u00fchrt. In der Praxis sind nat\u00fcrlich die Relationen beim Datenbankentwurf noch nicht in allen F\u00e4llen mit Daten gef\u00fcllt; Bewegungsdaten ver\u00e4ndern sich immer im laufenden Betrieb. Der Entwickler muss also einen\ngewissen Sp\u00fcrsinn haben, wo in Zukunft unerw\u00fcnschte funktionale Abh\u00e4ngigkeiten und Redundanzen auftreten k\u00f6nnten. Au\u00dferdem wird beim konzeptionellen Modell als ER-Modell oft schon intuitiv die dritte Normalform gew\u00e4hlt. \n2. Anders sieht das Ganze bei der Reorganisation alter Datenbest\u00e4nde aus. In diesen F\u00e4llen ist die Normalformenlehre ein n\u00fctzliches Instrument, um Redundanzen zu beseitigen und eine gute Datenstruktur zu erreichen. \n3. Durch die Normalisierung ergibt sich bei gr\u00f6\u00dferen Projekten eine Vielzahl von mit Fremdschl\u00fcsselbeziehungen verbundenen Tabellen. Informationen, die inhaltlich im Sinne der Objektorientierung zusammengeh\u00f6ren, werden unter Umst\u00e4nden auf viele Tabellen verteilt. Bei Abfragen kann es zu erheblichen Performanceverlusten kommen, da oft viele Relationen aufw\u00e4ndig miteinander verkn\u00fcpft werden m\u00fcssen. \n4. Aus den angef\u00fchrten Gr\u00fcnden ist eine Verletzung der dritten Normalform (Denormalisierung) in der Praxis manchmal gewollt. Die Normalisierung ist nicht als Dogma zu verstehen, aber nach wie vor ein analytisches Instrument, um Relationenstrukturen auf ihre Qualit\u00e4t hin zu \u00fcberpr\u00fcfen. Mit Datenbanktriggern wird das Problem der Redundanzen handhabbar.", "type": "multiple-choice", "answers": [{"text": "Problematisch ist, dass der Normalisierungsprozess von den vorhandenen Daten ausgeht.", "solution": "true"}, {"text": "Die Aufteilung auf viele Relationen kann zu l\u00e4ngeren Antwortzeiten bei Anfragen f\u00fchren.", "solution": "true"}, {"text": "Die Idee der Normalisierung widerspricht der Objektorientierung.", "solution": "true"}]}, {"id": 1750, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Relation R(A, B, C, D, E) mit den funktionalen Abh\u00e4ngigkeiten AB -> C, BC ->D, CD -> E. Welche Attributkombination ist ein (minimaler) eindeutiger Schl\u00fcssel?", "explanation": "Die beiden einzigen Attribute, die von keinem anderen Attribut abh\u00e4ngig sind, sind A und B, also ist die L\u00f6sung AB.\n\nAndererseits bestimmt eine Kombination aus AB und einem anderen Atrribut aus (C, D) alle anderen Attribute.", "type": "text", "answers": [{"text": "Das ist", "solution": "AB"}]}, {"id": 1659, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Relation R(A, B, C, D, E) mit den funktionalen Abh\u00e4ngigkeiten \nAB -> C, CD-> E und D -> B. Welche Attributkombination ist ein (minimaler) eindeutiger Schl\u00fcssel?", "explanation": "Es kann nur AD sein, weil dies die beiden einzigen Attribute sind, die von keinen anderen Attributen funktional abh\u00e4ngig sind.", "type": "multiple-choice", "answers": [{"text": "AB", "solution": "false"}, {"text": "AD", "solution": "true"}, {"text": "ABC", "solution": "false"}, {"text": "ABCD", "solution": "false"}, {"text": "ABE", "solution": "false"}]}, {"id": 1679, "category": 7, "difficulty": 2, "text": "A und B  seien zwei Attribute einer Relation R.\nWoran erkennt man eine (volle) funktionale Abh\u00e4ngigkeit A -> B?", "explanation": "X und Y seien zwei Teilmengen von Attributen einer Relation R. \nY hei\u00dft funktional abh\u00e4ngig von X, wenn Folgendes gilt: \nF\u00fcr alle Tupel r, s aus R gilt: \nAus ProjX(s) = ProjX(r) folgt stets: ProjY(s) = ProjY(r). \nAus dieser Definition folgt f\u00fcr einen Attributwert in A (=X) dass es in B (=Y) genau einen Attributwert gibt. \nAndere Aussagen l\u00e4sst diese Definition nicht zu.", "type": "multiple-choice", "answers": [{"text": "Zu einem Spaltenwert B gibt es mehrere Spaltenwerte in A.", "solution": "false"}, {"text": "Zu einem Spaltenwert B gibt es genau einen  Spaltenwert in A.", "solution": "false"}, {"text": "Es gibt einen Spaltenwert B, zu dem es keinen Spaltenwert in A gibt.", "solution": "false"}, {"text": "Zu einem Spaltenwert A gibt es mehrere Spaltenwerte in B.", "solution": "false"}, {"text": "Zu einem Spaltenwert A gibt es genau einen  Spaltenwert in B.", "solution": "true"}, {"text": "Es gibt einen Spaltenwert A, zu dem es keinen Spaltenwert in B gibt.", "solution": "false"}]}, {"id": 2449, "category": 7, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber Normalformen sind wahr?", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.", "type": "multiple-choice", "answers": [{"text": "Eine Relation in der 1NF kann Wiederholungsgruppen haben.", "solution": "false"}, {"text": "keine von beiden", "solution": "false"}, {"text": "Eine Relation in der 1NF kann keine Wiederholungsgruppen haben.", "solution": "true"}]}, {"id": 2165, "category": 7, "difficulty": 2, "text": "Gegeben sei eine Relation R(A, B, C) mit den funktionalen Abh\u00e4ngigkeiten A -> B, C und B -> C. Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 3NF?", "explanation": "In der 3. NF werden f\u00fcr jede funktionale Abh\u00e4ngigkeit eine eigene Relation erstellt, plus eine f\u00fcr den Prim\u00e4rschl\u00fcssel der 1.NF, sollte dieser nicht bereits Teil einer der Relationen sein.\n\n    \n\n    Da es sich oben um eine transitive Abh\u00e4ngigkeit handelt, muss das transitiv abh\u00e4ngige Attribut C aus der einen Relation entfernt werden.", "type": "multiple-choice", "answers": [{"text": "R={A,B,C}", "solution": "false"}, {"text": "R1={A,B,C} und R2 ={A,C}", "solution": "false"}, {"text": "R1={A,B,C} und R2 ={B,C}", "solution": "false"}, {"text": "R1={A,B} und R2 ={B,C}", "solution": "true"}]}, {"id": 2915, "category": 7, "difficulty": 1, "text": "F\u00fcr die Festlegung der 2NF braucht man einen Prim\u00e4rschl\u00fcssel", "explanation": "Die Definition der 2NF lautet:Eine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten \nNormalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut \nvoll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  Daher kann man die 2NF nur festlegen, wenn man vorher den Prim\u00e4rschl\u00fcssel kennt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2600, "category": 7, "difficulty": 2, "text": "Gegeben sei eine Relation R(A, B, C) mit den funktionalen Abh\u00e4ngigkeiten A -> B, C und B -> C. Um welche funktionale Abh\u00e4ngigkeit handelt es sich hier? Bitte vervollst\u00e4ndigen Sie die Antwort.", "explanation": "Hier ist C von B und B von A abh\u00e4ngig und damit ist C transitiv von A abh\u00e4ngig.\n\n    Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet.\n\n    Z hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist.\n\n    Also X \u2192 Y \u2192 Z, aber nicht Y \u2192 X.", "type": "text", "answers": [{"text": "Um eine ...", "solution": "transitive"}]}, {"id": 2866, "category": 9, "difficulty": 3, "text": "Welche abh\u00e4ngigen Objekte werden mit dem  DROP TABLE Befehl gel\u00f6scht?", "explanation": "Bis auf die Views werden alle abh\u00e4ngigen Objekte gel\u00f6scht. Die Views bleiben als Definition erhalten, sind aber erst wieder benutzbar, wenn die Tabelle neu angelegt wird. Unter Oracle wird der Status in user_objects auf 'invalid' gesetzt und die View muss neu \u00fcbersetzt werden.", "type": "multiple-choice", "answers": [{"text": "Indizes, die auf der Tabelle definiert sind", "solution": "true"}, {"text": "Constraints, die auf der Tabelle definiert sind", "solution": "true"}, {"text": "Views, die auf der Tabelle definiert sind", "solution": "false"}, {"text": "Die Daten der Tabelle", "solution": "true"}, {"text": "Trigger, die auf der Tabelle definiert sind.", "solution": "true"}]}, {"id": 3423, "category": 9, "difficulty": 2, "text": "Welche Auswirkung hat die folgende Anweisung, wenn die Tabelle Mitglied die Spalte TYPE enth\u00e4lt?\n\n    \n\n    ALTER TABLE  Mitglied\n\n    ADD CONSTRAINT  TYPE_CHECK CHECK (UPPER(TYPE) IN (\"Mitglied\", \"Anw\u00e4rter\", \"Gast\", \"Beobachter\"));", "explanation": "Da die Werte \"Mitglied\", \"Anw\u00e4rter\" etc . nicht in Gro\u00dfbuchstaben geschrieben sind, kann die Check-Bedingung TYPE CHECK nie erf\u00fcllt sein. Daher  k\u00f6nnen keine Werte in die Tabelle Mitglied eingef\u00fcgt werden.", "type": "multiple-choice", "answers": [{"text": "Es wird gepr\u00fcft, ob in der Spalte Type die Werte Mitglied, Anw\u00e4rter, Gast oder Beobachter steht, wobei Gro\u00dfschreibung und Kleinschreibung keine Rolle spielen.", "solution": "false"}, {"text": "In  die Tabelle Mitglied kann nie wieder ein Datensatz eingef\u00fcgt werden.", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 3424, "category": 9, "difficulty": 2, "text": "Welche Auswirkung hat die folgende Anweisung?\n\n    \n\n    CREATE TABLE ist_mitglied\n\n    ( Staat_id          INTEGER NOT NULL,\n\n       Organisation_id   INTEGER NOT NULL,\n\n       TYPE              VARCHAR2 (20)\n\n             UNIQUE\n\n             CONSTRAINT TYPE_CHECK CHECK\n\n                (TYPE IN (\"Mitglied\", \"Anw\u00e4rter\", \"Gast\", \"Beobachter\")),\n\n       PRIMARY KEY (Staat_id, Organisation_id) );", "explanation": "Durch das UNIQUE k\u00f6nnen die Werte \"Mitglied\", \"Anw\u00e4rter\", \"Gast\", \"Beobachter\" nur genau enmal in die Tabelle eingef\u00fcgt werden. Daher k\u00f6nnen h\u00f6chsten vier Werte in die Tabelle Mitglied eingef\u00fcgt werden.", "type": "multiple-choice", "answers": [{"text": "Es wird gepr\u00fcft, ob in der Spalte Type die Werte Mitglied, Anw\u00e4rter, Gast oder Beobachter steht, wobei Gro\u00dfschreibung und Kleinschreibung keine Rolle spielen.", "solution": "false"}, {"text": "In  die Tabelle ist_Mitglied k\u00f6nnen nicht mehr als vier  in Datens\u00e4tze eingef\u00fcgt werden.", "solution": "true"}, {"text": "keine von allen", "solution": "false"}, {"text": "Es wird gepr\u00fcft, ob in der Spalte Type die Werte Mitglied, Anw\u00e4rter, Gast oder Beobachter steht, wobei Gro\u00dfschreibung und Kleinschreibung eine Rolle spielen.", "solution": "true"}]}, {"id": 2817, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgende CREATE-Table-Anweisung und die anschlie\u00dfende ALTER-Anweisung:\n\n    CREATE TABLE Artikel (TNr NUMBER(38) PRIMARY KEY,\n\n    Bezeichnung VARCHAR2(50) NOT NULL,\n\n    Artikel_Typ VARCHAR2(50) NOT NULL,\n\n    Verkaufspreis NUMBER,\n\n    Jahresumsatz NUMBER,\n\n    Zeitstempel DATE);\n\n     ALTER TABLE Artikel DROP COLUMN Jahresumsatz;\n\n    Welche Aussagen sind wahr?", "explanation": "ALTER-Table geh\u00f6rt zur DDL-Sprache und kann daher nicht zur\u00fcckgerollt werden, da sie ein AUTOCOMMIT beinhaltet. Siehe auch <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/ALTER-TABLE\"> ALTER-TABLE", "type": "multiple-choice", "answers": [{"text": "Die Spalte Jahresumsatz wird gel\u00f6scht, auch wenn Daten enthalten sind.", "solution": "true"}, {"text": "Die Spalte Jahresumsatz wird nur gel\u00f6scht, wenn keine Daten enthalten sind.", "solution": "false"}, {"text": "Die Spalte Jahresumsatz wird nur gel\u00f6scht, wenn mindestens eine Spalte in der Tabelle verbleibt.", "solution": "true"}, {"text": "Eine Alter-Table-Anweisung kann \u00fcber die ROLLBACK-Anweisung wieder zur\u00fcckgerollt werden.", "solution": "false"}, {"text": "Die Spalte Jahresumsatz kann sogar gel\u00f6scht werden, wenn sie Bestandteil eines zusammengesetzten Prim\u00e4rschl\u00fcssels ist.", "solution": "true"}]}, {"id": 2816, "category": 9, "difficulty": 2, "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\n    CREATE TABLE Auftraege\n\n    (AuftragsNr NUMBER(38) PRIMARY KEY,\n\n    Auftrags_Typ VARCHAR2(50) NOT NULL,\n\n    Kun_Nr NUMBER(38) NOT NULL,\n\n    Ang_Nr NUMBER(38),\n\n    auftragssumme NUMBER);\n\n    \n\n    CREATE TABLE Auftragspositionen ,\n\n    (TNr NUMBER(38),\n\n    AuftragsNr NUMBER(38),\n\n    Menge NUMBER,\n\n    PRIMARY KEY Auftragspositionen(TNR, AuftragsNr));\n\n    \n\n    Welche CREATE-Index-Anweisungen sind korrekt?", "explanation": "Ein Index kann immer nur auf einer Tabelle definiert werden und auch nicht, wenn schon ein entsprechender Prim\u00e4rschl\u00fcssel mit den gleichen Spalten existiert. Siehe die Syntaxbeschreibung der CREATE-INDEX-Anweisung im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-INDEX\"> CREATE-INDEX-Anweisung", "type": "multiple-choice", "answers": [{"text": "CREATE UNIQUE INDEX Auftr_INDEX ON Auftraege(TNr);", "solution": "false"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX1 ON Auftragspositionen(TNr);", "solution": "true"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX2 ON Auftragspositionen(AuftragsNr);", "solution": "true"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX3 ON Auftraege, Auftragspositionen(AuftragsNr, Menge);", "solution": "false"}]}, {"id": 1930, "category": 9, "difficulty": 2, "text": "Jeder Column-Constraint (Spaltenbedingung) kann auch als Table-Constraint (Tabellenbedingung) geschrieben werden.", "explanation": "Ein Column-Constraint unterscheidet sich von einem Table-Constraint durch die Stellung im SQL-Befehl: \nDer Columns-Constraint wird durch ein Komma von der Spaltendefinition abgetrennt und kann sich nur auf einen Spalte beziehen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1929, "category": 9, "difficulty": 2, "text": "Jeder Table-Constraint (Tabellenbedingung) kann auch als Column-Constraint (Spaltenbedingung) geschrieben werden.", "explanation": "Ein COLUMN-Constraint kann sich nur auf eine Spalte beziehen, ein TABLE-Constraint auch auf mehrere Spalten. Der einzige Column-Constraint, der nicht als TABLE-Constraint geschrieben werden kann, ist der (NOT)-NULL-CONSTRAINT.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1582, "category": 9, "difficulty": 2, "text": "Es soll folgende Spieler-Tabelle angelegt werden:  spieler (spieler_id, name, handy) mit dem Prim\u00e4rschl\u00fcssel: spieler_id.\n\n    Mit welchem/n Befehl/en kann zus\u00e4tzlich ein zusammengesetzter, eindeutiger Zweitschl\u00fcssel f\u00fcr die Tabelle \"spieler\" \u00fcber die beiden Attribute \"name, handy\" definiert werden, der zum Transaktionsende gepr\u00fcft werden soll?", "explanation": "Nur der Ausdruck\n\n    \n\n    CREATE TABLE spieler\n\n    (spieler_id NUMBER(9) PRIMARY KEY,\n\n    name VARCHAR2(50),\n\n    handy NUMBER(11),\n\n    UNIQUE (name, handy) INITIALLY DEFERRED);\n\n    \n\n    ist syntaktisch richtig und entspricht der Fragestellung.", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \nname VARCHAR2(50), \nhandy    NUMBER(11), \nUNIQUE (name, handy) INITIALLY DEFERRED);", "solution": "true"}, {"text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \n name VARCHAR2(50) UNIQUE INITIALLY DEFERRED, \n handy NUMBER(11) UNIQUE INITIALLY DEFERRED);", "solution": "false"}, {"text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \nname VARCHAR2(50), \nhandy    NUMBER(11), \nUNIQUE (name, handy) INITIALLY IMMEDIATE);", "solution": "false"}, {"text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \n name VARCHAR2(50) UNIQUE INITIALLY IMMEDIATE, \n handy NUMBER(11) UNIQUE INITIALLY IMMEDIATE);", "solution": "false"}]}, {"id": 2836, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Constraints sind wahr?", "explanation": "Der einzige Spalten-Constraint, der nicht als Tabellenbedingung geschrieben werden kann, ist der NOT NULL CONSTRAINT.\nsiehe auch < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CONSTRAINT\"> CONSTRAINT im DB-Wiki.", "type": "multiple-choice", "answers": [{"text": "Eine Foreign-Key-Spalte kann keine NULL-Werte enthalten.", "solution": "false"}, {"text": "Eine UNIQUE-Spalte kann NULL-Werte enthalten.", "solution": "true"}, {"text": "Ein Constraint wird wird nur bei Insert-Anweisungen \u00fcberpr\u00fcft.", "solution": "false"}, {"text": "Ein Constraint kann unter Oracle-SQL auch disabled werden, wenn er Daten enth\u00e4lt", "solution": "true"}, {"text": "Alle Spalten-Constraints k\u00f6nnen auch als Tabellen-Constraint dfdefiniert werden.", "solution": "true"}]}, {"id": 2828, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Sequenzen (CREATE SEQUENCE....) sind wahr?", "explanation": "Siehe < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-SEQUENCE\"> CREATE SEQUENCE", "type": "multiple-choice", "answers": [{"text": "Mit DELETE SEQUENCE <sequencename>; wird eine Sequenz wieder gel\u00f6scht.", "solution": "false"}, {"text": "CURVAL enth\u00e4lt die zuletzt verwendete fortlaufende Nummer.", "solution": "true"}, {"text": "Mit ALTER SEQUENCE ... kann eine Sequenz nachtr\u00e4glich ver\u00e4ndert werden, wenn z.B. der MAXVALUE erreicht ist.", "solution": "true"}, {"text": "Sequenzen k\u00f6nnen auch absteigende Nummern erzeugen.", "solution": "false"}, {"text": "Sequenzen k\u00f6nnen nur in einer Tabelle genutzt werden.", "solution": "false"}, {"text": "Sequenzen werden ausschlie\u00dflich nur f\u00fcr k\u00fcnstliche Prim\u00e4rschl\u00fcssel verwendet.", "solution": "false"}]}, {"id": 2825, "category": 9, "difficulty": 3, "text": "Welche Ausage(n) \u00fcber Constraints ist wahr?", "explanation": "Die einzige Spaltenbedingung, die nicht als Tabellenbedingung fomuliert werden kann, ist der NOT NULL-Constraint. \n\nFOREIGN-KEY-Constraints und UNIQUE-Constraints k\u00f6nnen auch NULL -Werte enthalten. \n\nCONSTRAINTS werden auch bei UPDATE und DELETE \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "Eine Spalte mit FOREIGN KEY-Constraint kann keine NULL-Werte enthalten.", "solution": "false"}, {"text": "Eine Spalte mit UNIQUE-Constraint kann keine NULL-Werte enthalten.", "solution": "false"}, {"text": "Ein Constraint wird nur bei einer INSERT-Anweisung \u00fcberpr\u00fcft.", "solution": "false"}, {"text": "Ein Constraint kann unter Oracle auch DISABLED werden, wenn die Spalte Daten enth\u00e4lt.", "solution": "true"}, {"text": "Jeder Spaltenbedingung kann auch als Tabellenbedingung formuliert werden.", "solution": "false"}]}, {"id": 2820, "category": 9, "difficulty": 2, "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\n    CREATE TABLE Auftraege\n\n    (AuftragsNr NUMBER(38) PRIMARY KEY,\n\n    Auftrags_Typ VARCHAR2(50) NOT NULL,\n\n    Kun_Nr NUMBER(38) NOT NULL,\n\n    Ang_Nr NUMBER(38),\n\n    auftragssumme NUMBER);\n\n    \n\n    CREATE TABLE Auftragspositionen ,\n\n    (TNr NUMBER(38),\n\n    AuftragsNr NUMBER(38),\n\n    Menge NUMBER,\n\n    PRIMARY KEY Auftragspositionen(TNR, AuftragsNr));\n\n    \n\n    Welche CREATE-Index-Anweisungen sind korrekt?", "explanation": "Ein Index kann immer nur auf einer Tabelle definiert werden und auch nicht, wenn schon ein entsprechender Prim\u00e4rschl\u00fcssel mit den gleichen Spalten existiert. Siehe die Syntaxbeschreibung der CREATE-INDEX-Anweisung im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-INDEX\"> CREATE-INDEX-Anweisung.", "type": "multiple-choice", "answers": [{"text": "CREATE UNIQUE INDEX Auftr_INDEX ON Auftraege(TNr);", "solution": "false"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX1 ON Auftragspositionen(TNr);", "solution": "true"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX2 ON Auftragspositionen(AuftragsNr);", "solution": "true"}]}, {"id": 2818, "category": 9, "difficulty": 3, "text": "Mit welchem Befehl legt man einen CONSTRAINT nachtr\u00e4glich auf einer Tabelle an? Es soll nachtr\u00e4glich auf einer Tabelle Artikel die Spalte Verkaufspreis in NOT NULL ver\u00e4ndert werden.", "explanation": "Constraints sind keine eigenen Datenbankobjekte, sie der geh\u00f6ren zu einer Tabelle und werden daher auch nicht mit einem eigenen DROP-Befehl gel\u00f6scht, sondern mit einem ALTER TABLE-Befehl. Die genaue Syntax finden Sie im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/ALTER-TABLE\"> ALTER-Table", "type": "multiple-choice", "answers": [{"text": "ALTER  TABLE  artikel \nMODIFY verkaufspreis CONSTRAINT BEZ_NN NOT NULL;", "solution": "true"}, {"text": "ALTER  TABLE  artikel \nADD CONSTRAINT BEZ_NN NOT NULL(verkaufspreis);", "solution": "false"}, {"text": "ALTER TABLE XYZ DROP CONSTRAINT ...", "solution": "false"}, {"text": "ALTER  TABLE  artikel \nMODIFY verkaufspreis CONSTRAINT BEZ_NN NOT NULL(Verkaufspreis);", "solution": "false"}, {"text": "ALTER  TABLE  artikel \nADD verkaufspreis NUMBER  CONSTRAINT BEZ_NN NOT NULL;", "solution": "false"}]}, {"id": 3425, "category": 9, "difficulty": 2, "text": "Auf welchen Spalten ist ein Verweis \u00fcber einen Fremdschl\u00fcssel m\u00f6glich?", "explanation": "Fremdschl\u00fcssel k\u00f6nnen auf Spalten verweisen, die einen Prim\u00e4rschl\u00fcssel oder einen Zweitschl\u00fcssel haben. Ein Zweitschl\u00fcssel wird in SQL durch einen UNIQUE-Constraint oder einen CREATE UNIQUE INDEX .. implementiert.", "type": "multiple-choice", "answers": [{"text": "Auf Spalten, die als Zweitschl\u00fcssel (UNIQUE CONSTRAINT) definiert sind.", "solution": "true"}, {"text": "keine von allen", "solution": "false"}, {"text": "Auf Spalten, die als Prim\u00e4rschl\u00fcssel (Primary Key) definiert sind.", "solution": "true"}]}, {"id": 2775, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden CREATE-TABLE-Befehl:\n\n    CREATE TABLE Person (\n\n    ID NUMBER,\n\n    NACHNAME VARCHAR2,\n\n    TYP CHAR);\n\n    \n\n    Welche Aussage/n sind/ist korrekt?", "explanation": "NUMBER und CHAR kommen ohne L\u00e4ngenangabe aus, NUMBER ist eine Flie\u00dfkommazahl, CHAR ein Textfeld der L\u00e4nge 1.", "type": "multiple-choice", "answers": [{"text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil NUMBER ohne Nachkommastellen nicht zugelassen ist.", "solution": "false"}, {"text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil CHAR eine L\u00e4nge , z.B. CHAR(10) haben muss.", "solution": "false"}, {"text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil VARCHAR2 eine L\u00e4nge , z.B. VARCHAR(10) haben muss.", "solution": "true"}]}, {"id": 2774, "category": 9, "difficulty": 2, "text": "Welchem Schemaobjekt kann man ein CONSTRAINT zuweisen?", "explanation": "CONSTRAINTS sind immer an eine Tabelle angeh\u00e4ngt und k\u00f6nnen mit CREATE TABLE oder ALTER TABLE.. erzeugt werden.", "type": "multiple-choice", "answers": [{"text": "TABLE", "solution": "true"}, {"text": "VIEW", "solution": "false"}, {"text": "INDEX", "solution": "false"}, {"text": "SEQUENCE", "solution": "false"}]}, {"id": 2773, "category": 9, "difficulty": 3, "text": "Welche SQL-Anweisung einh\u00e4lt ein implizites COMMIT?", "explanation": "Alle DDL-Anweisungen(CREATE, DROP, ALTER..)  beinhalten ein implizites COMMIT, im Gegensatz zu den DML-Anweisungen INSERT, UPDATE und DELETE.", "type": "multiple-choice", "answers": [{"text": "DROP TABLE", "solution": "true"}, {"text": "INSERT", "solution": "false"}, {"text": "UPDATE", "solution": "false"}, {"text": "DELETE", "solution": "false"}, {"text": "SELECT", "solution": "false"}, {"text": "CREATE TABLE", "solution": "true"}, {"text": "CREATE VIEW", "solution": "true"}]}, {"id": 2764, "category": 9, "difficulty": 3, "text": "Welche CONSTRAINTS k\u00f6nnen nicht als Tabellen-Constraint definiert werden?", "explanation": "NOT NULL ist der einzige CONSTRAINT-Typ, der nicht als Tabellenbedingung geschrieben werden kann.", "type": "multiple-choice", "answers": [{"text": "NOT NULL", "solution": "true"}, {"text": "PRIMARY KEY", "solution": "false"}, {"text": "CHECK", "solution": "false"}, {"text": "UNIQUE", "solution": "false"}, {"text": "REFERENCES", "solution": "false"}]}, {"id": 2765, "category": 9, "difficulty": 2, "text": "Welche CONSTRAINTS k\u00f6nnen als Spalten-Constraint definiert werden?", "explanation": "Alle 5 Constraint-Typen k\u00f6nnen als Spaltenbedingung formuliert werden. NOT NULL ist der einzige CONSTRAINT-Typ, der nicht als Tabellenbedingung geschrieben werden kann.", "type": "multiple-choice", "answers": [{"text": "NOT NULL", "solution": "true"}, {"text": "PRIMARY KEY", "solution": "true"}, {"text": "CHECK", "solution": "true"}, {"text": "UNIQUE", "solution": "true"}, {"text": "REFERENCES", "solution": "true"}]}, {"id": 2763, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Fremdschl\u00fcssel (Foreign Keys) sind wahr?", "explanation": "F\u00fcr die Definition eines Fremdschl\u00fcssels reicht ein UNIQUE-Constraint auf der referenzierten Spalte aus. Ein Prim\u00e4rschl\u00fcssel ist hinreichend, aber nicht notwendig.", "type": "multiple-choice", "answers": [{"text": "Die Syntax eines Foreign-Key-Constraints setzt voraus, dass auf der referenzierten Spalte ein Prim\u00e4rschl\u00fcssel definiert ist.", "solution": "false"}, {"text": "Die Syntax eines Foreign-Key-Constraints setzt voraus, dass auf der referenzierten Spalte ein UNIQUE-Constraint oder ein Prim\u00e4rschl\u00fcssel definiert ist.", "solution": "true"}, {"text": "Keine von bedien Antworten ist richtig.", "solution": "false"}]}, {"id": 2779, "category": 9, "difficulty": 2, "text": "Betrachten Sie die folgenden SQL-Befehl: \n\nCREATE TABLE Person (\nID NUMBER PRIMARY KEY,\nNACHNAME VARCHAR2(20),\nTYP CHAR(1));\n\n\nINSERT INTO PERSON (1, NULL, NULL);\nINSERT INTO PERSON (2, WILLI, 'B');\n\nUPDATE PERSON\n  SET TYP = 'A' WHERE TYP = 'B';\nCOMMIT;\n\nWelche Aussage/n sind/ist korrekt?\n\n", "explanation": "Die WHERE-Klausel 'WHERE TYP = 'B' greift nur, wenn der TYP keinen Nullwert hat.", "type": "multiple-choice", "answers": [{"text": "Eine Zeile wird ver\u00e4ndert.", "solution": "true"}, {"text": "Zwei Zeilen werden ver\u00e4ndert.", "solution": "false"}, {"text": "Keine Zeile wird ver\u00e4ndert.", "solution": "false"}]}, {"id": 2776, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden CREATE-TABLE-Befehl: \n\nCREATE TABLE Person (\nID NUMBER PRIMARY KEY,\nNACHNAME VARCHAR2(20) PRIMARY KEY,\nTYP CHAR(1));\n\nWelche Aussage/n sind/ist korrekt?", "explanation": "Eine Tabelle kann nur einen PRIMRY KEY haben, der die physische Struktur der Tabelle festlegt.", "type": "multiple-choice", "answers": [{"text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil eine Tabelle nur eine PRIMARY KEY haben kann.", "solution": "true"}, {"text": "Der CREATE-TABLE -Befehl wirft keinen Fehler.", "solution": "false"}, {"text": "Der CREATE-TABLE -Befehl wirft keinen Fehler, aber es wird nur der erste PRIMARY KEY erzeugt.", "solution": "false"}]}, {"id": 2615, "category": 9, "difficulty": 3, "text": "Die Fehlerkorrektur beim Fremdschl\u00fcssel bietet welche Klauseln an?", "explanation": "Wenn man bedenkt, f\u00fcr welche Problemstellung die Fehlerkorrektur gedacht ist, dann kommt man schnell darauf, das es nur die beiden Klauseln \"ON UPDATE\" und \"ON DELETE\" geben kann.  \nWerden Fremdschl\u00fcssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datens\u00e4tze, die noch von Detail-Datens\u00e4tze referenziert werden, gel\u00f6scht oder deren Schl\u00fcsselwert ge\u00e4ndert wird und das anschlie\u00dfend Detail-Datens\u00e4tze existieren, f\u00fcr deren Fremdschl\u00fcsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt. \nDas Einf\u00fcgen von Master-Datens\u00e4tzen ist immer unproblematisch, da eine Fremdschl\u00fcsselbedingung es zul\u00e4\u00dft, dass es Master-Datens\u00e4tze gibt, f\u00fcr die es keine Detail-Datens\u00e4tze gibt. \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION", "type": "multiple-choice", "answers": [{"text": "ON INSERT <Fehlerkorrektur Aktion>", "solution": "false"}, {"text": "ON UPDATE <Fehlerkorrektur Aktion>", "solution": "true"}, {"text": "ON DELETE <Fehlerkorrektur Aktion>", "solution": "true"}, {"text": "Es gibt gar keine Fehlerkorrektur bei den Fremdschl\u00fcsseln in SQL.", "solution": "false"}, {"text": "Es gibt zwar eine Fehlerkorrektur bei den Fremdschl\u00fcsseln in SQL, die Klauseln hei\u00dfen aber ganz anders.", "solution": "false"}]}, {"id": 2614, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber das Fehlerverhalten des SQL-Integrit\u00e4tspr\u00fcfungskonzepts sind wahr?", "explanation": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird. Dieses Verhalten wird f\u00fcr Integrit\u00e4tsfehler ausschlie\u00dflich bei NOT NULL, PRIMARY KEY, UNIQUE ausgef\u00fchrt. \n\nLediglich die Fremdschl\u00fcssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabh\u00e4ngig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik, wenn Masterdatens\u00e4tze gel\u00f6scht werden, f\u00fcr die noch abh\u00e4ngige Detail-Datens\u00e4tze bestehen. Es besteht dann die M\u00f6glichkeit, z.B. die abh\u00e4ngigen Detaildatens\u00e4tze ebenfalls zu l\u00f6schen (CASCADE) oder deren Fremdschl\u00fcsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION", "type": "multiple-choice", "answers": [{"text": "Im Falle eines Integrit\u00e4tsfehlers wird mit einer Warnmeldung reagiert, die Datenmanipulation persistent in der Datenbasis gespeichert.", "solution": "false"}, {"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und die Datenmanipulation abgebrochen wird.(IMMEDIATE sowie DEFERRED)", "solution": "false"}, {"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird.", "solution": "true"}, {"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird bzw. bei einer DEFERRED-Pr\u00fcfung die Datenmanipulation abgebrochen wird.", "solution": "false"}, {"text": "Das Fremdschl\u00fcsel-Constraint bietet die Option, dass das DBMS eine Fehlerkorrektur durchf\u00fchrt.", "solution": "true"}, {"text": "Die Constraints PRIMARY KEY, FOREIGN KEY und UNIQUE bieten die Option, dass das DBMS eine Fehlerkorrektur durchf\u00fchrt.", "solution": "false"}]}, {"id": 262, "category": 9, "difficulty": 2, "text": "Welcher der folgenden CHECK-Constraints ist korrekt?", "explanation": "RICHTIG ist: \ngeschlecht VARCHAR2(1) CHECK (geschlecht IN ('W', 'M'))\nDa die CHECK-Bedingung f\u00fcr Tabellen- und Spalten-Constraints die gleiche Syntax aufweist, startet die Bedingung nach der \u00f6ffenenden Klammer immer mit einem Spaltennamen. Der IN-Operator erwartet als zweiten Operanden eine Komma getrennte Liste konstanter Werte (unterschiedliche Werte gleichen Datentyps ohne Wiederholungen) oder eine SELECT-Anfrage, daher sind die OR-Operatoren dort v\u00f6llig fehl am Platze.", "type": "multiple-choice", "answers": [{"text": "geschlecht VARCHAR2(1) CHECK (IN ('W', 'M'))", "solution": "false"}, {"text": "geschlecht VARCHAR2(1) CHECK (geschlecht IN ('W', 'M'))", "solution": "true"}, {"text": "geschlecht VARCHAR2(1) CHECK (geschlecht IN ('W' OR 'M'))", "solution": "false"}]}, {"id": 660, "category": 9, "difficulty": 1, "text": "CONSTRAINTS sind eigene Datenbankobjekte, die unabh\u00e4ngig von einer Tabelle existieren.", "explanation": "Constraints werden nicht mit einem eigenen CREATE-Table-Befehl, sondern \u00fcber ein ALTER-Table oder CREATE-Table angelegt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 664, "category": 9, "difficulty": 2, "text": "Durch welches Zeichen wird in SQL die Konkatenation von Zeichenketten dargestellt?", "explanation": "In SQL ist es das Pipe-Zeichen: || ", "type": "text", "answers": [{"text": "Das Zeichen ist:", "solution": "||"}]}, {"id": 400, "category": 9, "difficulty": 1, "text": "Bei einem  COLUMN-CONSTRAINT", "explanation": "Ein COLUMN-Constraint kann sich nur auf eine Spalte beziehen, ein TABLE-Constraint auch auf mehrere Spalten.", "type": "multiple-choice", "answers": [{"text": "k\u00f6nnen mehrere Spalten betroffen sein", "solution": "false"}, {"text": "sind immer mehrere Spalten betroffen", "solution": "false"}, {"text": "kann nur eine Spalte betroffen sein", "solution": "true"}, {"text": "ist \u00fcberhaupt keine Spalte betroffen", "solution": "false"}]}, {"id": 444, "category": 9, "difficulty": 3, "text": "Mit welcher Erg\u00e4nzung zu DROP TABLE... l\u00f6scht man alle Fremdschl\u00fcssel-CONSTRAINTS, die diese Tabelle referenzieren?", "explanation": "Specify CASCADE CONSTRAINTS to drop all referential integrity constraints that refer to primary and unique keys in the dropped table. If you omit this clause, and such referential integrity constraints exist, then the database returns an error and does not drop the table.", "type": "text", "answers": [{"text": "Der Befehl hei\u00dft:", "solution": "CASCADE CONSTRAINTS"}]}, {"id": 264, "category": 9, "difficulty": 2, "text": "Der Vergleichsoperator \"ungleich\" hei\u00dft in SQL:", "explanation": "Die Vergleichsoperatoren f\u00fcr Ungleicheit sind: <> oder !=", "type": "multiple-choice", "answers": [{"text": "=!", "solution": "false"}, {"text": "<>", "solution": "true"}, {"text": "!=", "solution": "true"}, {"text": "UNLIKE", "solution": "false"}, {"text": "UNEQUAL", "solution": "false"}]}, {"id": 103, "category": 9, "difficulty": 2, "text": "Mit welchem Befehl l\u00f6scht man einen CONSTRAINT?", "explanation": "Constraints sind keine eigenen Datenbankobjekte, sie der geh\u00f6ren zu einer Tabelle und werden daher auch nicht mit einem eigenen DROP-Befehl gel\u00f6scht, sondern mit einem ALTER TABLE-Befehl.", "type": "multiple-choice", "answers": [{"text": "ALTER TABLE XYZ DELETE CONSTRAINT ...", "solution": "false"}, {"text": "DELETE CONSTRAINT ...", "solution": "false"}, {"text": "ALTER TABLE XYZ DROP CONSTRAINT ...", "solution": "true"}, {"text": "DROP CONSTRAINT ...", "solution": "false"}]}, {"id": 118, "category": 9, "difficulty": 1, "text": "Die Programmierung von SQL-Befehlen muss case-sensitive erfolgen.", "explanation": "Der SQL-\u00dcbersetzer arbeitet nicht case-sensitiv, so dass bei der Programmierung von SQL-Befehlen die Gro\u00df-/Kleinschreibung von reservierten W\u00f6rtern v\u00f6llig irrelevant ist. \nLediglich bei Vergleichen z.B. in der WHERE-Klausel muss jedoch sehr wohl auf die passende Gro\u00df-/Kleinschreibung geachtet werden, da hier case-sensitiv die Inhalte von Datenspalten verglichen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 121, "category": 9, "difficulty": 1, "text": "Mit dem DROP TABLE - Befehl werden Tabellen-Definition und Daten der Tabelle gel\u00f6scht.", "explanation": "Mit dem DROP TABLE-Befehl werden die Daten, die Tabelle selbst und alle abh\u00e4ngigen Datenbankobjekte, wie z.B. Constraints und  Trigger gel\u00f6scht.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "false"}, {"text": "stimmt", "solution": "true"}]}, {"id": 2613, "category": 9, "difficulty": 3, "text": "Welches SQL-Constraint bietet die M\u00f6glichkeit zur Fehlerkorrektur?", "explanation": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird. Dieses Verhalten wird f\u00fcr Integrit\u00e4tsfehler ausschlie\u00dflich bei NOT NULL, PRIMARY KEY, UNIQUE ausgef\u00fchrt. \n\nLediglich die Fremdschl\u00fcssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabh\u00e4ngig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik, wenn Masterdatens\u00e4tze gel\u00f6scht werden, f\u00fcr die noch abh\u00e4ngige Detail-Datens\u00e4tze bestehen. Es besteht dann die M\u00f6glichkeit, z.B. die abh\u00e4ngigen Detaildatens\u00e4tze ebenfalls zu l\u00f6schen (CASCADE) oder deren Fremdschl\u00fcsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION", "type": "text", "answers": [{"text": "Bitte geben Sie den deutschsprachigen Namen ein (ohne Zus\u00e4tze wie Bedignung oder Constraint):", "solution": "Fremdschl\u00fcssel"}]}, {"id": 2606, "category": 9, "difficulty": 3, "text": "Ein Tabellen-Constraint (TABLE CONSTRAINT) kann folgende Klauseln haben:", "explanation": "FALSCH ist:\nDie REFERENCES-Klausel gibt es nur bei den Spalten-Constraints, als Tabellen-Constraint hei\u00dft diese Funktion FOREIGN KEY. Die NULL-Klausel gibt es ausschlie\u00dflich als Spalten-Constraint.\n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n\n ::= \nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... )\n\n| CHECK (  )\n\n\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "NULL", "solution": "false"}, {"text": "CHECK", "solution": "true"}, {"text": "UNIQUE", "solution": "true"}, {"text": "PRIMARY KEY", "solution": "true"}, {"text": "FOREIGN KEY", "solution": "true"}, {"text": "REFERENCES", "solution": "false"}]}, {"id": 2621, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    \n\n    Welche Aussagen sind wahr?", "explanation": "Das Problem hier ist: Die leere Tabelle Hierarchie kann gar nicht gef\u00fcllt werden mit Datens\u00e4tzen.\n\n    \n\n    F\u00fcgt man erst (\"Emil\", \"Hugo\") ein, so schl\u00e4gt dies fehl, weil die Fremdschl\u00fcsselbeziehung verletzt ist. Es gibt keinen Master-Datensatz mit Hugo als Angestellten z.B.: (\"Hugo\", ...).\n\n    \n\n    F\u00fcgt man erst (\"Hugo\", NULL) ein, so schl\u00e4gt dies fehl, weil die NOT NULL-Bedingung f\u00fcr die Vorgesetzten-Spalte verletzt ist.\n\n    \n\n    Da beide Constraints als IMMEDIATE definiert sind (Default, wenn eine Angabe des Pr\u00fcfungszeitpunkts fehlt) macht es keinen Unterschied, ob man beide Einf\u00fcgungen in einer Transaktion ablaufen l\u00e4sst.\n\n    \n\n    Wenn man beide Constraints als DEFERRED definiert h\u00e4tte, dann w\u00e4re es jedoch unerheblich, ob erst der eine oder erst der andere Satz eingef\u00fcgt w\u00fcrde, dann w\u00fcrden also beide Einf\u00fcgereihenfolgen funktionieren. Es w\u00fcrde ja erst zum COMMIT-Zeitpunkt gepr\u00fcft, ob der Endzustand ok ist und keine Zwischenzust\u00e4nde.\n\n    \n\n    Der Datensatz kann nicht eingef\u00fcgt werden, weil das Pflichteingabe-Constraint (NOT NULL) der Spalte Vorgesetzter fehl schl\u00e4gt. Der Datensatz kann nicht eingef\u00fcgt werden, weil die Fremdschl\u00fcsselbeziehung mit dem Wert \"Emil\" fehlschl\u00e4gt. Es gibt ja noch keinen anderen Datensatz in der Tabelle.", "type": "multiple-choice", "answers": [{"text": "Der Datensatz ('Emil', 'Hugo') kann in die leere Tabelle eingef\u00fcgt werden. ", "solution": "false"}, {"text": "Der Datensatz ('Hugo', NULL) kann in die leere Tabelle eingef\u00fcgt werden. \nNULL bezeichnet die leere Spalte.", "solution": "false"}, {"text": "Innerhalb einer Transaktion k\u00f6nnen die beiden Datens\u00e4tze ('Hugo', NULL) ('Emil', 'Hugo') in dieser Reihenfolge in die leere Tabelle eingef\u00fcgt werden. ", "solution": "false"}, {"text": "Innerhalb einer Transaktion k\u00f6nnen die beiden Datens\u00e4tze ('Emil', 'Hugo') ('Hugo', NULL) in dieser Reihenfolge in die leere Tabelle eingef\u00fcgt werden. ", "solution": "false"}, {"text": "Es kann gar kein Datensatz in die leere Tabelle eingef\u00fcgt werden.", "solution": "true"}]}, {"id": 3740, "category": 9, "difficulty": 1, "text": "F\u00fcr welche Datenbankobjekte gibt es einen CREATE-Befehl?", "explanation": "Constraints werden mit der Tabelle angelegt, alle anderen Objekte mittels CREATE ....", "type": "multiple-choice", "answers": [{"text": "SEQUENCE", "solution": "true"}, {"text": "CONSTRAINT", "solution": "false"}, {"text": "INDEX", "solution": "true"}, {"text": "VIEW", "solution": "true"}]}, {"id": 2633, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft der CONSTRAINT, wenn eine Spalte Zweitschl\u00fcssel ist?", "explanation": "Das Zweitschl\u00fcssel-Constraint hei\u00dft UNIQUE.\n\n    \n\n    Die \u00fcbrigen vier Constraints sind: FOREIGN KEY, CHECK, PRIMARY KEY und NOT NULL.", "type": "text", "answers": [{"text": "Das ist:", "solution": "UNIQUE"}]}, {"id": 2624, "category": 9, "difficulty": 3, "text": "Welche SQL-Befehle l\u00f6sen eine IMMEDIATE-Integrit\u00e4tspr\u00fcfung aus?", "explanation": "Ziel der Integrit\u00e4tspr\u00fcfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints gen\u00fcgen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erf\u00fcllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Pr\u00fcfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE l\u00f6sen also IMMEDIATE-Integrit\u00e4tspr\u00fcfung aus. \nCOMMIT beendet eine Transaktion und l\u00f6st damit eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie r\u00fcckg\u00e4ngig gemacht wird. Eine Integrit\u00e4tspr\u00fcfung ist daher unn\u00f6tig und wird nicht ausgef\u00fchrt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was daf\u00fcr sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integrit\u00e4tspr\u00fcfung ausl\u00f6sen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Pr\u00fcfung wird damit nicht ausgel\u00f6st.", "type": "multiple-choice", "answers": [{"text": "ROLLBACK", "solution": "false"}, {"text": "DELETE", "solution": "true"}, {"text": "SELECT", "solution": "false"}, {"text": "INSERT", "solution": "true"}, {"text": "CHECK", "solution": "false"}, {"text": "UPDATE", "solution": "true"}, {"text": "COMMIT", "solution": "false"}, {"text": "SAVE", "solution": "false"}, {"text": "DROP", "solution": "false"}, {"text": "CREATE", "solution": "false"}, {"text": "ALTER", "solution": "false"}]}, {"id": 2620, "category": 9, "difficulty": 1, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    Es wird versucht, folgenden Datensatz einzuf\u00fcgen in die leere Tabelle einzuf\u00fcgen:\n\n    INSERT INTO hierarchie VALUES (\"Hugo\",NULL);\n\n    Geben Sie den Inhalt der Tabelle nach dem Einf\u00fcgen des Datensatzes an!", "explanation": "Der Datensatz kann nicht eingef\u00fcgt werden, weil das Pflichteingabe-Constraint (NOT NULL) der Spalte Vorgesetzter fehl schl\u00e4gt.", "type": "text", "answers": [{"text": "Der Inhalt ist folgender: \n(f\u00fcr einen oder mehrere eingef\u00fcgte Datens\u00e4tze nur die beiden Namen mit Leerzeichen getrennt; f\u00fcr eine leere Tabelle das Wort: leer)", "solution": "leer"}]}, {"id": 2604, "category": 9, "difficulty": 2, "text": "Was muss man tun, damit eine mit einer DROP-Anweisung gel\u00f6schtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) aus der Datenbank entfernt ist?", "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausf\u00fchrung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl \"ALTER TABLE tabellenname DROP persistent\" gibt es nicht und ebenso wenig die DROP-Option PERSISTENT.", "type": "multiple-choice", "answers": [{"text": "Nach der DROP-Anweisung ein COMMIT absetzen.", "solution": "false"}, {"text": "Gar nichts, weil bei der Ausf\u00fchrung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgef\u00fchrt wird.", "solution": "true"}, {"text": "Die Option PERSISTENT beim DROP-Befehl verwenden.", "solution": "false"}, {"text": "F\u00fcr jedes DB-Objekt gibt es einen ALTER-Befehl, der f\u00fcr die dauerhafte L\u00f6schung sorgt. Hier z.B. f\u00fcr eine Tabelle:\nALTER TABLE tabellenname DROP persistent;", "solution": "false"}]}, {"id": 2634, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft der CONSTRAINT, dessen Semantik durch den Programmierer festgelegt wird?", "explanation": "Das Zweitschl\u00fcssel-Constraint hei\u00dft UNIQUE.\n\n    \n\n    Die \u00fcbrigen vier Constraints sind: FOREIGN KEY, CHECK, PRIMARY KEY und NOT NULL.", "type": "text", "answers": [{"text": "Das ist:", "solution": "CHECK"}]}, {"id": 2720, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle:\n\n    CREATE TABLE Zeitschrift\n\n    ( Zeitschrift_id INTEGER NOT NULL,\n\n    Namen VARCHAR2(20) NULL,\n\n    PRIMARY KEY (Zeitschrift_id));\n\n    \n\n    CREATE TABLE Aufsatz\n\n    ( Aufsatz_id INTEGER NOT NULL,\n\n    Titel VARCHAR2(20) NULL,\n\n    Zeitschrift_id INTEGER NOT NULL,\n\n    PRIMARY KEY (Aufsatz_id),\n\n    FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\n    Auf welcher der beiden Tabellen ist ein ON DELETE CASCADE m\u00f6glich, mit dem Zweck, dass zu einer Zeitschrift auch die zuh\u00f6rigen Aufs\u00e4tze gel\u00f6scht werden?", "explanation": "ON DELETE CASCADE ist eine Option des Fremdschl\u00fcssel-Constraints und da bei der Zeitschriften-Tabelle gar kein Fremdschl\u00fcssel definiert ist, kann auch kein ON DELETE CASCADE spezifiziert werden.", "type": "multiple-choice", "answers": [{"text": "Zeitschrift", "solution": "false"}, {"text": "Aufsatz", "solution": "true"}]}, {"id": 2608, "category": 9, "difficulty": 1, "text": "Welcher CONSTRAINT-Typ kann sich nur auf eine Spalte beziehen?", "explanation": "Je nach Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung)\ndifferenziert. Die Spaltenbedingungen werden direkt bei der Spaltendefinition des CREATE TABLE-Befehls programmiert und k\u00f6nnen sich nur auf eine, die gerade definierte Spalte beziehen. Tabellenbedingungen werden auch beim CREATE TALBE-Befehl definiert, sind aber nicht Teil einer Spaltenspezifikation und k\u00f6nnen sich somit auf mehrere Spalten beziehen.", "type": "multiple-choice", "answers": [{"text": "ein TABLE CONSTRAINT", "solution": "false"}, {"text": "ein COLUMN CONSTRAINT", "solution": "true"}, {"text": "keiner von beiden", "solution": "false"}]}, {"id": 2607, "category": 9, "difficulty": 1, "text": "Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden nur alle neu eingef\u00fcgten Datens\u00e4tze und alle zuk\u00fcnftigen Daten\u00e4nderungen und -l\u00f6schungen in und aus dieser Tabelle gepr\u00fcft, ob sie den CONSTRAINT erf\u00fcllen. Die bereits gespeicherten Daten werden nicht gepr\u00fcft.", "explanation": "Falsch, das Constraint-Konzept bietet einen 100% Schutz. Das Wort \"nur\" stimmt hier nicht. Wenn man in der ORACLE-DBA-View USER_CONSTRAINTS sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabh\u00e4ngig vom Zeitpunkt der Speicherung korrekt sind. Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden zur\u00fcckwirkend alle in der Datenbank vorhanden Daten gepr\u00fcft, ob sie dem CONSTRAINT gen\u00fcgen. Falls dies nicht der Fall ist, kann der CONSTRAINT nicht erzeugt werden.\n\n    \n\n    Das ist einer der Punkte, bei dem sich Integrit\u00e4tspr\u00fcfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden nur f\u00fcr alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2605, "category": 9, "difficulty": 2, "text": "Was muss man tun, damit eine mit einer ALTER-Anweisung gel\u00f6schtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) in der Datenbank ge\u00e4ndert vorliegt?", "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausf\u00fchrung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl ALTER mit einer Option PERSISTENT gibt es gar nicht.", "type": "multiple-choice", "answers": [{"text": "Nach der ALTER-Anweisung ein COMMIT absetzen.", "solution": "false"}, {"text": "Gar nichts, weil bei der Ausf\u00fchrung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgef\u00fchrt wird.", "solution": "true"}, {"text": "Die Option PERSISTENT beim ALTER-Befehl verwenden.", "solution": "false"}]}, {"id": 2603, "category": 9, "difficulty": 2, "text": "Was muss man tun, damit eine mit einer CREATE-Anweisung neu erzeugtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) in der Datenbank existiert?", "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausf\u00fchrung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl \"ALTER TABLE tabellenname persistent\" gibt es nicht und ebenso wenig die CREATE-Option PERSISTENT.", "type": "multiple-choice", "answers": [{"text": "Nach der CREATE-Anweisung ein COMMIT absetzen.", "solution": "false"}, {"text": "Gar nichts, weil bei der Ausf\u00fchrung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgef\u00fchrt wird.", "solution": "true"}, {"text": "Die Option PERSISTENT beim CREATE-Befehl verwenden.", "solution": "false"}, {"text": "F\u00fcr jedes DB-Objekt gibt es einen ALTER-Befehl, der f\u00fcr die dauerhafte Speicherung sorgt. Hier z.B. f\u00fcr eine Tabelle:\nALTER TABLE tabellenname persistent;", "solution": "false"}]}, {"id": 2632, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft der CONSTRAINT, wenn eine Spalte Fremdschl\u00fcssel ist?", "explanation": "Das Fremdschl\u00fcssel-Constraint hei\u00dft FOREIGN KEY.\n\n    \n\n    Die <font color=\"#000000\" face=\"Arial, Helvetica, Geneva, sans-serif\">\u00fcbrigen vier  Constraints sind: UNIQUE, CHECK, PRIMARY KEY und NOT NULL.", "type": "text", "answers": [{"text": "Das ist:", "solution": "FOREIGN KEY"}]}, {"id": 2626, "category": 9, "difficulty": 3, "text": "Wann ist ein Constraint erf\u00fcllt in SQL?", "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\nEin Constraint in SQL ist erf\u00fcllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist. ...\n\n\nAchtung: Bei SELECT-Anfragen ist es anders, da wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wurde. Bei UNKNOWN oder FALSE wird der Datensatz \"fallen gelassen\".", "type": "multiple-choice", "answers": [{"text": "Wenn es zu FALSE ausgewertet wird.", "solution": "false"}, {"text": "Wenn es zu UNKNOWN ausgewertet wird.", "solution": "true"}, {"text": "Wenn es zu TRUE ausgewertet wird.", "solution": "true"}]}, {"id": 2619, "category": 9, "difficulty": 2, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    \n\n    Es wird versucht, einen Datensatz in die leere Tabelle einzuf\u00fcgen:\n\n    INSERT INTO HIERACHIE (Hans, Emil);\n\n    Was ist das Ergebnis dieser INSERT-Anweisung?", "explanation": "Der Datensatz kann nicht eingef\u00fcgt werden, weil die Fremdschl\u00fcsselbeziehung mit dem Wert \"Emil\" fehlschl\u00e4gt. Es gibt ja noch keinen anderen Datensatz in der Tabelle.\n\n    \n\n    Fehlerbericht:\n\n    SQL-Fehler: ORA-02291: Integrit\u00e4ts-Constraint (SS_10.SYS_C0015753) verletzt - \u00fcbergeordneter Schl\u00fcssel nicht gefunden\n\n    02291. 00000 - \"integrity constraint (%s.%s) violated - parent key not found\"\n\n    *Cause: A foreign key value has no matching primary key value.\n\n    *Action: Delete the foreign key or add a matching primary key.", "type": "text", "answers": [{"text": "Der Inhalt ist folgender: \n(f\u00fcr einen oder mehrere eingef\u00fcgte Datens\u00e4tze nur die beiden Namen mit Leerzeichen getrennt; f\u00fcr eine leere Tabelle das Wort: leer)", "solution": "leer"}]}, {"id": 2616, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber das Fehlerverhalten des SQL-Integrit\u00e4tspr\u00fcfungskonzepts sind wahr?", "explanation": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird. Dieses Verhalten wird f\u00fcr Integrit\u00e4tsfehler ausschlie\u00dflich bei NOT NULL, PRIMARY KEY, UNIQUE ausgef\u00fchrt.\n\n    \n\n    Lediglich die Fremdschl\u00fcssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabh\u00e4ngig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik,wenn Masterdatens\u00e4tze gel\u00f6scht werden, f\u00fcr die noch abh\u00e4ngige Detail-Datens\u00e4tze bestehen. Es besteht dann die M\u00f6glichkeit, z.B. die abh\u00e4ngigen Detaildatens\u00e4tze ebenfalls zu l\u00f6schen (CASCADE) oder deren Fremdschl\u00fcsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)...\n\n    \n\n     ::=\n\n    REFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n    <\u00dcbereinstimmungstyp>\n\n    [ <fehlerkorrektur definition=\"\"> ]\n\n    \n\n    <fehlerkorrektur definition=\"\"> ::=\n\n    ON UPDATE <fehlerkorrektur aktion=\"\">\n\n    | ON DELETE <fehlerkorrektur aktion=\"\">\n\n    \n\n    <fehlerkorrektur aktion=\"\"> ::=\n\n    CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n\n    \n\n    Wenn man bedenkt, f\u00fcr welche Problemstellung die Fehlerkorrektur gedacht ist, dann kommt man schnell darauf, das es nur die beiden Klauseln \"ON UPDATE\" und \"ON DELETE\" geben kann.\n\n    Werden Fremdschl\u00fcssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datens\u00e4tze, die noch von Detail-Datens\u00e4tze referenziert werden, gel\u00f6scht oder deren Schl\u00fcsselwert ge\u00e4ndert wird und das anschlie\u00dfend Detail-Datens\u00e4tze existieren, f\u00fcr deren Fremdschl\u00fcsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt.\n\n    Das Einf\u00fcgen von Master-Datens\u00e4tzen ist immer unproblematisch, da eine Fremdschl\u00fcsselbedingung es zul\u00e4sst, dass es Master-Datens\u00e4tze gibt, f\u00fcr die es keine Detail-Datens\u00e4tze gibt.", "type": "multiple-choice", "answers": [{"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung nur die fehlerhafte Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird.", "solution": "true"}, {"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird bzw. bei einer DEFERRED-Pr\u00fcfung nur die fehlerhafte Datenmanipulation abgebrochen wird.", "solution": "false"}, {"text": "Das Fremdschl\u00fcsel-Constraint bietet die Option, dass das DBMS eine Fehlerkorrektur durchf\u00fchrt.", "solution": "true"}, {"text": "Die Constraints PRIMARY KEY, FOREIGN KEY und UNIQUE bieten die Option, dass das DBMS eine Fehlerkorrektur durchf\u00fchrt.", "solution": "false"}, {"text": "F\u00fcr die Fehlerkorrektur wird im CREATE TABLE-Befehl eine PL/SQL-Prozedur angegeben, die im Fehlerfall auszuf\u00fchren ist.", "solution": "false"}, {"text": "Die Fehlerkorrektur ist auf einen Spezialfall beschr\u00e4nkt, der im Zusammenhang mit den Fremdschl\u00fcsseln auftreten kann, den sog. \"Dangling Tuples\".", "solution": "true"}, {"text": "F\u00fcr die Fehlerkorrektur stehen drei Anwendungsf\u00e4lle zur Verf\u00fcgung, wann eine Korrektur ausgef\u00fchrt werden soll:\n\n<Fehlerkorrektur Definition> ::=\n  ON INSERT <Fehlerkorrektur Aktion>\n| ON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>", "solution": "false"}]}, {"id": 2627, "category": 9, "difficulty": 2, "text": "Wann ist ein Constraint nicht erf\u00fcllt in SQL? D.h. wann schl\u00e4gt die Integrit\u00e4tspr\u00fcfung fehl?", "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\nEin Constraint in SQL ist erf\u00fcllt wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist. ...\n\n\nAchtung: Bei SELECT-Anfragen ist es anders, da wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wurde. Bei UNKNOWN oder FALSE wird der Datensatz \"fallen gelassen\".", "type": "multiple-choice", "answers": [{"text": "Wenn es zu FALSE ausgewertet wird.", "solution": "true"}, {"text": "Wenn es zu UNKNOWN ausgewertet wird.", "solution": "false"}, {"text": "Wenn es zu TRUE ausgewertet wird.", "solution": "false"}]}, {"id": 2625, "category": 9, "difficulty": 3, "text": "Welche SQL-Befehle l\u00f6sen eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus?", "explanation": "Ziel der Integrit\u00e4tspr\u00fcfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints gen\u00fcgen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erf\u00fcllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Pr\u00fcfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE l\u00f6sen also IMMEDIATE-Integrit\u00e4tspr\u00fcfung aus. \nCOMMIT beendet eine Transaktion und l\u00f6st damit eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie r\u00fcckg\u00e4ngig gemacht wird. Eine Integrit\u00e4tspr\u00fcfung ist daher unn\u00f6tig und wird nicht ausgef\u00fchrt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was daf\u00fcr sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integrit\u00e4tspr\u00fcfung ausl\u00f6sen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Pr\u00fcfung wird damit nicht ausgel\u00f6st.", "type": "multiple-choice", "answers": [{"text": "ROLLBACK", "solution": "false"}, {"text": "DELETE", "solution": "false"}, {"text": "SELECT", "solution": "false"}, {"text": "INSERT", "solution": "false"}, {"text": "CHECK", "solution": "false"}, {"text": "UPDATE", "solution": "false"}, {"text": "COMMIT", "solution": "true"}, {"text": "SAVE", "solution": "false"}, {"text": "CREATE", "solution": "true"}, {"text": "ALTER", "solution": "true"}, {"text": "DROP", "solution": "true"}]}, {"id": 2475, "category": 9, "difficulty": 3, "text": "Welche Constraints sind IMMEDIATE definierbar?", "explanation": "Alle f\u00fcnf SQL-Constraints NULL, CHECK, FOREIGN KEY, PRIMARY KEY, UNIQUE sind unabh\u00e4ngig davon, ob sie Spalten- oder Tabellen-Constraint sind, als IMMEDIATE definierbar. Der Pr\u00fcfungszeitpunkt \"IMMEDIATE\" (unmittelbar) bezeichnet die Pr\u00fcfung unmittelbar, wenn die Datenmanipulation (INSERT, UPDATE, DELETE) eingegeben wird. \n\nAus dem Syntax-Diagramm wird dies ersichtlich, weil f\u00fcr jeden Spalten-/Tabellenbedingungsausdruck die <CONSTRAINT Chraketristika> gelten und hinter denen verbergen sich u.a. die Optionen DEFERRED und IMMEDIATE.", "type": "multiple-choice", "answers": [{"text": "PRIMARY KEY", "solution": "true"}, {"text": "UNIQUE", "solution": "true"}, {"text": "FOREIGN KEY", "solution": "true"}, {"text": "NULL", "solution": "true"}, {"text": "CHECK", "solution": "true"}]}, {"id": 2463, "category": 9, "difficulty": 3, "text": "Welche Constraints sind DEFERRED definierbar?", "explanation": "Alle f\u00fcnf SQL-Constraints NULL, CHECK, FOREIGN KEY, PRIMARY KEY, UNIQUE sind unabh\u00e4ngig davon, ob sie Spalten- oder Tabellen-Constraint sind, als DEFERRED definierbar. Der Pr\u00fcfungszeitpunkt \"DEFERRED\" (verz\u00f6gert) bezeichnet den Zeitpunkt zum Transaktionsende, also dann, wenn COMMIT eingegeben wird. \n\nAus dem Syntax-Diagramm wird dies ersichtlich, weil f\u00fcr jeden Spalten-/Tabellenbedingungsausdruck die <CONSTRAINT Chraketristika> gelten und hinter denen verbergen sich u.a. die Optionen DEFERRED und IMMEDIATE.", "type": "multiple-choice", "answers": [{"text": "NULL", "solution": "true"}, {"text": "Foreign Key", "solution": "true"}, {"text": "Primary Key", "solution": "true"}, {"text": "Unique", "solution": "true"}, {"text": "Check", "solution": "true"}]}, {"id": 2461, "category": 9, "difficulty": 3, "text": "Welche SQL-Befehle l\u00f6sen eine Integrit\u00e4tspr\u00fcfung aus?", "explanation": "Ziel der Integrit\u00e4tspr\u00fcfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints gen\u00fcgen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erf\u00fcllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Pr\u00fcfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE l\u00f6sen also IMMEDIATE-Integrit\u00e4tspr\u00fcfung aus. \nCOMMIT beendet eine Transaktion und l\u00f6st damit eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie r\u00fcckg\u00e4ngig gemacht wird. Eine Integrit\u00e4tspr\u00fcfung ist daher unn\u00f6tig und wird nicht ausgef\u00fchrt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was daf\u00fcr sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integrit\u00e4tspr\u00fcfung ausl\u00f6sen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Pr\u00fcfung wird damit nicht ausgel\u00f6st.", "type": "multiple-choice", "answers": [{"text": "ROLLBACK", "solution": "false"}, {"text": "DELETE", "solution": "true"}, {"text": "SELECT", "solution": "false"}, {"text": "INSERT", "solution": "true"}, {"text": "CHECK", "solution": "false"}, {"text": "UPDATE", "solution": "true"}, {"text": "COMMIT", "solution": "true"}, {"text": "SAVE", "solution": "false"}, {"text": "ALTER", "solution": "true"}, {"text": "DROP", "solution": "true"}, {"text": "CREATE", "solution": "true"}]}, {"id": 2460, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft der CONSTRAINT, wenn eine Spalte Pflichteingabespalte ist?", "explanation": "Das SQL-Constraint f\u00fcr die Pflichteingabe hei\u00dft NOT NULL und ist als einziges Constraint ausschlie\u00dflich als Spalten-Constraint definierbar und erzwingt f\u00fcr eine Spalte die Eingabe eines Wertes. Diese Spalte kann nicht leer sein (NULL).", "type": "text", "answers": [{"text": "Das ist:", "solution": "NOT NULL"}]}, {"id": 2458, "category": 9, "difficulty": 3, "text": "Ein Index", "explanation": "F\u00fcr einen Prim\u00e4rschl\u00fcssel wird automatisch ein Index erstellt vom DBMS, weil man davon ausgeht, dass \u00fcber diese Prim\u00e4rschl\u00fcsselspalten sehr h\u00e4ufig zugreift und dann soll es m\u00f6glichst schnell gehen. \nEin Index ist kein Werkzeug der Integrit\u00e4tspr\u00fcfung sondern ein Mittel des Tunings. Seine Aufgabe ist es, Anfragen (SELECT) zu beschleunigen, mit dem kleinen Nachteil, dass Einf\u00fcgungen, \u00c4nderungen und L\u00f6schungen (INSERT, UPDATE, DELETE) etwas langsamer werden. Neben der eigentlichen Datenmanipulation muss ja auch noch der Index aktualisiert werden.", "type": "multiple-choice", "answers": [{"text": "wird immer f\u00fcr Prim\u00e4rschl\u00fcssel erstellt.", "solution": "true"}, {"text": "beschleunigt das Einf\u00fcgen von Daten.", "solution": "false"}, {"text": "erleichtert die Integrit\u00e4tspr\u00fcfung.", "solution": "false"}, {"text": "besteht aus wenigstens zwei Spalten der zugeh\u00f6rigen Tabelle.", "solution": "false"}]}, {"id": 2127, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl: \n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL, Vorgesetzter VARCHAR2(20) NOT NULL, PRIMARY KEY (Angestellter), FOREIGN KEY (Angestellter) REFERENCES Hierarchie (Vorgesetzter) ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?", "explanation": "Nein, die CREATE-Anweisung ist syntaktisch  nicht korrekt, weil eine Spalte referenziert wird, die gar keine Schl\u00fcsselspalte ist. Die Fremdschl\u00fcsselbeziehung kann nur funktionieren, wenn die referenzierte Spalte der Master-Tabelle, hier Vorgesetzter, auch eindeutig ist. F\u00fcr den Vorgesetzten fehlt jedoch ein PRIMARY KEY- oder UNIQUE-Constraint.\n\n    \n\n    Nein, die Angestellten-Vorgesetzten-Beziehung wird hier nicht semantisch korrekt abgebildet, weil der Fremdschl\u00fcssel von der Angestellten-Spalte auf die Vorgesetzten-Spalte referenziert, dort k\u00f6nnen Werte mehrfach auftreten, so dass eine eindeutige Referenz nicht gegeben ist. z.B.\n\n    \n\n    Angestellter Vorgesetzter\n\n    (\"Hugo\",\"Anton\"),\n\n    (\"Emil\",\"Hugo\"),\n\n    (\"Erna\",\"Hugo\")\n\n    \n\n    Emil und Erna haben beide den Vorgesetzten Hugo. Hier tritt jedoch ein Konflikt ein, weil der Fremdschl\u00fcssel immer den Master-Datensatz referenziert und der muss eindeutig sein. Hier w\u00fcrde vom 1. Datensatz mit dem Wert \"Hugo\" auf sowohl den 2. wie auch den 3. referenziert werden - so etwas geht nicht!", "type": "multiple-choice", "answers": [{"text": "Dieser SQL-Befehl ist syntaktisch nicht korrekt.", "solution": "true"}, {"text": "Dieser SQL-Befehl ist syntaktisch korrekt.", "solution": "false"}, {"text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch nicht korrekt ab.", "solution": "true"}, {"text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch korrekt ab.", "solution": "false"}]}, {"id": 2126, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?", "explanation": "Ja, die CREATE-Anweisung ist syntaktisch korrekt.\n\n    \n\n    Ja, die Angestellten-Vorgesetzten-Beziehung wird hier semantisch korrekt abgebildet, weil der Fremdschl\u00fcssel der Vorgesetzten-Spalte auf den Prim\u00e4rschl\u00fcssel des Angestellten zeigt, der sein Vorgesetzter ist.\n\n    \n\n    z.B.: Emil hat den Vorgesetzten Hugo:\n\n    Angestellter Vorgesetzter\n\n    (\"Hugo\",\"Anton\"),\n\n    (\"Emil\",\"Hugo\"),\n\n    \n\n    Der 1. Datensatz ist der Mitarbeiter-Datensatz von Hugo und der 2. der von Emil. Der Fremdschl\u00fcssel des Emil-Datensatzes verweist auf den Mitarbeiter Hugo, der sein Vorgesetzter ist.", "type": "multiple-choice", "answers": [{"text": "Dieser SQL-Befehl ist syntaktisch nicht korrekt.", "solution": "false"}, {"text": "Dieser SQL-Befehl ist syntaktisch korrekt.", "solution": "true"}, {"text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch nicht korrekt ab.", "solution": "false"}, {"text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch korrekt ab.", "solution": "true"}]}, {"id": 2159, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl: \n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Angestellter) REFERENCES Hierarchie (Vorgesetzter) ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?", "explanation": "Der Prim\u00e4rschl\u00fcssel ist als Tabellen-Constraint definiert. Gut zu erkennen an dem trennenden Komma zu der vorangehenden Spaltendefinition der Spalte Vorgesetzter.\n\n    \n\n    Die Eingabe der Datens\u00e4tze \"(\"Hugo\",\"Emil\"), (\"Erna\",\"Emil\"), (\"Anna\",\"Emil\")\" wird bereits beim 1. Datensatz fehl schlagen, da die Fremdschl\u00fcsselbeziehung f\u00fcr \"Emil\" fehl schl\u00e4gt, weil es keinen Mitarbeitersatz f\u00fcr Emil mit seinem Vorgesetzten gibt z.B. mit (\"Emil\",\"Annna\").\n\n    \n\n    Die Einf\u00fcgung von Anton schl\u00e4gt ebenfalls fehl, weil f\u00fcr Anton der Name seines Vorgesetzten fehlt, den er ja nicht hat. Die Spalte Vorgesetzter ist jedoch Pflichteingabe (NOT NULL).\n\n    \n\n    Wenn f\u00fcr eine Einf\u00fcgung eines neuen Datensatzes die Prim\u00e4rschl\u00fcsselbedingung fehl schl\u00e4gt, dann wird die Einf\u00fcgung r\u00fcckg\u00e4ngig gemacht und eine entsprechende Fehlermeldung angezeigt.", "type": "multiple-choice", "answers": [{"text": "Der Prim\u00e4rschl\u00fcssel ist als Spalten-Constraint definiert.", "solution": "false"}, {"text": "Es sollen die folgenden 3 Datens\u00e4tze in die noch leere Tabelle Hierarchie eingef\u00fcgt werden:\n \n('Hugo','Emil'), ('Erna','Emil'), ('Anna','Emil')\n\nStimmt die Aussage: \n\"Das ist ein semantisch korrekter Inhalt der Tabelle Hierarchie.\"?", "solution": "false"}, {"text": "Als erster Datensatz wird erfolgreich der 'oberste Chef' Anton eingef\u00fcgt: \n\nINSERT INTO hierarchie VALUES ('Anton',NULL);", "solution": "false"}, {"text": "Wenn f\u00fcr eine Einf\u00fcgung eines neuen Datensatzes die Prim\u00e4rschl\u00fcsselbedingung fehl schl\u00e4gt, dann wird die Einf\u00fcgung r\u00fcckg\u00e4ngig gemacht und eine entsprechende Fehlermeldung angezeigt.", "solution": "true"}]}, {"id": 2470, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft der CONSTRAINT, wenn eine Spalte Prim\u00e4rschl\u00fcssel ist?", "explanation": "Das Prim\u00e4rschl\u00fcssel-Constraint hei\u00dft PRIMARY KEY.\n\n    \n\n    Die \u00fcbrigen vier  Constraints sind: UNIQUE, CHECK, FOREIGN KEY und NOT NULL.", "type": "text", "answers": [{"text": "Das ist:", "solution": "PRIMARY KEY"}]}, {"id": 2471, "category": 9, "difficulty": 3, "text": "Wie verh\u00e4lt sich ein DEFERRED-Constraint bei einem Integrit\u00e4tsfehler?", "explanation": "Bei einem Deferred-Constraint wird der Fehler erst angezeigt, wenn die Transaktion z.B. mit COMMIT oder ROLLBACk abgeschlossen wird. \nEs wird nicht nur die fehlerhafte Manipulation, sondern alle Manipulationen, die zur Transaktion geh\u00f6ren, zur\u00fcckgerollt.", "type": "multiple-choice", "answers": [{"text": "Unmittelbar nach der Manipulation eines Datensatzes wird der Fehler angezeigt und der fehlerhafte Datensatz wird nicht angenommen.", "solution": "false"}, {"text": "Zum Transaktionsende wird der Fehler angezeigt und die fehlerhafte Manipulation r\u00fcckg\u00e4ngig gemacht.", "solution": "false"}, {"text": "Keine von diesen Reaktionen", "solution": "true"}]}, {"id": 1693, "category": 9, "difficulty": 2, "text": "Ein CHECK-CONSTRAINT kann sich als COLUMN-Constraint auch auf mehrere Spalten beziehen.", "explanation": "Das ist ja gerade der entscheidende Unterschied zwischen Spalten- (COLUMN-) und Tabellen-Constraints (TABLE-Constraint). Spalten-Constraints k\u00f6nnen sich nur auf eine Spalte beziehen, w\u00e4hrend Tabellen-Constraints sich sowohl auf nur eine oder auf mehrere Spalten beziehen kann.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1692, "category": 9, "difficulty": 3, "text": "Mit welchem CONSTRAINT_CHARACTERISTICA  kann man den Pr\u00fcfungszeitpunkt unmittelbar direkt nach einer DML-Anweisung ausf\u00fchren?", "explanation": "<CONSTRAINT Characteristika> ::= \n{ INITIALLY DEFERRED | INITIALLY IMMEDIATE } [ [ NOT ] DEFERRABLE ]\n\nMit DEFERRED (verz\u00f6gert) wird die Pr\u00fcfung der Integrit\u00e4tsbedingung zum Ende der Transaktion (COMMIT) bezeichnet. IMMEDIATE (unmittelbar) beschreibt die Pr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung einer einzelnen \u00c4nderungsanweisung. \nIMMEDIATE hat den Vorteil, dass Integrit\u00e4tsfehler so fr\u00fch wie m\u00f6glich erkannt werden und DEFERRED, dass w\u00e4hrend der laufenden Transaktion durch nachfolgende Anweisungen ein zwischenzeitlich inkonsistenter Zustand wieder korrigiert werden kann.", "type": "text", "answers": [{"text": "CONSTRAINT_CHARACTERISTICA  =", "solution": "INITIALLY IMMEDIATE"}]}, {"id": 1645, "category": 9, "difficulty": 3, "text": "Welche SQL-Anweisungen mit CONSTRAINTS sind syntaktisch korrekt?", "explanation": "RICHTIG sind: \nknz      VARCHAR2(1)    CHECK (knz IN ('J','N'))\nknz      VARCHAR2(1)    CHECK (knz = ALL ('J','N'))\nBeide CHECK-Bedingungen sind syntaktisch richtig, verf\u00fcgen aber eine unterschiedliche Semantik. Beim IN wird gepr\u00fcft, ob der Wert der Spalte knz 'J' oder 'N' ist. Beim =ALL wird gepr\u00fcft, ob der Wert der Spalte knz die beiden Werte 'J' und 'N' hat. Diese Bedingung ist nicht erf\u00fcllbar, denn wie kann eine Spalte gleichzeitig zwei verschiedene Werte enthalten. Semantisch \u00e4quivalent w\u00e4re die Formulierung mit =ANY. \nFALSCH ist: \nWenn ein Vergleichsoperand eine Menge kosntanter Werte ist, da hilft ein einfaches \"=\" nicht weiter, nur ein IN oder ein \"=\" mit ANY- oder ALL-Option.\nDies \"IN ('J','N')\" reicht syntaktisch auch nicht aus. Ein CHECK-Constraint startet mit \"CHECK ( spaltenname ...\".", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz IN ('J','N')));", "solution": "true"}, {"text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz = ('J','N')));", "solution": "false"}, {"text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz = ALL ('J','N')));", "solution": "true"}, {"text": "keine dieser SQL-Anweisungen", "solution": "false"}, {"text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    IN ('J','N'));", "solution": "false"}]}, {"id": 1752, "category": 9, "difficulty": 1, "text": "Wie viele Spalten kann man innerhalb eines ALTER-Table-Befehls (ALTER TABLE XXX ADD (...)) ver\u00e4ndern bzw. neu hinzuf\u00fcgen?", "explanation": "Man kann mit einem ALTER TABLE xxx ADD | MODIFY mehrere Spalten \u00e4ndern bzw. hinzuf\u00fcgen.", "type": "multiple-choice", "answers": [{"text": "eine Spalte", "solution": "false"}, {"text": "mehrere Spalten", "solution": "true"}]}, {"id": 1751, "category": 9, "difficulty": 1, "text": "Wie erzeugt man mit einem ALTER TABLE-Befehl einen TABLE-CONSTRAINT?", "explanation": "Mit der Option ADD beim ALTER TABLE k\u00f6nnen Constraint einer bereits bestehenden Tabelle hinzugef\u00fcgt werden. Die Option MODIFY gibt es nicht f\u00fcr CONSTRAINTS selber, sondern nur f\u00fcr Spaltendefinitionen, die aber einen COMSTRAINT haben k\u00f6nnen. \nConstraints sind keine eigenst\u00e4ndigen DB-Objekte, so dass es f\u00fcr sie keine eigenen CREATE, ALTER, DROP-Befehle gibt. Sie k\u00f6nnen nur durch entsprechende CREATE TABLE, ALTER TABLE, DROP TABLE-Befehle erzeugt, manipuliert oder gel\u00f6scht werden.", "type": "multiple-choice", "answers": [{"text": "Mit dem Zusatz MODIFY", "solution": "false"}, {"text": "Mit dem Zusatz ADD", "solution": "true"}]}, {"id": 217, "category": 9, "difficulty": 2, "text": "Mit dem Wildcard \"%\" und LIKE selektiert man unter SQL:", "explanation": "Mit dem LIKE-Operator wird die \u00dcbereinstimmung mit einem Zeichenmuster gesucht. Zul\u00e4ssige Wildcards sind: \"%\" f\u00fcr kein, ein, oder mehrere Zeichen und \"_\" f\u00fcr genau ein Zeichen.", "type": "multiple-choice", "answers": [{"text": "kein, ein oder mehrere Zeichen", "solution": "true"}, {"text": "ein oder mehrere Zeichen", "solution": "false"}, {"text": "genau ein Zeichen", "solution": "false"}]}, {"id": 214, "category": 9, "difficulty": 2, "text": "Mit welchem Wildcard wird unter SQL mit LIKE genau ein Zeichen selektiert ?", "explanation": "Mit dem LIKE-Operator wird die \u00dcbereinstimmung mit einem Zeichenmuster gesucht. Zul\u00e4ssige Wildcards sind: \"%\" f\u00fcr kein, ein, oder mehrere Zeichen und \"_\" f\u00fcr genau ein Zeichen.", "type": "multiple-choice", "answers": [{"text": "%", "solution": "false"}, {"text": "_", "solution": "true"}, {"text": "Solch einen Wildcard gibt es nicht.", "solution": "false"}]}, {"id": 218, "category": 9, "difficulty": 3, "text": "Mit welchem Wildcard werden unter SQL mit LIKE ein oder mehrere  Zeichen selektiert ?", "explanation": "Mit dem LIKE-Operator wird die \u00dcbereinstimmung mit einem Zeichenmuster gesucht. Zul\u00e4ssige Wildcards sind: \"%\" f\u00fcr kein, ein, oder mehrere Zeichen und \"_\" f\u00fcr genau ein Zeichen.", "type": "multiple-choice", "answers": [{"text": "%", "solution": "false"}, {"text": "-", "solution": "false"}, {"text": "solch einen Wildcard gibt es nicht.", "solution": "true"}]}, {"id": 216, "category": 9, "difficulty": 1, "text": "Mit welchem Wildcard werden unter SQL mit LIKE kein, ein oder mehrere Zeichen selektiert ?", "explanation": "Mit dem LIKE-Operator wird die \u00dcbereinstimmung mit einem Zeichenmuster gesucht. Zul\u00e4ssige Wildcards sind: \"%\" f\u00fcr kein, ein, oder mehrere Zeichen und \"_\" f\u00fcr genau ein Zeichen.", "type": "multiple-choice", "answers": [{"text": "%", "solution": "true"}, {"text": "_", "solution": "false"}, {"text": "solch einen Wildcard gibt es nicht.", "solution": "false"}]}, {"id": 684, "category": 9, "difficulty": 1, "text": "Die Pflichteingabebedingung kann mit der NOT-NULL-Klausel nur als COLUMN-Constraint definiert werden.", "explanation": "Die Funktionalit\u00e4t des NULL-Constraints ist als einziges Constraint ausschlie\u00dflich als Spalten-Constraint zu haben. Die Funktionalit\u00e4t der anderen Constraints (Prim\u00e4r-, Eindeutigkeit-, Fremdschl\u00fcssel und CHECK) sind sowohl als Spalten- wie auch Tabellen-Constraint definierbar. Beim Fremdschl\u00fcssel muss auf eine unterschiedliche Syntax geachtet werden: Als Spalten-Constraint hei\u00dft es \"REFERENCES\" und als Tabellen-Constraint \"FOREIGN KEY\" \n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... )\n\n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1392, "category": 9, "difficulty": 1, "text": "Wenn ein CONSTRAINT existiert, kann der Anwender sicher sein, dass alle in der Datenbank gespeicherten Daten die Bedingung erf\u00fcllen, die durch den CONSTRAINT definiert ist.", "explanation": "Genau das ist der 100% Schutz, den Datenbanksysteme bei Constraints bieten. Wenn man in der USER_CONSTRAINTS des Dictionary sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabh\u00e4ngig vom Zeitpunkt der Speicherung korrekt sind. \nDas ist einer der Punkte, bei dem sich Integrit\u00e4tspr\u00fcfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden dort nur f\u00fcr alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1741, "category": 9, "difficulty": 3, "text": "Mit welchem CONSTRAINT_CHARACTERISTICA  kann man den Pr\u00fcfungszeitpunkt bis zum Ende der Transaktion verz\u00f6gern?", "explanation": "<CONSTRAINT Characteristika> ::= \n{ INITIALLY DEFERRED | INITIALLY IMMEDIATE } [ [ NOT ] DEFERRABLE ]\n\nMit DEFERRED (verz\u00f6gert) wird die Pr\u00fcfung der Integrit\u00e4tsbedingung zum Ende der Transaktion (COMMIT) bezeichnet. IMMEDIATE (unmittelbar) beschreibt die Pr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung einer einzelnen \u00c4nderungsanweisung. \nIMMEDIATE hat den Vorteil, dass Integrit\u00e4tsfehler so fr\u00fch wie m\u00f6glich erkannt werden, und DEFERRED, dass w\u00e4hrend der laufenden Transaktion durch nachfolgende Anweisungen ein zwischenzeitlich inkonsistenter Zustand wieder korrigiert werden kann.", "type": "text", "answers": [{"text": "CONSTRAINT_CHARACTERISTICA  =", "solution": "INITIALLY DEFERRED"}]}, {"id": 2410, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle: \n\nCREATE TABLE Zeitschrift ( Zeitschrift_id INTEGER NOT NULL, Namen VARCHAR2(20) NULL, PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz ( Aufsatz_id INTEGER NOT NULL, Titel VARCHAR2(20) NULL, Zeitschrift_id INTEGER NOT NULL, PRIMARY KEY (Aufsatz_id), FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\nAuf welcher der beiden Tabellen ist ein ON DELETE CASCADE m\u00f6glich, mit dem Zweck, dass zu einer Zeitschrift auch die zuh\u00f6rigen Aufs\u00e4tze gel\u00f6scht werden?", "explanation": "ON DELETE CASCADE ist eine Option des Fremdschl\u00fcssel-Constraints und da bei der Zeitschriften-Tabelle gar kein Fremdschl\u00fcssel definiert ist, kann auch kein ON DELETE CASCADE spezifiziert werden.", "type": "multiple-choice", "answers": [{"text": "Zeitschrift", "solution": "false"}, {"text": "Aufsatz", "solution": "true"}]}, {"id": 2409, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle: \n\n    CREATE TABLE Zeitschrift ( Zeitschrift_id INTEGER NOT NULL, Namen VARCHAR2(20) NULL, PRIMARY KEY (Zeitschrift_id));\n\n    CREATE TABLE Aufsatz ( Aufsatz_id INTEGER NOT NULL, Titel VARCHAR2(20) NULL, Zeitschrift_id INTEGER NOT NULL, PRIMARY KEY (Aufsatz_id), FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\n    Welche der beiden Tabellen kann zuerst gel\u00f6scht werden?", "explanation": "Eine Tabelle mit einem Primary-Key (hier Zeitschrift mit Zeitschrift_id) , der als Foreign-Key in einer anderen Tabelle vorkommt, kann nicht gel\u00f6scht werden, solange die Verweistabelle noch existiert.", "type": "multiple-choice", "answers": [{"text": "Zeitschrift", "solution": "false"}, {"text": "Aufsatz", "solution": "true"}]}, {"id": 2162, "category": 9, "difficulty": 3, "text": "In welchen Punkten unterscheidet sich ein PRIMARY KEY-Constraint von einem UNIQUE-Constraint?", "explanation": "Die Constraints UNIQUE und PRIMARY KEY unterscheiden sich in den beiden Punkten: \nEs gibt pro Tabelle nur einen PRIMARY KEY aber beliebig viele UNIQUE-Schl\u00fcssel.\nDie Spalten eines PRIMARY KEY sind implizit auch Pflichteingabespalten, w\u00e4hrend die Spalten des UNIQUE-Schl\u00fcssels auch leer sein d\u00fcrfen.", "type": "multiple-choice", "answers": [{"text": "Prim\u00e4rschl\u00fcssel muss immer NOT NULL sein", "solution": "true"}, {"text": "Ein UNIQUE-Schl\u00fcssel muss immer NOT NULL sein", "solution": "false"}, {"text": "Prim\u00e4rschl\u00fcssel sind automatisch indiziert, UNIQUE-Schl\u00fcssel nicht.", "solution": "false"}, {"text": "Es ist nur ein Prim\u00e4rschl\u00fcssel pro Tabelle zul\u00e4ssig, aber viele UNIQUE-Schl\u00fcssel.", "solution": "true"}, {"text": "Ein Prim\u00e4rschl\u00fcssel darf nicht zusammengesetzt sein aus mehreren Spalten.", "solution": "false"}, {"text": "Ein UNIQUE-Schl\u00fcssel darf nicht zusammengesetzt sein aus mehreren Spalten.", "solution": "false"}]}, {"id": 2064, "category": 9, "difficulty": 3, "text": "Der SQL-Ausdruck UNIQUE kann verwendet werden:", "explanation": "Ein INDEX verbessert den Datenzugriff durch den Aufbau von gut zu durchsuchenden separaten Verzeichnissen der Gestalt (Wert, Adresse). Die Spaltenwerte eines solchen Index k\u00f6nnen nun optional eindeutig (UNIQUE) sein oder nicht.\n \n\n<CREATE INDEX Anweisung> ::= \nCREATE [UNIQUE] INDEX Indexname ON Tabellenname  \n       (Spaltenname [, Spaltenname]... );\n \n\nUNIQUE ist einer der 5 SQL-Constraints und zwar der f\u00fcr die Eindeutikeitsschl\u00fcssel (Zweitschl\u00fcssel aus dem relationalen Modell) und bestimmt eine oder mehrere Spalten als eindeutigen Schl\u00fcssel. Die Werte dieser Schl\u00fcsselspalten erlauben keine Duplikate, d\u00fcrfen jedoch NULL-Werte enthalten. Mehrere UNIQUE KEYS sind je Tabelle definierbar. F\u00fcr die Schl\u00fcsselspalten wird automatisch ein INDEX angelegt.\n \nHier das Syntaxbeispiel f\u00fcr die Tabellen-Constraints, gleiches gilt aber auch f\u00fcr die Spalten-Constraints:\n \n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )", "type": "multiple-choice", "answers": [{"text": "bei CONSTRAINTS", "solution": "true"}, {"text": "in einer CREATE-INDEX-Anweisung", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 2051, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber Fremdschl\u00fcssel-Beziehungen sind richtig?", "explanation": "Klar geht das, alle Tabellen- und Spalten-Constraints haben die gleichen Typen (PRIMARY KEY, CHECK, UNIQUE, Fremdschl\u00fcssel) bis auf das [NOT] NULL-Constraint, das gibt es nur bei den Spalten-Constraints. Beim Fremdschl\u00fcssel besteht jedoch der syntaktische Unterschied, dass dieses Constraint als Tabellen-Constraint mit der Option FOREIGN KEY startet und als Spalten-Constraint direkt mit REFERENCES. Die Semantik bleibt jedoch in beiden F\u00e4llen gleich \n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ] \n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "Fremdschl\u00fcssel-Constraints k\u00f6nnen nur als Tabellen-Constraints definiert werden.", "solution": "false"}, {"text": "Fremdschl\u00fcssel-Constraints k\u00f6nnen nur als Spalten-Constraints definiert werden.", "solution": "false"}, {"text": "Fremdschl\u00fcssel-Constraints k\u00f6nnen sowohl als Tabellen- wie auch Spalten-Constraint definiert werden.", "solution": "true"}]}, {"id": 1697, "category": 9, "difficulty": 2, "text": "Welche CONSTRAINT-Typen gibt es in SQL?", "explanation": "Je nach der Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung) differenziert. \nDen Begriff USER_CONSTRAINTS gibt es nur als Name der Tabelle im Oracle-Data-Dictionary, in der alle angelegten Constraints eingetragen sind, nicht aber als Constraint-Typ. Den Begriff der SEQUENCE CONSTRAINTS gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "SEQUENCE CONSTRAINTS", "solution": "false"}, {"text": "COLUMNS CONSTRAINTS", "solution": "true"}, {"text": "TABLE CONSTRAINTS", "solution": "true"}, {"text": "USER_CONSTRAINTS", "solution": "false"}]}, {"id": 1695, "category": 9, "difficulty": 2, "text": "Ein COLUMN CONSTRAINT kann einen Fremdschl\u00fcssel definieren.", "explanation": "Klar geht das, alle Tabellen- und Spalten-Constraints haben die gleichen Typen (PRIMARY KEY, CHECK, UNIQUE, Fremdschl\u00fcssel) bis auf das [NOT] NULL-Constraint, das gibt es nur bei den Spalten-Constraints. Beim Fremdschl\u00fcssel besteht jedoch der syntaktische Unterschied, dass dieses Constraint als Tabellen-Constraint mit der Option FOREIGN KEY startet und als Spalten-Constraint direkt mit REFERENCES. \n\n ::= \n[ CONSTRAINT Constraintname ]  \n[ <CONSTRAINT Characteristika> ] \n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1136, "category": 9, "difficulty": 1, "text": "Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden r\u00fcckwirkend alle in der Datenbank vorhanden Daten gepr\u00fcft, ob sie dem CONSTRAINT gen\u00fcgen. Falls dies nicht der Fall ist, kann das CONSTRAINT nicht erzeugt werden.", "explanation": "Genau das ist der 100% Schutz, den Datenbanksysteme bei Constraints bieten. Wenn man in der USER_CONSTRAINTS des Dictionary sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabh\u00e4ngig vom Zeitpunkt der Speicherung korrekt sind. \nDas ist einer der Punkte, bei dem sich Integrit\u00e4tspr\u00fcfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden nur f\u00fcr alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1309, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber CONSTRAINTS sind wahr?", "explanation": "Die drei richtigen Aussagen erkl\u00e4ren sich selbst. \nFALSCH ist: \nDie Sache mit dem \"MANDATORY-CONSTRAINT\". Ein Constraint dieses Namens gibt es nicht. Das Constraint mit der gew\u00fcnschten Funktion hei\u00dft: NOT NULL bei SQL.", "type": "multiple-choice", "answers": [{"text": "Die Standardreaktion auf einen Integrit\u00e4tsfehler beim \"integrity checking\" mittels Constraints ist das Zur\u00fcckrollen des fehlerhaften DML-Befehls (Pr\u00fcfungsmodus IMMEDIATE) bzw. der gesamten Transaktion beim Pr\u00fcfungsmodus DEFERRED. Nur das FOREIGN KEY-Constraint bietet mit der Action-Klausel eine M\u00f6glichkeit zur Fehlerkorrektur wie z.B. das kaskadierendes L\u00f6schen bei \"dangling tuples\".", "solution": "true"}, {"text": "Transitionale Integrit\u00e4tsbedingungen k\u00f6nnen in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Referenzvariablen (:OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.", "solution": "true"}, {"text": "Oracle-Trigger erweitern das Oracle-Integrit\u00e4tskonzept im Wesentlichen in 2 Punkten. \n- Die Bedingungen die mit Triggern abgepr\u00fcft werden k\u00f6nnen, sind wesentlich komplexer als mit CHECK-CONSTRAINTS (Zugriff auf andere Tabellen, transitionale Integrit\u00e4tsbedingungen).\n- Neben dem Zur\u00fcckrollen des fehlerausl\u00f6senden DML-Befehls, kann mittels der Triggeraktion der Fehler auch korrigiert werden.", "solution": "true"}, {"text": "F\u00fcr im ER-Modell als \"obligatorisch\" (Pflichteingabe) deklarierte Attribute werden im Datenmodell MANDATORY-CONSTRAINTS definiert.", "solution": "false"}]}, {"id": 1306, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber virtuelle SQL-Sichten sind richtig?", "explanation": "Mit dem SQL-Befehl \"CREATE VIEW  ...\" werden virtuelle Sichten erstellt. \nVirtuelle Sichten k\u00f6nnen sowohl auf der Basis von Tabellen als auch aufgrund von anderen Sichten definiert werden, so k\u00f6nnen Sicht-Hierarchien aufgebaut werden. \nAktualit\u00e4tsprobleme (veraltete Daten in der Sicht gegen\u00fcber neuen Daten in den Tabellen oder auch umgekehrt) gibt es nur bei den materialisierten Sichten, weil dort die Daten in Tabellen und Sichten redundant gespeichert sind. Bei virtuellen Sichten wird der Datenbestand bei jeder Anfrage auf den Tabellen ausgewertet und ist damit absolut aktuell, auch wenn es (etwas) l\u00e4nger dauert. \nDas Problem des \"View Updating\", was die automatische Weiterleitung/Transformation der \u00c4nderung von Sichtdaten auf die gespeicherten Tabellen-Daten meint, ist auch noch ein in der Wissenschaft ungel\u00f6stes Problem. F\u00fcr einige F\u00e4lle kann man die Daten automatisch transformieren (einige wenige davon sich auch bei Oracle implementiert), um viele andere F\u00e4lle wird semantisches Hintergrundwissen bei der Transformation ben\u00f6tigt, \u00fcber das nur der Entwickler verf\u00fcgt.", "type": "multiple-choice", "answers": [{"text": "Mit dem SQL-Befehl \"CREATE VIEW <viewname> ...\" werden virtuelle Sichten erstellt.", "solution": "true"}, {"text": "Virtuelle Sichten k\u00f6nnen nur auf der Basis von Tabellen und nicht aufgrund von anderen Sichten definiert werden.", "solution": "false"}, {"text": "Virtuelle Sichten k\u00f6nnen auch auf der Basis von anderen Sichten definiert werden.", "solution": "true"}, {"text": "Da die auf virtuellen Sichten ausgef\u00fchrten \u00c4nderungsoperationen (INSERT, UPDATE, DELETE) ja sowieso auf den zugrunde liegenden Tabellen ausgef\u00fchrt werden, k\u00f6nnen die \u00c4nderungsoperationen auf Sichten mit beliebig komplizierten Definitionen ohne jede Einschr\u00e4nkung ausgef\u00fchrt werden.", "solution": "false"}, {"text": "Bei virtuellen Sichten treten Aktualit\u00e4tsprobleme bei \u00c4nderungen der zugrunde liegenden Daten in den Tabellen auf.", "solution": "false"}]}, {"id": 1391, "category": 9, "difficulty": 1, "text": "Welcher CONSTRAINT-Typ kann sich auch auf mehrere Spalten beziehen?", "explanation": "Je nach Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung)\ndifferenziert. Die Spaltenbedingungen werden direkt bei der Spaltendefinition des CREATE TABLE-Befehls programmiert und k\u00f6nnen sich nur auf eine, die gerade definierte Spalte beziehen. Tabellenbedingungen werden auch beim CREATE TALBE-Befehl definiert, sind aber nicht Teil einer Spaltenspezifikation und k\u00f6nnen sich somit auf mehrere Spalten beziehen.", "type": "multiple-choice", "answers": [{"text": "ein COLUMN-CONSTRAINT", "solution": "false"}, {"text": "ein TABLE-CONSTRAINT", "solution": "true"}, {"text": "keiner von beiden", "solution": "false"}]}, {"id": 1782, "category": 9, "difficulty": 3, "text": "Ein Spalten-Constraint (COLUMN CONSTRAINT) kann folgende Klauseln haben:", "explanation": "FALSCH ist: \nDie FOREIGN KEY-Klausel gibt es nur bei den Tabellen-Constraints, als Spalten-Constraint hei\u00dft diese Funktion REFERENCES. \n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "NULL", "solution": "true"}, {"text": "CHECK", "solution": "true"}, {"text": "UNIQUE", "solution": "true"}, {"text": "PRIMARY KEY", "solution": "true"}, {"text": "FOREIGN KEY", "solution": "false"}, {"text": "REFERENCES", "solution": "true"}]}, {"id": 1703, "category": 9, "difficulty": 2, "text": "Welche \u00c4nderungen kann man mit ALTER TABLE auf den Spalten einer Tabelle durchf\u00fchren, wenn die Spalten leer sind (NULL)?", "explanation": "Weil die Spalten leer sind, ist vieles m\u00f6glich. All diese Dinge sind bei Spalten mit Daten nicht durchf\u00fchrbar, weil sie u.U. zu Konfikten mit den gespeicherten Daten f\u00fchren k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "die Nachkomma-Stellen einer NUMBER-Spalte erh\u00f6hen", "solution": "true"}, {"text": "den Datentyp der Spalte \u00e4ndern", "solution": "true"}, {"text": "die Breite einer Text-Spalte im CHARACTER-oder VARCHAR-Format reduzieren", "solution": "true"}, {"text": "Anzahl-Ziffern in einer NUMBER-Spalte reduzieren", "solution": "true"}, {"text": "Text-Spalten im CHARACTER-oder VARCHAR-Format vergr\u00f6\u00dfern", "solution": "true"}, {"text": "Anzahl-Ziffern in einer NUMBER-Spalte erh\u00f6hen", "solution": "true"}]}, {"id": 3192, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber Views (Sichten) sind wahr?", "explanation": "Den View -Begriff (\u00e4nderbare Sicht)  bitte im DB-Wiki unter   <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht\" target=\"\" title=\"\u00c4nderbare Sicht\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht nachschlagen!", "type": "multiple-choice", "answers": [{"text": "Eine View, in der Spaltenabk\u00fcrzungen benutzt werden (create view  as select spalte1 as neue_Spalte) erlaubt kein UPDATE der Daten.", "solution": "false"}, {"text": "Eine View, mit einer SELECT-Anweisung, die DISTINCT enth\u00e4lt, erlaubt kein UPDATE der Daten.", "solution": "true"}, {"text": "Wenn man in einer virtuellen View Daten l\u00f6scht, bleiben diese Daten in der zugrundeliegenden Tabelle enthalten.", "solution": "false"}, {"text": "Mit CREATE OR REPLACE view wird eine VIEW erst gel\u00f6scht (DROP) und dann wieder angelegt.", "solution": "true"}, {"text": "Mit der ORACLE-Option \"WITH CHECK OPTION\" kann man die in einer View enthaltenen Spalten einschr\u00e4nken.", "solution": "false"}]}, {"id": 3487, "category": 9, "difficulty": 3, "text": "Welche Aussage(n) \u00fcber Unterabfragen sind wahr?", "explanation": "Der In-Operator kann immer benutzt werden, unabh\u00e4ngig davon, wieviele Zeilen die Unterabfrage liefert.\n\n    siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "keine von allen", "solution": "false"}, {"text": "Der IN-Operator kann auch benutzt werden, wenn die Unterabfrage nur eine Zeile liefert.", "solution": "true"}, {"text": "Der IN-Operator kann auch benutzt werden, wenn die Unterabfrage mehr als eine Zeile liefert.", "solution": "true"}]}, {"id": 2905, "category": 9, "difficulty": 2, "text": "Welche SELECT-Abfrage beantwortet die Frage :\n\n    \n\n    \"In welchem Land leben die meisten Menschen?\"\n\n    \n\n    auf der Tabelle country:\n\n    \n\n    CREATE TABLE Country\n\n    (Name VARCHAR2(35) NOT NULL UNIQUE,\n\n    COUNTRY VARCHAR2(4) CONSTRAINT CountryKey PRIMARY KEY,\n\n    Capital VARCHAR2(35),\n\n    Province VARCHAR2(35),\n\n    Population NUMBER);", "explanation": "Die Abfrage mit <> ALL ist syntaktisch korrekt, liefert aber nicht die gew\u00fcnschten L\u00e4nder.", "type": "multiple-choice", "answers": [{"text": "SELECT   country, Name, population    FROM   country  WHERE population <>  ALL (  SELECT   population from country);", "solution": "false"}, {"text": "keine von allen", "solution": "false"}, {"text": "SELECT   country, Name, population    FROM   country  WHERE population >= ALL (  SELECT   population from country);", "solution": "true"}, {"text": "SELECT   country, Name, population    FROM   country  WHERE population = (SELECT MAX(population) from country)", "solution": "true"}]}, {"id": 2824, "category": 9, "difficulty": 3, "text": "Welche Aussage(n) \u00fcber Unterabfragen sind wahr?", "explanation": "siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "Der NOT-Operator kann zusammen mit IN, ALL oder ANY benutzt werden.", "solution": "false"}, {"text": "NOT IN ist \u00e4quivalent zu IS NULL", "solution": "false"}, {"text": "= ANY und = All haben die gleiche Funktionalit\u00e4t", "solution": "false"}, {"text": "Der IN-Operator kann benutzt werden, wenn die Unterabfrage nur eine Zeile liefert.", "solution": "true"}]}, {"id": 2846, "category": 9, "difficulty": 3, "text": "Mit welcher Abfrage kann man ausgeben, wieviele Angestellte keine tel_nr haben (tel_nr ist NULL as Spalteneintrag)?", "explanation": "Einen NULL-Wert fragt man mit IS NULL ab. Wenn COUNT auf eine Spalte mit NULL trifft, ist das Ergebis COUNT(tel_nr) = 0, unabh\u00e4ngig davon, wie oft der NULL-Wert auftaucht. Daher ist die NVL-Funktion notwendig.", "type": "multiple-choice", "answers": [{"text": "SELECT COUNT(tel_nr)\nFROM angestellte\nWHERE tel_nr IS NULL:", "solution": "false"}, {"text": "SELECT COUNT(tel_nr)\nFROM angestellte\nWHERE tel_nr = NULL:", "solution": "false"}, {"text": "SELECT COUNT(DISTINCT tel_nr)\nFROM angestellte\nWHERE tel_nr IS NULL:", "solution": "false"}, {"text": "SELECT COUNT(NVL(tel_nr, 0))\nFROM angestellte\nWHERE tel_nr IS NULL:", "solution": "true"}]}, {"id": 3480, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgenden SQL-Anweisungen:\n\n    CREATE TABLE test (spalte varchar2(10));\n\n    INSERT INTO TEST VALUES (\"Ja\");\n\n    INSERT INTO TEST VALUES (\"Nein\");\n\n    INSERT INTO TEST VALUES (NULL);\n\n    COMMIT;\n\n    SELECT * FROM TEST WHERE Spalte not in (\"Ja\", \"Nein\");\n\n    Welches Ergebnis hat diese SELECT-Abfrage?", "explanation": "Wegen der <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Dreiwertige-Logik\"> dreiwertigen Logik  in SQL liefert der Vergleich mit einem NULL-Wert den Wahrheitswert UNKNOWN, der in der WHERE-Klauesel zu FALSE ausgewertet wird.  Da UNKNOWN mit UNKNOWN  verneint wird, wird die Zeile mit dem NULL-Wert nicht ausgegeben,", "type": "multiple-choice", "answers": [{"text": "Die beiden Tupel mit den Werten \"Ja\" und \"Nein\"", "solution": "false"}, {"text": "Keine Zeilen (no Rows)", "solution": "true"}, {"text": "Diese Abfrage wirft einen Fehler.", "solution": "false"}, {"text": "Das Tupel mit dem Null-Wert in der Spalte", "solution": "false"}]}, {"id": 2827, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank: Abteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Ang_Nr} Angestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr } Es sollen alle Abteilungen mit den zugeh\u00f6rigen Angestellten ausgegeben werden, deren Budget mehr als 5000 \u0080 betr\u00e4gt. Es wird dazu das folgende SELECT-Statement abgesetzt:\n\n    SELECT abt_nr, Name, Budget, Nachname FROM abteilungen WHERE leiter > 2 JOIN angestellte USING (Abt_nr);\n\n    Welche der folgenden Aussagen ist wahr?", "explanation": "Auch in einer SELECT-Anweisung mit JOIN..... USING steht die WHERE-Klausel immer nach der FROM-Klausel.", "type": "multiple-choice", "answers": [{"text": "Die SELECT-Abfrage wird ausgef\u00fchrt und liefert das gew\u00fcnschte Ergebnis.", "solution": "false"}, {"text": "Die SELECT-Abfrage wird nicht ausgef\u00fchrt, da eine ON-Klausel fehlt.", "solution": "false"}, {"text": "Die SELECT-Abfrage wird nicht ausgef\u00fchrt, da die WHERE-Klausel an der falschen Stelle der SELECT-Anweisung steht.", "solution": "true"}]}, {"id": 2826, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Unterabfragen sind wahr?", "explanation": "siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Unterabfrage\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "Eine Unterabfrage kann Daten aus ein oder mehreren Tabellen oder Views auslesen.", "solution": "true"}, {"text": "In einer SELECT-Anweisung k\u00f6nnen nur zwei Unterabfragen parallel genutzt werden.", "solution": "false"}, {"text": "Falls eine Unterabfrage als Ergebnis 0 Zeilen hat, wird NULL zur\u00fcckgegeben.", "solution": "true"}, {"text": "Die Spalten einer Unterabfrage m\u00fcssen immer einen Tabellennamen oder einen Tabellealias haben.", "solution": "false"}, {"text": "In einer WHERE-Klausel k\u00f6nnen Unterabfragen h\u00f6chstens dreimal ineinander geschachtelt werden.", "solution": "false"}]}, {"id": 2823, "category": 9, "difficulty": 3, "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nDer Vertriebsleiter Dr. Guck der Firma Byce & Co. m\u00f6chte herausfinden, f\u00fcr welche Artikel \u00fcberhaupt Auftr\u00e4ge vorliegen. Er stellt folgende Abfrage an die Datenbank:\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   NOT EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr <> b.TNr);\n\nWelche Aussage(n) sind korrekt?", "explanation": "Die korrekte Abfrage w\u00e4re\n\n SELECT  a.TNr, a.Bezeichnung\n FROM    Artikel a\n WHERE   NOT EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);", "type": "multiple-choice", "answers": [{"text": "Die Abfrage wird ausgef\u00fchrt und liefert das gew\u00fcnschte Ergebnis.", "solution": "false"}, {"text": "Die Abfrage wird ausgef\u00fchrt und liefert nicht das gew\u00fcnschte Ergebnis.", "solution": "true"}, {"text": "Die Abfrage wird ausgef\u00fchrt und liefert keine Zeilen als Ergebnis, da der Vergleichsoperator \"=\" in der inneren Abfrage an Stelle von \"<>\" genutzt werden muss.", "solution": "true"}, {"text": "Die Abfrage wirft einen Fehler, da die WHERE-Klausel der \u00e4u\u00dferen Abfrage auf einen Spalte der inneren Abfrage verweisen muss.", "solution": "false"}, {"text": "Die Abfrage wirft einen Fehler, da die WHERE-Klausel der \u00e4u\u00dferen Abfrage einen Vergleichsoperator enthalten muss.", "solution": "false"}]}, {"id": 2821, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden CREATE-Table-Befehl:\n\nCREATE TABLE Auftraege\n(AuftragsNr     NUMBER(38)   PRIMARY KEY\n Auftrags_Typ   VARCHAR2(50) NOT NULL,\n Kun_Nr         NUMBER(38)   NOT NULL,\n Ang_Nr         NUMBER(38),\n auftragssumme  NUMBER);\n\nF\u00fcr welche Datenbankabfrage braucht man eine Unterabfrage?", "explanation": "Bei Abfragen vom Typ \"Berechnen Sie die Summe \u00fcber alle Auftragssummen eines bestimmten Kunden, der vom Angestellten mit der ang_nr = 1 betreut wird!  \" braucht man eine SELECT-Anweisung mit GROUP BY kund_nr zus\u00e4tzlichem WHERE oder HABING-Klausel, je nach Datenbankabfrage.", "type": "multiple-choice", "answers": [{"text": "Berechnen Sie die Summe \u00fcber alle Auftragssummen eines bestimmten Kunden!", "solution": "false"}, {"text": "Berechnen Sie die Summe \u00fcber alle Auftragssummen eines bestimmten Kunden, der vom Angestellten mit der ang_nr = 1 betreut wird!", "solution": "false"}, {"text": "Geben Sie alle Auftrage aus, deren Auftragssumme h\u00f6her ist als der Durchschnitt aller Auftragssummen aus der Tabelle Auftraege!", "solution": "true"}]}, {"id": 2815, "category": 9, "difficulty": 3, "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\nCREATE TABLE Auftraege\n(AuftragsNr         NUMBER(38) NOT NULL,\n Auftrags_Typ         VARCHAR2(50) NOT NULL,\n Kun_Nr         NUMBER(38) NOT NULL,\n Ang_Nr         NUMBER(38),\n auftragssumme             NUMBER);\n\nCREATE TABLE Auftragspositionen\n(TNr             NUMBER(38) NOT NULL,\n AuftragsNr         NUMBER(38) NOT NULL,\n Menge             NUMBER);\n\nWelche DELETE-Anweisungen sind korrekt?", "explanation": "Mit der DELETE-Anweisung kann man keine einzelnen Werte in Spalten, sondern nur komplette Zeilen l\u00f6schen. Siehe die Syntaxbeschreibung der DELETE-Anweisung im Datenbankwiki unter\n<a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/DELETE\"> DELETE-Anweisung", "type": "multiple-choice", "answers": [{"text": "DELETE AuftragsNr FROM Auftraege WHERE auftragssumme < 1000;", "solution": "false"}, {"text": "DELETE Auftraege WHERE auftragssumme < 1000;", "solution": "true"}, {"text": "DELETE FROM Auftraege WHERE (SELECT AuftragsNr FROM Auftragspositionen);", "solution": "false"}, {"text": "DELETE * FROM Auftraege, Auftragspositionen\nWHERE Auftraaege.auftragssumme < 1000\nAND Auftraege.AuftragsNr = Auftragspositionen.AuftragsNr;", "solution": "false"}]}, {"id": 2814, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber die GROUP-BY-Klausel sind wahr?", "explanation": "Siehe die Syntaxbeschreibung der SELECT -Anweisung im Datenbankwiki unter <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/SELECT\"> SELECT-Anweisung", "type": "multiple-choice", "answers": [{"text": "Man kann in einer GROUP-BY-Klausel Spaltenabk\u00fcrzungen benutzen.", "solution": "false"}, {"text": "Die WHERE-Klausel kann nach der GROUP-BY-Klausel stehen und Zeilen ausschlie\u00dfen, bevor gruppiert wird.", "solution": "false"}, {"text": "Die WHERE-Klausel kann vor der GROUP-BY-Klausel stehen und Zeilen ausschlie\u00dfen, bevor gruppiert wird.", "solution": "true"}, {"text": "Wenn die SELECT-Klausel Gruppenfunktionen (SUM, MIN, MAX, COUNT..) hat, dann m\u00fcssen alle Spalten der SELECT-Klausel, die keine Gruppenfunktion haben, in der GROUP-BY-Klausel vorkommen.", "solution": "true"}]}, {"id": 2878, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgenden SQL-Anweisungen:\n\n    CREATE TABLE test (spalte varchar2(10));\n\n    INSERT INTO TEST VALUES (\"Ja\");\n\n    INSERT INTO TEST VALUES (\"Nein\");\n\n    INSERT INTO TEST VALUES (NULL);\n\n    COMMIT;\n\n    SELECT * FROM TEST WHERE Spalte in (\"Ja\", \"Nein\");\n\n    Welches Ergebnis hat diese SELECT-Abfrage?", "explanation": "Wegen der <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Dreiwertige-Logik\"> dreiwertigen Logik  in SQL liefert der Vergleich mit einem NULL-Wert den Wahrheitswert UNKNOWN, der in der WHERE-Klauesel zu FALSE ausgewertet wird. Es werden daher in der SELECT-Abfrage die Zeilen mit \"Ja\" und \"Nein\" ausgegeben.", "type": "multiple-choice", "answers": [{"text": "Die beiden Tupel mit den Werten 'Ja' und 'Nein'", "solution": "true"}, {"text": "Keine Zeilen (no Rows)", "solution": "false"}, {"text": "Diese Abfrage wirft einen Fehler.", "solution": "false"}]}, {"id": 3488, "category": 9, "difficulty": 3, "text": "Welche Aussage \u00fcber Unterabfragen ist wahr?\n\n    Unterabfragen mit ALL und ANY k\u00f6nnen verneint werden, d.h. eine Unterabfrage der Form\n\n    SELECT  Nachname, Gehalt\n\n    FROM  Angestellte\n\n    WHERE  Gehalt > NOT ALL\n\n    (SELECT  Gehalt\n\n    FROM  Angestellte a, Abteilungen b\n\n    WHERE  a.Abt_Nr = b.Abt_Nr  AND Leiter = 4);\n\n    ist syntaktisch korrekt.", "explanation": "Unterabfragen mit ANY oder All k\u00f6nen leider nicht verneint werden.\n\n    siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2661, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche SELECT-Abfrage entspricht dem nat\u00fcrlichen Join?", "explanation": "RICHTIG w\u00e4re: \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr\nAND   Angestellte.ORT = Abteilungen.ORT\nAND   Angestellte.ANG_Nr = Abteilungen.ANG_NR;\" \nweil ein Natural Join, \u00fcber alle Spalten dieser Tabellen, die gleich hei\u00dfen, Abt_Nr, Ort, Ang_Nr, auf Gleichheit verglichen werden und die Teilbedingungen mit AND verkn\u00fcpft werden. \noder diese Anfrage: \nSELECT * FROM Angestellte NATURAL JOIN Abteilungen;\n\n\nDie Semantik dieses nat\u00fcrlichen Joins hei\u00dft: \"Welche Mitarbeiter arbeiten in Abteilungen, deren Leiter sie sind und deren Abteilung an ihrem Wohnort liegt.\"\n\n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verkn\u00fcpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN weil nur \u00fcber eine der drei gleich lautenden Spalten verkn\u00fcpft wird und nicht \u00fcber alle drei!", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen;", "solution": "false"}, {"text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "keine von allen", "solution": "true"}]}, {"id": 2660, "category": 9, "difficulty": 3, "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte folgende Werte enth\u00e4lt: 1000, 4000, NULL, 3000, 2000.    \n     \nSELECT AVG(gehalt*12) Durchschnitt_Jahresgehalt FROM Mitarbeiter;", "explanation": "Die numerische Operation gehalt*12 liefert f\u00fcr den NULL-Datensatz zwar als Ergebnis wieder NULL, der AVG-Operator ignoriert hingegen, die Datens\u00e4tze mit NULL-Werten und kommt zu dem Ergebnis: (1000+4000+3000+2000)/4 = 10000/4 = 2500.", "type": "text", "answers": [{"text": "Das Ergebnis ist:", "solution": "30000"}]}, {"id": 2663, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle: \nCREATE TABLE Zeitschrift (\n       Zeitschrift_id           INTEGER NOT NULL,\n       Namen                    VARCHAR2(20) NULL,\n       PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz (\n       Aufsatz_id              INTEGER NOT NULL,\n       Titel                      VARCHAR2(20) NULL,\n       Zeitschrift_id            INTEGER NOT NULL,\n       PRIMARY KEY (Aufsatz_id), \n       FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift); Die Tabellen enthalten folgende Datens\u00e4tze: Zeitschrift (1, \"DB-Spektrum\"); Zeitschrift (2, \"Informatik-Spektrum\"); Aufsatz (1, \"Tuning\", 1); Aufsatz (2, \"DWH\", 1); Kann es problematisch werden, wenn Zeitschrift-Datens\u00e4tze gel\u00f6scht werden?", "explanation": "Es kann ein Problem sein, weil Zeitschrift die Master-Tabelle ist.\n\n    Wenn Master-Datens\u00e4tze (hier Zeitschrift) gel\u00f6scht werden wird vor dem L\u00f6schen gepr\u00fcft, ob es abh\u00e4ngige Datens\u00e4tze (Detail: Aufsatz) mit einem passenden Fremdschl\u00fcsselwert gibt. Wenn ja, wird nicht gel\u00f6scht. Nur wenn nicht, wird der Master-Datensatz gel\u00f6scht.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "true"}, {"text": "nein", "solution": "false"}]}, {"id": 2662, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle:\nCREATE TABLE Zeitschrift (\n       Zeitschrift_id           INTEGER NOT NULL,\n       Namen                    VARCHAR2(20) NULL,\n       PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz (\n       Aufsatz_id              INTEGER NOT NULL,\n       Titel                      VARCHAR2(20) NULL,\n       Zeitschrift_id            INTEGER NOT NULL,\n       PRIMARY KEY (Aufsatz_id), \n       FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);      \n\nDie Tabellen enthalten folgende Datens\u00e4tze: \nZeitschrift (1, 'DB-Spektrum');\nZeitschrift (2, 'Informatik-Spektrum');\n\nAufsatz (1, 'Tuning', 1); \nAufsatz (2, 'DWH', 1); \n\nKann es problematisch werden, wenn Aufsatz-Datens\u00e4tze gel\u00f6scht werden?", "explanation": "Es ist kein Problem, weil Aufsatz die Detail-Tabelle ist. \nProblematisch w\u00e4re es, wenn Master-Datens\u00e4tze (hier Zeitschrift) gel\u00f6scht werden, weil dann vor dem L\u00f6schen gepr\u00fcft wird, ob es abh\u00e4ngige Datens\u00e4tze (Detail: Aufsatz) mit einem passenden Fremdschl\u00fcsselwert gibt. Wenn ja, wird nicht gel\u00f6scht. Nur wenn nicht, wird der Master-Datensatz gel\u00f6scht.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "false"}, {"text": "nein", "solution": "true"}]}, {"id": 2659, "category": 9, "difficulty": 3, "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte folgende Werte enth\u00e4lt: 3000, 4000, NULL, 2000, 4000.    \n     \nSELECT SUM(gehalt*12) Jahresgehalt FROM Mitarbeiter;", "explanation": "Die numerische Operation gehalt*12 liefert f\u00fcr den NULL-Datensatz zwar als Ergebnis wieder NULL, der SUM-Oerator ignoriert hingegen die NULL-Werte und kommt zu dem Ergebnis: 3000+4000+2000+4000 = 13000.", "type": "text", "answers": [{"text": "Das Ergebnis ist:", "solution": "156000"}]}, {"id": 2785, "category": 9, "difficulty": 1, "text": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX)", "explanation": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX) geh\u00f6ren zum SQL-Standard und fassen Werte aus unterschiedlichen Tupeln zu genau einem Wert zusammen.", "type": "multiple-choice", "answers": [{"text": "geben immer genau einen Wert zur\u00fcck.", "solution": "true"}, {"text": "K\u00f6nnen auch mehrere Werte zur\u00fcckgeben.", "solution": "false"}]}, {"id": 2778, "category": 9, "difficulty": 2, "text": "Welche Klauseln muss ein UPDATE-STATEMENT haben?", "explanation": "Ein UPDATE ohne WHERE ist zul\u00e4ssig und \u00e4ndert alle Tupel der Tabelle. UPDATE selber und SET sind notwendig.", "type": "multiple-choice", "answers": [{"text": "UPDATE", "solution": "true"}, {"text": "SET", "solution": "true"}, {"text": "WHERE", "solution": "false"}]}, {"id": 2772, "category": 9, "difficulty": 2, "text": "Welche SELECT-Abfrage mit DISTINCT filtert aus einer Tabelle(Spalte1, Spalte2) alle Werte heraus, dies sowohl in der Spalte1 als auch in der Spalte2 verschiedene Werte haben?", "explanation": "Das Schl\u00fcsselwort DISTINCT kann nur einmal in der SELECT-Klausel vorkommen, und zwar vor dem ersten Spaltennamen.", "type": "multiple-choice", "answers": [{"text": "SELECT DISTINCT SPALTE1, SPALTE2\nFROM Tabelle;", "solution": "true"}, {"text": "SELECT DISTINCT SPALTE1, DISTINCT SPALTE2\nFROM Tabelle;", "solution": "false"}, {"text": "SELECT SPALTE1, DISTINCT SPALTE2\nFROM Tabelle;", "solution": "false"}]}, {"id": 2790, "category": 9, "difficulty": 3, "text": "Eine SQL-Gruppenfunktion(SUM, MIN, MAX, etc..)  kann aufgerufen werden", "explanation": "Eine SELECT-Klausel kann Gruppenfunktionen beinhalten. Eine INSERT-Anweisung  hat keine SELECT-Klausel, eine DELETE hat keinen .\n\nsiehe < href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Gruppenfunktionen\" > Gruppenfunktionen", "type": "multiple-choice", "answers": [{"text": "aus der HAVING-Klausel einer SELECT-Anweisung", "solution": "true"}, {"text": "aus der ORDER-BY--Klausel einer SELECT-Anweisung", "solution": "true"}, {"text": "aus einem Ausdruck in einer DELETE-Anweisung", "solution": "false"}, {"text": "innerhalb einer SELECT-Klausel in einer SELECT-Anweisung", "solution": "true"}, {"text": "an keiner Stelle von allen", "solution": "false"}]}, {"id": 2789, "category": 9, "difficulty": 2, "text": "Betrachten Sie die folgende SELECT-Abfrage gegen eine Angestellten-Tabelle, wobei die entsprechenden Spalten vorhanden sein sollten:\n\n SELECT Abt_nr, SUM(gehalt) \n FROM Angestellte\n\nWelche Aussagen sind korrekt?", "explanation": "Alle Spalten, die in der SELECT-Klausel kein GRPOUB-BY haben, hier Abt_nr, m\u00fcssen in der GROUP-BY-Klasuel vorhanden sein.\n\nsiehe < href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Gruppenfunktionen\"> Gruppenfunktionen", "type": "multiple-choice", "answers": [{"text": "Diese Abfrage wirft einen Fehler, da skalare und aggregierte Daten vermischt werden.", "solution": "true"}, {"text": "Dieser SELECT-Anweisung fehlt eine GROUP-BY-Klausel", "solution": "true"}, {"text": "Die Anweisung wirft keinen Fehler.", "solution": "false"}, {"text": "Die Anweisung wirft keine Fehler, gibt aber keine Daten aus.", "solution": "false"}]}, {"id": 2769, "category": 9, "difficulty": 3, "text": "Wenn man eine SELECT-Abfrage, die aus mehrere Mengenoperatoren (UNION, INTERSECT, MINUS)  besteht, sortieren will, welche ORDER By-Form kann man benutzen?", "explanation": "Da die Spaltennamen nicht eindeutig festliegen, kann man nur ORDER BY POSITION (z.B. ORDER BY 3) benutzen.", "type": "multiple-choice", "answers": [{"text": "ORDER by Spaltenname", "solution": "false"}, {"text": "ORDER BY postion", "solution": "true"}, {"text": "Das geht \u00fcberhaupt nicht.", "solution": "false"}]}, {"id": 2762, "category": 9, "difficulty": 1, "text": "Welcher Operator unterdr\u00fcckt doppelte Datens\u00e4tze?", "explanation": "UNION unterdr\u00fcckt mehrfach vorkommende Datens\u00e4tze, bei UNION ALL bleiben sie erhalten. UNION ANY gibt es in SQL nicht.", "type": "multiple-choice", "answers": [{"text": "UNION ALL", "solution": "false"}, {"text": "UNION ANY", "solution": "false"}, {"text": "UNION", "solution": "true"}]}, {"id": 2787, "category": 9, "difficulty": 2, "text": "Welchen Wert gibt die SQL-Gruppenfunktionen auf einer Tabelle test wieder, wnn diese Tabelle keine Zeilen enth\u00e4lt?\n\nSELECT COUNT(*) FROM test;", "explanation": "COUNT gibt immer einen numerischen Wert zur\u00fcck. Dieser ist 0,  wenn die Tabelle keine Tupel enth\u00e4lt", "type": "multiple-choice", "answers": [{"text": "0", "solution": "true"}, {"text": "NULL", "solution": "false"}]}, {"id": 2783, "category": 9, "difficulty": 1, "text": "Was bewirken Klammern in einem Ausdruck einer SELECT-Anweisung?", "explanation": "In SQL gilt wie in der Mathematik die Merkregel  \"Punktrechnung geht vor Strichrechnung\". Durch Klammern kann man diese Reihenfolge \u00fcberschreiben. (siehe <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Operator\"> Operatoren in SQL )", "type": "multiple-choice", "answers": [{"text": "Man kann in SQL reservierte W\u00f6rter als Spaltennamen benutzen.", "solution": "false"}, {"text": "Das ist eine Matrix-Schreibweise f\u00fcr komplexe Vektoren.", "solution": "false"}, {"text": "Damit kann man die Priorit\u00e4tsreihenfolge numerischer Operatoren \u00fcberschreiben.", "solution": "true"}]}, {"id": 2767, "category": 9, "difficulty": 2, "text": "Welcher der folgenden Mengenoperatoren hat die h\u00f6chste Priorit\u00e4t?", "explanation": "Die Mengenoperatoren union, intersect und minus haben unter SQL keine Priorit\u00e4tsreihenfolge, sondern werden in der Reihenfolge abgearbeitet, in der sie in der SELECT-Abfrage stehen.", "type": "multiple-choice", "answers": [{"text": "union", "solution": "false"}, {"text": "intersect", "solution": "false"}, {"text": "minus", "solution": "false"}, {"text": "Keiner von allen", "solution": "true"}]}, {"id": 2649, "category": 9, "difficulty": 1, "text": "Welche der beiden folgenden SELECT-Anweisungen ist liefert das gleiche Ergebnis, wenn die Tabelle TEST die Spalte \"Spalte1\" hat?", "explanation": "Eine ORDER_BY-Klausel kann in zwei SELECTs, die mit UNION verkn\u00fcpft werden, nicht verwendet werden.\n\nBei einem UNION werden doppelte Tupel unterdr\u00fcckt.", "type": "multiple-choice", "answers": [{"text": "SELECT Spalte1 FROM TEST", "solution": "true"}, {"text": "SELECT Spalte_1 FROM TEST ORDER BY Spalte1\nUNION\nSELECT Spalte_2 FROM TEST ORDER BY Spalte1", "solution": "false"}, {"text": "SELECT Spalte1 FROM TEST\nUNION\nSELECT Spalte1 FROM TEST", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 2643, "category": 9, "difficulty": 3, "text": "In welcher Reihenfolge werden die Klauseln eines SELECT-Befehls ausgef\u00fchrt bzw. geparst? (Geben Sie Zahlen von 1 bis 6 an!)", "explanation": "Die Reihenfolge Ausf\u00fchrung der Klauseln einer SELECT-Anfrage sind:\n\n    6. SELECT ...\n\n    1. FROM ...\n\n    2. [ WHERE ... ]\n\n    3. [ GROUP BY ... ]\n\n    4. [ HAVING ... ]\n\n    5. [ ORDER BY ... ]\n\n    Die eckigen Klammern geben die Optionalit\u00e4t der Klauseln an.", "type": "text", "answers": [{"text": "WHERE", "solution": "2"}, {"text": "FROM", "solution": "1"}, {"text": "ORDER BY", "solution": "5"}, {"text": "HAVING", "solution": "4"}, {"text": "GROUP BY", "solution": "3"}, {"text": "SELECT", "solution": "6"}]}, {"id": 2642, "category": 9, "difficulty": 2, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr}\n\nAbteilungen hat den Prim\u00e4rschl\u00fcssel Abt_nr und den Fremdschl\u00fcssel Leiter_Ang_Nr.\nAngestellte hat den Prim\u00e4rschl\u00fcssel Ang_nr und den Fremdschl\u00fcssel Abt_Nr.\n\nWelche der folgenden SELECT-Anweisungen liefern das gleiche Ergebnis?", "explanation": "RICHTIG sind: \nSELECT *\nFROM Angestellte NATURAL JOIN Abteilungen; \n und \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr; \n\ndenn der NATURAL JOIN verkn\u00fcpft alle Spalten, die gleich hei\u00dfen, Abt_NR und Ort, auf Gleichheit und mit AND.\n \nDie Semantik ist: \"Welche Mitarbeiter arbeiten in \nAbteilungen, die im Wohnort des Mitarbeiters liegen?\"\n\n\nFALSCH ist: \nSELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;\nweil nur \u00fcber eine der beiden gleich lautenden Spalte verkn\u00fcpft wird und nicht \u00fcber beide.", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;", "solution": "false"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr;", "solution": "true"}, {"text": "SELECT *\nFROM Angestellte NATURAL JOIN Abteilungen;", "solution": "true"}]}, {"id": 2829, "category": 9, "difficulty": 3, "text": "Betrachten Sie eine Tabelle Kunden (K_ID, Nachname, Vorname, Kontonummer, BLZ, ....) .\n\nMit welcher SELECT-Anweisung kann mann die Anzahl der Kunden bestimmen, deren BLZ (Bankleitzahl) leer, das hei\u00dft NULL ist?", "explanation": "Alle Antworten sind syntaktisch richtg, aber nur die Antwort \n\nSELECT COUNT(NVL(BLZ, 0))\nFROM KUNDEN \nWHERE BLZ IS NULL;\n\nliefert das gew\u00fcnschte Ergebnis. \n\nNull-Werte werden nicht mit = NULL abgefragt. Die DISTINCT-Abfrage liefert die falsche Zahl. Die Funktion NVL ist hier notwendig, da sonst COUNT(BLZ) = 0 ist, wenn eine BLZ in der Spalte den Wert NULL hat", "type": "multiple-choice", "answers": [{"text": "SELECT COUNT(BLZ)\nFROM KUNDEN \nWHERE BLZ IS NULL;", "solution": "false"}, {"text": "SELECT COUNT(BLZ)\nFROM KUNDEN \nWHERE BLZ = NULL;", "solution": "false"}, {"text": "SELECT COUNT(DISTINCT BLZ)\nFROM KUNDEN \nWHERE BLZ IS NULL;", "solution": "false"}, {"text": "SELECT COUNT(NVL(BLZ, 0))\nFROM KUNDEN \nWHERE BLZ IS NULL;", "solution": "true"}]}, {"id": 2641, "category": 9, "difficulty": 1, "text": "Welche Semantik hat folgender SELECT-Ausdruck? \n\nSELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'K\u00f6ln'\nOR    NOT (Ort = 'Gummersbach')", "explanation": "Der Begriff Semantik meint die Aufgabenstellung, die zu dieser SELECT-Anfrage geh\u00f6rt. \nDie Semantik obiger Anfrage ist: \"Zeigen Sie die Kunden, die nicht in Gummersbach wohnen oder in K\u00f6ln leben?\"", "type": "multiple-choice", "answers": [{"text": "Welche Kunden wohnen weder in Gummersbach noch in K\u00f6ln?", "solution": "false"}, {"text": "Welche Kunden wohnen nicht in Gummersbach aber in K\u00f6ln?", "solution": "false"}, {"text": "Welche Kunden wohnen nicht in Gummersbach oder in K\u00f6ln?", "solution": "true"}]}, {"id": 2640, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Vorname FROM KUNDEN ORDER BY Nachname DESC\"", "explanation": "Die Sortierung kann ausgef\u00fchrt werden, weil die ORDER BY-Klausel als vorletzte Klausel ausgef\u00fchrt wird, unmittelbar vor der letzten Klausel der SELECT-Klausel. Daher kann auch \u00fcber Spalten sortiert werden, die anschlie\u00dfend mittels der SELECT-Klausel \"weg projiziert\" werden.\n\n    Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel.", "type": "multiple-choice", "answers": [{"text": "ist nicht ausf\u00fchrbar, da \u00fcber eine Spalte \"Nachname\" sortiert wird, die gar nicht angezeigt wird.", "solution": "false"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "true"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}]}, {"id": 2639, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Vorname FROM KUNDEN ORDER BY Nachname ASC\"", "explanation": "Die Sortierung kann ausgef\u00fchrt werden, weil die ORDER BY-Klausel als vorletzte Klausel ausgef\u00fchrt wird, unmittelbar vor der letzten Klausel der SELECT-Klausel. Daher kann auch \u00fcber Spalten sortiert werden, die anschlie\u00dfend mittels der SELECT-Klausel \"weg projiziert\" werden.\n\n    Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.", "type": "multiple-choice", "answers": [{"text": "ist nicht ausf\u00fchrbar, da \u00fcber eine Spalte \"Nachname\" sortiert wird, die gar nicht angezeigt wird.", "solution": "false"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "true"}]}, {"id": 2569, "category": 9, "difficulty": 3, "text": "Eine Menge von Tabellen besitzt die Eigenschaft, dass jede Tabelle einen Prim\u00e4rschl\u00fcssel besitzt.", "explanation": "Eine Menge von Tabellen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Tabelle einen Prim\u00e4rschl\u00fcssel besitzt.", "type": "text", "answers": [{"text": "Diese Eigenschaft hei\u00dft", "solution": "Entity-Integrit\u00e4t"}]}, {"id": 2566, "category": 9, "difficulty": 3, "text": "Welche Anforderungen muss ein \"vereinigungskonformer\" SQL-Operator  erf\u00fcllen? (relevant f\u00fcr die Durchf\u00fchrung von Mengenoperationen)", "explanation": "Die Forderung in SQL \"<a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) m\u00fcssen die gleichen Spaltendefinitionen aufweisen, d.h.:\n\nDie Anzahl der Spalten muss \u00fcbereinstimmen.\nDie Datentypen der der Spalten m\u00fcssen gleich sein. \nDie Reihenfolge der Spalten muss \u00fcbereinstimmen.\n\nAchtung: In der RA mussten die Spalten auch noch gleich hei\u00dfen, das ist hier in SQL nicht mehr notwendig. Es werden in SQL die Spaltennamen der links vom Operator stehenden Tabelle verwendet.", "type": "multiple-choice", "answers": [{"text": "Die Anzahl der Spalten muss \u00fcbereinstimmen.", "solution": "true"}, {"text": "Die Spalten m\u00fcssen gleich hei\u00dfen.", "solution": "false"}, {"text": "Die Datentypen der der Spalten m\u00fcssen gleich sein.", "solution": "true"}, {"text": "Die Reihenfolge der Spalten muss \u00fcbereinstimmen.", "solution": "true"}, {"text": "Es gibt keine solche Anforderung in SQL.", "solution": "false"}]}, {"id": 2630, "category": 9, "difficulty": 1, "text": "Wann wird eine UPDATE-Anweisung mit WHERE-Bedingung ausgef\u00fchrt?", "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\nAchtung: Bei der Integrit\u00e4tspr\u00fcfung ist das etwas anders: \nEin Constraint in SQL ist erf\u00fcllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist.", "type": "multiple-choice", "answers": [{"text": "Die, f\u00fcr die die WHERE-Bedingung zu FALSE ausgewertet wird.", "solution": "false"}, {"text": "Die, f\u00fcr die die WHERE-Bedingung zu UNKNOWN ausgewertet wird.", "solution": "false"}, {"text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.", "solution": "true"}]}, {"id": 2904, "category": 9, "difficulty": 3, "text": "Welche Aussage(n) \u00fcber Unterabfragen sind wahr?", "explanation": "Wenn ein Wert kleiner ist als irgendein Wert des Ergebnis einer Unterabfrage, ist er insbesondere auch kleiner als das Maximum der Werte der Unterabfrage. Wenn ein Wert kleiner als das Maximum des Ergebnises einer Unterbafrage ist, ist er auch kleiner als ein beliebiger Wert des Ergebnises der Unterabfrage.\n\n    Wenn ein Wert kleiner ist als jeder Wert des Ergebnis einer Unterabfrage, ist er insbesondere auch kleiner als das Minimum der Werte der Unterabfrage. Wenn ein Wert kleiner als das Minimum des Ergebnises einer Unterabfrage ist, ist er auch kleiner als alle Werte der Unterabfrage.\n\n    Die Aussage (< ANY(Unterabfrage)) ist schw\u00e4cher als < ALL(Unterabfrage) und genauso ist das die Aussage (kleiner als das Maximum) schw\u00e4cher als (kleiner als das Minimum).\n\n    siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "< ANY(Unterabfrage) ist \u00e4quivalent zu kleiner als das Maximum.", "solution": "true"}, {"text": "< ANY(Unterabfrage) ist \u00e4quivalent zu kleiner als das Minimum.", "solution": "false"}, {"text": "< ALL(Unterabfrage) ist \u00e4quivalent zu kleiner als das Minimum.", "solution": "true"}, {"text": "< ALL(Unterabfrage) ist \u00e4quivalent zu kleiner als das Maximum.", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2565, "category": 9, "difficulty": 3, "text": "Welche der folgenden SQL-Operatoren  m\u00fcssen der Anforderung gen\u00fcgen, \"vereinigungskonform\" zu sein?", "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) m\u00fcssen die gleichen Spaltendefinitionen aufweisen, d.h.: \n\nDie Anzahl der Spalten muss \u00fcbereinstimmen. \nDie Datentypen der der Spalten m\u00fcssen gleich sein.  \nDie Reihenfolge der Spalten muss \u00fcbereinstimmen.\n\nAchtung: In der RA mussten die Spalten auch noch gleich hei\u00dfen, das ist hier in SQL nicht mehr notwendig. Es werden in SQL die Spaltennamen der links vom Operator stehenden Tabelle verwendet.", "type": "multiple-choice", "answers": [{"text": "Projektion (SELECT-Klausel)", "solution": "false"}, {"text": "Selektion (WHERE-Klausel)", "solution": "false"}, {"text": "Kartesisches Produkt (FROM-Klausel ohne WHERE-Bedingung)", "solution": "false"}, {"text": "Join (NATURAL, THETA, EQUI, )", "solution": "false"}, {"text": "OUTER JOIN (LEFT, RIGHT, FULL)", "solution": "false"}, {"text": "UNION", "solution": "true"}, {"text": "MINUS / EXCEPT", "solution": "true"}, {"text": "INTERSECTION", "solution": "true"}, {"text": "Es gibt keine solche Anforderung in SQL.", "solution": "false"}]}, {"id": 2631, "category": 9, "difficulty": 1, "text": "Es wird eine DELETE-Anweisung mit WHERE-Bedingung ausgef\u00fchrt?", "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\nAchtung: Bei der Integrit\u00e4tspr\u00fcfung ist das etwas anders: \nEin Constraint in SQL ist erf\u00fcllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist.", "type": "multiple-choice", "answers": [{"text": "Die, f\u00fcr die die WHERE-Bedingung zu FALSE ausgewertet wird.", "solution": "false"}, {"text": "Die, f\u00fcr die die WHERE-Bedingung zu UNKNOWN ausgewertet wird.", "solution": "false"}, {"text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.", "solution": "true"}]}, {"id": 2503, "category": 9, "difficulty": 3, "text": "Welche SELECT-Anweisungen beantworten die Frage, welche Busse  haben keine Eins\u00e4tze absolviert, wobei die Relationen \"busse\" und \"einsatzplan\" die angegebenen Spalten haben?", "explanation": "SELECT b.kfz_knz \nFROM   busse b  \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e); \nSELECT b.kfz_knz \nFROM   busse b  \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e  \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id); \nDiese beiden Anfragen sind syntaktisch falsch: IN ist ein bin\u00e4rer Operator. Es fehlt der linke Operand.  \n \nSELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);\nist semantisch falsch: Es fehlt die Korrelation zwischen Busse und Einsatzplan. So liefert die Anfrage immer die leere Menge als Ergebnis, sobald in der Einsatzplan-Tabelle irgendein Datensatz gespeichert ist.  \n\nSELECT b.kfz_knz\nFROM   busse b \nWHERE  EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e); \nist doppelt:-) semantisch falsch: Es fehlt das NOT vor EXISTS und es fehlt die Korrelation zwischen Busse und Einsatzplan.\n\nSELECT b.kfz_knz\nFROM   busse b natural join einsatzplan;\nist semantisch falsch: Das sind die Busse, die einen Einsatz gefahren sind. \n\nSELECT b.kfz_knz   FROM  busse b, einsatzplan e\nWHERE  e.fahrzeug_id <> b.fahrzeug_id; \nist unsinnig: So unsinnig, dass es schwer f\u00e4llt, dazu eine Semantik zu finden. Technisch ausgedr\u00fcckt: Es ist die Komplementmenge des Natural Joins zum kartesischen Produkt.", "type": "multiple-choice", "answers": [{"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  b.fahrzeug_id NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e);", "solution": "true"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e);", "solution": "false"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id);", "solution": "true"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id);", "solution": "false"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);", "solution": "false"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);", "solution": "false"}, {"text": "SELECT b.kfz_knz\nFROM   busse b natural join einsatzplan;", "solution": "false"}, {"text": "SELECT kfz_knz, COUNT(tag) as Anzahl_Eins\u00e4tze\nFROM   busse LEFT OUTER JOIN einsatzplan USING  (fahrzeug_id)\nGROUP  BY kfz_knz\nhaving count(tag) = 0;", "solution": "true"}, {"text": "SELECT b.kfz_knz   FROM  busse b, einsatzplan e\nWHERE  e.fahrzeug_id <> b.fahrzeug_id;", "solution": "false"}]}, {"id": 2504, "category": 9, "difficulty": 2, "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte f\u00fcr einen Datensatz leer ist?   \n     \nSELECT gehalt*12 AS Jahresgehalt FROM Mitarbeiter;", "explanation": "Eine numerische Operation auf einem Nullwert ergibt immer einen Nullwert.", "type": "text", "answers": [{"text": "Das Ergebnis ist", "solution": "NULL"}]}, {"id": 2155, "category": 9, "difficulty": 1, "text": "Die Duplikate der Ergebnismenge einer Anfrage sollen nur einmal angezeigt werden. Welches Schl\u00fcsselwort ist in der Anfrage daf\u00fcr zust\u00e4ndig?", "explanation": "Anders als bei der Relationalen Algebra, in der Duplikate nicht zugelassen sind und daher automatisch eliminieren werden, sind in SQL Duplikate zugelassen. Um Duplikate in SQL zu unterdr\u00fccken, muss man in der SELECT-Anweisung explizit die Option DISTINCT verwenden: SELECT DISTINCT spaltenname, .... FROM ....; \n\nUNIQUE ist ein Constraint und zwar das f\u00fcr die Zweitschl\u00fcssel. \nASC/DESC sind die Schl\u00fcsselw\u00f6rter f\u00fcr die ab-/aufsteigende Sortierung in der ORDER BY-Klausel von SELECT-Anfragen.", "type": "multiple-choice", "answers": [{"text": "DESC", "solution": "false"}, {"text": "DISTINCT", "solution": "true"}, {"text": "UNIQUE", "solution": "false"}, {"text": "ASC", "solution": "false"}, {"text": "Diese Problematik gibt es bei SQL nicht, da Duplikate nicht zugelassen sind und automatisch unterdr\u00fcckt werden.", "solution": "false"}]}, {"id": 2901, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Views (Sichten) sind wahr?", "explanation": "Zu dem View -Begriff (sicht ) bitte im DB-Wiki unter   <a target=\"\" title=\"\u00c4nderbare Sicht\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht nachschlagen!", "type": "multiple-choice", "answers": [{"text": "Eine View, in der Spaltenabk\u00fcrzungen benutzt werden (create view  as select spalt1 as neue_Spalte) erlaubt kein UPDATE der Daten.", "solution": "false"}, {"text": "Eine View, mit einer SELECT-Anweisung, die DISTINCT enth\u00e4lt, erlaubt kein UPDATE der Daten.", "solution": "true"}, {"text": "Wenn man in einer virtuellen View Daten l\u00f6scht, bleiben diese Daten in der zugrundeliegenden Tabelle enthalten.", "solution": "false"}, {"text": "Mit CREATE OR REPLACE view wird eine VIEW erst gel\u00f6scht (DROP) und dann wieder angelegt.", "solution": "true"}, {"text": "Mit der ORACLE-Option \"WITH CHECK OPTION\" kann man die in einer View enthaltenen Spalten einschr\u00e4nken.", "solution": "false"}]}, {"id": 2629, "category": 9, "difficulty": 2, "text": "Wann wird ein Datensatz nicht in die Ergebnismenge einer SQL-Anfrage aufgenommen?", "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\". \n\n\nAchtung: Bei der Integrit\u00e4tspr\u00fcfung ist das etwas anders: \nEin Constraint in SQL ist erf\u00fcllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist.", "type": "multiple-choice", "answers": [{"text": "Wenn die WHERE-Bedingung zu FALSE ausgewertet wird.", "solution": "true"}, {"text": "Wenn die WHERE-Bedingung zu UNKNOWN ausgewertet wird.", "solution": "true"}, {"text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.", "solution": "false"}]}, {"id": 2628, "category": 9, "difficulty": 1, "text": "Wann wird ein Datensatz in die Ergebnismenge einer SQL-Anfrage aufgenommen?", "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\n\n\nBei SELECT-Anfragen wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedinung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\n\nAchtung: Bei der Integrit\u00e4tspr\u00fcfung ist das etwas anders:\n\nEin Constraint in SQL ist erf\u00fcllt wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\n\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist. ...", "type": "multiple-choice", "answers": [{"text": "Wenn die WHERE-Bedingung zu FALSE ausgewertet wird.", "solution": "false"}, {"text": "Wenn die WHERE-Bedingung zu UNKNOWN ausgewertet wird.", "solution": "false"}, {"text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.", "solution": "true"}]}, {"id": 1960, "category": 9, "difficulty": 2, "text": "Wenn zwei Relationen R und S in SQL mit einem Natural Join verbunden werden, dann", "explanation": "Ein Natural Join verkn\u00fcpft nach Definition alle Tupel von zwei Tabellen \u00fcber gleichnamige Attribute.", "type": "multiple-choice", "answers": [{"text": "muss Relation R mehr Tupel als Relation S beinhalten", "solution": "false"}, {"text": "ermittelt man alle Tupel aus R und S, die \u00fcbereinstimmen", "solution": "false"}, {"text": "sollten die Relationen R und S mindestens ein gleich bezeichnetes Attribut haben.", "solution": "true"}]}, {"id": 1979, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche Anfragen liefern das gleiche Ergebnis?", "explanation": "RICHTIG sind: \nDie Anfragen \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nund \n\"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\"\nhaben die gleiche Semantik: \"Welche Mitarbeiter sind Leiter einer Abteilung?\"\n\nOb Fremd-, E\u00edndeutigkeits- oder Prim\u00e4rschl\u00fcssel auf diesen Spalten definiert sind, ist unerheblich f\u00fcr die Ausf\u00fchrung des NATURAL JOINs, dessen Bedingung alle gleich lautenden Spalten auf Gleichheit pr\u00fcft und mit AND verkn\u00fcpft.\n\n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ort = Abteilungen.Standort AND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter wohnen am gleichen Ort, an dem sie auch arbeiten?\".\n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\".", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Standort\nAND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "true"}, {"text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2429, "category": 9, "difficulty": 3, "text": "Wann hei\u00dft eine (\u00e4u\u00dfere) SELECT-Abfrage mit einer Unterabfrage (innerer SELECT) korreliert?", "explanation": "Korreliert bedeutet, dass die Spalten der \u00e4u\u00dferen Anweisung mit der innneren SELECT-Anweisung durch eine WHERE-Klausel verkn\u00fcpft werden.", "type": "multiple-choice", "answers": [{"text": "Die Anzahl der Spalten in der Unterabfrage ist kleiner als die Anzahl der Spalten in der \u00e4u\u00dferen SELECT-Anweisung", "solution": "false"}, {"text": "Die \u00e4u\u00dfere SELECT-Anweisung ist durch einen Join-Operator mit der inneren Select-Anweisung verbunden.", "solution": "true"}, {"text": "Die \u00e4u\u00dfere SELECT-Anweisung ist nicht durch einen Join-Operator mit der inneren Select-Anweisung verbunden.", "solution": "false"}, {"text": "In der WHERE-Bedingung der Unterabfrage werden Spalten der \u00e4u\u00dferen SELECT-Anweisung mit den Spalten der inneren SELECT-Anweisung verkn\u00fcpft.", "solution": "true"}]}, {"id": 1987, "category": 9, "difficulty": 1, "text": "In der relationalen Algebra gibt es wie unter SQL die M\u00f6glichkeit, Daten \u00fcber eine dem ORDER-BY \u00e4hnlichem Konstrukt zu sortieren.", "explanation": "Neben dem zentralen Unterschied zwischen Relationaler Algebra und SQL\n\nRA: nur Mengen von Datens\u00e4tzen mit automatischer Duplikatelimination\nSQL: Multimengen von Datens\u00e4tzen mit Duplikaten\n\ngibt es einen weiteren: \n\nSQL: Sortierung m\u00f6glich\nRA:  keine Sortierung m\u00f6glich", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2345, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Indexe sind wahr?", "explanation": "\n    Die L\u00f6sung ergibt sich aus der Definition eines Index.", "type": "multiple-choice", "answers": [{"text": "Ein Index ist eine separate Speicherstruktur, die zus\u00e4tzlich zur Tabelle angelegt wird.", "solution": "true"}, {"text": "F\u00fcr eine Tabelle kann nur ein Index angelegt werden.", "solution": "false"}, {"text": "Einf\u00fcgen und L\u00f6schen von Datens\u00e4tzen sind aufw\u00e4ndiger, als bei Tabellen ohne Index.", "solution": "true"}, {"text": "Indexe beschleunigen die Suche von Datens\u00e4tzen, weil bei ihnen in der Regel mit jedem lesen-dem Zugriff auf einen physischen Block mehr Suchinformationen in den Hauptspeicher geladen wird.", "solution": "true"}, {"text": "Indexe beschleunigen die Suche von Datens\u00e4tzen, weil sie sortiert werden k\u00f6nnen und damit optimierte Suchalgorithmen ausgef\u00fchrt werden k\u00f6nnen.", "solution": "true"}, {"text": "Indexe haben den Vorteil, dass man f\u00fcr eine Tabelle mehrere anlegen kann und damit nach verschiedenen Spalten optimiert suchen kann.", "solution": "true"}]}, {"id": 2108, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche SELECT-Abfrage entspricht dem nat\u00fcrlichen Join?", "explanation": "RICHTIG sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist ein Natural Join, weil \u00fcber die einzige Spalte dieser Tabellen, die gleich hei\u00dft, Abt_Nr, auf Gleichheit verglichen wird. \n\nWie das Schl\u00fcsselwort es sagt, hier wird ein nat\u00fcrlicher JOIN ausgef\u00fchrt: \"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\" \n\nDie Semantik dieses nat\u00fcrlichen Joins hei\u00dft: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\" \n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verkn\u00fcpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN weil \u00fcber zwei Spalten verkn\u00fcpft wird, die nicht gleich hei\u00dfen: \"Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr\".", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen;", "solution": "false"}, {"text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "true"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 417, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgende Frage an eine Auftrags-/Kunden-Tabelle:\nWelche Kunden haben einen Auftrag aufgegeben?\nWelche der folgenden Abfragen liefert das gew\u00fcnschte Ergebnis?", "explanation": "Eine Exists-Bedingung liefert den Wahrheitswert wahr, wenn der SELECT (hier SELECT * FROM auftraege) mindestens einen Datensatz ergibt. \nDas ist hier der Fall, falls die Auftraege-Relation nicht leer ist, beantwortet aber nicht die oben gestellte Frage.", "type": "multiple-choice", "answers": [{"text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE EXISTS\n(SELECT * FROM Auftraege\nWHERE  Kunden.Kun_Nr = Auftraege.Kun_Nr);", "solution": "true"}, {"text": "SELECT    DISTINCT Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege\nWHERE    Auftraege.Kun_Nr=Kunden.Kun_Nr;", "solution": "true"}, {"text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE EXISTS\n(SELECT * FROM Auftraege)", "solution": "false"}, {"text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege\nWHERE    Auftraege.Kun_Nr=Kunden.Kun_Nr;", "solution": "true"}, {"text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE Kunden_nr IN\n(SELECT DISTINCT Kun_Nr FROM Auftraege);", "solution": "true"}, {"text": "SELECT    DISTINCT Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege;", "solution": "false"}]}, {"id": 234, "category": 9, "difficulty": 2, "text": "Mit welchem SQL-Befehl werden Daten in Tabellen ver\u00e4ndert?", "explanation": "Mit der UPDATE-Anweisung k\u00f6nnen Mengen von Daten oder einzelne Datens\u00e4tze in Tabellen ver\u00e4ndert werden. Die Suchbedingung ist wie in der SELECT-Anweisung definiert. Die Wertzuweisung l\u00e4sst einen NULL-Wert zu, einen Ausdruck wie bei der Default-Option der CREATE TABLE-Anweisung, oder einen Anfrageausdruck. Der Anfrageausdruck darf hier keine Datensatzmenge als Ergebnis liefern, sondern nur einen Datensatz. Je nachdem, ob in der SET-Klausel nur eine einzelne oder mehrere Spalten ge\u00e4ndert werden, k\u00f6nnen inden Anfrageausdruck eine oder entsprechend auch mehrere Spalten selektiert werden.", "type": "text", "answers": [{"text": "Der Befehl hei\u00dft:", "solution": "UPDATE"}]}, {"id": 241, "category": 9, "difficulty": 3, "text": "Welcher SQL-Befehl kann eine SELECT-Abfrage enthalten?", "explanation": "Es gibt einen Befehl zum Einf\u00fcgen von mehreren Datens\u00e4tzen aus anderen Tabellen oder Sichten: \nINSERT INTO tabellenname AS SELECT (spaltenwert_1, ..., spaltenwert_n) FROM ... WHERE ...; \nBei den DML-Befehlen UPDATE und DELETE kann die SELECT-Anweisung in der WHERE-Klausel auftreten, um nur bestimmte Datens\u00e4tze zu \u00e4ndern bzw. zu l\u00f6schen. Beim UPDATE k\u00f6nnen zudem SELECT-Anweisungen auch in der SET-Klausel verwendet werden, um neue Werte f\u00fcr den zu \u00e4ndernden Datensatz zu ermitteln. \nBeim CREATE TABLE kann eine neue Tabellenstruktur erstellt und gleichzeitig mit Daten aus anderen Tabellen oder Sichten gef\u00fcllt werden. \nBeim DROP TABLE gibt es keine Verwendungsm\u00f6glichkeit f\u00fcr einen SELECT und ist daher auch nicht m\u00f6glich. Eine Tabellen wird als Ganzes gel\u00f6scht, inklusive dem Tabelleninhalt.", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE", "solution": "true"}, {"text": "INSERT", "solution": "true"}, {"text": "UPDATE", "solution": "true"}, {"text": "DELETE", "solution": "true"}, {"text": "DROP TABLE", "solution": "false"}]}, {"id": 240, "category": 9, "difficulty": 2, "text": "Die folgende UPDATE-Anweisung ist syntaktisch korrekt:\nUPDATE TABELLE1 SET SPALTE1 = (SELECT SPALTE2 FROM TABELLE2);", "explanation": "Ein UPDATE_Befehl kann auch eine SELECT-Anweisung enthalten, wenn die Spalten der SET-Zuweisung mit der Spaltenliste der SELECT-Anweisung \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 238, "category": 9, "difficulty": 1, "text": "Ein UPDATE-Befehl kann eine SELECT-Anweisung enthalten.", "explanation": "Die Wert-Zuweisung \"SET Spalte = ...\"  kann auch mit dem Ergebnis einer SELECT-Anweisung gef\u00fcllt werden, wenn die Datentypen \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 265, "category": 9, "difficulty": 1, "text": "Welche SELECT-Komponenten sind obligatorisch?", "explanation": "Eine SELECT-Anweisung muss mindestens eine Spalte aus einer Tabelle selektieren, also eine SELECT-Klausel und eine FROM-Klausel enthalten.\n Alle anderen Klauseln sind optional.", "type": "multiple-choice", "answers": [{"text": "FROM", "solution": "true"}, {"text": "WHERE", "solution": "false"}, {"text": "GROUP BY", "solution": "false"}, {"text": "HAVING", "solution": "false"}, {"text": "ORDER BY", "solution": "false"}, {"text": "SELECT", "solution": "true"}]}, {"id": 291, "category": 9, "difficulty": 3, "text": "Welche der folgenden DELETE-Anweisungen ist korrekt?", "explanation": "Eine DELETE-Anweisung kann nur komplette Zeilen einer Tabelle, keine einzelnen Spaltenwerte, l\u00f6schen.", "type": "multiple-choice", "answers": [{"text": "DELETE FROM Abteilungen;", "solution": "true"}, {"text": "DELETE Abt_nr, Bezeichnung\nFROM Abteilungen;", "solution": "false"}, {"text": "DELETE FROM TABLE Abteilungen;", "solution": "false"}]}, {"id": 284, "category": 9, "difficulty": 1, "text": "Mit welcher SELECT-Abfrage stellt man fest, ob eine Spalte vom Typ VARCHAR einen NULL-Wert hat?", "explanation": "Die einzige M\u00f6glichkeit, abzufragen, ob eine Spalte keinen Wert hat, ist im SQL-Standard \"IS NULL\".", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Tabelle\nWHERE Spalte <> '';\n", "solution": "false"}, {"text": "SELECT * FROM Tabelle\nWHERE Spalte IS NULL;", "solution": "true"}, {"text": "SELECT * FROM Tabelle\nWHERE Spalte > 0;", "solution": "false"}]}, {"id": 292, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Befehl l\u00f6scht man Tabellendefinitionen und gleichzeitig die Daten einer Tabelle?", "explanation": "Mit DELETE werden nur (einige) Datens\u00e4tze gel\u00f6scht, die Struktur der Tabelle bleibt erhalten. \nMit DROP werden die Datens\u00e4tze gel\u00f6scht und die Tabeellenstruktur zerst\u00f6rt, d.h. die Tabellendefinition aus dem Dictionary entfernt.", "type": "multiple-choice", "answers": [{"text": "DROP", "solution": "true"}, {"text": "DELETE", "solution": "false"}]}, {"id": 293, "category": 9, "difficulty": 3, "text": "Welchem Operator aus der relationalen Algebra entspricht der SQL-Ausdruck \"SELECT * FROM Teile, Artikel\"?", "explanation": "Eine SELECT-Anweisung auf mehreren Tabellen ohne WHERE-Klausel entspricht einen kartesischen Produkt bzw. einem Cross-Join. \n\nRA    SQL\n---------------\nProjektion     SELECT\nSelektion      WHERE \nKart. Produkt  FROM\nTheta Join     FROM + WHERE\nNatural Join   FROM + WHERE + ELECT\nVereinigung    UNION\nDifferenz      EXCEPT / MINUS / NOT IN / NOT EXISTS\nDurchschnitt    INTERSECTION\nDivision        \"doppeltes NOT EXISTS\" / \"Z\u00e4hlen\"", "type": "text", "answers": [{"text": "Dieser Operator hei\u00dft:", "solution": "kartesisches Produkt"}]}, {"id": 290, "category": 9, "difficulty": 2, "text": "Welche der folgenden Abfragen ist in SQL syntaktisch korrekt?", "explanation": "Eine Spalte, die nicht in der GROUP-BY-Klausel vorkommt, muss in der SELECT-Klausel eine Gruppenfunktion (AVG, SUM , MIN, MAX oder COUNT) haben.", "type": "multiple-choice", "answers": [{"text": "SELECT      Abt_Nr\nFROM       Angestellte\nGROUP BY  Abt_Nr\nWHERE     COUNT(*) > = 5;", "solution": "false"}, {"text": "SELECT      Abt_Nr\nFROM       Angestellte\nGROUP BY  Abt_Nr\nHAVING COUNT(*) > = 5;", "solution": "true"}, {"text": "SELECT      Abt_Nr\nFROM       Angestellte\nWHERE     COUNT(*) > = 5;\nGROUP BY  Abt_Nr;", "solution": "false"}]}, {"id": 294, "category": 9, "difficulty": 1, "text": "In Unterabfragen ist die ORDER-BY-Komponente vorgesehen.", "explanation": "Unterabfragen mit ORDER-BY machen keinen Sinn, da sie als ungeordnete Ergebnismenge genutzt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 295, "category": 9, "difficulty": 1, "text": "Womit wird in einer SQL-Abfrage der Existenzquantor umgesetzt?", "explanation": "Der Existenzquantor wird mit dem EXISTS-Operator umgesetzt. \nBeim Allquantor wird es etwas schwieriger. In der Relationalen Algebra gibt es die Division, In SQL gibt es daf\u00fcr gibt es keinen eigenen Operator. Man kann den Allquantor simulieren, entweder mittels einem \"doppelten NOT EXISTS\" oder durch z\u00e4hlen.", "type": "text", "answers": [{"text": "Der Ausdruck ist", "solution": "EXISTS"}]}, {"id": 665, "category": 9, "difficulty": 1, "text": "Mit welchem Zeichen in der SELECT-Klausel werden alle Spalten einer Tabelle bei einer SELECT-Anfrage ausgegeben?", "explanation": "SELECT * FROM tabellen WHERE ...; \nMit * werden immer alle Spalten aller Tabellen der FROM-Klausel ausgegeben.", "type": "text", "answers": [{"text": "Das Zeichen ist:", "solution": "*"}]}, {"id": 395, "category": 9, "difficulty": 1, "text": "Welche Priorit\u00e4tsreihenfolge habe die logischen Operatorn unter SQL? \nTragen Sie bitte 1, 2, 3 oder 4 ein!", "explanation": "Priorit\u00e4tenreihenfolge der Operatoren (es ist die gleiche wie bei der Relationalen Algebra)\nPriorit\u00e4t Operator\n1         Alle Vergleichsoperatoren\n2         NOT\n3         AND\n4         OR", "type": "text", "answers": [{"text": "OR", "solution": "4"}, {"text": "Vergleichssoperatoren", "solution": "1"}, {"text": "AND", "solution": "3"}, {"text": "NOT", "solution": "2"}]}, {"id": 404, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgende Abfrage an einen Angestellten / Abteilungs -Tabelle:\nMan finde die Abteilungsnummern von Abteilungen in Dortmund, in denen es Angestellten gibt, die weniger als 2000 verdienen. Welche Abfrage liefert das gew\u00fcnschte Ergebnis?", "explanation": "Wenn die Tabellen der FROM-Klausel nicht mit einer Join-Bedingungen (hier AB.Abt_NR = a.Abt_Nr ) verkn\u00fcft sind, liefert die SELECT-Anweisung das kartesische Produkt der beteiligten Tabellen.", "type": "multiple-choice", "answers": [{"text": "SELECT A.Abt_NR \nFROM Angestellte A, Abteilungen AB\nWHERE AB.Ort = 'Dortmund' \nAND a.Gehalt < 2000;\n", "solution": "false"}, {"text": "SELECT A.Abt_NR \nFROM Angestellte A, Abteilungen AB\nWHERE AB.Abt_NR = a.Abt_NR\nAND AB.Ort = 'Dortmund' \nAND a.Gehalt < 2000;\n", "solution": "true"}]}, {"id": 481, "category": 9, "difficulty": 3, "text": "Folgende Aussagen treffen auf virtuelle VIEWS zu:", "explanation": "Nur auf einfachen Views, z.B. ohne GROUP-BY, k\u00f6nnen UPDATE-Operationen durchgef\u00fchrt werden.", "type": "multiple-choice", "answers": [{"text": "Auf Views k\u00f6nnen Benutzerrechte vergeben werden.", "solution": "true"}, {"text": "In VIEWS k\u00f6nnen die gleichen UPDATE-Operationen durchgef\u00fchrt werden, wie auf Tabellen.", "solution": "false"}, {"text": "Auf Views k\u00f6nnen Abfragen (SELECT) gestartet werden", "solution": "true"}]}, {"id": 507, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgende Frage an die beiden Tabellen Angestellten und Abteilungen: In welchen Abteilungen sind alle Berufe der Unternehmung vertreten? Welche der folgenden Abfragen liefert das gew\u00fcnschte Ergebnis?", "explanation": "Da es hier darum geht, die Abteilungen mit \"ALLEN\" Berufen zu ermitteln, handelt es sich um eine sogennate  Allaussage (Allquantor) und der wird ja bekanntlich in der Relationalen Algebra mittels der Division realisiert. In SQL fehlt ein solcher Operator leider. Aber wie aus der Logik bekannt, kann ein Allquantor mittels einem \"doppelte negierten Existenzquantor\" simuliert werden. Diese Anfrage hat w\u00f6rtlich genommen die Semantik: \"Zeigen Sie die Abteilungen, f\u00fcr die es KEINE Berufe gibt, die es NICHT in der Firma gibt\" (vgl. mit Originalanfrage: semantisch \u00e4quivalent)\n\n    \n\n    Ein alternativer L\u00f6sungsansatz z\u00e4hlt die verschiedenen Berufe und ermittelt dann die Abteilungen mit der gleichen Anzahl an verschiedenen Berufen.\n\n    \n\n    SELECT A.Abt_NR, MAX(COUNT(A.Beruf))\n\n    FROM Angestellte A , Abteilungen B\n\n    WHERE A.Abt_Nr = B.Abt_Nr\n\n    GROUP BY A.Abt_nr\n\n    Diese Anfrage ist syntaktisch nicht ausf\u00fchrbar, da bei der Verwendung der MAX-Funktion in der SELECT-Klausel keine weiteren Spalten zul\u00e4ssig sind. MAX liefert nur einen Datensatz, es k\u00f6nnten aber durchaus mehrere Abteilungen alle Berufe enthalten.\n\n    \n\n    SELECT Abt_NR, Beruf\n\n    FROM Angestellte\n\n    WHERE beruf = ALL\n\n    (SELECT DISTINCT Beruf FROM Angestellte)\n\n    Diese Anfrage liefert immer die leere Menge, sobald mehr als zwei verschiedene Berufe in der Angestellten-Tabelle vorkommen. Denn f\u00fcr jeden Angestellten wird sein eingetragener Beruf verglichen, ob er gleich allen Datens\u00e4tzen der Unteranfrage ist. Ein Wert kann aber niemals GLEICH mit mehreren unterschiedlichen Werten sein.", "type": "multiple-choice", "answers": [{"text": "SELECT A1.Abt_Nr, A1.Name FROM Abteilungen A1\n\n      WHERE NOT EXISTS ( SELECT * FROM Angestellte A2\n\n          WHERE NOT EXISTS ( SELECT * FROM Angestellte A3 WHERE a2.Beruf = a3.Beruf AND a1.Abt_NR = a3.Abt_nr))", "solution": "true"}, {"text": "SELECT Abt_NR, Beruf\nFROM Angestellte \nwhere beruf = ALL \n  (SELECT Beruf FROM Angestellte)", "solution": "false"}, {"text": "SELECT Abt_NR, COUNT( DISTINCT Beruf) FROM Angestellte\n\n       GROUP By Abt_NR HAVING COUNT ( DISTINCT beruf) = (SELECT COUNT ( DISTINCT Beruf) FROM angestellte)", "solution": "true"}, {"text": "SELECT A.Abt_NR, MAX(COUNT(A.Beruf))\nFROM Angestellte A , Abteilungen B\nWHERE A.Abt_Nr = B.Abt_Nr\nGROUP BY A.Abt_nr", "solution": "false"}]}, {"id": 501, "category": 9, "difficulty": 1, "text": "Welche der folgenden Aussagen ist wahr?", "explanation": "Die GROUP BY-Klausel sorgt f\u00fcr die Gruppierung entsprechend den Werten in den aufgef\u00fchrten Spalten. Nachdem gruppiert wurde, kann - muss aber nicht - mittels der HAVING-Klausel eine Bedingung f\u00fcr diese Gruppen formuliert werden, die diese erf\u00fcllen m\u00fcssen. Da die HAVING-Klausel eine Bedingung f\u00fcr die Gruppen formuliert, macht eine HAVING-Klausel ohne GROUP BY keinen Sinn.", "type": "multiple-choice", "answers": [{"text": "Nach jeder GROUP-BY-Klausel muss eine HAVING-Klausel folgen", "solution": "false"}, {"text": "Nach einer GROUP-BY-Klausel kann eine HAVING-Klausel folgen", "solution": "true"}, {"text": "Eine HAVING-Klausel kann auch ohne GROUP BY vorkommen.", "solution": "false"}]}, {"id": 505, "category": 9, "difficulty": 3, "text": "Welche SELECT-Anweisung beantwortet die folgende Frage an die be\u00edden Tabellen \"Auto\" und \"Sonderausstattung\":\nWelche Autos haben keine Sonderausstattung?", "explanation": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr\nDieses SELECT hat eine so unsinnige Semantik, dass sie sich kaum in Worte fassen l\u00e4sst: Formal ist es die \"Komplementmenge des Natural Joins zum kartesischen Produkt\". Wem daf\u00fcr eine Semantik einf\u00e4llt, darf sich gerne melden - wird honoriert :-) versprochen :-) \n\nSELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)\nDer NOT IN w\u00e4re ja gut, wenn da nicht vorher der Natural Join zwischen Auto und Sonderausstattung w\u00e4re. Mit dem Natural Join werden alle Autos mit Sonderausstattung ermittelt und anschlie\u00dfend gepr\u00fcft, ob sie keine Sonderaustattung haben. Da wird wohl immer die leere Menge herauskommen.", "type": "multiple-choice", "answers": [{"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   B.Sonderausstattung IS NULL", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A\nWHERE A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)", "solution": "true"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr NOT EXISTS(\n      SELECT SerienNr FROM Sonderausstattung)", "solution": "false"}]}, {"id": 445, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN ORDER BY Nachname DESC\"", "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel-", "type": "multiple-choice", "answers": [{"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "true"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine Gruppierung", "solution": "false"}]}, {"id": 453, "category": 9, "difficulty": 2, "text": "Zur DML-Sprache geh\u00f6ren die folgenden Befehle:", "explanation": "DDL (Data Definition Language): CREATE, ALTER, DROP, RENAME, ... \nDML (Data Manipulation Language): INSERT, UPDATE, DELETE \nDQL (Data Query Language): SELECT", "type": "multiple-choice", "answers": [{"text": "CREATE", "solution": "false"}, {"text": "INSERT", "solution": "true"}, {"text": "UPDATE", "solution": "true"}, {"text": "ALTER", "solution": "false"}, {"text": "RENAME", "solution": "false"}]}, {"id": 455, "category": 9, "difficulty": 3, "text": "In welcher SELECT-Klausel sind Gruppenfunktionen (COUNT, MIN, MAX, AVG, SUM) erlaubt, wenn der SELECT keinen SUBSELECT enth\u00e4lt?", "explanation": "In der WHERE-Klausel sind keine Gruppenfunktionen erlaubt, da sich die Where-Klausel auf einzelne Zeilen, nicht auf eine Menge von Zeilen bezieht.", "type": "multiple-choice", "answers": [{"text": "In der FROM-Klausel", "solution": "false"}, {"text": "In der WHERE-Klausel", "solution": "false"}, {"text": "In der GROUP-BY-Klausel", "solution": "false"}, {"text": "in der HAVING-Klausel", "solution": "true"}, {"text": "In der ORDER-BY-Klausel", "solution": "true"}, {"text": "In der SELECT-Klausel", "solution": "true"}]}, {"id": 470, "category": 9, "difficulty": 1, "text": "Welche SQL-Abfragen liefern das gleiche Ergebnis?", "explanation": "Der BETWEEN-Vergleichsoperator schlie\u00dft die Grenzwerte beim Vergleich mit ein, so dass die WHERE-Klausel \"Gehalt >= 3000  AND  Gehalt <= 3600\" die gleichen Datens\u00e4tze in der Ergebnisdatenmenge liefert. \nIN vergleicht nur mit den beiden Werten 3000 und 3600, aber nicht die Zwischenwerte 3001 ... 3599.", "type": "multiple-choice", "answers": [{"text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt BETWEEN 3000 AND 3600;", "solution": "true"}, {"text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt > 3000 \nAND     Gehalt < 3600", "solution": "false"}, {"text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt >= 3000 \nAND     Gehalt <= 3600", "solution": "true"}, {"text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt IN (3000, 3600)", "solution": "false"}]}, {"id": 472, "category": 9, "difficulty": 3, "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nDer Vertriebsleiter Dr. Guck der Firma Byce & Co. m\u00f6chte herausfinden, f\u00fcr welche Artikel \u00fcberhaupt Auftr\u00e4ge vorliegen. Er stellt diese Anfrage an die EDV-Abteilung. Welche der folgenden Anfragen liefert das gew\u00fcnschte Ergebnis?", "explanation": "Man kann diese Anfrage mittels Natural Join, IN-, EXISTS-Operator l\u00f6sen. Mann kann auch eine Anfrage in einer FROM-Klausel formulieren. \n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN (SELECT * FROM Auftraege b \n        WHERE a.TNr = b.TNr); \nDiese Anfrage ist falsch, weil sie syntaktisch nicht richtig ist. Wenn der linke Operand des IN-Operators die TNR ist, dann k\u00f6nnen beim rechten Operanden nicht alle Spalten f\u00fcr die Ergebnismenge selektiert werden. Statt SELECT * m\u00fcsste hier SELECT TNR stehen. Und dann w\u00e4re die WHERE-Klausel beim Sub-SELECT \u00fcberfl\u00fcssig. \n\n\nSELECT      DISTINCT a.TNr,  a.Bezeichnung\nFROM         Artikel a, (SELECT * FROM Auftragspositionen) b;\nDiese Anfrage ist falsch, weil statt einem Natural Join nur ein kartesisches Produkt formuliert wurde. Es fehlt z.B. eine WHERE-Klausel mit  WHERE      a.Tnr = b.Tnr; \n\n\nSELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;\nDiese Anfrage ist falsch, weil sie syntaktisch nicht richtig ist. \nDie Spalte Bezeichnung gibt es nicht in der Auftragspositionen-Tabelle, sondern nur in der Artikel-Tabelle.", "type": "multiple-choice", "answers": [{"text": "SELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;", "solution": "true"}, {"text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN (SELECT * FROM Auftraege b \n        WHERE a.TNr = b.TNr);", "solution": "false"}, {"text": "SELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS \n        (SELECT b.TNR FROM Auftragspositionen b \n                  WHERE a.TNR = b.TNR);", "solution": "true"}, {"text": "SELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;", "solution": "true"}, {"text": "SELECT      DISTINCT a.TNr,  a.Bezeichnung\nFROM         Artikel a, (SELECT * FROM Auftragspositionen) b;", "solution": "false"}, {"text": "SELECT      a.TNr, a.Bezeichnung\nFROM         Artikel a\nWHERE       TNR IN (SELECT TNr FROM Auftragspositionen);", "solution": "true"}, {"text": "SELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;", "solution": "false"}]}, {"id": 220, "category": 9, "difficulty": 3, "text": "Das \"IN\"-Pr\u00e4dikat hat unter der SELECT-Anweisung in SQL folgende Eigenschaften:", "explanation": "Die rechte Vergleichsmenge des IN-Operators kann entweder eine Menge konstanter Werte gleichen Typs aber ohne Duplikate sein oder es wird an dieser Stelle eine SELECT-Anfrage ausgef\u00fchrt und mit deren Ergebnismenge verglichen.", "type": "multiple-choice", "answers": [{"text": "Die rechte Vergleichsmenge darf Konstanten gleichen Typs enthalten.", "solution": "true"}, {"text": "Die rechte Vergleichsmenge darf Operatoren wie \"+, - , *  und / \" enthalten.", "solution": "false"}, {"text": "Die rechte Vergleichsmenge darf Konstanten unterschiedlichen Typs enthalten.", "solution": "false"}, {"text": "Die rechte Vergleichsmenge darf eine SELECT-Anweisung enthalten.", "solution": "true"}, {"text": "Die rechte Vergleichsmenge darf zwei gleiche Konstanten enthalten.", "solution": "true"}]}, {"id": 223, "category": 9, "difficulty": 1, "text": "Mit welcher SQL-Gruppenfunktion berechnet man den Mittelwert einer Spalte?", "explanation": "Die SQL-Gruppenfunktion AVG(spaltenname) berechnet den Mittelwert einer Spalte \"spaltenname\".", "type": "text", "answers": [{"text": "Die Funktion hei\u00dft:", "solution": "AVG"}]}, {"id": 224, "category": 9, "difficulty": 1, "text": "NULL-Werte werden bei den Gruppenfunktionen in SQL (z.B. COUNT) ber\u00fccksichtigt.", "explanation": "NULL-Werte werden bei den Gruppenfunktionen in SQL (z.B. COUNT) nicht ber\u00fccksichtigt. \nGehen Sie z.B. von folgenden Datens\u00e4tzen aus: \nspalte1  spalte2\n   ab,       123,  \n   cd,       NULL, \n   df,       234, \nWird nun mit SELECT COUNT(spalte2) \u00fcber Spalte2 gez\u00e4hlt, so lautet das Ergebnis: 2 Datens\u00e4tze. \nWird aber mit SELECT COUNT(spalte1) \u00fcber Spalte1 gez\u00e4hlt, so lautet das Ergebnis: 3 Datens\u00e4tze. \nDie Semantik beider SELECTs ist sehr unterschiedlich. \nZ\u00e4hlt man \u00fcber Spalte2, so hat die Ergebnismenge die Semantik:  \"Wieviele Datens\u00e4tze sind in Spalte2 nicht leer?\"\nZ\u00e4hlt man \u00fcber Spalte1, so hat die Ergebnismenge die Semantik:  \"Wieviele Datens\u00e4tze hat die Tabelle?\"", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 227, "category": 9, "difficulty": 2, "text": "In der Ausgabe wird \u00fcber die GROUP-BY-Spalten aufsteigend sortiert.\nDiese Aussage", "explanation": "In der Ausgabe wird \u00fcber die GROUP BY-Spalten aufsteigend sortiert. \nAber eigentlich ist f\u00fcr die Sortierung die ORDER BY-Klausel zust\u00e4ndig mit den beiden Optionen ASC und DESC. Die Sortierung bei der Gruppierung ist nur ein Nebenprodukt der eigentlichen Aufgabe, der Guppenbildung.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 233, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Befehl werden Daten in Tabellen eingef\u00fcgt? Bitte geben Sie nur einen Ausdruck, nicht den kompletten Befehl  ein!", "explanation": "Es gibt einen Befehl zum Einf\u00fcgen von genau einem Datensatz:\n\n    INSERT INTO tabellenname VALUES (spaltenwert_1, ..., spaltenwert_n);\n\n    Und es  gibt einen Befehl zum Einf\u00fcgen von mehreren Datens\u00e4tzen aus anderen Tabellen oder Sichten:\n\n    INSERT INTO tabellenname AS SELECT (spaltenwert_1, ..., spaltenwert_n) FROM ... WHERE ...;", "type": "text", "answers": [{"text": "Der Befehl hei\u00dft:", "solution": "INSERT"}]}, {"id": 231, "category": 9, "difficulty": 2, "text": "Bei einer \"CREATE VIEW AS SELECT * FROM TABLE TEST\" - Anweisung", "explanation": "Mit \"CREATE VIEW AS SELECT..\" wird eine virtuelles View nach SQL-Standard, keine materialisierte View, angelegt.", "type": "multiple-choice", "answers": [{"text": "werden auch die Daten der Tabelle Test kopiert", "solution": "false"}, {"text": "wird nur die SELECT-Anweisung in der Datenbank gespeichert.", "solution": "true"}]}, {"id": 107, "category": 9, "difficulty": 1, "text": "Was bedeutet die Abk\u00fcrzung (DML)?", "explanation": "DML ist die Abk\u00fcrzung f\u00fcr Data Manipulation Language und meint die SQL-Befehle INSERT, UPDATE, DELETE. Manche z\u00e4hlen auch noch SELECT dazu. Aber bei uns geh\u00f6rt SELECT zur DQL: Data Query Language.", "type": "text", "answers": [{"text": "DML =", "solution": "Data Manipulation Language"}]}, {"id": 192, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Befehl werden tempor\u00e4re \u00c4nderungen endg\u00fcltig in die Datenbank geschrieben?", "explanation": "Die COMMIT-Anweisung macht Datenbankzugriffe erst dauerhaft wirksam, die ROLLBACK-Anweisung spielt tempor\u00e4re Anweisungen wieder auf einen konsistenten Zustand zur\u00fcck. Beide Anweisungen geh\u00f6ren zur DAL-Sprache.", "type": "text", "answers": [{"text": "Der SQL-Befehl hei\u00dft:", "solution": "commit"}]}, {"id": 203, "category": 9, "difficulty": 1, "text": "Mit welchem Schl\u00fcsselwort werden in SQL doppelte Datens\u00e4tze unterdr\u00fcckt?", "explanation": "Anders als bei der Relationalen Algebra, in der Duplikate nicht zugelassen sind und daher automatisch eliminieren werden, sind in SQL Duplikate zugelassen. Um Duplikate in SQL zu unterdr\u00fccken, muss man in der SELECT-Anweisung explizit die Option DISTINCT verwenden: SELECT DISTINCT spaltenname, .... FROM ....;", "type": "text", "answers": [{"text": "Das Schl\u00fcsselwort hei\u00dft", "solution": "DISTINCT"}]}, {"id": 206, "category": 9, "difficulty": 1, "text": "Mit welchem WHERE-Ausdruck pr\u00fcft man, ob eine Spalte NULL-Werte hat?", "explanation": "Der \"IS [NOT] NULL\"-Vergleichsoperator bietet als einziger Vergleichsoperator die M\u00f6glichkeit, leere Spaltenwerte in Bedingungen zu TRUE resp. FALSE zu transformieren. Wenn bei einem der \u00fcbrigen Vergleichsoperatoren wie z.B. =, <>, >=, LIKE, BETWEEN, ... einer der Operanden leer (NULL) ist, dann ist das Ergebnis der Auswertung dieser Bedingung immer UNKNOWN.", "type": "text", "answers": [{"text": "Der WHERE - Ausdruck hei\u00dft:", "solution": "IS NULL"}]}, {"id": 208, "category": 9, "difficulty": 3, "text": "Welche SQL-Ausdr\u00fccke liefern das gleiche Ergebnis?", "explanation": "Bei einem IN-Operator wird nicht ein Intervall, sondern nur die Eckwerte abgefragt, bei einem BETWEEN-Operator geh\u00f6ren die Eckwerte (hier 1000 und 2000) mit zur L\u00f6sungsmenge.", "type": "multiple-choice", "answers": [{"text": "SELECT gehalt FROM Angestellte WHERE gehalt > 1000 AND gehalt < 2000", "solution": "false"}, {"text": "SELECT gehalt FROM Angestellte WHERE gehalt in (1000, 2000)", "solution": "false"}, {"text": "SELECT gehalt FROM Angestellte WHERE gehalt >= 1000 AND gehalt <= 2000", "solution": "true"}, {"text": "SELECT gehalt FROM Angestellte WHERE gehalt between 1000 and 2000", "solution": "true"}]}, {"id": 212, "category": 9, "difficulty": 2, "text": "Sortieren Sie die Verlgleichs- und logischen Operatoren nach der Priorit\u00e4t unter SQL ( Zahlen 1-4 eintragen)!", "explanation": "Die Ausf\u00fchrungsreihenfolge bei den Verlgleichs- und logischen Operatoren ist folgende: \n1. Vergleichsoperatoren (=, <=, >=, ...) \n2. NOT \n3. AND \n4. OR  \n\nAm einfachsten ist es jedoch, man setzt Klammern, da kann man bei der Ausf\u00fchrungsreihenfolge nichts falsch machen ;-)", "type": "text", "answers": [{"text": "OR", "solution": "4"}, {"text": "Vergleichoperatoren ( <, > , ...)", "solution": "1"}, {"text": "AND", "solution": "3"}, {"text": "NOT", "solution": "2"}]}, {"id": 211, "category": 9, "difficulty": 1, "text": "Welcher der folgenden logischen Operatoren hat in SQL die h\u00f6chste Priorit\u00e4t?", "explanation": "Die Ausf\u00fchrungsreihenfolge bei den logischen Operatoren ist folgende: \n1. NOT \n2. AND \n3. OR  \n\nAm einfachsten ist es jedoch, man setzt Klammern, dann kann man bei der Ausf\u00fchrungsreihenfolge nichts falsch machen ;-)", "type": "multiple-choice", "answers": [{"text": "OR", "solution": "false"}, {"text": "NOT", "solution": "true"}, {"text": "AND", "solution": "false"}]}, {"id": 875, "category": 9, "difficulty": 2, "text": "In welcher Reihenfolge m\u00fcssen in einem SELECT-Befehl die folgenden Klauseln stehen? (Geben Zahlen von 1 bis 6 an)", "explanation": "Die Reihenfolge der Klauseln einer SELECT-Anfrage sind: \nSELECT ...\nFROM ...\n[ WHERE ... ]\n[ GROUP BY ... ]\n[ HAVING ... ]\n[ ORDER BY ... ]\nDie eckigen Klammern geben die Optionalit\u00e4t der Klauseln an.", "type": "text", "answers": [{"text": "WHERE", "solution": "3"}, {"text": "FROM", "solution": "2"}, {"text": "ORDER BY", "solution": "6"}, {"text": "HAVING", "solution": "5"}, {"text": "GROUP BY", "solution": "4"}, {"text": "SELECT", "solution": "1"}]}, {"id": 683, "category": 9, "difficulty": 1, "text": "Bei einer INSERT-Anweisung kann man die Spaltennamen hinter \"INSERT INTO Tabellenname (...)\" unter bestimmten Bedingungen weglassen.", "explanation": "In einer INSERT-Anweisung kann man die Spaltennamen nach INSERT weglassen, wenn alle Spalten der Tabelle mit Werten gef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2501, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Unterabfragen sind wahr?", "explanation": "Korreliert bedeutet, dass die Spalten der \u00e4u\u00dferen Anweisung mit der innneren SELECT-Anweisung durch eine WHERE-Klausel verkn\u00fcpft werden.", "type": "multiple-choice", "answers": [{"text": "Unterabfragen, die mit einem Vergleichsoperator (=,<,>,) aber ohne ANY oder ALL, d\u00fcrfen nur maximal einen Ergebnisdatensatz liefern.", "solution": "true"}, {"text": "Unterabfragen mit einem IN-Operator sind aufgrund der Syntax immer korrelierte Unterabfragen.", "solution": "false"}, {"text": "Unterabfragen k\u00f6nnen in der WHERE-Klausel wie auch der FROM-Klausel auftreten.", "solution": "true"}]}, {"id": 2136, "category": 9, "difficulty": 2, "text": "Welcher Operator der Relationalen Algebra verbirgt sich hinter der ORDER BY-Klausel einer SQL-Anfrage?", "explanation": "Order By ist in der Relationalen Algebra nicht vorgesehen, da Relationen als ungegeordnete Mengen vereinbart sind.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Sortierung", "solution": "false"}, {"text": "keiner der RA-Operatoren", "solution": "true"}]}, {"id": 2128, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN ORDER BY Nachname ASC\"", "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel.", "type": "multiple-choice", "answers": [{"text": "bewirkt eine Gruppierung", "solution": "false"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "true"}]}, {"id": 2072, "category": 9, "difficulty": 1, "text": "Welcher JOIN-Tabellen-Typ hat eine USING-Klausel?", "explanation": "Beim CROSS JOIN, dem kartesischen Produkt, gibt es gar keine Verkn\u00fcpfungsspalten. Jeder Datensatz der einen Relation wird \"grundlos\" mit jedem anderen aus der anderen Relation verkn\u00fcpft.\nBeim NATURAL JOIN gibt es zwar eine Bedingung, aber die ist vordefiniert, so dass keine Spalten mittels ON spezifiziert werden m\u00fcssen. Die vordefinierte Bedingung hei\u00dft: Alle Spalten mit gleichen Namen werden auf Gleichheit verglichen und die Teilbedingungen ggf. mit AND verkn\u00fcpft.\nLediglich beim THETA JOIN k\u00f6nnen Spalten f\u00fcr die JOIN-Bedingung angegeben werden.", "type": "multiple-choice", "answers": [{"text": "CROSS-Join", "solution": "false"}, {"text": "THETA-Join", "solution": "true"}, {"text": "NATURAL-Join", "solution": "false"}]}, {"id": 2156, "category": 9, "difficulty": 3, "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nWelche der folgenden Anfragen liefern das gleiche Ergebnis?", "explanation": "Das gleiche Ergebnis liefern: \n\nSELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);\n\nSELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN  (SELECT b.TNr FROM Auftragspositionen b \n         WHERE a.TNr = b.TNr);\n\nDie Semantik dieser Anfragen ist: \"Welche Artikel wurden verkauft?\"\n\nEine ganz andere Semantik hat:  \nSELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;\nSemantik: \"F\u00fcr welche Auftraege gibt es auch verkaufte Artikel?\"\n\n\nSELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT b.TNR FROM Auftragspositionen b);\nDiese Anfrage h\u00e4tte eine richtige Semantik, wenn die Anfrage korreliert w\u00e4re, d.h. es g\u00e4be eine Bedingung bei der unteren Anfrage, die die obere und die untere Anfrage in Beziehung setzt: \"WHERE b.tnr=a.trn\". Ohne diese Korrelation liefert diese Anfrage immer alle Artikel, sobald in der Auftragspositionen-Tabelle wenigstens ein Datensatz gespeichert ist - unabh\u00e4ngig davon, ob die TNR \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "SELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;", "solution": "true"}, {"text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);", "solution": "true"}, {"text": "SELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT b.TNR FROM Auftragspositionen b);", "solution": "false"}, {"text": "SELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;", "solution": "true"}, {"text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN  (SELECT b.TNr FROM Auftragspositionen b \n         WHERE a.TNr = b.TNr);", "solution": "true"}, {"text": "SELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;", "solution": "false"}]}, {"id": 2163, "category": 9, "difficulty": 3, "text": "Betrachten Sie zwei Relationen R und S mit jeweils einer Spalte A mit dem Datentyp Integer. \n\nWelche SQL-Anweisung beantwortet die Anfrage R - S (Differenz) aus der relationalen Algebra?", "explanation": "SELECT *\nFROM S\nWHERE A NOT IN (SELECT B FROM R); \nist falsch, da S-R berechnet wird \n\nMit UNION kann keine Differenz, sondern nur die Vereinigungsmenge berechnet werden. \n\nMinus kann ansonsten mit NOT IN oder \u00fcber den LEFT JOIN ausgedr\u00fcckt werden.", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM R\nWHERE A NOT IN (SELECT A FROM S);", "solution": "true"}, {"text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;", "solution": "true"}, {"text": "SELECT *\nFROM S\nWHERE A NOT IN (SELECT A FROM R);", "solution": "false"}, {"text": "SELECT * FROM R\n UINON\nSELECT * FROM S;", "solution": "false"}, {"text": "SELECT A FROM R LEFT OUTER JOIN S  ON S.A = R.A\nWHERE S.A IS NULL;", "solution": "true"}]}, {"id": 2498, "category": 9, "difficulty": 1, "text": "\u00dcber die Verwendung von Prim\u00e4rschl\u00fcsseln f\u00fcr Anfragen sind folgende Aussagen wahr:", "explanation": "Die einzig richtige Aussage ist: \"Prim\u00e4rschl\u00fcsselspalten k\u00f6nnen eine Rolle spielen, wenn die Laufzeit von Anfragen verbessert werden muss.\". \nDie \u00fcbrigen Aussagen sind falsch: Prim\u00e4rschl\u00fcsselspalten werden weder f\u00fcr die Projektion noch f\u00fcr die Selektion von Daten gebraucht.", "type": "multiple-choice", "answers": [{"text": "Man kann in der SELECT-Klausel nur Prim\u00e4rschl\u00fcsselspalten projizieren.", "solution": "false"}, {"text": "Man kann in der WHERE-Klausel nur \u00fcber Prim\u00e4rschl\u00fcsselspalten suchen.", "solution": "false"}, {"text": "Prim\u00e4rschl\u00fcsselspalten k\u00f6nnen eine Rolle spielen, wenn die Laufzeit von Anfragen verbessert werden muss.", "solution": "true"}, {"text": "Keine von diesen Aussagen.", "solution": "false"}]}, {"id": 964, "category": 9, "difficulty": 3, "text": "Autos mit ihren Sonderausstattungen werden in zwei Tabellen Auto und Sonderausstattung gespeichert. Welche SELECT-Anweisung befriedigt die folgende Anfrage: \nErstellen Sie eine Liste aller Autos, die keine Sonderausstattung haben!", "explanation": "Die Abfrage\n\nSELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr \n\ngibt aus dem kartesischen Produkt alle Autos mit allen Sonderausstattungen diejenigen aus, deren Seriennummer verschieden ist. \n\nSELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung) \n\nliefert alle Autos, da der NOT EXIST immer erf\u00fcllt ist.", "type": "multiple-choice", "answers": [{"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A\nWHERE A.SerienNr NOT IN \n   (SELECT SerienNr FROM Sonderausstattung)", "solution": "true"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung B\n WHERE A.SerienNr = B.SerienNr)", "solution": "true"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A LEFT JOIN Sonderausstattung B ON (A.SerienNr = B.SerienNr) GROUP BY A.SerienNr, A.Modell\nHAVING count(B.Sonderausstattung) = 0", "solution": "true"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung)", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung\n WHERE A.SerienNr = B.SerienNr)", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr", "solution": "false"}]}, {"id": 1291, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Operator wird der F\u00fcr-Alle-Quantor umgesetzt?", "explanation": "Der F\u00fcr-Alle-Quantor kann in SQL nicht direkt umgesetzt werden, sondern nur \u00fcber zwei m\u00f6gliche Umwege: \u00dcber ein doppeltes NOT EXISTS oder durch ein GROUP-BY/HAVING mit Z\u00e4hlen \u00fcber COUNT(*).", "type": "multiple-choice", "answers": [{"text": "Mit einem NOT EXISTS", "solution": "false"}, {"text": "Mit zwei NOT EXISTS", "solution": "true"}, {"text": "Mit FORALL", "solution": "false"}, {"text": "Mit keinem dieser Operatoren", "solution": "false"}]}, {"id": 1293, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank:\n\n    Spieler (Spieler_id, Name, Adresse, Geburtsdatum) Vereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr )\n\n    Spiele (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\n\n    Spieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\n    Welche der angegeben SQL-Abfragen beantwortet/en die Frage: Welche Vereine (K\u00fcrzel, Name) haben wenigstens ein Ausw\u00e4rtsspiel, also wenigstens ein als Spiel als Gastmannschaft in der R\u00fcckrunde (Spieltag 18-34) absolviert?", "explanation": "SELECT v_kuerzel, vereinsname\n\n    FROM verein, spiele\n\n    WHERE spieltag BETWEEN 18 AND 34;\n\n    \n\n    ist semantisch falsch: Es wird hier das kartesische Produkt zwischen den beiden Tabellen ausgef\u00fchrt und nicht der Natural Join.\n\n    \n\n    Die \u00fcbrigen Anfragen sind alle richtig.", "type": "multiple-choice", "answers": [{"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND  spieltag BETWEEN 18 AND 34;", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND spieltag >= 18 AND <= 34;", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele  \nWHERE  spieltag BETWEEN 18 AND 34;", "solution": "false"}, {"text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34);", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34\n GROUP BY gast_v_kuerzel \n  HAVING COUNT (*) >=1);", "solution": "true"}]}, {"id": 1448, "category": 9, "difficulty": 3, "text": "Wo sind SQL-Aggregatfunktionen (SUM, MIN, MAX, COUNT, AVG) erlaubt?", "explanation": "Die SQL-Gruppenfunktionen SUM,MIN, MAX, AVG und COUNT machen in der WHERE-Klausel keinen Sinn, da sie sich auf Gruppen von Werten, nicht auf einzelne Werte, beziehen.", "type": "multiple-choice", "answers": [{"text": "SELECT-Klausel ohne SUBSELECT", "solution": "true"}, {"text": "FROM-Klausel ohne SUBSELECT", "solution": "false"}, {"text": "WHERE-Klausel ohne SUBSELECT", "solution": "false"}, {"text": "GROUP BY-Klausel", "solution": "false"}, {"text": "HAVING-Klausel ohne SUBSELECT", "solution": "true"}, {"text": "ORDER BY-Komponente", "solution": "true"}]}, {"id": 626, "category": 9, "difficulty": 1, "text": "Welche SELECT-Ausdr\u00fccke liefern das gleiche Ergebnis?", "explanation": "Der logische Operator OR ist assoziativ und daher liefert er die gleichen Ergebnisse, unabh\u00e4ngig davon, ob ein Operator rechts oder links steht. \nDie Semantik dieser beiden Anfragen ist: \"Welche Kunden wohnen nicht in Gummersbach oder in K\u00f6ln?\". \nDie Anfrage ohne \"Gummersbach\" hat die Semantik: \"Welche Kunden wohnen in K\u00f6ln?\".", "type": "multiple-choice", "answers": [{"text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'K\u00f6ln'\nOR    NOT (Ort = 'Gummersbach')\n", "solution": "true"}, {"text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'K\u00f6ln'\n", "solution": "false"}, {"text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     NOT (Ort = 'Gummersbach')\nOR      Ort = 'K\u00f6ln'", "solution": "true"}]}, {"id": 627, "category": 9, "difficulty": 3, "text": "Mit welcher SELECT-Komponente kann man die Reihenfolge der Datens\u00e4tze der Ergebnismenge einer SELECT-Abfrage festlegen?", "explanation": "Mit der ORDER BY-Klausel kann auf- (ASC) oder absteigend (DESC) sortiert werden. Die GROUP BY-Klausel sortiert als \"Nebenergebnis\" der Gruppierung die Gruppen auch, aber nur aufsteigend. \nMit den WHERE- und HAVING-Klauseln k\u00f6nnen einzelne Datens\u00e4tze bzw. Gruppen selektiert werden, aber nicht sortiert. \nDie FROM-Klausel verkn\u00fcpft die angegebenen Tabellen mittels kartesischem Produkt bzw. Join, sortiert aber nicht.", "type": "multiple-choice", "answers": [{"text": "WHERE", "solution": "false"}, {"text": "HAVING", "solution": "false"}, {"text": "FROM", "solution": "false"}, {"text": "ORDER BY", "solution": "true"}, {"text": "GROUP BY", "solution": "true"}, {"text": "solch eine Komponente gibt es nicht.", "solution": "false"}]}, {"id": 826, "category": 9, "difficulty": 1, "text": "Welches Pr\u00e4dikat in einer SELECT-WHERE-Bedingung mit Unterabfrage wird als wahr erkannt, wenn die Unterabfrage mindestens einen Datensatz selektiert?", "explanation": "Das EXISTS-Pr\u00e4dikat liefert TRUE, wenn die Ergebnismenge der Unterabfrage wenigstens einen Datensatz enth\u00e4lt. \nDas IN-Pr\u00e4dikat liefert TRUE, wenn der Wert des linken Operators in der Ergebnismenge des rechten Operators der Unteranfrage enthalten ist.", "type": "multiple-choice", "answers": [{"text": "EXISTS", "solution": "true"}, {"text": "solche ein Pr\u00e4dikat gibt es nicht", "solution": "false"}, {"text": "IN", "solution": "false"}]}, {"id": 758, "category": 9, "difficulty": 1, "text": "Mit welcher Komponente kann man in einer SELECT-Anweisung Spalten absteigend sortieren?", "explanation": "Mit der ORDER BY-Klausel kann auf- (ASC) oder absteigend (DESC) sortiert werden. Die GROUP BY-Klausel sortiert als \"Nebenergebnis\" der Gruppierung die Gruppen auch, aber nur aufsteigend. \nMit den WHERE- und HAVING-Klauseln k\u00f6nnen einzelne Datens\u00e4tze bzw. Gruppen selektiert werden, aber nicht sortiert. \nDie FROM-Klausel verkn\u00fcpft die angegebenen Tabellen mittels kartesischem Produkt bzw. Join, sortiert aber nicht.", "type": "multiple-choice", "answers": [{"text": "ORDER BY", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}, {"text": "GROUP BY", "solution": "false"}]}, {"id": 897, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Ausdruck werden in einer Gruppenfunktion ( z.B. COUNT)  auch Werte, die mehrfach vorkommen, ber\u00fccksichtigt?", "explanation": "Bei \"ALL\"  werden alle Werte ber\u00fccksichtigt, bei \"DISTINCT\" nur unterschiedliche Werte.", "type": "text", "answers": [{"text": "Der SQL-Ausdruck, der vor der Gruppenfunktion steht, hei\u00dft:", "solution": "ALL"}]}, {"id": 1705, "category": 9, "difficulty": 2, "text": "Betrachten Sie die Tabelle Test(NR1 number, NR2 number), wobei nur ein Tupel existiert. NR1 hat den Wert 1, NR2 hat einen NULL-Wert, also keinen Eintrag.\n\nWelches Ergebnis hat die folgende SQL-Abfrage?\n\nSELECT NR1 + NR2 FROM Test;", "explanation": "Die Summe aus einer Zahl und einem NULL-Wert ist unter SQL wieder NULL.", "type": "multiple-choice", "answers": [{"text": "1", "solution": "false"}, {"text": "2", "solution": "false"}, {"text": "NULL", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1709, "category": 9, "difficulty": 2, "text": "Es sei folgende Kunden-Tabelle gegeben:\n            Kunden( Kunden_id, Name, Handy ) \nMit welchem/n Befehl/en kann ein Prim\u00e4rschl\u00fcssel f\u00fcr die Kunden_Id sowie ein zusammengesetzter, eindeutiger Zweitschl\u00fcssel f\u00fcr die Tabelle \"Kunden\" \u00fcber die beiden Attribute \"Name\" und \"Handy\" definiert werden?", "explanation": "Eine Tabelle kann nur einen Primary Key haben und CONSTRAINT-Namen sind eindeutig.", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE Kunden  \n(Kunden_Id    NUMBER(9) PRIMARY KEY,     \n Name              VARCHAR2(50),    \n Handy        NUMBER(11), \nCONSTRAINT Kunden_uk  UNIQUE (Name, Handy));", "solution": "true"}, {"text": "CREATE TABLE Kunden  \n(Kunden_I NUMBER(9) PRIMARY KEY,     \nName VARCHAR2(50)  CONSTRAINT Kunden_uk  UNIQUE, \nHandy      NUMBER(11) CONSTRAINT Kunden_uk  UNIQUE);", "solution": "false"}, {"text": "CREATE TABLE Kunden  \n(Kunden_Id NUMBER(9) PRIMARY KEY,     \n Name  VARCHAR2(50), \n Handy NUMBER(11), \n CONSTRAINT Kunden_pk2  PRIMARY KEY (Name, Handy));", "solution": "false"}, {"text": "CREATE TABLE Kunden  \n(Kunden_Id NUMBER(9) PRIMARY KEY,     \nName  VARCHAR2(50) CONSTRAINT Kunden_pk2 PRIMARY KEY), \nHandy  NUMBER(11)CONSTRAINT Kunden_pk2 PRIMARY KEY));", "solution": "false"}]}, {"id": 1779, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft die Operation der relationalen Algebra, die in SQL nicht direkt, sondern mit einer doppelten Verneinung und EXISTS abbildbar ist (doppeltes NOT EXISTS)?", "explanation": "Die Anfrage: \"Zeige die Kunden an, die ALLE Artikel gekauft haben\", wird in der relationalen Algebra mittels Division gel\u00f6st. \nDiese Anfrage kann man doppelt negiert umformulieren: \n\"Zeige die Kunden, f\u00fcr die gilt, das es KEINE Artikel gibt, die sie NICHT gekauft haben\". \nWenn es KEINE Artikel gibt, die sie NICHT gekauft haben, dann haben die Kunden doch ALLE Artikel gekauft. Ergo, die Allaussage kann in SQL mittels \"doppeltem NOT EXISTS\" programmiert werden. \nOder mit einem SELECT COUNT(..). \nBeispiele finden Sie im <a href =\"http:://edb.g,.fh-koeln.de\" edb-SQL-Trainer", "type": "text", "answers": [{"text": "Die Operation hei\u00dft", "solution": "Division"}]}, {"id": 1784, "category": 9, "difficulty": 2, "text": "In einer SQL-Anweisung an eine Tabelle \"Auto\" sollen alle Opel Corsa ausgegeben werden und alle VW Polo, wobei die letzteren weniger als 6000 Euro kosten sollen. Welche SELECT-Anweisung befriedigt diese Anfrage?", "explanation": "Die Abfrage \nSELECT Modell, Preis\nFROM Auto\nWHERE (Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO')\nAND Preis < 6000 \n\nist von der SQL-Syntax her richtig, gibt aber nur die Opel Corsa-Fahrzeuge mit einem Preis kleiner als 6000 \u0080 aus.", "type": "multiple-choice", "answers": [{"text": "SELECT Modell, Preis\nFROM Auto\nWHERE Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO'\nAND Preis < 6000", "solution": "true"}, {"text": "SELECT Modell, Preis\nFROM Auto\nWHERE (Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO')\nAND Preis < 6000", "solution": "false"}, {"text": "SELECT Modell, Preis\nFROM Auto\nWHERE Modell = 'OPEL CORSA'\nOR (Modell = 'VW POLO'\nAND Preis < 6000)", "solution": "true"}]}, {"id": 2116, "category": 9, "difficulty": 2, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat der Durchschnitt der Tabelle Test mit sich selber?", "explanation": "Der Durchschnitt einer Tabelle mit sich selber ist die Ursprungstabelle selber.", "type": "text", "answers": [{"text": "", "solution": "3"}]}, {"id": 2117, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat der Durchschnitt der Tabelle Test mit sich selber?", "explanation": "Der Durchschnitt einer Tabelle mit sich selber ist die Ursprungstabelle selber.", "type": "text", "answers": [{"text": "", "solution": "5"}]}, {"id": 2118, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat die Differenz der Tabelle Test mit sich selber?", "explanation": "x-x = 0 :-), das gilt sogar f\u00fcr Relationen.", "type": "text", "answers": [{"text": "", "solution": "0"}]}, {"id": 2119, "category": 9, "difficulty": 2, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat die Vereinigungsmenge der Tabelle Test mit sich selber?", "explanation": "Die Vereinigungsmenge der Tabelle Test mit sich selber ist wieder die Tabelle Test.", "type": "text", "answers": [{"text": "", "solution": "5"}]}, {"id": 2120, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat die Projektion der Tabelle Test auf die Spalten Spalte_1, Spalte_2, wenn Spalte 2 der Prim\u00e4rschl\u00fcssel ist?", "explanation": "Prim\u00e4rschl\u00fcssel sind eindeutig.", "type": "text", "answers": [{"text": "", "solution": "5"}]}, {"id": 2121, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat die Projektion der Tabelle Test auf die Spalten Spalte_2, Spalte_3?", "explanation": "2 = 2.", "type": "text", "answers": [{"text": "", "solution": "2"}]}, {"id": 2122, "category": 9, "difficulty": 3, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind, die sich alle im Wert f\u00fcr Spalte_3 unterscheiden.\n\nWie viele Spalten hat die Selektion der Tabelle Test auf einen Wert der Spalte_3?\nBitte numerischen Wert azfschrieben!", "explanation": "Da in der Selektion keine Spalten ausgeschlossen werden, bleibt es bei urspr\u00fcnglichen Spalten Spalte_1, Spalte_2, Spalte_3, also 3.", "type": "text", "answers": [{"text": "", "solution": "3"}]}, {"id": 2123, "category": 9, "difficulty": 3, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind, die sich alle im Wert f\u00fcr Spalte_3 unterscheiden.\n\nWie viele Tupel hat die Selektion der Tabelle Test auf einen Wert der Spalte_3?\nBitte  numerischen Wert aufschreiben!", "explanation": "1 = 1 :-).", "type": "text", "answers": [{"text": "", "solution": "1"}]}, {"id": 1381, "category": 9, "difficulty": 1, "text": "Mit welcher SELECT-Komponente kann man die Reihenfolge der Ergebnisdatens\u00e4tze einer SELECT-Abfrage festlegen?", "explanation": "Neben ORDER BY sortiert auch GROUP By in der Reihenfolge der angegebenen Spalten.", "type": "multiple-choice", "answers": [{"text": "ORDER BY", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}, {"text": "GROUP BY", "solution": "false"}]}, {"id": 1441, "category": 9, "difficulty": 3, "text": "Mit welchem SQL-Befehl l\u00f6scht man die Daten einer Tabelle, ohne die Tabellendefinition zu l\u00f6schen?", "explanation": "Der DROP-Befehl l\u00f6scht auch die Tabellendefinitionen.", "type": "multiple-choice", "answers": [{"text": "DROP table...", "solution": "false"}, {"text": "DELETE FROM table ...", "solution": "true"}, {"text": "CANCEL table ..", "solution": "false"}, {"text": "truncate table ...", "solution": "true"}]}, {"id": 1433, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank:\n\nSpieler (Spieler_id, Name, Adresse, Geburtsdatum)\nVereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr)\nSpiele (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\nSpieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\nWelche der angegeben SQL-Abfragen beantwortet/en die Frage: \nWelche Spieler (Name, Adresse) haben noch nie in einem Spiel mit mehr als 30000 Zuschauern mitgespielt?", "explanation": "SELECT name, adresse FROM spieler se \nWHERE NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                  WHERE anzahl_zuschauer > 30000); \nist semantisch falsch: Der Unteranfrage fehlt die Korrelation zur oberen Anfragen (unkorrelierter EXISTS). So liefert die obere Anfrage immer die leere Menge als Ergebnis, sobald es wenigstens ein Spiel mit mehr als 3000 Zuschauern gibt, also wenn der untere SELECT wenigstens einen Datensatz liefert. \n\nSELECT name, adresse FROM spieler se \nWHERE  NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                   WHERE   anzahl_zuschauer > 30000) \nAND    se.spieler_id = sp.spieler_id;\nist semantisch und syntaktisch falsch: Die schlie\u00dfende Klammer steht falsch. Richtig w\u00e4re die Anfrage, wenn die AND-Bedingung zur Unteranfrage geh\u00f6ren w\u00fcrde. Aber so, geh\u00f6rt sie zur oberen Anfrage und damit ist das Ganze nicht ausf\u00fchrbar, denn z.B. der Tabellenalias se ist im oberen SELECT nicht bekannt, nur im unteren. \n\nSELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nHAVING COUNT(s.spieler_id ) = 0; \nist semantisch falsch: Mit dem Natural Join werden nur die Spiele mit mehr als 3000 Zuschauern ermittelt. Anschlie\u00dfend wird mit der HAVING-Bedingung versucht, die Spieler zu ermitteln, die kein solches Spiel haben. Ergebnis: aufgrund dieses Widerspruchs immer die leere Menge.  \n\nSELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nAND    COUNT(s.spieler_id ) IS NULL;   \nist syntaktisch falsch: Aggregatfunktionen k\u00f6nnen nicht in der WHERE-Klausel verwendet werden, nur in der SELECT-, GROUP BY, HAVING-Klausel.\n \n\n\nrichtig isz :\nSELECT name, adresse FROM spieler \nWHERE spieler_id NOT IN \n   (SELECT spieler_id \n    FROM   spieleinsatz, spiele \n    WHERE  anzahl_zuschauer > 30000\n    AND    spiele.spiel_id = spieleinsatz.spiel_id );", "type": "multiple-choice", "answers": [{"text": "SELECT name, adresse FROM spieler se \nWHERE NOT EXISTS (SELECT spieler_id \n                  FROM   spieleinsatz se \n                  WHERE  anzahl_zuschauer > 30000);", "solution": "false"}, {"text": "SELECT name, adresse FROM spieler \nWHERE spieler_id NOT IN \n   (SELECT spieler_id \n    FROM   spieleinsatz, spiele \n    WHERE  anzahl_zuschauer > 30000\n    AND    spiele.spiel_id = spieleinsatz.spiel_id );", "solution": "true"}, {"text": "SELECT name, adresse FROM spieler se \nWHERE  NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                   WHERE   anzahl_zuschauer > 30000) \nAND    se.spieler_id = sp.spieler_id;", "solution": "false"}, {"text": "SELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nHAVING COUNT(s.spieler_id ) = 0;", "solution": "false"}, {"text": "SELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nAND    COUNT(s.spieler_id ) IS NULL;", "solution": "false"}]}, {"id": 1443, "category": 9, "difficulty": 2, "text": "Welcher der folgenden SQL-Ausdr\u00fccke ist korrekt?", "explanation": "In der SELECT-Klausel d\u00fcrfen nur zwei Arten von Spalten vorkommen:\n\ndie, die mit einer Gruppenfunktion versehen sind (hier Gehalt) \ndie anderen Spalten m\u00fcssen in der GROUP-BY-Klausel enthalten sein.", "type": "multiple-choice", "answers": [{"text": "keine von allen", "solution": "false"}, {"text": "SELECT\n    Abt_Nr,\n    AVG(Gehalt)\nFROM     Angestellte\nGROUP BY Abt_Nr;", "solution": "true"}, {"text": "SELECT\n    Abt_Nr,\n    Nachname,\n    AVG(Gehalt)\nFROM     Angestellte\nGROUP BY Abt_Nr;", "solution": "false"}]}, {"id": 1753, "category": 9, "difficulty": 1, "text": "Welche der beiden folgenden SELECT-Anweisungen ist korrekt, wenn Spalte_1 und Spalte_2 den gleichen Datentyp haben?", "explanation": "Eine ORDER-BY-Klausel kann in zwei SELECTs, die mit UNION verkn\u00fcpft werden, nicht verwendet werden.", "type": "multiple-choice", "answers": [{"text": "SELECT Spalte_1 FROM TEST1 ORDER BY Spalte_1\nUNION\nSELECT Spalte_2 FROM TEST2 ORDER BY Spalte_2", "solution": "false"}, {"text": "SELECT Spalte_1 FROM TEST1\nUNION\nSELECT Spalte_2 FROM TEST2", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 1772, "category": 9, "difficulty": 3, "text": "Welche der folgenden INSERT-Anweisungen in eine Tabelle test\n   \nCREATE TABLE test( Nr NUMBER(9), \nBezeichnung VARCHAR2(20), Wert NUMBER(9))  \n\nist korrekt? \n\nTabelle 2 soll die gleichen Spalten wie Tabelle test haben.", "explanation": "Bei einer INSERT-Anweisung m\u00fcssen die Werte in der Reihenfolge der Spaltenliste hinter dem Tabellennamen, oder wenn dieser fehlt, in der Reihenfolge der Spaltendefinition vorkommen.", "type": "multiple-choice", "answers": [{"text": "INSERT INTO TEST\nVALUES (1, 'Bier')", "solution": "false"}, {"text": "INSERT INTO TEST\nVALUES (1, 'Bier', 20)", "solution": "true"}, {"text": "INSERT INTO TEST (Nr, Bezeichnung, Wert)\nVALUES (1, 'Bier', 20)", "solution": "true"}, {"text": "INSERT INTO TEST (Nr, Wert, Bezeichnung)\nVALUES (1, 'Bier', '20')", "solution": "false"}, {"text": "INSERT INTO TEST SELECT Nr, Bezeichnung, Wert FROM Tabelle2", "solution": "true"}, {"text": "INSERT INTO TEST\n(1, 20, 'Bier')", "solution": "false"}]}, {"id": 2082, "category": 9, "difficulty": 1, "text": "SELECT-Abfragen, die SELECT-Anweisungen der Grundform \u00fcber einen UNION, einen INTERSECT oder MINUS verkn\u00fcpfen, m\u00fcssen", "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) m\u00fcssen die gleichen Spaltendefinitionen aufweisen: \nDie Anzahl der Spalten muss \u00fcbereinstimmen. \nDie Datentypen der der Spalten m\u00fcssen gleich sein.  \nDie Reihenfolge der Spalten muss \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "disjunkt sein", "solution": "false"}, {"text": "vollst\u00e4ndig sein", "solution": "false"}, {"text": "vereinigungskonform sein", "solution": "true"}, {"text": "linear \u00e4quivalent sein", "solution": "false"}]}, {"id": 2411, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber WHERE und GROUP BY sind korrekt?", "explanation": "Die Reihenfolge der Klauseln der SELECT-Anweisung ist folgende: \nSELECT ...\nFROM ...\nWHERE ....\nGROUP BY ...\nHAVING ...\nORDER BY ....", "type": "multiple-choice", "answers": [{"text": "Die GROUP-BY-Klausel steht immer vor der WHERE-Klausel", "solution": "false"}, {"text": "Die GROUP-BY-Klausel steht immer nach der WHERE-Klausel", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 2442, "category": 9, "difficulty": 3, "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Prim\u00e4rschl\u00fcssel A, S den Prim\u00e4rschl\u00fcssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz)?", "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS oder einem LEFT Outer Join ausgedr\u00fcckt werden.", "type": "multiple-choice", "answers": [{"text": "SELECT A \nFROM R LEFT OUTER JOIN S ON S.B = R.A\nWHERE B is NULL;", "solution": "true"}, {"text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;", "solution": "true"}, {"text": "SELECT * FROM R,S WHERE R.ID <> S.ID;", "solution": "false"}, {"text": "SELECT * FROM R\nJOIN S USING (R.id !0 S.ID);", "solution": "false"}]}, {"id": 2441, "category": 9, "difficulty": 2, "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Prim\u00e4rschl\u00fcssel A, S den Prim\u00e4rschl\u00fcssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz)?", "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS ausgedr\u00fcckt werden. Der Natural Join \u00e4hnelt dem Durchschnitt, nur das doppelte Spalten unterdr\u00fcckt werden.", "type": "multiple-choice", "answers": [{"text": "SELECT *\nFROM R\nWHERE NOT EXISTS (SELECT B FROM S where a = b);", "solution": "true"}, {"text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;", "solution": "true"}, {"text": "SELECT * FROM R natural Join S;", "solution": "false"}]}, {"id": 1687, "category": 9, "difficulty": 2, "text": "Welche der folgenden SELECT-Abfragen ist syntaktisch korrekt?", "explanation": "Die WHERE-Klausel steht immer vor der Group-By-Klausel. \nIn der SELECT-Klausel d\u00fcrfen nur zwei Arten von Spalten vorkommen:\n\ndie, die mit einer Gruppenfunktion versehen sind (hier Gehalt) \ndie anderen Spalten m\u00fcssen in der GROUP-BY-Klausel enthalten sein.", "type": "multiple-choice", "answers": [{"text": "SELECT COUNT(*), Gruppe\nFROM Praktikum\nWHERE Fachkuerzel = 'DBS'\nGROUP BY Gruppe;", "solution": "true"}, {"text": "SELECT COUNT(*), Gruppe\nFROM Praktikum\nGROUP BY Gruppe\nWHERE Fachkuerzel = 'DBS';", "solution": "false"}, {"text": "SELECT COUNT(*), Gruppe\nFROM Praktikum;", "solution": "false"}, {"text": "keine", "solution": "false"}]}, {"id": 1654, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgenden Mini-Datenbank eines Weinh\u00e4ndlers:\nRebsorte (Sorte, Name, Farbe)\nWein (WeinID, Name, Rebsorte)\nJahrgang (WeinID, Jahr, Preis, Qualitaet)\n\nWelche SELECT-Abfrage beantwortet die folgende Anfrage:\n\nWelche Riesling Weine haben in keinem Jahrgang die Qualit\u00e4tsstufe 3 besessen?", "explanation": "Die Antworten mit NOT EXISTS  entsprechen den Antworten mit NOT IN. Allerdings muss man darauf achten, dass man korrelierte Subselects verwendet, damit man auch die Weine enth\u00e4lt, die der Semantik (Welche Riesling Weine haben in keinem Jahrgang die Qualit\u00e4tsstufe 3 besessen?) gen\u00fcgen. Die \u00e4u\u00dferen SELECT-Anweisungen m\u00fcssen mit den inneren \u00fcber Join-Bedingungen verkn\u00fcpft werden. Wenn eine Join-Verkn\u00fcpfung fehlt, liefert der NOT EXISTS immer ein Ergebnis.", "type": "multiple-choice", "answers": [{"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte  = r.sorte\nAND    r.name      = 'Riesling'\nAND    NOT EXISTS (SELECT j.wein_id\n                   FROM   jahrgang j\n                   WHERE  j.qualitaet = 3);\n", "solution": "false"}, {"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name       = 'Riesling'\nAND    w.wein_id NOT IN (SELECT j.wein_id\n                         FROM   jahrgang j\n                         WHERE  j.qualitaet > 3);\n", "solution": "false"}, {"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte  = r.sorte\nAND    r.name      = 'Riesling'\nAND    NOT EXISTS (SELECT j.wein_id\n                   FROM   jahrgang j\n                   WHERE  j.qualitaet = 3\n           AND    j.wein_id   = w.wein_id);", "solution": "true"}, {"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name       = 'Riesling'\nAND    w.wein_id NOT EXISTS(SELECT j.wein_id\n                          FROM   jahrgang j\n                          WHERE  j.qualitaet = 3);\n", "solution": "false"}, {"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name    = 'Riesling'\nAND    w.wein_id NOT IN (SELECT j.wein_id\n                         FROM   jahrgang j\n                         WHERE  j.qualitaet = 3);\n", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1626, "category": 9, "difficulty": 2, "text": "Betrachten Sie die folgende Abfrage an eine Angestellten-Tabelle:\nWelche Angestellten wohnen in K\u00f6ln oder Gummersbach?\nWelche der folgenden Abfragen liefert das gew\u00fcnschte Ergebnis:", "explanation": "Der logische Operator \"=\" kann nur mit einem einzelnen Wert vergleichen.\nEine Ort kann nicht gleichzeitig K\u00f6ln und Gummersbach hei\u00dfen.", "type": "multiple-choice", "answers": [{"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = 'K\u00f6ln'\nOR ORT = 'Gummersbach'", "solution": "true"}, {"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT in ( 'K\u00f6ln',  'Gummersbach')", "solution": "true"}, {"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = ( 'K\u00f6ln',  'Gummersbach')", "solution": "false"}, {"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = ALL ( 'K\u00f6ln',  'Gummersbach')", "solution": "false"}, {"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = 'K\u00f6ln'\nAND ORT = 'Gummersbach'", "solution": "false"}]}, {"id": 2132, "category": 9, "difficulty": 3, "text": "In welcher Reihenfolge werden in einem SELECT-Befehl die folgenden Komponenten vom DBMS ausgef\u00fchrt? (Geben Zahlen von 1 bis 6 an)", "explanation": "F\u00fcr die SELECT-Anweisungen gelten folgende Ausf\u00fchrungsreihenfolgen der einzelnen Klauseln: \n6. SELECT\n1. FROM\n2. WHERE\n3. GROUP BY \n4. HAVING\n5. ORDER BY", "type": "text", "answers": [{"text": "WHERE", "solution": "2"}, {"text": "FROM", "solution": "1"}, {"text": "ORDER BY", "solution": "5"}, {"text": "HAVING", "solution": "4"}, {"text": "GROUP BY", "solution": "3"}, {"text": "SELECT", "solution": "6"}]}, {"id": 2131, "category": 9, "difficulty": 3, "text": "Der Ausdruck \"SELECT Nachname, SUM(Umsaetze) FROM KUNDEN GROUP BY Nachname\"", "explanation": "GROUP By bewirkt hier keine Sortierung \u00fcber den Nachnamen.", "type": "multiple-choice", "answers": [{"text": "bewirkt eine Gruppierung", "solution": "true"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}]}, {"id": 2130, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN\"", "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.", "type": "multiple-choice", "answers": [{"text": "bewirkt keine Sortierung", "solution": "true"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}]}, {"id": 1515, "category": 9, "difficulty": 2, "text": "Welcher der folgenden UPDATE-Befehle ist syntaktisch korrekt, vorausgesetzt, die Tabellen haben die angegebenen Spalten?", "explanation": "In einem UPDATE-Befehl kann man nur \u00fcber eine SELECT-Anweisung auf eine andere Tabelle zugreifen.", "type": "multiple-choice", "answers": [{"text": "UPDATE tab1\nSET spalte1 = tab2.spalte2\nWHERE tab1.spalte3 = tab2.spalte3;", "solution": "false"}, {"text": "UPDATE tab1\nSET spalte1 = \n   (SELECT tab2.spalte2 FROM tab2\n    WHERE  tab1.spalte3 = tab2.spalte3);", "solution": "true"}]}, {"id": 2440, "category": 9, "difficulty": 2, "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Prim\u00e4rschl\u00fcssel A, S den Prim\u00e4rschl\u00fcssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz?", "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS ausgedr\u00fcckt werden.", "type": "multiple-choice", "answers": [{"text": "SELECT *\nFROM R\nWHERE A NOT IN (SELECT B FROM S);", "solution": "true"}, {"text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;", "solution": "true"}, {"text": "SELECT * FROM S\n MINUS\nSELECT * FROM R;", "solution": "false"}]}, {"id": 2084, "category": 9, "difficulty": 3, "text": "Welche SELECT-Abfragen sind syntaktisch korrekt?", "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \n* Die beteiligten Tabellen (Eingangsdatenmengen) m\u00fcssen die gleichen Spaltendefinitionen aufweisen: \n* Die Anzahl der Spalten muss \u00fcbereinstimmen. \n* Die Datentypen der der Spalten m\u00fcssen gleich sein.  \n* Die Reihenfolge der Spalten muss \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "SELECT Nachname, Vorname\nFROM Angestellte\n    UNION\nSELECT Nachname\nFROM Kunden;", "solution": "false"}, {"text": "SELECT Nachname\nFROM Angestellte\n    UNION\nSELECT Nachname\nFROM Kunden;", "solution": "true"}, {"text": "SELECT Nachname\nFROM Angestellte\n    MINUS\nSELECT Vorname\nFROM Kunden;", "solution": "true"}]}, {"id": 2138, "category": 9, "difficulty": 2, "text": "Damit die folgende UPDATE-Anweisung ausgef\u00fchrt werden kann:\nUPDATE TABELLE 1 SET SPALTE1 = (SELECT SPALTE2 FROM TABELLE2);", "explanation": "Die Abfrage darf nur einen Ergebnisdatensatz liefern, da ein Tupel in einem Feld (hier Spalte1) auch nur einen Wert aufnehmen kann.", "type": "multiple-choice", "answers": [{"text": "darf die Abfrage nur einen Ergebnisdatensatz liefern.", "solution": "true"}, {"text": "muss die Abfrage so viele Ergebnisdatens\u00e4tze liefern, wie Datens\u00e4tze mit der UPDATE-Anweisung ge\u00e4ndert werden.", "solution": "false"}, {"text": "gelten keine Einschr\u00e4nkungen hinsichtlich der Ergebnismenge der Abfrage.", "solution": "false"}]}, {"id": 2137, "category": 9, "difficulty": 2, "text": "Die Tabellen \"ausleihen\" und \"fahrzeuge\" sollen unter anderem folgende Spalten  haben: \nausleihen (kfz_nr, Kunden_Nr, von, bis,....)\nFahrzeuge (kfz_nr, nummernschild,...)\n\nWelche SELECT-Anweisung beantwortet die Anfrage: \n\"Gibt es Fahrzeuge, die noch nie ausgeliehen wurden?\"", "explanation": "RICHTIG sind: \nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT EXISTS \n(SELECT * from ausleihen WHERE fahrzeuge.kfz_nr = ausleihen.kfz_nr)\n\nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)\n \n\nFALSCH sind: \nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;\nmit der Semantik: \"Welche Fahrzeuge wurden ausgeliehen?\" \n\nSELECT kfz_nr, nummernschild, ausleihen.von \nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr;\nmit einer unerf\u00fcllbaren Bedingung. Die implizite Bedingung des Natural Joins \"fahrzeuge.kfz_nr = ausleihen.kfz_nr\" wiederspricht der formulierten WHERE-Klausel \"WHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr\".", "type": "multiple-choice", "answers": [{"text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;", "solution": "false"}, {"text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge \nWHERE NOT EXISTS \n(SELECT * from ausleihen WHERE fahrzeuge.kfz_nr = ausleihen.kfz_nr)", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr;", "solution": "false"}]}, {"id": 2107, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat der Natural Join der Tabelle Test mit sich selber?", "explanation": "Der Natural Join einer Tabelle mit sich selber ergibt wieder die Ursprungstabelle, und die hat hier 3 Spalten.", "type": "multiple-choice", "answers": [{"text": "5", "solution": "false"}, {"text": "10", "solution": "false"}, {"text": "25", "solution": "false"}, {"text": "3", "solution": "true"}]}, {"id": 2125, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank \nSpieler (Spieler_id, Name, Adresse, Geburtsdatum)\nVereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr)\nSpiele  (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\nSpieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\nWelche der angegeben SQL-Abfragen beantwortet/en die Frage: \nWelche Vereine (K\u00fcrzel, Name) haben wenigstens ein Ausw\u00e4rtsspiel, also wenigstens ein Spiel als Gastmannschaft in der R\u00fcckrunde (Spieltag 18-34) absolviert?", "explanation": "RICHTIG sind: alle Anfragen\nDie Teilaussage \"...welche Vereine haben gespielt...\" kann durch einen (Natural) Join, einen IN- oder auch einen EXISTS-Operator formuliert werden. \nDa der BETWEEN-Operator die Grenzen mit einschlie\u00dft, muss die Simulation <= und >= verwenden. \n\nFALSCH ist: keine der Anfragen", "type": "multiple-choice", "answers": [{"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND  spieltag BETWEEN 18 AND 34;", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND spieltag >= 18 AND spieltag <= 34;", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34);", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE EXISTS \n(SELECT * FROM spiele \n WHERE spieltag BETWEEN 18 AND 34\n AND gast_v_kuerzel = v_kuerzel);", "solution": "true"}]}, {"id": 2092, "category": 9, "difficulty": 3, "text": "Die Tabellen \"ausleihen\" und \"fahrzeuge\" sollen unter anderem folgende Spalten  haben: \nausleihen (kfz_nr, Kunden_Nr, von, bis,....)\nFahrzeuge (kfz_nr, nummernschild,...)\n\nWelche SELECT-Anweisung beantwortet die Anfrage: Gibt es Fahrzeuge, die noch nie ausgeliehen wurden?", "explanation": "RICHTIG sind: \nDer LEFT OUTER JOIN nimmt alle Datens\u00e4tze der linken Tabelle, also der Fahrzeuge und verkn\u00fcpft sie falls m\u00f6glich mit Ausleihvorg\u00e4ngen. Bei den Fahrzeugen, f\u00fcr die es keine Ausleihvorg\u00e4nge gibt, ist die Spalte von NULL. \nDer FULL OUTER JOIN nimmt sowohl von den Ausleihen wie auch von den Fahrzeugen alle Datens\u00e4tze und verf\u00e4hrt dann weiter wie beim LEFT OUTER JOIN. Der FULL ist etwas \"oversized\", der LEFT reicht v\u00f6llig aus f\u00fcr den gew\u00fcnschten Effekt.\nBeim NOT IN werden alle Fahrzeug-Datens\u00e4tze gepr\u00fcft, ob es f\u00fcr ihre kfz_nr einen Datensatz in der Ausleihe-Tabelle gibt, wenn nicht, dann kommt dieser Fahrzeug-Datensatz in die Ergebnismenge. \n\nFALSCH sind: \nRIGHT OUTER Join hei\u00dft ja, das die rechte Tabelle vollst\u00e4ndig \u00fcbernommen wird, hier also die Ausleihen und falls m\u00f6glich mit KFZs verbunden wird und die sonst fehlenden Spalten mit NULL aufgef\u00fcllt werden. Damit ist die Semantik mit der IS NULL-Bedingung: \"F\u00fcr welche Ausleihen haben keine Fahrzeuge?\" \n\nDer NATURAL JOIN ist falsch, weil er implizit die Bedingung \"WHERE ausleihen.kfz_nr = fahrzeuge.kfz_nr\" ausf\u00fchrt. Seine Semantik w\u00e4re bis dahin: \"Welche Fahrzeuge wurden ausgeliehen?\" Die zus\u00e4tzliche Bedingung \"von IS NULL\" f\u00fchrt f\u00fcr den Fall, dass \"von\" f\u00fcr Ausleihen Pflichteinfabefeld ist, zu einer unerf\u00fcllbaren Bedingung, so dass die Ergebnismenge immer leer ist. Ist die Spalte \"von\" kein Pflichteingabefeld, so ist die Semantik der Anfrage: \"Welche Fahrzeuge wurden ausgeliehen und deren von-Datum ist vergessen worden einzutragen.\"\n\nDie NOT EXISTS-Anfrage w\u00e4re richtig, wenn sie korreliert w\u00e4re, also die Bedingung \"WHERE ausleihen.kfz_nr = fahrzeuge.kfz_nr\" h\u00e4tte. So liefert die Unteranfrage immer dann wenigstens einen Datensatz, wenn die Tabelle Ausleihen gef\u00fcllt ist - und damit ist NOT EXISTS immer FALSE, wenn die Ausleihen-Tabelle Datens\u00e4tze enth\u00e4lt, unabh\u00e4ngig davon, welche KfFZ_NR dort vertreten sind.", "type": "multiple-choice", "answers": [{"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge LEFT OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge RIGHT OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;", "solution": "false"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge FULL OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;", "solution": "false"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT EXISTS (SELECT DISTINCT kfz_nr from ausleihen)", "solution": "false"}]}, {"id": 2109, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat die Vereinigungsmenge der Tabelle Test mit sich selber?", "explanation": "Es wird nach den Spalten,  nicht nach die Zeilen der Tabelle gefragt :-).", "type": "text", "answers": [{"text": "", "solution": "3"}]}, {"id": 2111, "category": 9, "difficulty": 3, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat die Differenz der Tabelle Test mit sich selber?", "explanation": "Die Differenz einer Tabelle mit sich selber ist die leere Menge.", "type": "text", "answers": [{"text": "Bitte schreiben Sie die Zahl als numerischen Wert auf!", "solution": "3"}]}, {"id": 1490, "category": 9, "difficulty": 2, "text": "In einer WHEN-Bedingung eines zeilenorientierten Triggers haben die Transitionsvariable einen Doppelpunkt.", "explanation": "Der Doppelpunkt steht zur St\u00e4rkung des Ged\u00e4chtnisses bei den Transitionsvariablen nur im PL/SQL-Ausf\u00fchrungsteil eines Triggers, nicht in der WHEN-Bedingung.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1803, "category": 9, "difficulty": 3, "text": "Betrachten Sie die Tabelle Angestellte(Ang_Nr, Nachname, Jahresgehalt). \nEs werden die Angestellten gesucht, die das h\u00f6chste Jahresgehalt haben. Welche Abfrage liefert das gew\u00fcnschte Ergebnis?", "explanation": "Die Abfrage \nSELECT nachname, max(jahresgehalt)\nFROM angestellte\nGROUP by nachname;\nist syntaktisch korrekt, aber nicht semantisch, da die h\u00f6chsten Jahresgeh\u00e4lter je Nachname berechnet werden.\n\nAnsonsten kann das Ergebnis \u00fcber \"where jahresgehalt >= ALL(...)\"berechnet werden.", "type": "multiple-choice", "answers": [{"text": "SELECT ang_nr\nFROM angestellte\nWHERE jahresgehalt > all ;", "solution": "false"}, {"text": "SELECT max( all jahresgehalt)\nFROM angestellte;", "solution": "false"}, {"text": "SELECT nachname, max(jahresgehalt)\nFROM angestellte\nGROUP by nachname;", "solution": "false"}, {"text": "SELECT nachname, max(jahresgehalt) \nFROM angestellte;", "solution": "false"}, {"text": "SELECT a.nachname, a.jahresgehalt\nFROM angestellte a\nWHERE a.jahresgehalt = max(jahresgehalt);", "solution": "false"}, {"text": "SELECT ang_nr, jahresgehalt\nfrom angestellte\nwhere jahresgehalt = (SELECT max(jahresgehalt) from angestellte);", "solution": "true"}, {"text": "SELECT ang_nr\nFROM angestellte\nwhere jahresgehalt > ALL(\nSELECT jahresgehalt from angestellte)", "solution": "false"}, {"text": "select ang_nr, jahresgehalt\nFROM angestellte\nwhere jahresgehalt >= ALL(\nSELECT jahresgehalt from angestellte);", "solution": "true"}]}, {"id": 1804, "category": 9, "difficulty": 2, "text": "Betrachten Sie die Tabelle Angestellte(Ang_Nr, Nachname, Jahresgehalt) und die Tabelle Kurse(Kurs, Ang_NR, Anzahl). Es werden die Angestellten gesucht, die meisten Kurse abgehalten haben. Welche Abfrage liefert das gew\u00fcnschte Ergebnis?", "explanation": "Diese Anfrage kann nur \u00fcber eine Unterabfrage beantwortet werden; in den anderen Abfragen ist die Gruppenfunktion SUM falsch verwendet.", "type": "multiple-choice", "answers": [{"text": "SELECT nachname\nFROM angestellte\nWHERE ang_nr = (SELECT SUM(ang_nr)\nFROM kurse\nGROUP BY  k.ang_nr);", "solution": "false"}, {"text": "SELECT  a.ang_nr, a.Nachname, SUM(anzahl)\nFROM    angestellte a , kurse b\nWHERE a.ang_nr = b.ang_nr\nGROUP BY a.ang_nr, Nachname\nHAVING SUM(anzahl)  >= ALL\n       (SELECT SUM(anzahl)\n        FROM    angestellte a , kurse b\n        WHERE a.ang_nr = b.ang_nr\n        GROUP BY a.ang_nr);", "solution": "true"}, {"text": "SELECT SUM(anzahl), a.nachname\nFROM angestelltea, kurse b,\nWHERE a.ang_nr = b.ang_nr\nGROUP BY a.nachname\nORDER BY SUM(b.anzahl) DESC ;", "solution": "false"}]}, {"id": 1730, "category": 9, "difficulty": 3, "text": "Welche der folgenden INSERT -Ausdr\u00fccke in die Teile-Tabelle  sind syntaktisch und semantisch korrekt, wenn die Teile-Tabelle durch das folgende CREATE-Table-Statement angelegt wird:\n\nCREATE TABLE TEILE\n( TNR NUMBER(38) NOT NULL,\n  BEZEICHNUNG VARCHAR2(50) NOT NULL,\n  TYP VARCHAR2(50),\n  MINDESTBESTAND NUMBER,\n  BESTAND NUMBER,\n  ZEITSTEMPEL DATE,\n  CONSTRAINT pruefe_bestand CHECK (Bestand >= Mindestbestand )\n);", "explanation": "Bei einem INSERT-Befehl m\u00fcssen alle Spalten, die mit NOT-NULL angelegt wurden, auch mit einem Wert versorgt werden,", "type": "multiple-choice", "answers": [{"text": "INSERT INTO Teile\n(TNR, BEZEICHNUNG, TYP, MINDESTBESTAND, BESTAND, ZEITSTEMPEL)\nVALUES  (33,  \"Dynamo\", \"Material\", 15, 20, \"01.01.2000\");", "solution": "true"}, {"text": "keiner von allen", "solution": "false"}, {"text": "INSERT INTO Teile\n       (TNR, BEZEICHNUNG, TYP, MINDESTBESTAND, BESTAND, ZEITSTEMPEL)\nVALUES  (3333,  \"Dynamo\", \"Material\", 20, 15, \"01.01.2000\");", "solution": "false"}, {"text": "INSERT INTO Teile (TNR, TYP, BEZEICHNUNG)\nVALUES  (\"33\", \"fremd\", Dynamo);", "solution": "true"}, {"text": "INSERT INTO Teile\nVALUES  (33, \"kg\", \"Dynamo\",  \"Material\", 20, 15;", "solution": "false"}, {"text": "INSERT INTO Teile (TNR, TYP, BEZEICHNUNG)\nVALUES  (33, \"Material\", \"Dynamo\");", "solution": "true"}, {"text": "INSERT INTO Teile (TYP, BEZEICHNUNG)\nVALUES  (\"Material\", \"Dynamo\");", "solution": "false"}, {"text": "INSERT INTO Teile (TNR, TYP)\nVALUES  (\"33\", \"Material\");", "solution": "false"}]}, {"id": 1713, "category": 9, "difficulty": 3, "text": "Wie hei\u00dfen SELECT-Anweisungen auf die man die Mengenoperationen UNION, INTERSECT und EXCEPT bzw. MINUS anwenden kann?", "explanation": "SELECT-Anweisungen hei\u00dfen <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform , wenn die beteiligten SELECT-Ausdr\u00fccke (UNION, INTERSECT und MINUS) die gleichen Spaltendefinitionen haben, also nicht zwingend gleich hei\u00dfen, sondern nur die Anzahl und die Datentypen und Inhalte kompatibel sind sowie die Reihenfolge \u00fcbereinstimmen.", "type": "text", "answers": [{"text": "Solche Anweisungen hei\u00dfen", "solution": "vereinigungskonform"}]}, {"id": 1631, "category": 9, "difficulty": 1, "text": "Auf einer Tabelle A soll ein Fremdschl\u00fcssel mit Bezug auf die Spalte \"Nr\" der Tabelle B definiert werden. Dazu muss auf der Spalte \"Nr\" in B vorher ein Prim\u00e4rschl\u00fcssel oder als UNIQUE KEY angelegt werden.", "explanation": "Spalte A geh\u00f6rt der Detailtabelle an und enth\u00e4lt Werte, die Spaltenwerte in B der Mastertabelle referenzieren. Das kann nur funktionieren, wenn die Werte in A eindeutig einen Datensatz der Mastertabelle referenzieren. Dies wird dadurch gew\u00e4hrleistet, dass die referenzierte Spalte B als PRIMARY oder UNIQUE KEY definiert werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1722, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Befehl \u00e4ndert man Daten?", "explanation": "Mit der UPDATE-Anweisung unter SQL k\u00f6nnen Mengen von Daten oder einzelne Datens\u00e4tze in Tabellen ver\u00e4ndert werden.", "type": "multiple-choice", "answers": [{"text": "SAVE", "solution": "false"}, {"text": "MODIFY", "solution": "false"}, {"text": "UPDATE", "solution": "true"}, {"text": "SAVE AS", "solution": "false"}]}, {"id": 1723, "category": 9, "difficulty": 1, "text": "Mit welcher SQL-Anweisung l\u00f6scht man Daten aus einer Tabelle, ohne die Tabellendefinition zu l\u00f6schen?", "explanation": "Die DROP-Anweisung l\u00f6scht auch die Tabellendefinitionen, die anderen Anweisungen gibt es unter SQL nicht.", "type": "multiple-choice", "answers": [{"text": "REMOVE", "solution": "false"}, {"text": "DELETE", "solution": "true"}, {"text": "DROP", "solution": "false"}, {"text": "COLLAPSE", "solution": "false"}]}, {"id": 1724, "category": 9, "difficulty": 1, "text": "Mit welcher SQL-Anweisung f\u00fcgt man Daten in eine Tabelle ein?", "explanation": "Eine INSERT-Anweisung hat unter SQL immer ein INTO, die anderen Anweisungen gibt es unter SQL nicht.", "type": "multiple-choice", "answers": [{"text": "INSERT INTO", "solution": "true"}, {"text": "INSERT NEW", "solution": "false"}, {"text": "ADD", "solution": "false"}, {"text": "ADD RECORD", "solution": "false"}]}, {"id": 1725, "category": 9, "difficulty": 1, "text": "Wie liest man alle Daten aus einer Tabelle \"Test\" unter Standard-SQL aus?", "explanation": "SELECT * FROM Test ist korrekt,  die anderen Anweisungen entsprechen nicht dem SQL-Standard.", "type": "multiple-choice", "answers": [{"text": "SELECT Test;", "solution": "false"}, {"text": "SELECT * FROM Test;", "solution": "true"}, {"text": "SELECT ALL FROM Test;", "solution": "false"}]}, {"id": 1997, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat der Natural Join der Tabelle Test mit sich selber?", "explanation": "Der Natural Join einer Tabelle mit sich selber ergibt wieder die Ursprungstabelle.", "type": "multiple-choice", "answers": [{"text": "5", "solution": "true"}, {"text": "25", "solution": "false"}, {"text": "3", "solution": "false"}]}, {"id": 1998, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat das kartesische Produkt der Tabelle Test mit sich selber?", "explanation": "Beim kartesischen Produkt wird jedes Tupel mit der beteiligten Tabellen miteinander verkn\u00fcpft, im Beispiel ergibt das 5 * 5 = 25 Tupel.", "type": "multiple-choice", "answers": [{"text": "5", "solution": "false"}, {"text": "10", "solution": "false"}, {"text": "25", "solution": "true"}]}, {"id": 1957, "category": 9, "difficulty": 2, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr}\n\nAbteilungen hat den Prim\u00e4rschl\u00fcssel Abt_nr und den Fremdschl\u00fcssel Leiter_Ang_Nr.\nAngestellte hat den Prim\u00e4rschl\u00fcssel Ang_nr und den Fremdschl\u00fcssel Abt_Nr.\n\nWelche der folgenden SELECT-Anweisungen liefern das gleiche Ergebnis?", "explanation": "RICHTIG sind: \nDie Anfragen \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ORT = Abteilungen.ORT AND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;\" \nund \n\"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\"\nhaben die gleiche Semantik: \"Welche Mitarbeiter arbeiten im gleichen Ort, in dem sie auch wohnen?\"\n\nOb Fremd-, E\u00edndeutigkeits- oder Prim\u00e4rschl\u00fcssel auf diesen Spalten definiert sind, ist unerheblich f\u00fcr die Ausf\u00fchrung des NATURAL JOINs, dessen Bedingung alle gleich lautenden Spalten auf Gleichheit pr\u00fcft und mit AND verkn\u00fcpft.\n\n\nFALSCH ist: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\".", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;", "solution": "false"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr;", "solution": "true"}, {"text": "SELECT *\nFROM Angestellte NATURAL JOIN Abteilungen;", "solution": "true"}]}, {"id": 1980, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche Abfragen liefern das gleiche Ergebnis, wenn die Tabellen mit Daten gef\u00fcllt sind?", "explanation": "RICHTIG ist: \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr\nAND  Angestellte.Ang_Nr = Abteilungen.Ang_Nr;\" \nweil ein Natural Join, \u00fcber alle Spalten dieser Tabellen, die gleich hei\u00dfen, Abt_Nr, Ang_Nr, auf Gleichheit verglichen werden und die Teilbedingungen mit AND verkn\u00fcpft werden. \noder diese Anfrage: \nSELECT * FROM Angestellte NATURAL JOIN Abteilungen;\n\n\nDie Semantik dieses nat\u00fcrlichen Joins hei\u00dft: \"Welche Mitarbeiter arbeiten in Abteilungen, deren Leiter sie sind?\"\n\n\nFALSCH sind:\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verkn\u00fcpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ort = Abteilungen.Standort AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN, weil \u00fcber zwei Spalten verglichen wird, die nicht gleich hei\u00dfen: \"Angestellte.Ort = Abteilungen.Standort\". \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN, weil nur \u00fcber eine gleich hei\u00dfende Spalte verkn\u00fcpft wird und nicht \u00fcber alle beide.", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.ORT = Abteilungen.STANDORT\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM     Angestellte, Abteilungen\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr\nAND   Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "true"}, {"text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1958, "category": 9, "difficulty": 3, "text": "Worauf muss man bei Gruppierungen in SQL achten?", "explanation": "Die WHERE-Klausel bezieht sich auf einzelne Tupel, daher sind Aggregationsfunktionen nicht zul\u00e4ssig.", "type": "multiple-choice", "answers": [{"text": "Nach allen nicht aggregierten Projektionsattributen der SELECT-Klausel muss gruppiert werden.", "solution": "true"}, {"text": "In der SELECT-Klausel darf nur auf aggregierte Attribute projiziert werden.", "solution": "false"}, {"text": "Die WHERE-Klausel darf keine Aggregationsfunktionen (SUM, AVG, MIN, MAX, COUNT) benutzen.", "solution": "true"}, {"text": "Die Having-Klausel darf keine Aggregationsfunktionen (SUM, AVG, MIN, MAX, COUNT) benutzen.", "solution": "false"}, {"text": "In der WHERE-Klausel d\u00fcrfen nur Gruppierungsattribute auftreten.", "solution": "false"}]}, {"id": 1959, "category": 9, "difficulty": 1, "text": "Wenn in durch AVG aggregierten Attributen NULL-Werte auftreten, dann", "explanation": "Null-Werte werden in Gruppenfunktionen (AVG, SUM, COUNT, MIN und MAX) einfach ignoriert.", "type": "multiple-choice", "answers": [{"text": "wird das ganze Ergebnis zu NULL", "solution": "false"}, {"text": "geht das Tupel mit 0 in die Berechnung ein", "solution": "false"}, {"text": "wird das Tupel in der Berechnung ignoriert", "solution": "true"}, {"text": "wird ein Fehler ausgegeben", "solution": "false"}]}, {"id": 1947, "category": 9, "difficulty": 3, "text": "Mit welchem Operator werden auch auch mehrfach vorkommenden Datens\u00e4tze des gleichen Satzaufbaus vereinigt?", "explanation": "UNION unterdr\u00fcckt mehrfach vorkommende Datens\u00e4tze, bei UNION ALL bleiben sie erhalten.", "type": "text", "answers": [{"text": "Dieser  Operator hei\u00dft:", "solution": "UNION ALL"}]}, {"id": 2394, "category": 9, "difficulty": 3, "text": "Welche Semantik hat die folgende Anfrage?\n\nSELECT m.pers_nr, m.name, m.vorname, a.bez, \n       l.name||l.vorname, v.name||v.vorname \nFROM mitarbeiter_r m, abteilungen_r a, \n       mitarbeiter_r l, mitarbeiter_r v\nWHERE  m.abt_nr       = a.abt_nr \n   AND a.leiter       = l.pers_nr \n   AND m.vorgesetzter = v.pers_nr;", "explanation": "Richtig ist: \nAnzeige der Mitarbeiter (Personalnummer, Name, Vorname), die in Abteilungen arbeiten, mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung; \n\nAufgrund der Join-Verkn\u00fcpfung zwischen den Tabellen, werden hier nur die Angestellten angezeigt, die auch in Abteilungen arbeiten. Wenn es Mitarbeiter gibt, die in keinen Abteilungen arbeiten, so werden sie bei dieser Anfrage nicht angezeigt.", "type": "multiple-choice", "answers": [{"text": "Anzeige der Mitarbeiter (Personalnummer, Name, Vorname), die in Abteilungen arbeiten, mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung;", "solution": "true"}, {"text": "Anzeige aller Mitarbeiter (Personalnummer, Name, Vorname) mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung;", "solution": "false"}, {"text": "Keine dieser Antworten ist richtig.", "solution": "false"}]}, {"id": 3077, "category": 9, "difficulty": 1, "text": "Was versteht man unter Selektivit\u00e4t?", "explanation": "Unter der Selektivit\u00e4t versteht man das Verh\u00e4ltnis der zu findendenden Datens\u00e4tze gegen\u00fcber ihrer Gesamtzahl. Eine hohe Selektivit\u00e4t bedeutet also viele unterschiedliche Werte in einer Spalte.", "type": "multiple-choice", "answers": [{"text": "Verh\u00e4ltnis zu findender Datens\u00e4tze gegen\u00fcber ihrer Gesamtzahl.", "solution": "true"}, {"text": "Differenz aus der Anzahl der Datens\u00e4tze in einer Spalte minus der Gesamtzahl von Spalten in einer Tabelle", "solution": "false"}, {"text": "Produkt aus der Gesamtzahl der gefundenen Datens\u00e4tze dividiert durch die Gesamtzahl der Datens\u00e4tze in einer Spalte", "solution": "false"}]}, {"id": 2784, "category": 9, "difficulty": 1, "text": "Mit welchem Datenbankobjekt kann man eine SELECT-Abfrage beschleunigen?", "explanation": "Indizes werden genau zu dem Zweck in der Datenbank abgelegt, n\u00e4mlich um Abfragen zu beschleunigen.", "type": "multiple-choice", "answers": [{"text": "ROWID", "solution": "false"}, {"text": "VIEW", "solution": "false"}, {"text": "INDEX", "solution": "true"}, {"text": "SEQUENCE", "solution": "false"}]}, {"id": 3084, "category": 9, "difficulty": 1, "text": "Jahr ist eine Spalte vom Typ DATE. Welche der WHERE-Bedingungen ist die kosteng\u00fcnstigeste/schnellste?", "explanation": "Die Konvertierungsfunktionen TO_NUMBER und TO_CHAR sind f\u00fcr die Spalte Jahr programmiert und werden somit in diesem Beispiel f\u00fcr jeden Spaltenwert ausgef\u00fchrt, also f\u00fcr jeden Datensatz. Die TO_DATE-Funktion hingegen ist hier f\u00fcr einen String programmiert und wird daher nur einmal bei der Kompilierung der Anweisung ausgef\u00fchrt. Je mehr Datens\u00e4tze die Tabelle hat, umso mehr Zeit spart die TO_DATE-Funktion mit dem String als Parameter.", "type": "multiple-choice", "answers": [{"text": "WHERE TO_CHAR(Jahr, 'RRRR') BETWEEN '2010' AND '2012'", "solution": "false"}, {"text": "WHERE Jahr BETWEEN TO_DATE('01.01.2010', 'DD.MM.RRRR') AND TO_DATE('31.12.2012', 'DD.MM.RRRR')", "solution": "true"}, {"text": "WHERE TO_NUMBER(Jahr) BETWEEN 2010 AND 2012", "solution": "false"}]}, {"id": 3074, "category": 9, "difficulty": 1, "text": "Wo liegen die gr\u00f6\u00dften Tuning-Potentiale?", "explanation": "Nach einer Studie von Forrester-Research liegt das gr\u00f6\u00dfte Potential im SQL-Tuning,\nsiehe: <a href = \"http://www.dailymotion.com/video/xtpc8a_researching-sql-performance-tuning-tips_school\" target=\"_blank\"> http://www.dailymotion.com/video/xtpc8a_researching-sql-performance-tuning-tips_school", "type": "multiple-choice", "answers": [{"text": "SQL-Tuning, insbesondere von SELECT-Anweisungen", "solution": "true"}, {"text": "Erzeugen von zus\u00e4tzlichen Indizes in der Datenbank", "solution": "false"}, {"text": "\u00c4nderungen an den Parametern der Datenbankinstance", "solution": "false"}, {"text": "Verbesserungen des Netzwerks", "solution": "false"}]}, {"id": 3079, "category": 9, "difficulty": 2, "text": "Welche der folgenden SELECT-Abfragen haben in der Regel eine schlechte Performance und k\u00f6nnen daher getunt werden?", "explanation": "SELECT * muss alle Spalten der Tabelle ermitteln, was zus\u00e4tzliche Zeit kostet. Ein Sortiervorgang bedeutet bei gro\u00dfen Tabellen eine schlechte Performance und muss auch bei DISTINCT erfolgen.", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Tabelle;", "solution": "true"}, {"text": "SELECT t.Spalte FROM Tabelle t;", "solution": "false"}, {"text": "SELECT Spalte FROM Tabelle ORDER BY Spalte;", "solution": "true"}, {"text": "SELECT DISTINCT Spalte FROM Tabelle;", "solution": "true"}]}, {"id": 3086, "category": 9, "difficulty": 1, "text": "Welcher Anfragetyp ist schneller?", "explanation": "Falls die Spaltennamen ohne Tabellennamen angegeben werden, muss das Datenbanksystem zus\u00e4tzlich ermitteln, in welchen Tabellen die Spalten enthalten sind.", "type": "multiple-choice", "answers": [{"text": "Eine SELECT-Anweisung mit vollst\u00e4ndig qualifizierten Spaltennamen, also in der Form Tabellennamen.Spaltennamen", "solution": "true"}, {"text": "Eine SELECT-Anweisung ohne vollst\u00e4ndig qualifizierte Spaltennamen, also in der Form Spaltennamen", "solution": "false"}]}, {"id": 3088, "category": 9, "difficulty": 2, "text": "Welche Datenbankoperationen kosten in der Regel unn\u00f6tige Zeit?", "explanation": "Bei UNION wird zus\u00e4tzlich eine DISTINCT-Operation ausgef\u00fchrt, um Duplikate zu eliminieren, bei UNION ALL ist das nicht der Fall. Funktionsaufrufe wie UPPER() , LOWER() oder andere k\u00f6nnen den \nzugeh\u00f6rigen Index auf einer Spalte nicht nutzen, wenn er nicht ein funktionsbasierter Index ist. Dies ist auch bei Typkonvertierungen der Fall. (siehe \n< a href \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Funktionsbasierter-Index\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Funktionsbasierter-Index ).", "type": "multiple-choice", "answers": [{"text": "Typkonvertierungen", "solution": "true"}, {"text": "Funktionsaufrufe wie UPPER, LOWER, etc", "solution": "true"}, {"text": "UNION", "solution": "true"}, {"text": "UNION ALL", "solution": "false"}]}, {"id": 3092, "category": 9, "difficulty": 2, "text": "Welche Datenbankoperation ist in der Regel schneller?", "explanation": "SELECT COUNT(*) erfordert einen Zugriff auf alle Spalten der Tabelle und ist daher in der Regel langsamer. DISTINCT f\u00fchrt zus\u00e4tzlich eine Sortierung durch.", "type": "multiple-choice", "answers": [{"text": "EXISTS mit\nSELECT c.Country \u000b  FROM Country c \u000b WHERE EXISTS            (SELECT \n1\u000b  FROM Language l \u000b  WHERE c.country = \nl.country);", "solution": "true"}, {"text": "SELECT COUNT(*)...", "solution": "false"}, {"text": "SELECT COUNT(Spaltenname)...", "solution": "true"}, {"text": "DISTINCT mit SELECT DISTINCT Country FROM Language;", "solution": "false"}]}, {"id": 3075, "category": 9, "difficulty": 2, "text": "Welche Datenbank-Situationen k\u00f6nnen eine schlechte Performance mit langen Wartezeiten verursachen?", "explanation": "Bei einer View-Hierarchie muss das Datenbanksystem unter Umst\u00e4nden alle beteiligten Views parsen, was einen erh\u00f6hten Zeitaufwand bedeutet. Kartesische Produkte k\u00f6nnen zu einem sehr gro\u00dfen Datenvolumen f\u00fchren, das von der Festplatte gelesen werden muss. Natural-Join sind in der Regel schnell, da Sie \u00fcber die Prim\u00e4rschl\u00fcssel auf die Tabellen zugreifen.", "type": "multiple-choice", "answers": [{"text": "Die Anfrage bezieht sich auf eine View, die an oberster Stelle in ener View-Hierachie steht.", "solution": "true"}, {"text": "Die SELECT-Anfrage enth\u00e4lt ein kartesisches Produkt.", "solution": "true"}, {"text": "Die SELECT-Anfrage enth\u00e4lt einen Natural-Join.", "solution": "false"}]}, {"id": 3083, "category": 9, "difficulty": 1, "text": "Es gibt eine Tabelle Nation mit den Spalten Nation_id, Name, Flagge und auf der Nation_id ist der Prim\u00e4rschl\u00fcssel definiert. Welcher Befehl ist der kosteng\u00fcnstigste/schnellste?", "explanation": "Da f\u00fcr einen Prim\u00e4rschl\u00fcssel automatisch ein Index definiert wird und die Anfrage auf keine weiteren Spalten zugreift, ist der COUNT \u00fcber die Nation_id die kosteng\u00fcnstigste und schnellste L\u00f6sung. Die Anfrage kann so ausschlie\u00dflich \u00fcber den Index und ohne Zugriff auf die eigentlichen Datens\u00e4tze ausgewertet werden.", "type": "multiple-choice", "answers": [{"text": "SELECT COUNT(*) FROM Nation n;", "solution": "false"}, {"text": "SELECT COUNT(n.Name) FROM Nation n;", "solution": "false"}, {"text": "SELECT COUNT(n.Nation_id) FROM Nation n;", "solution": "true"}]}, {"id": 3073, "category": 9, "difficulty": 1, "text": "Was ist eine Grundanforderung beim SQL-Tuning, auf die man nicht verzichten kann?", "explanation": "Es geht nur um das SQL-Tuning, da bleibt die Datenbankinstance unver\u00e4ndert. Die  Semantik muss dabei erhalten bleiben, die Syntax nicht.", "type": "multiple-choice", "answers": [{"text": "Beibehalten der korrekten Semantik", "solution": "true"}, {"text": "Beibehalten einer unver\u00e4nderten Syntax der SQL-Anweisung", "solution": "false"}, {"text": "\u00c4nderung an den Parametern der Datenbankinstance", "solution": "false"}]}, {"id": 3545, "category": 9, "difficulty": 1, "text": "Bei welchen SQL-Lesezugriffen ist das Sortieren immer notwendig?", "explanation": "Au\u00dfer bei Unterabfragen muss immer sortiert werden, um Duplikate zu erkennen.Das kostet Zeit!", "type": "multiple-choice", "answers": [{"text": "SELECT mit Unterabfrage", "solution": "false"}, {"text": "SELECT mit GROUP BY", "solution": "true"}, {"text": "SELECT mit ORDER BY", "solution": "true"}, {"text": "SELECT mit DISTINCT", "solution": "true"}]}, {"id": 3688, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Tabelle test (Nr number primary key, Beschreibung varchar(100)), die 100.000 Datensatze beinhaltet. Welche Abfrage ist schneller?", "explanation": "Durch den Primary Key wird ein Index angelegt, der durch die like-Abfrage nicht genutzt werden kann.", "type": "multiple-choice", "answers": [{"text": "SELECT * from Test where nr = 4711;", "solution": "true"}, {"text": "SELECT * from TEST where nr like \"4711%\";", "solution": "false"}]}, {"id": 2741, "category": 9, "difficulty": 2, "text": "Ausgehend von der Klassifikation von Stonebraker und Morre sind relationale DBS f\u00fcr welche Art von Anwendungen gut geeignet?\n\nQuelle: \nStonebraker, M., Morre, D.: \"Objektrelationale Datenbanken \u0096 Die n\u00e4chste gro\u00dfe Welle\", Hanser, M\u00fcnchen, 1999", "explanation": "Stonebraker und Morre haben in ihrem Buch \"Objektrelationale Datenbanken \u0096 Die n\u00e4chste gro\u00dfe Welle\" 1999 folgende Klassifikation postuliert, die sich gut bew\u00e4hrt hat. Interessant wird es, wenn es um Anwendungen geht, die mehrere dieser Eigenschaften abdecken. \n\n* Einfache Daten und wenig Anfragen erfordern Dateisysteme\n* Einfache Daten und viele Anfragen erfordern relationale DBMS\n* Komplexe Daten und viele Anfragen erfordern objektrelationale DBMS\n* Komplexe Daten und wenig Anfragen erfordern objektorientierte DBMS\n\nBei objektorientierten Datenbanksystemen bestehen \"Anfragen\" in der Regel aus Spezialoperationen, die mittels Methoden implementiert sind z.B. bei Geo-Informationssystemen: schneiden sich zwei Stra\u00dfen, haben zwei Orte die gleichen H\u00f6henmeter, \u00fcberlagern sich zwei Gesteinsformationen etc. ... \nund kaum aus Mengenanfragen, wie man es aus der relationalen Welt gewohnt ist.\nBei objektrelationalen Datenbanksystemen m\u00f6chte man komplexere Objektstrukturen analog zur Realit\u00e4t abbilden k\u00f6nnen und nicht wie im relationalen Modell Objekte ggf. \u00fcber mehrere Relationen verteilen. Es stehen weiterhin die Mengenanfragen zur Verf\u00fcgung aber auch \u00fcber die Methoden die Programmierung beliebige Spezialoperationen.", "type": "multiple-choice", "answers": [{"text": "einfache Daten und wenige Anfragen", "solution": "false"}, {"text": "einfache Daten und viele Anfragen", "solution": "true"}, {"text": "komplexe Daten und viele Anfragen", "solution": "false"}, {"text": "komplexe Daten und wenig Anfragen", "solution": "false"}]}, {"id": 1603, "category": 9, "difficulty": 2, "text": "Wie k\u00f6nnen Sie den Java Datentyp \"float\" in den meisten relationalen Datenbanken ablegen?", "explanation": "INTEGER hat keine Nachkommastellen.", "type": "multiple-choice", "answers": [{"text": "FLOAT", "solution": "true"}, {"text": "DOUBLE", "solution": "true"}, {"text": "INTEGER", "solution": "false"}]}, {"id": 1328, "category": 9, "difficulty": 2, "text": "Wie k\u00f6nnen Sie den Java Datentyp \"String\" in den meisten relationalen Datenbanken ablegen?", "explanation": "Standardm\u00e4\u00dfig wird der Datentyp varchar benutzt, char kann auch angegeben werden, ist aber nicht der default.", "type": "text", "answers": [{"text": "Das entspricht im SQL-Standard", "solution": "varchar"}]}, {"id": 984, "category": 10, "difficulty": 1, "text": "Ein Trigger kann sich selber oder einen anderen Trigger ansto\u00dfen.", "explanation": "Trigger k\u00f6nnen durch DML-Anweisungen oder eben auch durch Datenbanktrigger ausgel\u00f6st werden, wobei auch rekursive Trigger syntaktisch zugelassen sind. F\u00fcr die Semantik ist dann der Programmierer selber zust\u00e4ndig.", "type": "multiple-choice", "answers": [{"text": "Stimmt", "solution": "true"}, {"text": "Stimmt nicht", "solution": "false"}]}, {"id": 2413, "category": 10, "difficulty": 2, "text": "Ein Oracle-Trigger kann ein COMMIT oder ROLLBACK enthalten", "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten.", "type": "multiple-choice", "answers": [{"text": "keine von beiden", "solution": "false"}, {"text": "stimmt", "solution": "false"}, {"text": "stimmt  nicht", "solution": "true"}]}, {"id": 3579, "category": 10, "difficulty": 1, "text": "Sobald ein Trigger erzeugt und aktiviert wird, werden r\u00fcckwirkend alle in der Datenbank vorhandenen Daten gepr\u00fcft, ob sie dem Trigger  gen\u00fcgen. Falls dies nicht der Fall ist, kann der Trigger nicht erzeugt werden.", "explanation": "Genau das ist der Schutz, den Datenbanksysteme bei Constraints, aber nicht bei Triggerrn bieten. Werden Trigger verwendet, besteht diese Sicherheit nicht. Es werden nur alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 890, "category": 10, "difficulty": 1, "text": "Triggerereignisse k\u00f6nnen sich beziehen auf", "explanation": "Bei SQL sind drei Ereignisse zugelassen, und zwar die Manipulationsanweisungen INSERT, UPDATE, DELETE. Ein Trigger kann nur zu einem einzigen Ereignis bzw, f\u00fcr eine einzigen Tabelle programmiert werden. Die Ereignisse gelten nur f\u00fcr die in der ON Klausel mit \"Tabellenname\" spezifizierten Tabelle. Das UPDATE-Ereignis l\u00e4sst sich f\u00fcr die \u00c4nderung ganz bestimmter Spalten weiter eingrenzen, wobei die Spalten nat\u00fcrlich Spalten der Tabelle aus der ON-Klausel sein m\u00fcssen.", "type": "multiple-choice", "answers": [{"text": "mehrere Tabellen", "solution": "false"}, {"text": "genau eine Tabelle", "solution": "true"}]}, {"id": 1153, "category": 10, "difficulty": 1, "text": "Sobald ein Datenbanktrigger erzeugt und aktiviert wird, werden r\u00fcckwirkend alle in der Datenbank vorhanden Daten gepr\u00fcft, ob sie dem Trigger gen\u00fcgen. Falls dies nicht der Fall ist, kann der Trigger nicht erzeugt werden.", "explanation": "Die Eigenschaft, dass r\u00fcckwirkend die Daten kontrolliert werden, haben nur Constraints. Das f\u00fchrt dazu, dass man keinen Constraint anlegen kann, wenn die bestehenden Daten nicht der in dem Constraint enthaltenen Bedingung gen\u00fcgen. F\u00fcr Trigger ist das nicht der Fall. Um die Kontrolle, die im Trigger enthalten ist, auszuf\u00fchren, muss der Trigger angesto\u00dfen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3687, "category": 11, "difficulty": 1, "text": "Bei welcher Art von Sperren k\u00f6nnen Deadlocks entstehen?", "explanation": "Siehe http://lwibs01.gm.fh-koeln.de/wikis/wiki_db/index.php?n=Datenbanken.DEADLOCK", "type": "multiple-choice", "answers": [{"text": "keine der anderen", "solution": "false"}, {"text": "Lesesperre", "solution": "false"}, {"text": "Schreibsperre", "solution": "true"}]}, {"id": 3550, "category": 11, "difficulty": 1, "text": "Welches Problem kann beim Isolationsgrad SERIALIABLE auftreten?", "explanation": "Der Isolationsgrad SERIALIABLE unterbindet jedes der aufgelisteten Probleme.", "type": "multiple-choice", "answers": [{"text": "Keins von allen", "solution": "true"}, {"text": "PHANTOM", "solution": "false"}, {"text": "LOST UPDATE", "solution": "false"}, {"text": "DIRTY READ", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 3682, "category": 11, "difficulty": 1, "text": "Bei welchem Problem werden nicht freigegebene \u00c4nderungen (ohne commit) \u00fcberschrieben?", "explanation": "Beim LOST UPDATE Problem handelt es sich um das \u00dcberschreiben von ge\u00e4nderten Daten. Bei allen anderen Problemen werden nicht freigegebene \u00c4nderungen in unterschiedlicher Weise verwendet.", "type": "multiple-choice", "answers": [{"text": "PHANTOM", "solution": "false"}, {"text": "LOST UPDATE", "solution": "true"}, {"text": "DIRTY READ", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 2678, "category": 11, "difficulty": 3, "text": "Welche Probleme sind Probleme der Lesekonsistenz?", "explanation": "Lesekonsistenz ist ein weiteres Problem, welches beim Mehrbenutzerbetrieb auftritt. Bei l\u00e4nger andauernden Transaktionen stellt sich die Frage, auf welchem Datenbankzustand die Anfragen eigentlich ausgewertet werden, wenn parallel andere Benutzer die zu lesenden Daten \u00e4ndern.\n\nDaraus resultieren mehrere Probleme: \n\nBei innerhalb einer Transaktion wiederholten Anfragen k\u00f6nnen bei der Wiederholung Datens\u00e4tze angezeigt werden, die vorher nicht da waren, also \"Phantome\", bzw. es werden Datens\u00e4tze nicht mehr angezeigt oder mit ge\u00e4nderten Inhalt, also \"nicht wiederholbares Lesen\".  Grund daf\u00fcr sind jeweils andere Transaktionen, die ihre \u00c4nderungen persistent gespeichert haben (COMMIT).\n\nEin anderes Problem stellt sich bei langandauernden Anfragen, was passiert mit den \u00c4nderungen parallel ausgef\u00fchrter Transaktionen, die zwischenzeitlich ihre \u00c4nderungen persistent gespeichert haben. (COMMIT).\n\n\"Dirty Read\" ist ein Problem, das beiden Aufgabenstellungen, Nebenl\u00e4ufigkeitskontrolle wie auch Lesekonsistenz betrifft.\n\n\"Lost Update\" ist ein Problem der Nebenl\u00e4ufigkeitskontrolle weniger der Lesekonsistenz.", "type": "multiple-choice", "answers": [{"text": "LOST UPDATE", "solution": "false"}, {"text": "DIRTY READ", "solution": "true"}, {"text": "PHANTOM", "solution": "true"}, {"text": "NON REPEATABLE READ", "solution": "true"}]}, {"id": 2673, "category": 11, "difficulty": 1, "text": "Bei welchem Pr\u00fcfungszeitpunkt (= CONSTRAINT_CHARACTERISTICA ) wird die Datenpr\u00fcfung sofort nach einer Daten\u00e4nderung (INSERT, UPDATE, DELETE) durchgef\u00fchrt?", "explanation": "Werden Daten\u00e4nderungen ausgef\u00fchrt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integrit\u00e4tsbedingung gepr\u00fcft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung r\u00fcckg\u00e4ngig gemacht. Die \u00fcbrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl l\u00f6st das Transaktionsende aus und damit die Pr\u00fcfung aller CONSTRAINTs (Integrit\u00e4tsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden w\u00e4hrend einer Transaktion erst mal akzeptiert und er zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs gepr\u00fcft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, f\u00fchrt dies zur Anzeige einer Fehlermeldung und zum Zur\u00fcckrollen der gesamten Transaktion.", "type": "multiple-choice", "answers": [{"text": "INITIALLY IMMEDIATE", "solution": "true"}, {"text": "INITIALLY DEFERRED", "solution": "false"}]}, {"id": 2677, "category": 11, "difficulty": 2, "text": "Wie nennt man das folgende Problem:\nW\u00e4hrend einer Transaktion A wird eine Anfrage mehrmals gestellt und zwischenzeitlich werden durch andere Transaktionen Datens\u00e4tze gel\u00f6scht bzw. ihre Werte ge\u00e4ndert.", "explanation": "LOST UPDATE (verlorene \u00c4nderungen) ist das Problem, das auf dem \u00dcberschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgef\u00fchrter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn \u00c4nderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zu\u00fcckgerollt werden (ROLLBACK, Integrit\u00e4tsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgef\u00fchrte Transaktionen die Daten zwischenzeitlich ge\u00e4ndert bzw. gel\u00f6scht haben (NON REPEATABLE READ) oder neue Datens\u00e4tze eingef\u00fcgt wurden (PHANTOME).", "type": "multiple-choice", "answers": [{"text": "DIRTY READ", "solution": "false"}, {"text": "PHANTOM", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "true"}, {"text": "LOST UPDATE", "solution": "false"}]}, {"id": 2676, "category": 11, "difficulty": 3, "text": "Wie nennt man das folgende Problem:\nW\u00e4hrend einer Transaktion A wird eine Anfrage mehrmals gestellt und zwischenzeitlich werden durch andere Transaktionen neue Datens\u00e4tze eingef\u00fcgt.", "explanation": "LOST UPDATE (verlorene \u00c4nderungen) ist das Problem, das auf dem \u00dcberschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgef\u00fchrter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn \u00c4nderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zu\u00fcckgerollt werden (ROLLBACK, Integrit\u00e4tsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgef\u00fchrte Transaktionen die Daten zwischenzeitlich ge\u00e4ndert bzw. gel\u00f6scht haben (NON REPEATABLE READ) oder neue Datens\u00e4tze eingef\u00fcgt wurden (PHANTOME).", "type": "multiple-choice", "answers": [{"text": "DIRTY READ", "solution": "false"}, {"text": "PHANTOM", "solution": "true"}, {"text": "NON REPEATABLE READ", "solution": "false"}, {"text": "LOST UPDATE", "solution": "false"}]}, {"id": 2674, "category": 11, "difficulty": 1, "text": "Welcher Pr\u00fcfungszeitpunkt (CONSTRAINT_CHARACTERISTICA) f\u00fchrt dazu, dass beim Erkennen eines Fehlers nur die fehlerhafte DML-Anweisung zur\u00fcckgesetzt wird und die \u00fcbrigen Datens\u00e4tze der laufenden Transaktion nicht betroffen sind?", "explanation": "Werden Daten\u00e4nderungen ausgef\u00fchrt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integrit\u00e4tsbedingung gepr\u00fcft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung r\u00fcckg\u00e4ngig gemacht. Die \u00fcbrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl l\u00f6st das Transaktionsende aus und damit die Pr\u00fcfung aller CONSTRAINTs (Integrit\u00e4tsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \n\nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden w\u00e4hrend einer Transaktion erst mal akzeptiert und er zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs gepr\u00fcft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, f\u00fchrt dies zur Anzeige einer Fehlermeldung und zum Zur\u00fcckrollen der gesamten Transaktion.", "type": "multiple-choice", "answers": [{"text": "INITIALLY DEFERRED", "solution": "false"}, {"text": "INITIALLY IMMEDIATE", "solution": "true"}]}, {"id": 3684, "category": 11, "difficulty": 1, "text": "Welche Aussagen \u00fcber Sperren in SQL sind wahr?", "explanation": "Lesesperren (read lock, shared lock oder SLOCK) auf Objekt und Schreibsperren (write lock, exclusive lock oder XLOCK)\n\n    geh\u00f6ren zum SQL-Standard. Lesesperren k\u00f6nen mehrfach auf eine Objekt ausgef\u00fchrt werden, Schreibsperren nicht.", "type": "multiple-choice", "answers": [{"text": "Mehrere Lesesperren auf dem gleichen Objekt x sind erlaubt.", "solution": "true"}, {"text": "Mehrere Schreibsperren auf dem gleichen Objekt x  sind erlaubt.", "solution": "false"}]}, {"id": 3683, "category": 11, "difficulty": 1, "text": "Welche Arten von Sperren gibt es in SQL?", "explanation": "Lesesperren (read lock, shared lock oder SLOCK) auf Objekt und Schreibsperren (write lock, exclusive lock oder XLOCK)\n\n    geh\u00f6ren zum SQL-Standard.", "type": "multiple-choice", "answers": [{"text": "Lesesperre", "solution": "true"}, {"text": "Schreibsperre", "solution": "true"}, {"text": "COMMIT-Sperre", "solution": "false"}, {"text": "ROLLBACK-Sperre", "solution": "false"}, {"text": "Transaktionssperre", "solution": "false"}]}, {"id": 1715, "category": 11, "difficulty": 3, "text": "Welche Sperren k\u00f6nnen beim 2-Phasen-Sperrprotokoll gesetzt werden?", "explanation": "LOCK ist eine sehr undifferenzierte Sperre, die wenig Parallelit\u00e4t zul\u00e4\u00dft, daher wird sie nicht verwendet. \nVerwendet werden: \nREAD_LOCK hingegen l\u00e4\u00dft paralleles Lesen zu und WRITE_LOCK sorgt f\u00fcr das exclusive Sperren bei Daten\u00e4nderungen/-einf\u00fcgungen. \nUNLOCK gibt die gesetzten Sperren wieder frei.", "type": "multiple-choice", "answers": [{"text": "read_lock", "solution": "true"}, {"text": "write_lock", "solution": "true"}, {"text": "lock", "solution": "false"}, {"text": "unlock", "solution": "true"}]}, {"id": 1716, "category": 11, "difficulty": 2, "text": "Wie viele Sperrzust\u00e4nde werden beim 2-Phasen-Sperrprotokoll verwendet?", "explanation": "Nur die beiden Zust\u00e4nde LOCK und UNLOCK sind sehr \"grob\" und lassen wenig parallen Zugriff zu, da nicht zwischen \"schreiben\" und \"lesen\" differenziert wird. \nDaher wird mit drei Sperrzust\u00e4nden gearbeitet: \nUNLOCK - entsperrt\nWRITELOCK - exklusiv sperren f\u00fcr einen Schreibzugriff\nREADLOCK - sperren f\u00fcr parallele Lesezugriffe", "type": "multiple-choice", "answers": [{"text": "1", "solution": "false"}, {"text": "2", "solution": "false"}, {"text": "3", "solution": "true"}, {"text": "4", "solution": "false"}]}, {"id": 1714, "category": 11, "difficulty": 1, "text": "Eine Transaktion unter SQL ist", "explanation": "Eine SQL-Transaktion ist eine Folge von \u00c4nderungsanweisungen, die aus einer oder mehreren SQL-DML- und DQL-Anweisungen (INSERT, UPDATE, DELETE, SELECT) besteht und \u00fcber die ACID-Eigenschaften verf\u00fcgt. Die Reihenfolge ergibt sich aus dem zeitlichen Ablauf der Ausf\u00fchrung der DML-Anweisungen. \n\nIn der Wissenschaft wird eine Transaktion oft auch als Menge von \u00c4nderungsanweisungen definiert, woraus sich zus\u00e4tziche interessante Aspekte erforschen lassen ;-)", "type": "multiple-choice", "answers": [{"text": "eine Folge von \u00c4nderungen", "solution": "true"}, {"text": "eine Menge von \u00c4nderungen", "solution": "false"}]}, {"id": 1694, "category": 11, "difficulty": 2, "text": "Welche Aussagen \u00fcber \"Transaktionen und Integrit\u00e4tspr\u00fcfung in SQL\" sind richtig?", "explanation": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integrit\u00e4tspr\u00fcfung erkannt, so wird NICHT die gesamte Transaktion zur\u00fcckgerollt, sondern nur die fehlerhafte Datenmanipulation.\n\nWird vom DBMS ein Fehler bei der DEFERRED-Integrit\u00e4tspr\u00fcfung erkannt, so wird die gesamte Transaktion zur\u00fcckgerollt, denn die DEFERRED-Bedingungen werden ja erst zum Transaktionsende gepr\u00fcft.\n\nIMMEDIATE bezeichnet die Integrit\u00e4tspr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung des DML-Befehls und DEFERRED erst zum Transaktionsende. \n\nIn SQL gibt es f\u00fcnf CONSTRAINTs mittels denen die Datenintegrit\u00e4t gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.", "type": "multiple-choice", "answers": [{"text": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integrit\u00e4tspr\u00fcfung erkannt, so wird die gesamte Transaktion zur\u00fcckgerollt.", "solution": "false"}, {"text": "Wird vom DBMS ein Fehler bei der DEFERRED-Integrit\u00e4tspr\u00fcfung erkannt, so wird nur der fehlerhafte DML-Befehl zur\u00fcckgerollt.", "solution": "false"}, {"text": "IMMEDIATE bezeichnet die Integrit\u00e4tspr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung des DML-Befehls und DEFERRED erst zum Transaktionsende.", "solution": "true"}, {"text": "In SQL gibt es f\u00fcnf CONSTRAINTs mittels denen die Datenintegrit\u00e4t gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.", "solution": "true"}]}, {"id": 1058, "category": 11, "difficulty": 2, "text": "Mit welchem Befehl kann man in SQL eine Transaktion beenden?", "explanation": "RICHTIG sind:\nCOMMIT f\u00fcr das persistente Abspeichern der Datenmanipulationen der Transaktion nach erfolgreicher DEFERRED-Integrit\u00e4tspr\u00fcfung. \n\nROLLBACK f\u00fcr das Zur\u00fcckrollen der Datenmanipulationen der Transaktion (R\u00fcckg\u00e4ngigmachen). \n\nFALSCH sind: \nEOT und END_OF_TRANSACTION: Es gibt zwar einen Begin of Transaktion-Befehl (START TRANSACTION) und es gibt ein implizites Begin of Transaktion-Ereignis, wenn dieser Befehl nicht abgesetzt wird: das letzte ausgef\u00fchrte COMMIT, aber ein EOT etc. gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "COMMIT", "solution": "true"}, {"text": "EOT", "solution": "false"}, {"text": "END_OF_TRANSACTION", "solution": "false"}, {"text": "ROLLBACK", "solution": "true"}]}, {"id": 1056, "category": 11, "difficulty": 3, "text": "Welche Aussagen \u00fcber \"Transaktionen in SQL\" sind richtig?", "explanation": "FALSCH sind:  \n\"Im SQL-Standard sind keine \"dirty reads\" m\u00f6glich.\" Dirty reads sind bei Oracle grunds\u00e4tzlich ausgeschlossen, so dass es dort, anders als beim SQL-Standard, den Isolationsgrad READ UNCOMMITTED nicht gibt.\n\n\"F\u00fchrt eine Transaktion eine Anfrage mehrfach aus, so k\u00f6nnen u.a. \"lost updates\", \"non repeatable reads\" und \"phantome\" auftreten.\" Diese Aussage ist hinsichtlich \"non repeatable reads\" und \"phantome\" richtig, nur f\u00fcr \"lost updates\" falsch. \"lost updates\" sind keine Probleme der Lesekonsistenz wie die anderen beiden, sie sind Probleme der Nebenl\u00e4ufigkeitskontrolle. \n\nRICHTIG sind: \n\"Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und \u00fcberschreibt somit die \u00c4nderungen von T2 ungesehen.\"\n\n\"Ein Ausf\u00fchrungsplan ist serialisierbar, wenn er zu einem seriellen Ausf\u00fchrungsplan \u00e4quivalent ist.\"", "type": "multiple-choice", "answers": [{"text": "Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und \u00fcberschreibt somit die \u00c4nderungen von T2 ungesehen.", "solution": "true"}, {"text": "Ein Ausf\u00fchrungsplan ist serialisierbar, wenn er zu einem seriellen Ausf\u00fchrungsplan \u00e4quivalent ist.", "solution": "true"}, {"text": "Im SQL-Standard sind keine \"dirty reads\" m\u00f6glich.", "solution": "false"}, {"text": "F\u00fchrt eine Transaktion eine Anfrage mehrfach aus, so k\u00f6nnen u.a. \"lost updates\", \"non repeatable reads\" und \"phantome\" auftreten.", "solution": "false"}]}, {"id": 1299, "category": 11, "difficulty": 2, "text": "Wie viele Sperrzust\u00e4nde kennt das 2-Phasen-Sperrprotokoll?", "explanation": "Nur die beiden Zust\u00e4nde LOCK und UNLOCK sind sehr \"grob\" und lassen wenig parallelen Zugriff zu, da nicht zwischen \"schreiben\" und \"lesen\" differenziert wird. \nDaher wird mit drei Sperrzust\u00e4nden gearbeitet: \nUNLOCK - entsperrt\nWRITELOCK - exklusiv sperren f\u00fcr einen Schreibzugriff\nREADLOCK - sperren f\u00fcr parallele Lesezugriffe", "type": "multiple-choice", "answers": [{"text": "einen Zustand", "solution": "false"}, {"text": "zwei Zust\u00e4nde", "solution": "false"}, {"text": "drei Zust\u00e4nde", "solution": "true"}]}, {"id": 1386, "category": 11, "difficulty": 2, "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Szenarium verletzt?\n\nEine Transaktion A \u00e4ndert zwei S\u00e4tze S1 und S2. Beim Systemabsturz wird die Aktion S2 zur\u00fcckgerollt, w\u00e4hrend S1 weiterhin in ge\u00e4nderter Form vorliegt.", "explanation": "Es ist die \"Atomarit\u00e4t\" verletzt. \nDie Atomarit\u00e4t besagt, dass entweder alle Manipulationen einer Transaktion persistent in der DB gespeichert werden - oder gar nicht. Hier wird nur eine Teilmenge der Aktionen in der DB ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "Atomarit\u00e4t", "solution": "true"}, {"text": "Isolation", "solution": "false"}, {"text": "Konsistenz", "solution": "false"}, {"text": "Dauerhaftigkeit", "solution": "false"}]}, {"id": 563, "category": 11, "difficulty": 3, "text": "Welcher Lock-Typ erlaubt anderen Benutzern nicht, weitere Sperren auf eine Tabelle zu setzen, die mit diesem Lock-Typ gesperrt wurden?", "explanation": "1. Typ: XLOCKS oder EXKLUSIVE LOCKS\nEin XLOCK bewirkt, dass keine andere Transaktion eine Sperrung auf ein Objekt, das schon einen XLOCK hat, absetzen kann. Der XLOCK wird bis zum Ende der Transaktion gehalten.\n\n2.Typ: SHARED LOCKS oder SLOCKS (geteilte LOCKS )\nFalls eine Transaktion T1 einen SLOCK auf eine Tabelle h\u00e4lt, hei\u00dft das, dass sie nur lesend zugreifen wird. Eine andere Transaktion T2 kann parallel auch einen SLOCK absetzen, wenn nur Lesezugriffe beabsichtigt sind. Allerdings kann eine Transaktion T3 keinen XLOCK auf die betroffene Tabelle absetzen, bis alle SLOCKS wieder gel\u00f6scht sind.", "type": "multiple-choice", "answers": [{"text": "SLOCK", "solution": "false"}, {"text": "XLOCK", "solution": "true"}, {"text": "EXCLUSIVE LOCK", "solution": "true"}]}, {"id": 906, "category": 11, "difficulty": 1, "text": "Bei welchem Pr\u00fcfungszeitpunkt (= CONSTRAINT_CHARACTERISTICA ) wird die Datenpr\u00fcfung zum Transaktionsende durchgef\u00fchrt?", "explanation": "Werden Daten\u00e4nderungen ausgef\u00fchrt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integrit\u00e4tsbedingung gepr\u00fcft.  \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung r\u00fcckg\u00e4ngig gemacht. Die \u00fcbrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl l\u00f6st das Transaktionsende aus und damit die Pr\u00fcfung aller CONSTRAINTs (Integrit\u00e4tsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden.  \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden w\u00e4hrend f\u00fcr eine Transaktion erst mal akzeptiert und erst zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs gepr\u00fcft und die Fehler erkannt.  \nWenn ein DEFERRED-Fehler auftritt, f\u00fchrt dies zur Anzeige einer Fehlermeldung und zum Zur\u00fcckrollen der gesamten Transaktion.", "type": "multiple-choice", "answers": [{"text": "INITIALLY IMMEDIATE", "solution": "false"}, {"text": "INITIALLY DEFERRED", "solution": "true"}]}, {"id": 958, "category": 11, "difficulty": 2, "text": "Wie nennt man das folgende Problem:\nZuerst liest A das Objekt X, dann B. Anschlie\u00dfend schreibt erst A seinen neuen Wert f\u00fcr zur\u00fcck, anschlie\u00dfend B. In der Datenbasis wurde mit dem neuen Wert von B der neue Wert von A \u00fcberschrieben, ohne dass B diesen Wert gesehen hat.", "explanation": "LOST UPDATE (verlorene \u00c4nderungen) ist das Problem, das auf dem \u00dcberschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgef\u00fchrter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn \u00c4nderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zu\u00fcckgerollt werden (ROLLBACK, Integrit\u00e4tsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgef\u00fchrte Transaktionen die Daten zwischenzeitlich ge\u00e4ndert bzw. gel\u00f6scht haben (NON REPEATABLE READ) oder neue Datens\u00e4tze eingef\u00fcgt wurden (PHANTOME).", "type": "multiple-choice", "answers": [{"text": "LOST UPDATE", "solution": "true"}, {"text": "DIRTY READ", "solution": "false"}, {"text": "PHANTOM", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 957, "category": 11, "difficulty": 2, "text": "Wie nennt man das folgende Problem:\nA liest und \u00e4ndert Objekt X und \u00e4ndert dann noch weitere Objekte. B liest nach der \u00c4nderung von A den neuen Wert von Objekt X und \u00e4ndert diesen wiederum. Anschlie\u00dfend wird die Transaktion A zur\u00fcckgerollt, womit auch die \u00c4nderungen an Objekt X r\u00fcckg\u00e4ngig gemacht werden. Aber B hat bereits den ge\u00e4nderten Wert weiter verarbeitet, obwohl er noch nicht dauerhaft g\u00fcltig war.", "explanation": "LOST UPDATE (verlorene \u00c4nderungen) ist das Problem, das auf dem \u00dcberschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgef\u00fchrter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn \u00c4nderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zu\u00fcckgerollt werden (ROLLBACK, Integrit\u00e4tsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgef\u00fchrte Transaktionen die Daten zwischenzeitlich ge\u00e4ndert bzw. gel\u00f6scht haben (NON REPEATABLE READ) oder neue Datens\u00e4tze eingef\u00fcgt wurden (PHANTOME).", "type": "multiple-choice", "answers": [{"text": "LOST UPDATE", "solution": "false"}, {"text": "DIRTY READ", "solution": "true"}, {"text": "PHANTOM", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 959, "category": 11, "difficulty": 2, "text": "Wie nennt man das folgende Problem:\nEine Verklemmung entsteht, wenn eine Transaktion A ein Objekt X gesperrt h\u00e4lt und im weiteren Verlauf ein Objekt Y sperren m\u00f6chte. Zudem h\u00e4lt eine Transaktion B das Objekt Y gesperrt und will sp\u00e4ter noch Objekt X sperren. Somit warten beide Transaktionen jeweils auf das Objekt, das die andere Transaktion gesperrt h\u00e4lt. Eine Freigabe durch eine der beiden Transaktionen ist ohne Eingriff von Au\u00dfen nicht m\u00f6glich.", "explanation": "Da bei Transaktionen die beteiligten Relationen im Vorfeld nicht bekannt sind, tritt das Problem der Verklemmung (Deadlock) durchaus schon mal auf und ist wie oben definiert.", "type": "text", "answers": [{"text": "Das ist ein", "solution": "DEADLOCK"}]}, {"id": 1742, "category": 11, "difficulty": 2, "text": "Welche Aussagen \u00fcber \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?", "explanation": "RICHTIG ist: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.\"\n\nFALSCH ist: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion keine SLOCKs auf das gesperrte Objekt absetzen.\"\nEs ist ja gerade Sinn und Zweck der SLOCKs parallleles Lesen zuzulassen und daher sind mehrere SLOCKs auf einer Tabelle m\u00f6glich. \nXLOCKS hingegen k\u00f6nnen erst wieder gesetzt werden, wenn keine SLOCKs mehr vorliegen und auch keine anderen XLOCKs.", "type": "multiple-choice", "answers": [{"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.", "solution": "true"}, {"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion keine SLOCKs auf das gesperrte Objekt absetzen.", "solution": "false"}]}, {"id": 918, "category": 11, "difficulty": 1, "text": "Welcher Pr\u00fcfungszeitpunkt (CONSTRAINT_CHARACTERISTICA) f\u00fchrt dazu, dass beim Erkennen eines Fehlers die gesamte Transaktion zur\u00fcckgerollt wird (Fehlerreaktion entspricht der ROLLBACK-Anweisung)?", "explanation": "Werden Daten\u00e4nderungen ausgef\u00fchrt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integrit\u00e4tsbedingung gepr\u00fcft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung r\u00fcckg\u00e4ngig gemacht. Die \u00fcbrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen.\n\n\nDer COMMIT-Befehl l\u00f6st das Transaktionsende aus und damit die Pr\u00fcfung aller CONSTRAINTs (Integrit\u00e4tsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden w\u00e4hrend einer Transaktion erst mal akzeptiert und erst zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs gepr\u00fcft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, f\u00fchrt dies zur Anzeige einer Fehlermeldung und zum Zur\u00fcckrollen der gesamten Transaktion.", "type": "multiple-choice", "answers": [{"text": "INITIALLY DEFERRED", "solution": "true"}, {"text": "INITIALLY IMMEDIATE", "solution": "false"}]}, {"id": 1245, "category": 11, "difficulty": 3, "text": "Wie hei\u00dft ein Ausf\u00fchrungsplan, der zu einem seriellen Ausf\u00fchrungsplan \u00e4quivalent ist?", "explanation": "Ein Ausf\u00fchrungsplan definiert eine (partielle) Reihenfolge der Operationen von verschiedenen Transaktionen.\n\nZwei Ausf\u00fchrungspl\u00e4ne hei\u00dfen \u00e4quivalent, wenn die Ergebnisse ihrer Operationen in der Datenbasis gleich sind.\n\nBei einem seriellen Ausf\u00fchrungsplan wird jede Transaktion vollst\u00e4ndig hintereinander ausgef\u00fchrt.\n\nEin serialisierbarer Ausf\u00fchrungsplan ist ein geschachtelter Ausf\u00fchrungsplan, der zu einem seriellen Ausf\u00fchrungsplan \u00e4quivalent ist.", "type": "text", "answers": [{"text": "Das ist ein _____ Ausf\u00fchrungsplan.", "solution": "serialisierbarer"}]}, {"id": 925, "category": 11, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber Lese/Schreibsperren ist wahr?", "explanation": "Grundidee des Zwei-Phasen-Sperr-Protokolls ist das Sperren von Daten, auf die von verschiedenen Transaktionen gleichzeitig zugegriffen wird. Das einfache \"bin\u00e4re\" Sperren mit den beiden Zust\u00e4nden \"gesperrt\" (lock) und \"entsperrt\" (unlock) ist dabei zu grob. Es l\u00e4sst zu wenig paralleles Arbeiten zu. Da dabei nicht zwischen der Art des Zugriffs unterschieden wird, kann sogar nicht mehr als ein Anwender lesend zugreifen, obwohl gem\u00e4\u00df obiger Konfliktdefinition paralleles Lesen ja ungef\u00e4hrlich ist. Stattdessen wird eine verfeinerte Sperrtechnik mit drei Sperrzust\u00e4nden verwendet, die die\nArt des Zugriffs ber\u00fccksichtigt: \n\n1. lesend gesperrt (read_lock)\n2. schreibend gesperrt (write_lock)\n3. entsperrt (unlock)", "type": "multiple-choice", "answers": [{"text": "Ein Objekt wird exklusiv von einer Schreib-Transaktion gesperrt.", "solution": "true"}, {"text": "Ein Objekt kann von mehreren Lese-Transaktionen gleichzeitig gesperrt werden.", "solution": "true"}, {"text": "Ein Objekt wird exklusiv von einer Lese-Transaktion gesperrt.", "solution": "false"}, {"text": "Ein Objekt kann von mehreren Schreib-Transaktionen gleichzeitig gesperrt werden.", "solution": "false"}]}, {"id": 2094, "category": 1, "difficulty": 1, "text": "Was versteht man unter der Abk\u00fcrzung DDL?", "explanation": "DDL (Data Definition Language):\n\nDie DDL stellt Sprachelemente zur Verf\u00fcgung, mit denen die Datenbankobjekte definiert, modifiziert und gel\u00f6scht werden. Einsatzgebiet ist die konzeptionelle Ebene im ANSI-3-Ebenen-Modell.", "type": "text", "answers": [{"text": "Man versteht darunter:", "solution": "Data Definition Language"}]}, {"id": 2095, "category": 1, "difficulty": 1, "text": "Was versteht man unter der Abk\u00fcrzung DML?", "explanation": "DML (Data Manipulation Language):\nDie DML stellt Sprachelemente zum Anlegen, \u00c4ndern und L\u00f6schen von Daten zur Verf\u00fcgung. Einsatzgebiet ist die externe Ebene im ANSI-3-Ebenen-Modell.", "type": "text", "answers": [{"text": "Man versteht darunter:", "solution": "Data Manipulation Language"}]}, {"id": 634, "category": 4, "difficulty": 2, "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung wird ein ER-Modell erstellt?", "explanation": "In der Analysephase werden die Systemfunktionen und Daten in groben Z\u00fcgen geplant und festgelegt. Es wird eine explizite Systemdefinition in Form eines Lastenhefts vorgenommen. Dies geschieht umgangssprachlich in einer auch f\u00fcr Laien lesbaren Form. Au\u00dferdem werden die Daten mit Mitteln der Softwaretechnik, hier mit dem Entity-Relationship-Modell (kurz: ERM oder ER-Modell), genau beschrieben. Das ERM entspricht dem konzeptionellen Modell aus dem ANSI-3-Ebenen-Modell.", "type": "multiple-choice", "answers": [{"text": "Implementierungsphase", "solution": "false"}, {"text": "Analysephase", "solution": "true"}, {"text": "Entwurfsphase", "solution": "false"}]}, {"id": 635, "category": 4, "difficulty": 1, "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung wird das ER-Modell auf ein relationales Datenbankschema abgebildet?", "explanation": "In der Entwurfsphase wird das konzeptionelle Schema auf ein relationales Datenbankschema abgebildet und eine Normalisierung durchgef\u00fchrt. Au\u00dferdem wird bei einer geplanten Anwendungsentwicklung \nein objektorientiertes Klassenmodell erstellt, das die f\u00fcr die Datensicht erforderlichen Methoden und Funktionen enth\u00e4lt.", "type": "multiple-choice", "answers": [{"text": "Analysephase", "solution": "false"}, {"text": "Entwurfsphase", "solution": "true"}, {"text": "Implementierungsphase", "solution": "false"}]}, {"id": 2454, "category": 5, "difficulty": 3, "text": "Bei welchen Beziehungen tauchen Fremdschl\u00fcsselattribute in den Entity-Mengen des ERDs auf, die an der Beziehung beteiligt sind?", "explanation": "Bei n-m-Beziehungen entstehen die Fremdschl\u00fcsselattribute beim Aufl\u00f6sen in einer neuen Entity-Menge, nicht in den urspr\u00fcnglicheen Entity-Mengen.", "type": "multiple-choice", "answers": [{"text": "1:1-Beziehungen", "solution": "true"}, {"text": "1:n-Beziehungen", "solution": "true"}, {"text": "m:n-Beziehungen", "solution": "false"}]}, {"id": 654, "category": 5, "difficulty": 1, "text": "Wann hei\u00dft eine 1:n-Beziehung identifizierend?", "explanation": "Bei identifizierenden Beziehungen wird in der Detail-Entitymenge der Fremdschl\u00fcssel zum Prim\u00e4rschl\u00fcssel hinzugenommen, bei nicht identifizierenden Beziehungen wird der Fremdschl\u00fcssel nur als Attribut eingetragen, welches nicht zum Prim\u00e4rschl\u00fcssel der Relation geh\u00f6rt.", "type": "multiple-choice", "answers": [{"text": "Die Prim\u00e4rschl\u00fcsselattribute der Detail-Entity-Menge treten als Bestandteile des Prim\u00e4rschl\u00fcssels bei der Master-Entity-Menge auf.", "solution": "false"}, {"text": "Die Prim\u00e4rschl\u00fcsselattribute der Master-Entity-Menge treten als Bestandteile des Prim\u00e4rschl\u00fcssels bei der Detail-Entity-Menge auf.", "solution": "true"}, {"text": "Die Prim\u00e4rschl\u00fcsselattribute der Master-Entity-Menge treten als Fremdschl\u00fcssel-Attribute bei der Detail-Entity-Menge auf und sind aber kein Bestandteil des Prim\u00e4rschl\u00fcssels.", "solution": "false"}]}, {"id": 2008, "category": 5, "difficulty": 1, "text": "Tern\u00e4re Beziehungen lassen sich immer in bin\u00e4re Beziehungen aufl\u00f6sen, ohne eine Entity-Menge hinzuzuf\u00fcgen.", "explanation": "Um tern\u00e4re Beziehungen in bin\u00e4re Beziehungen aufzul\u00f6sen, braucht man eine zus\u00e4tzliche Entity-Menge.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2011, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber das EERM sind wahr?", "explanation": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen erg\u00e4nzt werden k\u00f6nnen. \nEin weiterer wichtiger Beziehungstyp ist die Aggregation, die die \"Ist Teil von\" Beziehung beschreibt. Mithilfe dieses Beziehungstyps lassen sich komplexe Objekte modellieren. Beispielsweise ist es m\u00f6glich, in der ER-Modellierung von Byce & Co. auf die Struktur-Entity-Menge zu verzichten und stattdessen die Bestandteile eines Fahrrads explizit aufzulisten. \nUnter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp, und unter einer Generalisierung den genau umgekehrten Prozess, die Gewinnung eines Supertypen aus gegebenen Subtypen. \nEin System von Subtypen und Supertypen nennt man vollst\u00e4ndig, wenn der Supertyp keine eigenen Elemente enth\u00e4lt, also jedes Element in einem der Subtypen enthalten ist.", "type": "multiple-choice", "answers": [{"text": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen erg\u00e4nzt werden k\u00f6nnen.", "solution": "true"}, {"text": "Eine Aggregation ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen erg\u00e4nzt werden k\u00f6nnen.", "solution": "false"}, {"text": "Unter einer Generalisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.", "solution": "false"}, {"text": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.", "solution": "true"}, {"text": "Ein System von Subtypen und Supertypen hei\u00dft vollst\u00e4ndig, wenn die einzelnen Subtypen keine gemeinsamen Elemente haben.", "solution": "false"}, {"text": "Ein System von Subtypen und Supertypen nennt man vollst\u00e4ndig, wenn der Supertyp keine eigenen Elemente enth\u00e4lt, also jedes Element in einem der Subtypen enthalten ist.", "solution": "true"}]}, {"id": 2468, "category": 5, "difficulty": 1, "text": "Eine m:n-Beziehung im ERD (ohne beteiligte Entity-Mengen) wird beim \u00dcbergang zum DB-Schema in wie viele der folgenden Objekte \u00fcberf\u00fchrt?", "explanation": "Eine n-m-Beziehung wird bei diesem \u00dcbergang in einer Relation und zwei 1:n-Beziehungen aufgel\u00f6st, die durch Fremdschl\u00fcssel dargestellt  werden.", "type": "multiple-choice", "answers": [{"text": "Eine 1:1-Beziehung und zwei Relationen", "solution": "false"}, {"text": "Zwei 1:1-Beziehungen und eine Relation", "solution": "false"}, {"text": "Zwei 1:n-Beziehungen und eine Relation", "solution": "true"}, {"text": "Zwei 1:n-Beziehungen", "solution": "false"}]}, {"id": 2469, "category": 5, "difficulty": 2, "text": "Folgende Aussagen \u00fcber Subtypen sind wahr:", "explanation": "Bei Subtypen werden identifizierende Beziehungen verwendet, da Supertyp und Subtyp den gleichen  Prim\u00e4rschl\u00fcssel haben", "type": "multiple-choice", "answers": [{"text": "Identifizierende Beziehungen k\u00f6nnen verwendet werden.", "solution": "true"}, {"text": "Nicht-identifizierende Beziehungen k\u00f6nnen verwendet werden.", "solution": "false"}, {"text": "Identifizierende und nicht-identifizierende Beziehungen k\u00f6nnen verwendet werden.", "solution": "false"}, {"text": "Es gibt Entity-Mengen, die aufgrund von 1:n-Beziehungen Fremdschl\u00fcssel besitzen, die aus mehreren Spalten bestehen.", "solution": "false"}]}, {"id": 2799, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber eine IS-A-Beziehung sind richtig?", "explanation": "Eine \"IS-A-Beziehung\" ist eine Beziehung zwischen einem Supertyp und einem Subtyp \n\u0095 Die Subtypen erben alle Attribute des Supertyps\n\u0095 Die Attribute des Subtyps k\u00f6nnen um eigene Attribute und Methoden erg\u00e4nzt werden.\n\u0095 Supertyp und Subtyp besitzen den gleichen Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Eine IS-A-Beziehung ist eine andere Bezeichnung f\u00fcr eine identifizierende 1:n-Beziehung.", "solution": "false"}, {"text": "Eine IS-A-Beziehung ist eine andere Bezeichnung f\u00fcr eine nicht-identifizierende 1:n-Beziehung.", "solution": "false"}, {"text": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp.", "solution": "true"}, {"text": "Bei einer IS-A-Beziehung werden alle Attribute des Subtypen an den Supertyp vererbt.", "solution": "false"}, {"text": "Supertyp und Subtyp haben die gleichen Prim\u00e4rschl\u00fcsselattribute und auch -werte.", "solution": "true"}]}, {"id": 3778, "category": 5, "difficulty": 1, "text": "Bei welcher/n Entity-Mengen sind bei m:n-Beziehungen die Fremdschl\u00fcssel einzutragen?", "explanation": "Bei einer m:n-Beziehung werden dei Fremdschl\u00fcssel sp\u00e4ter in einer Zwischentabelle ausgelagert.", "type": "multiple-choice", "answers": [{"text": "Nur m-Ende", "solution": "false"}, {"text": "nur n-Ende", "solution": "false"}, {"text": "Beide Enden", "solution": "false"}, {"text": "Keine Fremdschl\u00fcssel  in den Entity-Mengen", "solution": "true"}]}, {"id": 547, "category": 8, "difficulty": 3, "text": "Wie nennt man die Anzahl der Attribute einer Relation in der relationalen Algebra? (englischer Ausdruck)", "explanation": "Man schreibt auch: R(A1,...,An). Eine Relation entspricht dabei einer Tabelle mit den Attributen als Spalten\u00fcberschriften. Der Degree ist die Anzahl der Attribute der Relation.", "type": "text", "answers": [{"text": "Die Anzahl der Attribute hei\u00dft:", "solution": "Degree"}]}, {"id": 2555, "category": 8, "difficulty": 1, "text": "Bei einer Projektion wird eine n-stellige Relation auf eine (n-m)-stellige Relation abgebildet, mit m>=0.", "explanation": "Die Projektion ist die Operation der RA, die die Ergebnismenge auf einzelne Attribute aus einer Relation beschr\u00e4nken kann.  \nListet man bei der Projektion alle Attributnamen der Relation auf, so w\u00e4re das der Fall, dass m=0 ist (eine recht \u00fcberfl\u00fcssige Operation, da die Eingangstupelmenge identisch ist mit der Ergebnismenge). Listet man hingegen nur einige Attributnamen auf, so ist m>0.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2571, "category": 8, "difficulty": 1, "text": "Der Right Outer Join ist kommutativ.", "explanation": "Der rechte Outer-Join (rechter \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R1 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.\n\nDie rechten und linken Outer-Joins sind nicht kommutativ, da entweder nur die rechte oder nur die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden. \nDer Full-Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ist jedoch kommutativ, da bei ihn sowohl die rechte als aich die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2567, "category": 8, "difficulty": 3, "text": "Welche Anforderungen muss ein \"vereinigungskonformer\" Operator der relationalen Algebra erf\u00fcllen? (relevant f\u00fcr die Durchf\u00fchrung von Mengenoperationen)", "explanation": "Die Forderung in der Relationalen Algebra <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Relationen (Eingangsdatenmengen) m\u00fcssen die gleichen Attributdefinitionen aufweisen: \nDie Anzahl der Attribute muss \u00fcbereinstimmen. \nDie Attribute m\u00fcssen gleich hei\u00dfen. \nDie Datentypen der der Attribute m\u00fcssen gleich sein.  \nDie Reihenfolge der Attribute muss \u00fcbereinstimmen. \nAchtung: In SQL m\u00fcssen die Spalten nicht auch noch gleich hei\u00dfen.", "type": "multiple-choice", "answers": [{"text": "Die Attribute m\u00fcssen gleich hei\u00dfen.", "solution": "true"}, {"text": "Die Anzahl der Attribute muss \u00fcbereinstimmen.", "solution": "true"}, {"text": "Die Datentypen der der Attribute m\u00fcssen gleich sein.", "solution": "true"}, {"text": "Die Reihenfolge der Attribute muss \u00fcbereinstimmen.", "solution": "true"}, {"text": "Es gibt keine solche Anforderung in der RA.", "solution": "false"}]}, {"id": 2561, "category": 8, "difficulty": 1, "text": "\u00dcber welche Eigenschaften verf\u00fcgt ein bin\u00e4rer Operator in der relationalen Algebra?", "explanation": "Un\u00e4r:  F1 : Rn -> Rm      mit n , m \u2208 N\nBin\u00e4r: F2 : Rn \u00d7 Rm -> Rk mit n , m , k \u2208 N\nUn\u00e4re Operatoren: Selektion, Projektion\nBin\u00e4re Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division", "type": "multiple-choice", "answers": [{"text": "Er liefert zwei Ergebnisdatenmengen.", "solution": "false"}, {"text": "Er verarbeitet zwei Eingangsdatenmengen.", "solution": "true"}, {"text": "Die Ergebnisdatenmenge verf\u00fcgt \u00fcber zwei Attribute.", "solution": "false"}, {"text": "Die Eingangsdatenmengen verf\u00fcgen \u00fcber zwei Attribute.", "solution": "false"}, {"text": "Die Operation wird nur auf zwei Attributen ausgef\u00fchrt.", "solution": "false"}]}, {"id": 2556, "category": 8, "difficulty": 3, "text": "Wie viele Attribute hat die Ergebnismenge des kartesischen Produkts von zwei Relationen, die \u00fcber 15 bzw. 25 Attribute verf\u00fcgen, wobei es in der einen Relation drei Attribute gibt, die gleich hei\u00dfen wie in der anderen?", "explanation": "Die Struktur der Ergebnismenge des Kartesischen Produkts verf\u00fcgt \u00fcber alle Attribute aus beiden beteiligten Relationen: 15+25= 40 Attribute. \nDass drei Attribute in beiden Relationen gleich hei\u00dfen, spielt keine Rolle f\u00fcr das Kartesische Produkt, sondern lediglich f\u00fcr den Natural Join.", "type": "text", "answers": [{"text": "Das kartesische Produkt hat ... Attribute.", "solution": "40"}]}, {"id": 2558, "category": 8, "difficulty": 2, "text": "Wie viele Tupel hat die Ergebnismenge des Natural Joins von zwei Relationen, die 18 bzw. 20 Tupel beinhalten, wobei es f\u00fcr 14 Tupel der einen Relation Tupel der anderen Relation gibt, die in einem gleichhei\u00dfenden Attribut die gleichen Werte aufweisen?", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. Diese Bedingung trifft f\u00fcr 14 Tupel zu.", "type": "text", "answers": [{"text": "Der Natural Join hat ... Tupel.", "solution": "14"}]}, {"id": 1689, "category": 8, "difficulty": 1, "text": "Welche Operation aus der relationalen Algebra setzt den \"F\u00fcr-Alle-Quantor\" (Allaussage) um?", "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.", "type": "multiple-choice", "answers": [{"text": "Addition", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Division", "solution": "true"}, {"text": "Produkt", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2187, "category": 8, "difficulty": 1, "text": "Der Durchschnittsoperator ist aus den Grundoperatoren der relationalen Algebra (Selektion, Projektion, Kartesisches Produkt, Differenz, Union)  ableitbar.", "explanation": "Die Simulation sieht wie folgt aus: \n(A Durchschnitt B)  =  ( A ohne (A ohne B) ) \n\n(A Durchschnitt B)  =  ( A Differenz (A Differenz B) ) \n\nPS: Zeichnen Sie sich ruhig die Venn-Diagramme auf - es hilft ;-) \nPS: War mal Klausuraufgabe :-)", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2044, "category": 8, "difficulty": 1, "text": "Ein Operatorbaum w\u00e4chst", "explanation": "Um Anfragen an einen Datenbestand zu formulieren, k\u00f6nnen Operationen der relationalen Algebra beliebig ineinander geschachtelt werden. Bei komplexen Anfragen ist daher die oben verwendete sogenannte \"Inline-Notation\" schwer lesbar. F\u00fcr diesen Zweck verwendet man Operatorb\u00e4ume statt der Inline-Notation. Bei dieser grafischen Darstellung erstellt und liest man die Abfrage von unten nach oben. Operationen, die miteinander verkn\u00fcpft sind, sind durch Kanten im Graphen miteinander verbunden. Gestartet wird mit den relvanten Relationen als unterster Teil des OP-Baumes.", "type": "multiple-choice", "answers": [{"text": "von unten nach oben", "solution": "true"}, {"text": "von oben nach unten", "solution": "false"}]}, {"id": 1726, "category": 8, "difficulty": 3, "text": "Wie hei\u00dfen Tupel, die bei einem Natural Join verloren gehen k\u00f6nnen?", "explanation": "Beim nat\u00fcrlichen Join werden diejenigen Tupel, die nur in einer Relation vorkommen, unterdr\u00fcckt. Diese Tupel bezeichnet man auch als \"Dangeling\"-Tupel (dangling tuples).", "type": "text", "answers": [{"text": "Diese Tupel hei\u00dfen (englischsprachiger Begriff, alles kleingeschrieben):", "solution": "dangling tupels"}]}, {"id": 1155, "category": 8, "difficulty": 3, "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass jeder Wert eines Fremdschl\u00fcssels einer Relation Wert eines Prim\u00e4rschl\u00fcssel in einer anderen Relation ist.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrit\u00e4t, wenn jeder Wert eines Fremdschl\u00fcssels einer Relation Ri Wert eines Prim\u00e4rschl\u00fcssels in einer anderen Relation Rj ist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt.", "type": "text", "answers": [{"text": "Diese Eigenschaft hei\u00dft", "solution": "Referentielle Integrit\u00e4t"}]}, {"id": 801, "category": 8, "difficulty": 3, "text": "Welcher Optimierungsvorgang transformiert einen algebraischen Ausdruck der relationalen Algebra auf einen semantisch \u00e4quivalenten Ausdruck?", "explanation": "Bei der logischen Optimierung wird ein algebraischer Ausdruck der relationalen Algebra auf einen semantisch \u00e4quivalenten Ausdruck transformiert, der weniger Laufzeit ben\u00f6tigt. Je weniger Tupel die Zwischenergebnismengen haben, umso schneller ist die Anfrageauswertung.", "type": "text", "answers": [{"text": "Dies ist die ...", "solution": "logische Optimierung"}]}, {"id": 1133, "category": 8, "difficulty": 1, "text": "Die Division ist kommutativ.", "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind kommutativ (vertauschbar), die Division aber nicht. \nEs macht sehr wohl einen semantischen Unterschied, ob man die \"Kunden, die alle Artikel gekauft haben\" oder die \"Artikel, die von allen Kunden gekauft wurden\" anfragt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1132, "category": 8, "difficulty": 1, "text": "Die Differenz ist kommutativ.", "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind kommutativ (vertauschbar), die Differenz aber nicht. \nEs macht sehr wohl einen semantischen Unterschied, ob man die \"Artikel ohne Rechnungen\" oder die \"Rechnungen ohne Atrikel\" anfragt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1128, "category": 8, "difficulty": 1, "text": "Bei der Division R % S m\u00fcssen die Attribute von S in den Attributen von R enthalten sein.", "explanation": "Wir betrachten zwei Relationen R und S. Die Attribute von S sollen in den Attributen von R enthalten sein. Die Attribute der Ergebnismenge der Division entsprechen der Differenzmenge X der Attribute von R und S: \nDie Division R \u00f7 S besteht aus allen Tupeln x aus X, so dass die folgenden beiden Bedingungen f\u00fcr jedes x aus X gelten: \n1. Zu jedem s aus S gibt es eine Fortsetzung r aus R, so dass die Projektion von r auf S gleich s ist. \n2. Die Projektion von r auf X stimmt mit x \u00fcberein.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1126, "category": 8, "difficulty": 2, "text": "Wie hei\u00dft der Wertebereich eines Attributs?", "explanation": "Sei (A1,..., An) eine Menge von Attributen mit den Wertebereichen Mi. Die Elemente der Mi sind Basisdatentypen und beschreiben die Werte, die die Attribute annehmen k\u00f6nnen. \nDie Wertebereiche Mi hei\u00dfen Dom\u00e4nen. Dom\u00e4nen sind atomar, d.h. keine zusammengesetzten Datentypen. Bei der Definition von Dom\u00e4nen muss angegeben werden, ob NULL-Werte, also einzelne Attribute ohne Werteintrag, zugelassen sind. Eine Dom\u00e4ne kann auch eine festgelegte\nMenge von Werten aus den obigen Basisdatentypen sein.", "type": "text", "answers": [{"text": "Das ist eine", "solution": "Dom\u00e4ne"}]}, {"id": 1127, "category": 8, "difficulty": 3, "text": "Woraus k\u00f6nnen Selektionspr\u00e4dikate bestehen?", "explanation": "Bestandteile eines Selektionspr\u00e4dikats sind: \n1. Attribute einer Relation und Konstanten als Operanden, \n2. Vergleichsoperatoren = <, \u2264, >, \u2265 , <> und != (ungleich), \n3. die logischen Operatoren UND, ODER und NICHT und \n4. Berechnungen mit Konstanten und Spaltenwerten (z.B. Gehalt*1,.045)  \n5. eine beliebige Kombination aus den oben genannten M\u00f6glichkeiten, die durch Klammerung (..) erzeugt wird.", "type": "multiple-choice", "answers": [{"text": "Konstanten", "solution": "true"}, {"text": "Join-Operatoren", "solution": "false"}, {"text": "Attributen", "solution": "true"}, {"text": "Vergleichsoperatoren", "solution": "true"}, {"text": "Dom\u00e4nen", "solution": "false"}]}, {"id": 1049, "category": 8, "difficulty": 3, "text": "Welche Operatoren der relationalen Algebra sind assoziativ?", "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind assoziativ, d. h., Klammern k\u00f6nnen beliebig gesetzt werden.", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Natural Join", "solution": "true"}, {"text": "kartesisches Produkt", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Join-Operatoren (Theta, Natural, Equi)", "solution": "true"}]}, {"id": 1331, "category": 8, "difficulty": 1, "text": "Wodurch wird in der relationalen Algebra der \"F\u00fcr-Alle-Quantor\" (Allaussage) umgesetzt?", "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.", "type": "multiple-choice", "answers": [{"text": "Division", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Durchschnitt", "solution": "false"}]}, {"id": 1488, "category": 8, "difficulty": 1, "text": "Welche Aussagen \u00fcber die Join-Operation sind richtig?", "explanation": "In eine Join-Operation gehen nach Definition immer nur genau zwei Operatoren ein.", "type": "multiple-choice", "answers": [{"text": "Es ist eine un\u00e4re Operation.", "solution": "false"}, {"text": "Es ist eine bin\u00e4re Operation.", "solution": "true"}, {"text": "Es ist eine tern\u00e4re Operation.", "solution": "false"}, {"text": "Es k\u00f6nnen beliebig viele Relationen in einer Join-Operation miteinander verkn\u00fcpft werden.", "solution": "false"}]}, {"id": 556, "category": 8, "difficulty": 3, "text": "Wie hei\u00dft ein Natural Join, bei dem alle Tupel am Verbund der beiden Relationen teilnehmen?", "explanation": "Eine Join-Operation (Theta-Join, Equi-Join oder Natural-Join) zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.", "type": "text", "answers": [{"text": "Solch ein Join hei\u00dft", "solution": "verlustfrei"}]}, {"id": 559, "category": 8, "difficulty": 3, "text": "Welche der folgenden Operationen aus der relationalen Algebra sind kommutativ?", "explanation": "W\u00e4hrend die beiden Mengenoperationen Vereinigung und Durchschnitt kommutativ sind, ist es die Differenz nicht, weil das Ergebnis davon abh\u00e4ngt, welche Relation von der anderen abgezogen wird. \nKartesisches Produkt und Join-Operation sind kommutativ (vertauschbar), das einzige, was sich \u00e4ndert ist die Attributreihenfolge und das spielt keine Rolle.  \nHingegen sind die Left und Right Outer-Joins nicht kommutativ, da geht es ja gerade um die Anforderung, entweder die Tupel der linken oder rechten Relation vollst\u00e4ndig in die Ergebnismenge aufzunehmen.", "type": "multiple-choice", "answers": [{"text": "Durchschnitt", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Union", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Join-Operationen (Theta, Natural, Equi)", "solution": "true"}, {"text": "Outer Join-Operatoren (Left, Right)", "solution": "false"}]}, {"id": 569, "category": 8, "difficulty": 3, "text": "Welche Operationen der relationalen Algebra sind assoziativ?", "explanation": "Kartesisches Produkt, Union, Durchschnitt und Join-Operation sind assoziativ, d. h., Klammern k\u00f6nnen beliebig gesetzt werden.", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Selektion", "solution": "false"}, {"text": "kartesisches Produkt", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Union", "solution": "true"}]}, {"id": 2489, "category": 8, "difficulty": 3, "text": "Welche der folgenden Operatoren der relationalen Algebra m\u00fcssen der Anforderung gen\u00fcgen, \"vereinigungskonform\" zu sein?", "explanation": "Die Forderung in der Relationalen Algebra <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Relationen (Eingangsdatenmengen) m\u00fcssen die gleichen Attributdefinitionen aufweisen: \nDie Anzahl der Attribute muss \u00fcbereinstimmen. \nDie Attribute m\u00fcssen gleich hei\u00dfen.  \nDie Datentypen der der Attribute m\u00fcssen gleich sein.  \nDie Reihenfolge der Attribute muss \u00fcbereinstimmen. \nAchtung: In SQL wird diese Definition leicht variieren (keine gleichen Attributnamen).", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Selektion", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Join (NATURAL, THETA, EQUI, )", "solution": "false"}, {"text": "OUTER JOIN (LEFT, RIGHT, FULL)", "solution": "false"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Differenz", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Es gibt keine solche Anforderung in der RA.", "solution": "false"}]}, {"id": 2490, "category": 8, "difficulty": 3, "text": "Welche der folgende Aussagen \u00fcber den Natural Join sind wahr?", "explanation": "Der Natural Join ist ableitbar aus dem kartesischen Produkt mit anschlie\u00dfender Selektion gem\u00e4ss der implizit definierten Natural Join-Bedingung \u00fcber alle Attribute, die gleichhei\u00dfen, und abschlie\u00dfender Projektion, so dass die gleichhei\u00dfenden Attribute nur einmal in der Ergebnismenge vorkommen. \nGrundoperatoren sind Operatoren, die nicht simuliert werden k\u00f6nnen und damit ist der Natural Join keiner.", "type": "multiple-choice", "answers": [{"text": "F\u00fcr die Verkn\u00fcpfungsbedingung werden nur die Fremd- und Prim\u00e4rschl\u00fcsselattribute, die gleich hei\u00dfen, auf Gleichheit mit einander verglichen.", "solution": "false"}, {"text": "Die Attribute, die in beiden Relationen namensgleich vorkommen, treten in der Ergebnismenge nur einmal auf.", "solution": "true"}, {"text": "Er kann simuliert werden durch die RA-Operatoren kartesisches Produkt, Selektion, Projektion.", "solution": "true"}, {"text": "Er ist kein Grundoperator der relationalen Algebra.", "solution": "true"}]}, {"id": 468, "category": 8, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber die relationale Algebra ist wahr?", "explanation": "Selektion ist die Auswahl von Tupeln und Projektion die Auswahl von Attributen. \nDie Ergebnismenge eines kartesischen Produkts angewendet auf zwei Relationen mit je n bzw. m Tupeln umfasst n x m Tupel. \nDie Division (Allaussage, Allquantor) k\u00f6nnte man zwar analog zu SQL mittels einer doppelten Differenz und vielen anderen Operatoren simulieren, aber als eine spezielle Form der Differenz kann sie wahrlich nicht bezeichnet werden. \nDie beiden Operatoren Selektion und der Projektion als Grundoperationen reichen nicht, um alle Operatoren der relationalen Algebra abzuleiten. Es fehlt u.a. ein so wichtiger Operator wie das Kartesische Produkt, dem einzigen Grundoperator, mit dem man die Tupel \"nebeneinander verkn\u00fcpfen kann\".", "type": "multiple-choice", "answers": [{"text": "Selektion ist die Auswahl von Attributen und Projektion die Auswahl von Tupeln.", "solution": "false"}, {"text": "Die Ergebnismenge eines kartesischen Produkts angewendet auf zwei Relationen mit je n bzw. m Tupeln umfasst n x m Tupel.", "solution": "true"}, {"text": "Die Division ist eine spezielle Form der Differenz.", "solution": "false"}, {"text": "Alle Operatoren der relationalen Algebra lassen sich aus der Selektion und der Projektion als Grundoperationen ableiten.", "solution": "false"}]}, {"id": 469, "category": 8, "difficulty": 2, "text": "Betrachten Sie zwei Relationen Artikel(ArtikelNr, Bezeichnung...)und Auftragspositionen (AuftragsNr, ArtikelNr, Menge...). Die Relation Auftragspositionen enth\u00e4lt einen Fremdschl\u00fcssel zu dem Attribut ArtikelNr in der Relation Artikel. Die Relation Artikel soll jetzt nur noch Eintr\u00e4ge enthalten, die auch wenigstens einmal gekauft wurden. Kann man das Problem l\u00f6sen, indem man ArtikelNr in ARTIKEL als zus\u00e4tzlichen Fremdschl\u00fcssel deklariert, der auf das Attribut ArtikelNr in der Relation Auftragspositionen referenziert?", "explanation": "An dieser Stelle l\u00f6sen Fremdschl\u00fcssel, die man in beiden Richtungen vereinbaren kann, nicht das Problem, da sie sich gegenseitig behindern und so das Einf\u00fcgen von Daten generell verhindern w\u00fcrden. Denkbar sind allerdings Datenbanktrigger zur L\u00f6sung dieses Problems.", "type": "multiple-choice", "answers": [{"text": "Nein. Das w\u00e4re kein g\u00fcltiger Fremdschl\u00fcssel.", "solution": "false"}, {"text": "Man kann den Fremdschl\u00fcssel deklarieren, aber er w\u00fcrde das Problem nicht l\u00f6sen.", "solution": "true"}, {"text": "Ja", "solution": "false"}]}, {"id": 1032, "category": 8, "difficulty": 3, "text": "Was versteht man unter \"Dangling Tuples\" in der relationalen Algebra?", "explanation": "Gibt es Tupel in einer Relation, deren Werte in den Fremdschl\u00fcssel-Attributen auf Werte in der anderen Relation verweisen, die dort nicht (mehr) existieren, so sind dies die sog. \"dangling tuples\", die Probleme hinsichtlich der referenziellen Integrit\u00e4t darstellen. \nEbenso werden auch Tupel, die bei Join-Operationen nicht mit entsprechenden Tupeln aus der anderen Relation verkn\u00fcpft werden k\u00f6nnen, als \"dangling tuples\" bezeichnet.", "type": "multiple-choice", "answers": [{"text": "Tupel, die nicht gesichert werden.", "solution": "false"}, {"text": "Tupel, denen bei Join-Operationen die entsprechenden Tupel in der anderen Relation fehlen, mit denen sie verkn\u00fcpft werden k\u00f6nnten.", "solution": "true"}, {"text": "Tupel, denen Attributwerte fehlen.", "solution": "false"}, {"text": "Tupel in einer Relation, deren Werte in den Fremdschl\u00fcssel-Attributen auf Werte in der anderen Relation verweisen, die dort nicht (mehr) existieren.", "solution": "true"}]}, {"id": 639, "category": 8, "difficulty": 1, "text": "In der relationalen Algebra sind Null-Werte f\u00fcr Attribute nicht zul\u00e4ssig.", "explanation": "In der relationalen Algebra sind Null-Werte f\u00fcr Attribute zugelassen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 759, "category": 8, "difficulty": 3, "text": "Wie viele Tupel hat die Ergebnismenge des kartesischen Produkts von zwei Relationen, die 18 bzw. 20 Tupel beinhalten, wobei es f\u00fcr 14 Tupel der einen Relation Tupel der anderen Relation gibt, die in einem gleichhei\u00dfenden Attribut die gleichen Werte aufweisen?", "explanation": "Das Kartesische Produkt \"verbindet jedes Tupel der einen Relation mit jedem Tupel aus der anderen Relation unabh\u00e4ngig von irgendwelchen passenden oder nichtpassenden Werten\" und somit ergeben sich 18*20 = 360 Tupel in der Ergebnismenge. \nDas nur bei 14 Tupeln \u00fcbereinstimmende Werte gegeben sind, spielt f\u00fcr das kartesische Produkt keine Rolle, sondern nur f\u00fcr den Natural Join.", "type": "text", "answers": [{"text": "Das kartesische Produkt hat ... Tupel.", "solution": "360"}]}, {"id": 760, "category": 8, "difficulty": 1, "text": "Jede n-stellige Relation R ist eine Teilmenge des kartesischen Produkts der Wertebereiche der Attribute.", "explanation": "Sei (A1,..., An) eine Menge von Attributen mit den Wertebereichen Mi. Die Elemente der Mi sind Basisdatentypen und beschreiben die Werte, die die Attribute annehmen k\u00f6nnen. Eine n-stellige Relation R ist eine Teilmenge des kartesischen Produkts M1\u00d7...\u00d7Mn. Rn bezeichne die Menge aller n-stelligen Relationen. Man schreibt auch: R(A1,...,An).", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 763, "category": 8, "difficulty": 2, "text": "Relationale Operatoren sind immer Abbildungen, die zwei Relationen eine Ergebnis-Relation zuordnen.", "explanation": "Un\u00e4r:  F1 : Rn \u2192 Rm      mit n , m \u2208 N \nBin\u00e4r: F2 : Rn \u00d7 Rm \u2192 Rk mit n , m , k \u2208 N\nUn\u00e4re Operatoren: Selektion, Projektion\nBin\u00e4re Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 786, "category": 8, "difficulty": 2, "text": "Mit welchem Operator der relationalen Algebra wird der F\u00fcr-Alle-Quantor (die Allaussage) umgesetzt?", "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.", "type": "text", "answers": [{"text": "Der Operator hei\u00dft", "solution": "Division"}]}, {"id": 1270, "category": 8, "difficulty": 2, "text": "Relationale Operatoren sind immer Abbildungen, die aus einer Relation eine Ergebnis-Relation erzeugen.", "explanation": "Neben den un\u00e4ren (Selektion, Projektion) gibt es aber auch noch die bin\u00e4ren Operatoren (kartesisches Produkt, Joins, Mengenoperatoren, Division). \nDurch Anwendung einer dieser Operationen entsteht aus einer oder zwei Relationen wieder eine neue Relation. \nF1 : Rn -> Rm mit n , m \u2208 N \nF2 : Rn \u00d7 Rm -> Rk mit n , m , k \u2208 N", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1585, "category": 7, "difficulty": 1, "text": "Eine Relation in der zweiten Normalform mit zwei Attributen ist auch immer in der dritten Normalform.", "explanation": "Ja, denn f\u00fcr die Verletzung der 3. NF werden wenigstens drei Attribute ben\u00f6tigt, je eines f\u00fcr X,Y und Z. \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist. \nMit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist. \nAlso X \u2192Y \u2192Z, aber nicht Y \u2192X.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1587, "category": 7, "difficulty": 2, "text": "Eine Relation in der zweiten Normalform mit nur zwei funktionalen\nAbh\u00e4ngigkeiten ist immer in der dritten Normalform.", "explanation": "Mit nur einer funktionalen Abh\u00e4ngigkeit, w\u00e4re keine M\u00f6glichkeit zur Transitiviti\u00e4t gegeben. z.B. a->b,c. \nAber mit zwei funktionalen Abh\u00e4ngigkeiten ist als Mindestvoraussetzung grunds\u00e4tzlich die M\u00f6glichkeit gegeben, dass es sich dabei um transitive Abh\u00e4ngigkeiten handeln k\u00f6nnte. z.B. a->b,c. und b->c.", "type": "multiple-choice", "answers": [{"text": "Dieser Sachverhalt spielt in diesem Zusammenhang keine Rolle.", "solution": "false"}, {"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1604, "category": 7, "difficulty": 1, "text": "Eine Relation in der zweiten Normalform, in der keine transitiven Abh\u00e4ngigkeiten auftreten, ist immer in der dritten Normalform.", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 561, "category": 7, "difficulty": 2, "text": "Welche Integrit\u00e4tsarten gibt es in relationalen Datenbanksystemen/im relationalen Modell?", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrit\u00e4t, wenn jeder Wert eines Fremdschl\u00fcssels einer Relation Ri Wert eines Prim\u00e4rschl\u00fcssels in einer anderen Relation Rj\nist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt. \nEine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt. \nEine Menge von Relationen R1,...,Rk besitzt die semantische Integrit\u00e4t, wenn die Korrektheit der Eingaben der Benutzer gew\u00e4hrleistet ist. \nDie \u00fcrbrigen Integrit\u00e4tsbegriffe gibt es nicht in diesem Zusammenhang.", "type": "multiple-choice", "answers": [{"text": "Entity-Integrit\u00e4t", "solution": "true"}, {"text": "referentielle Integrit\u00e4t", "solution": "true"}, {"text": "semantische Integrit\u00e4t", "solution": "true"}, {"text": "differenzielle Integrit\u00e4t", "solution": "false"}, {"text": "divergente Integrit\u00e4t", "solution": "false"}, {"text": "resorbierende Integrit\u00e4t", "solution": "false"}]}, {"id": 682, "category": 7, "difficulty": 1, "text": "Bei welchem Beziehungstyp eines ER-Diagramms entsteht bei der Abbildung auf ein relationales Datenbankschema immer eine neue Relation?", "explanation": "F\u00fcr n:m, cn:m, n:cm, cn:cm-Beziehungen im ERD gilt: \nF\u00fcr beide (bzw. drei bei einer tern\u00e4ren Beziehung) Entity-Mengen und die Beziehung werden je eine Relation mit entsprechenden verbindenden Beziehungen erzeugt.", "type": "multiple-choice", "answers": [{"text": "1:1-Beziehung", "solution": "false"}, {"text": "1:n-Beziehung", "solution": "false"}, {"text": "n:m-Beziehung", "solution": "true"}]}, {"id": 1294, "category": 7, "difficulty": 3, "text": "Welche Aussagen \u00fcber Normalformen sind wahr?", "explanation": "In der 3. NF sind partielle (2.NF) und transitive funktionale Abh\u00e4ngigkeiten (3. NF) aufgel\u00f6st, so dass jedes Nichtschl\u00fcsselattribut nur einmal auftritt in allen Relationen. Lediglich Schl\u00fcsselattribute der einen Relation k\u00f6nnen in anderen Relationen als Fremdschschl\u00fcssel-Attribute auftreten, somit liegen nur noch in diesen Fremdschl\u00fcsselattributen Redundanzen vor. \nFalsch ist \"Redundanzen vermeiden Einf\u00fcge-/L\u00f6sch- und \u00c4nderungsanomalien.\", weil Redundanzen Grundvoraussetzungen f\u00fcr diese Anomalien sind. \nFalsch ist \"Eine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der ersten Normalform, wenn jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.\", weil dies die Definition der 2. NF ist. Die 1. NF schlie\u00dft mengenwertige (nicht atomare) Attribute aus. \nEine Relation ist in der dritten Normalform, wenn sie in der 1. und 2. NF ist und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig ist von einem Schl\u00fcsselattribut.", "type": "multiple-choice", "answers": [{"text": "Ein Datenmodell in 3. Normalform enth\u00e4lt keine Redundanzen au\u00dfer Schl\u00fcsselredundanzen (Fremdschl\u00fcsselbeziehungen).", "solution": "true"}, {"text": "Redundanzen vermeiden Einf\u00fcge-/L\u00f6sch- und \u00c4nderungsanomalien.", "solution": "false"}, {"text": "Eine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der ersten Normalform, wenn jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.", "solution": "false"}, {"text": "Eine Relation ist in der dritten Normalform, wenn sie in der 1. und 2. NF ist und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig ist von einem Schl\u00fcsselattribut.", "solution": "true"}]}, {"id": 586, "category": 7, "difficulty": 2, "text": "Attribute in der ersten Normalform d\u00fcrfen Wiederholungsgruppen von Attributen haben.", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 571, "category": 7, "difficulty": 2, "text": "Jedes Nicht-Schl\u00fcssel-Attribut ist in einer Relation R voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S.", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "Das ist die erste Normalform.", "solution": "false"}, {"text": "Das ist die zweite Normalform.", "solution": "true"}, {"text": "Das ist die dritte Normalform.", "solution": "false"}, {"text": "Das entspricht keiner Normalform.", "solution": "false"}]}, {"id": 3781, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abh\u00e4ngigkeiten (FD):  A-> B, C, E     C -> E  und   D -> F , sowie dem Prim\u00e4raschl\u00fcssel AD.  Welche davon sind bezogen auf den gefundenen Prim\u00e4rschl\u00fcssel partielle FDs?", "explanation": "A und D geh\u00f6ren zum Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Es gibt keine", "solution": "false"}, {"text": "A -> B, C, E", "solution": "true"}, {"text": "C -> E", "solution": "false"}, {"text": "D-> F", "solution": "false"}]}, {"id": 3780, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abh\u00e4ngigkeiten (FD):  A-> B, C, E     C -> E  und   D -> F , sowie dem Prim\u00e4raschl\u00fcssel AD.  Welche davon sind bezogen auf den gefundenen Prim\u00e4rschl\u00fcssel transitive FDs?", "explanation": "C geh\u00f6rt nicht zum Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Es gibt keine", "solution": "false"}, {"text": "A -> B, C, E", "solution": "false"}, {"text": "C -> E", "solution": "true"}, {"text": "D-> F", "solution": "false"}]}, {"id": 584, "category": 7, "difficulty": 1, "text": "In einer Relation sei kein Sekund\u00e4rattribut (Nicht-Schl\u00fcsselattribut) transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut.", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "Das ist die dritte Normalform.", "solution": "true"}, {"text": "Das ist die erste Normalform.", "solution": "false"}, {"text": "Das ist die zweite Normalform.", "solution": "false"}]}, {"id": 644, "category": 7, "difficulty": 3, "text": "Jeder Wert eines Fremdschl\u00fcssels einer Relation A ist Wert eines Prim\u00e4rschl\u00fcssel in einer anderen Relation. Diese Eigenschaft hei\u00dft", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrit\u00e4t, wenn jeder Wert eines Fremdschl\u00fcssels einer Relation Ri Wert eines Prim\u00e4rschl\u00fcssels in einer anderen Relation Rj ist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt.", "type": "text", "answers": [{"text": "Diese Integrit\u00e4t hei\u00dft:", "solution": "referentielle Integrit\u00e4t"}]}, {"id": 1788, "category": 7, "difficulty": 1, "text": "Eine Relation in der ersten Normalform mit nur einem Prim\u00e4rschl\u00fcsselattribut ist automatisch in der zweiten Normalform.", "explanation": "Das Gegebensein der 1. NF ist Grundvoraussetzung f\u00fcr die 2. NF. \nWenn ein Prim\u00e4rschl\u00fcssel nur aus Attribut besteht, dann sind alle abh\u00e4ngigen Attribute zwingend voll funktional abh\u00e4ngig. Partiell abh\u00e4ngig hie\u00dfe ja, dass Nichtschl\u00fcsselattribute nur von einer Teilmenge der Attribute abh\u00e4ngig w\u00e4ren, was bei nur einem Attribut des Prim\u00e4rschl\u00fcssels nicht geht.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1798, "category": 7, "difficulty": 1, "text": "Welche Aussagen \u00fcber Normalformen sind wahr?", "explanation": "Richtig ist: \"Jede 1NF-Relation mit einem Prim\u00e4rschl\u00fcssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 2NF.\" \nWenn ein Prim\u00e4rschl\u00fcssel nur aus einem Attribut besteht, wie soll es da eine partielle Abh\u00e4ngigkeit geben? Partielle hei\u00dft ja, dass einige Nichtschl\u00fcsselattribute nur von Teilen des Prim\u00e4rschl\u00fcssels abh\u00e4ngig sind, was bei einem Schl\u00fcssel mit nur einen Attribut ja ausgeschlossen ist. \nFalsch ist: \"Jede 1NF-Relation mit einem Prim\u00e4rschl\u00fcssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 3NF.\"\nGegenbeispiel: A->B,C und B->C und einer Relation R(A (PK),B,C).\n\nFalsch ist: \"Bei der \u00dcberf\u00fchrung in die dritte Normalform sind die vorher zu erstellende 2NF-Relationen immer von den endg\u00fcltigen 3NF-Relationen verschieden.\" \nWenn es keine transitiven Abh\u00e4ngigkeiten gibt, dann gilt: 2. NF = 3. NF und damit sind die Relationen gleich in beiden NFs.", "type": "multiple-choice", "answers": [{"text": "Jede 1NF-Relation mit einem Prim\u00e4rschl\u00fcssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 2NF.", "solution": "true"}, {"text": "Jede 1NF-Relation mit einem Prim\u00e4rschl\u00fcssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 3NF.", "solution": "false"}, {"text": "Bei der \u00dcberf\u00fchrung in die dritte Normalform sind die vorher zu erstellende 2NF-Relationen immer von den endg\u00fcltigen 3NF-Relationen verschieden.", "solution": "false"}]}, {"id": 2900, "category": 7, "difficulty": 2, "text": "Welche Normalform reduziert die Redundanz in einer relationalen Datenbank?", "explanation": "Die \u00dcberf\u00fchrung einer Relation in die 1NF erh\u00f6ht in der Regel die Redundanz, bei der 2NF und der 3NF ist es umgekehrt.", "type": "multiple-choice", "answers": [{"text": "3NF", "solution": "true"}, {"text": "Jede der drei Normalfomen (1NF, 2NF und 3NF)", "solution": "false"}, {"text": "1NF", "solution": "false"}, {"text": "2NF", "solution": "true"}]}, {"id": 2800, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine Relation in der 2NF, die au\u00dfer Prim\u00e4rschl\u00fcsselattributen nur ein einziges Nichtschl\u00fcsselattribut besitzt. Solch eine Relation ist immer automatisch in der 3NF.", "explanation": "Eine Relation, die nur ein Nichtschl\u00fcsselattribute hat, kann nie transitive Abh\u00e4ngigkeiten (siehe <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Transitive-Abhaengigkeit/\">DB-Wiki ) aufweisen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2797, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C und den folgenden funktionalen Abh\u00e4ngigkeiten Welche Arten funktionaler Abh\u00e4ngigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abh\u00e4ngigkeit als Antwort eintragen, also volle, partielle oder transitive.", "explanation": "B, D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig.\n\n    F ist von B abh\u00e4ngig und B von A,C und damit ist F transitiv von A,C abh\u00e4ngig.\n\n    E ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig.", "type": "text", "answers": [{"text": "A, C -> B, D, E, F", "solution": "volle"}, {"text": "D -> E", "solution": "transitive"}, {"text": "B -> F", "solution": "transitive"}]}, {"id": 2899, "category": 7, "difficulty": 2, "text": "Jede \u00dcberf\u00fchrung in eine Normalform (1NF, 2NF odr 3NF) verringert Redundanz in der Datenbank.", "explanation": "Die \u00dcberf\u00fchrung einer Relation in die 1NF erh\u00f6ht in der Regel die Redundanz.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2462, "category": 9, "difficulty": 3, "text": "Welche SQL-Constraints bieten die M\u00f6glichkeit zur Fehlerkorrektur?", "explanation": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird. Dieses Verhalten wird f\u00fcr Integrit\u00e4tsfehler ausschlie\u00dflich bei NOT NULL, PRIMARY KEY, UNIQUE ausgef\u00fchrt. \n\nLediglich die Fremdschl\u00fcssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabh\u00e4ngig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik,wenn Masterdatens\u00e4tze gel\u00f6scht werden, f\u00fcr die noch abh\u00e4ngige Detail-Datens\u00e4tze bestehen. Es besteht dann die M\u00f6glichkeit, z.B. die abh\u00e4ngigen Detaildatens\u00e4tze ebenfalls zu l\u00f6schen (CASCADE) oder deren Fremdschl\u00fcsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION", "type": "multiple-choice", "answers": [{"text": "CHECK (Bedingung)", "solution": "false"}, {"text": "PRIMARY KEY", "solution": "false"}, {"text": "FOREIGN KEY", "solution": "true"}, {"text": "NOT NULL", "solution": "false"}, {"text": "UNIQUE", "solution": "false"}]}, {"id": 1376, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber CONSTRAINTS sind wahr?", "explanation": "Die zwei richtigen Aussagen erkl\u00e4ren sich selbst. \nFALSCH ist: \nDie Sache mit dem \"MANDATORY-CONSTRAINT\". Ein Constraint dieses Namens gibt es nicht. Das Constraint mit der gew\u00fcnschten Funktion hei\u00dft: NOT NULL bei SQL.", "type": "multiple-choice", "answers": [{"text": "F\u00fcr im ER-Modell als \"obligatorisch\" (Pflichteingabe) deklarierte Attribute werden im Datenmodell MANDATORY-CONSTRAINTS definiert.", "solution": "false"}, {"text": "Die Standardreaktion auf einen Integrit\u00e4tsfehler beim \"integrity checking\" mittels Constraints ist das Zur\u00fcckrollen des fehlerhaften DML-Befehls (Pr\u00fcfungsmodus IMMEDIATE) bzw. der gesamten Transaktion beim Pr\u00fcfungsmodus DEFERRED.", "solution": "true"}, {"text": "Transitionale Integrit\u00e4tsbedingungen k\u00f6nnen in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Referenzvariablen (:OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.", "solution": "true"}]}, {"id": 2106, "category": 9, "difficulty": 2, "text": "Was versteht man unter \"Dangling-Datens\u00e4tzen\" in SQL?", "explanation": "Werden Fremdschl\u00fcssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datens\u00e4tze, die noch von Detail-Datens\u00e4tze referenziert werden, gel\u00f6scht oder deren Schl\u00fcsselwert ge\u00e4ndert wird und das anschlie\u00dfend Detail-Datens\u00e4tze existieren, f\u00fcr deren Fremdschl\u00fcsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt. \nDas Einf\u00fcgen von Master-Datens\u00e4tzen ist immer unproblematisch, da eine Fremdschl\u00fcsselbedingung es zul\u00e4\u00dft, dass es Master-Datens\u00e4tze gibt, f\u00fcr die es keine Detail-Datens\u00e4tze gibt. \n\nAnaloge Probleme k\u00f6nnen bei Join-Operationen (Theta, Equi, Natural) auftreten. In die Ergebnismenge werden nur die Datens\u00e4tze aufgenommen, die die Verkn\u00fcpfungsbedingung erf\u00fcllen. Alle anderen fallen heraus, das sind die sog. \"dangling tuples\". Will man diese auch anzeigen lassen, muss man mit LEFT/RIGHT/FULL OUTER JOINs arbeiten.", "type": "multiple-choice", "answers": [{"text": "Datens\u00e4tze, die nicht gesichert werden.", "solution": "false"}, {"text": "Datens\u00e4tze, denen bei Join-Operationen bzw. bei Fremdschl\u00fcsselbeziehungen die entsprechenden Datens\u00e4tze in der anderen Tabelle fehlen, mit denen sie verkn\u00fcpft werden k\u00f6nnen.", "solution": "true"}, {"text": "Datens\u00e4tze, denen Attributwerte fehlen.", "solution": "false"}, {"text": "Ge\u00e4nderte Datens\u00e4tze, deren Transaktion noch nicht abgeschlossen ist.", "solution": "false"}]}, {"id": 2073, "category": 9, "difficulty": 1, "text": "Welcher Join-Tabellen-Typ hat eine ON-Klausel?", "explanation": "Beim CROSS JOIN, dem kartesischen Produkt, gibt es gar keine Verkn\u00fcpfungsbedingung. Jeder Datensatz der einen Relation wird \"grundlos\" mit jedem anderen aus der anderen Relation verkn\u00fcpft.\nBeim NATURAL JOIN gibt es zwar eine Bedingung, aber die ist vordefiniert, so dass sie nicht mittels USING spezifiziert werden muss. Die vordefinierte Bedingung hei\u00dft: Alle Spalten mit gleichen Namen werden auf Gleichheit verglichen und die Teilbedingungen ggf. mit AND verkn\u00fcpft.\nLediglich beim THETA JOIN wird eine Bedingung angegeben.", "type": "multiple-choice", "answers": [{"text": "CROSS-Join", "solution": "false"}, {"text": "THETA-Join", "solution": "true"}, {"text": "NATURAL-Join", "solution": "false"}]}, {"id": 2702, "category": 9, "difficulty": 3, "text": "Unter welchen Voraussetzungen kann bei der Programmierung von SELECT INTO-Anweisungen auf die eine oder andere EXCEPTION, die \u00fcblicherweise immer im Zusammenhang mit SELECT-INTOs zu programmieren sind, ganz sicher verzichtet werden?", "explanation": "SELECT INTO \u00fcbergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datens\u00e4tze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datens\u00e4tze verarbeiten kann.\n\n    \n\n    Es reicht nicht aus, wenn in Tabellen Datens\u00e4tze vorhanden sind. Relevant ist, dass immer wdenigstens ein Datensatz gefunden wird, um auf die NO_DATA_FOUND verzichten zu k\u00f6nnen.\n\n    \n\n    Werden Anfragen \u00fcber Prim\u00e4r- oder Eindeutigkeitsschl\u00fcssel an eine einzige Tabelle formuliert, steht fest, dass es keine TOO_MANY_ROWS geben kann.\n\n    \n\n    Werden Anfragen \u00fcber Prim\u00e4r- oder Eindeutigkeitsschl\u00fcssel an die Detail-Tabelle von Joins formuliert, die mittels Fremdschl\u00fcsseln verknp\u00fcft sind, so steht fest, dass es keine TOO_MANY_ROWS geben kann.\n\n    \n\n    Aggregatfunktionen haben die Eigenschaft, dass sie je Gruppe nur einen Ergenbisdatensatz liefern. Steht also zwingend fest, dass es nur eine Gruppe gibt - z.B. bei fehlender Gruppierung nur \u00fcber die GEsamtmenge - dann kann auch auf die TOO_MANY_ROWS verzichtet werden.", "type": "multiple-choice", "answers": [{"text": "Wenigstens eine der beteiligten Tabellen enth\u00e4lt Datens\u00e4tze.", "solution": "false"}, {"text": "Die Anfrage liefert immer wenigstens einen Datensatz.", "solution": "true"}, {"text": "Es wird bei Anfragen ohne JOINs in der WHERE-Klausel \u00fcber die Prim\u00e4rschl\u00fcssel der beteiligten Tabelle zugegriffen.", "solution": "true"}, {"text": "Es wird bei Anfragen mit JOINs in der WHERE-Klausel \u00fcber die Fremdschl\u00fcssel verkn\u00fcpft und \u00fcber die Prim\u00e4rschl\u00fcssel bei den Detail-Tabellen eingeschr\u00e4nkt.", "solution": "true"}, {"text": "Es wird bei Anfragen ohne JOINs in der WHERE-Klausel \u00fcber die UNIQUE-Schl\u00fcssel der beteiligten Tabelle zugegriffen.", "solution": "true"}, {"text": "Alle beteiligten Tabellen enthalten Datens\u00e4tze.", "solution": "false"}, {"text": "Es wird bei Anfragen mit JOINs in der WHERE-Klausel \u00fcber die Fremdschl\u00fcssel verkn\u00fcpft und \u00fcber die UNIQUE-Schl\u00fcssel der Detail-Tabellen eingeschr\u00e4nkt.", "solution": "true"}, {"text": "Wenn in der SELECT-Klausel Aggregatfunktionen ohne Gruppierung verwendet werden.", "solution": "true"}, {"text": "Wenn in der SELECT-Klausel Aggregatfunktionen verwendet werden.", "solution": "false"}]}, {"id": 1301, "category": 11, "difficulty": 3, "text": "Welche Aussagen \u00fcber \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?", "explanation": "FALSCH ist:  \n\"Non repeatable read\" und \"phantome\" sind zwei eng verwandte Probleme. Bei beiden geht es darum, dass die eine Anwendung die gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausf\u00fchrt und dann ggf. auf unterschiedlichen Datenbankzust\u00e4nden ausf\u00fchrt, weil eine andere Transaktion Datens\u00e4tze eingef\u00fcgt oder ge\u00e4ndert hat.\"  \nDie Aussage ist richtig bis auf den Teil: \"...gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausf\u00fchrt...\" Ganz:-) richtig wird die Aussage, wenn man das \"zwei verschiedene Transaktionen\" durch \"eine Transaktion\" ersetzt.\n  \n\nRICHTIG sind die anderen beiden Aussagen.", "type": "multiple-choice", "answers": [{"text": "\"Non repeatable read\" und \"phantome\" sind zwei eng verwandte Probleme. Bei beiden geht es darum, dass die eine Anwendung die gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausf\u00fchrt und dann ggf. auf unterschiedlichen Datenbankzust\u00e4nden ausf\u00fchrt, weil eine andere Transaktion Datens\u00e4tze eingef\u00fcgt oder ge\u00e4ndert hat.", "solution": "false"}, {"text": "\"Dirty reads\" treten auf, wenn eine z.B. Transaktion T1 Datens\u00e4tze liest und verarbeitet, die eine andere Transaktion T2 zwar ge\u00e4ndert aber nicht \"committet\" hat und T2 sp\u00e4ter mit einem Rollback abgeschlossen wird.", "solution": "true"}, {"text": "Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und \u00fcberschreibt somit die \u00c4nderungen von T2 ungesehen.", "solution": "true"}]}, {"id": 1595, "category": 11, "difficulty": 2, "text": "Welche Aussagen \u00fcber \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?", "explanation": "Alle drei Antworten sind richtig.", "type": "multiple-choice", "answers": [{"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.", "solution": "true"}, {"text": "Beim \"pessimistischen\" LOCK-Verfahren l\u00f6sen auch lesende Zugriffe Sperren f\u00fcr andere Benutzer aus. Die Daten werden erst wieder freigegeben, wenn alle \u00c4nderungen gespeichert sind. Nachteil des pessimistischen Verfahrens ist, dass andere Transaktionen oft unn\u00f6tig lange auf die Freigabe von Daten warten m\u00fcssen. Das parallele Arbeiten vieler Benutzer kann dadurch sehr eingeschr\u00e4nkt sein.", "solution": "true"}, {"text": "Beim \"optimistischen\" LOCK-Verfahren l\u00f6sen lesende Zugriffe keine Sperren aus. Jede Tabelle verf\u00fcgt \u00fcber einen Zeitstempel, der den Zeitpunkt der letzten \u00c4nderung angibt. Bei Daten\u00e4nderungen wird zun\u00e4chst gepr\u00fcft, der Zeitstempel der Tabelle noch der gleiche ist wie beim Lesen der Daten. Ist dies der Fall, dann sind die Daten der Tabelle seit dem Lesen unver\u00e4ndert und die \u00c4nderungen k\u00f6nnen gespeichert werden.", "solution": "true"}]}, {"id": 1112, "category": 11, "difficulty": 1, "text": "Welche Aussagen \u00fcber Transaktionen und Integrit\u00e4tspr\u00fcfung in SQL sind richtig?", "explanation": "RICHTIG sind:\n\"IMMEDIATE bezeichnet die Integrit\u00e4tspr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung des DML-Befehls und DEFERRED erst zum Transaktionsende.\"\n\n\"In SQL gibt es 5 CONSTRAINTs mittels denen die Datenintegrit\u00e4t gesichert werden kann: [NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.\"\n\nFALSCH sind: \n\"Wird vom DBMS ein Fehler bei der IMMEDIATE-Integrit\u00e4tspr\u00fcfung erkannt, so wird die gesamte Transaktion zur\u00fcckgerollt.\" Bei einem IMMEDIATE-Fehler wird nur die eine fehlerhafte DML-Anweisung r\u00fcckg\u00e4ngig gemacht. \n\n\"Wird vom DBMS ein Fehler bei der DEFERRED-Integrit\u00e4tspr\u00fcfung erkannt, so wird nur der fehlerhafte DML-Befehl zur\u00fcckgerollt.\" Bei einem DEFERRED-Fehler wird die gesamte Transaktion zur\u00fcckgerollt.", "type": "multiple-choice", "answers": [{"text": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integrit\u00e4tspr\u00fcfung erkannt, so wird die gesamte Transaktion zur\u00fcckgerollt.", "solution": "false"}, {"text": "Wird vom DBMS ein Fehler bei der DEFERRED-Integrit\u00e4tspr\u00fcfung erkannt, so wird nur der fehlerhafte DML-Befehl zur\u00fcckgerollt.", "solution": "false"}, {"text": "IMMEDIATE bezeichnet die Integrit\u00e4tspr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung des DML-Befehls und DEFERRED erst zum Transaktionsende.", "solution": "true"}, {"text": "In SQL gibt es 5 CONSTRAINTs mittels denen die Datenintegrit\u00e4t gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.", "solution": "true"}]}]