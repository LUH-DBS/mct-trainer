[{"id": 1930, "category": 9, "difficulty": 2, "text": "Jeder Column-Constraint (Spaltenbedingung) kann auch als Table-Constraint (Tabellenbedingung) geschrieben werden.", "explanation": "Ein Column-Constraint unterscheidet sich von einem Table-Constraint durch die Stellung im SQL-Befehl: \nDer Columns-Constraint wird durch ein Komma von der Spaltendefinition abgetrennt und kann sich nur auf einen Spalte beziehen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1931, "category": 9, "difficulty": 3, "text": "Mit welchem Isolationsgrad (Konstante der Methode setTransactionIsolation des Interfaces connection in JDBC) werden bei lesenden Transaktionen keine Sperren ausgel\u00f6st?", "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgef\u00fchrt.", "type": "text", "answers": [{"text": "Der Isolationsgrad hei\u00dft", "solution": "TRANSACTION_READ_UNCOMMITED"}]}, {"id": 1932, "category": 9, "difficulty": 1, "text": "Tabellenname%ROWTYPE definiert in PL/SQL einen RECORD.", "explanation": "Mit Tabellenname%ROWTYPE wird die Attributstruktur einer Tabelle komplett an einen PL/SQL-Rekord \u00fcbertragen und dynamisch angepasst. wenn sich dien Tabellendefinition \u00e4ndert. Mit Tabellenname.Spaltenname%TYPE kann man eine Variable entsprechend der Spalte einer Tabelle definieren.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1960, "category": 9, "difficulty": 2, "text": "Wenn zwei Relationen R und S in SQL mit einem Natural Join verbunden werden, dann", "explanation": "Ein Natural Join verkn\u00fcpft nach Definition alle Tupel von zwei Tabellen \u00fcber gleichnamige Attribute.", "type": "multiple-choice", "answers": [{"text": "muss Relation R mehr Tupel als Relation S beinhalten", "solution": "false"}, {"text": "ermittelt man alle Tupel aus R und S, die \u00fcbereinstimmen", "solution": "false"}, {"text": "sollten die Relationen R und S mindestens ein gleich bezeichnetes Attribut haben.", "solution": "true"}]}, {"id": 1961, "category": 9, "difficulty": 2, "text": "F\u00fcr die JDBC-Klasse Connection gilt:", "explanation": "Ein JAVA-Programm kann eine oder mehrere Verbindungen zu einer oder mehreren Datenbanken unterhalten. \nJede Verbindung wird durch ein Objekt realisiert, das das Interface Connection implementiert. \nDieses Interface definiert unter anderem folgende Methoden: \nMit der Methode createStatement() kann ein Objekt, welches das Interface Statement implementiert, erzeugt werden.  Analog dazu wird mit der Methode prepareStatement(String sql) eine Anweisung vorbereitet.  Durch den Aufruf von setAutoCommit(boolean) wird der Autocommit-Modus der Verbindung an- oder ausgeschaltet.  \n- Mit getAutoCommit() wird gepr\u00fcft, welcher Modus vorliegt. \n- Mit close() wird die Verbindung explizit geschlossen, \n- mit isClosed() kann dies nachgepr\u00fcft werden.", "type": "multiple-choice", "answers": [{"text": "Sie verwaltet die Datenbankverbindung.", "solution": "true"}, {"text": "Mit ihrer Methode close wird die Datenbankverbindung geschlossen.", "solution": "true"}, {"text": "Sie enth\u00e4lt eine Methode rollback, mit der laufende Transaktionen\nabgebrochen werden k\u00f6nnen.", "solution": "true"}, {"text": "Mit ihrer Methode commit kann der Auto-Commit-Modus deaktiviert\nwerden.", "solution": "false"}]}, {"id": 1962, "category": 9, "difficulty": 3, "text": "F\u00fcr die JDBC-Schnittstelle (Interface) Statement gilt:", "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface. CallableStatement  und PreparedStatement k\u00f6nnen Parameter mit dem Platzhalter \"?\" aufnehmen.", "type": "multiple-choice", "answers": [{"text": "Sie ist Oberklasse von PreparedStatement.", "solution": "true"}, {"text": "Sie ist Unterklasse von CallableStatement.", "solution": "false"}, {"text": "Sie kann nur SQL-Anweisungen verarbeiten, die keine Daten zur\u00fcckliefern.", "solution": "false"}, {"text": "Mit ihrer Methode executeUpdate k\u00f6nnen Relationen auf der\nDatenbank erstellt werden.", "solution": "true"}, {"text": "Die Klasse liefert stets ein ResultSet zur\u00fcck.", "solution": "false"}]}, {"id": 1979, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche Anfragen liefern das gleiche Ergebnis?", "explanation": "RICHTIG sind: \nDie Anfragen \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nund \n\"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\"\nhaben die gleiche Semantik: \"Welche Mitarbeiter sind Leiter einer Abteilung?\"\n\nOb Fremd-, E\u00edndeutigkeits- oder Prim\u00e4rschl\u00fcssel auf diesen Spalten definiert sind, ist unerheblich f\u00fcr die Ausf\u00fchrung des NATURAL JOINs, dessen Bedingung alle gleich lautenden Spalten auf Gleichheit pr\u00fcft und mit AND verkn\u00fcpft.\n\n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ort = Abteilungen.Standort AND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter wohnen am gleichen Ort, an dem sie auch arbeiten?\".\n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\".", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Standort\nAND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "true"}, {"text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1929, "category": 9, "difficulty": 2, "text": "Jeder Table-Constraint (Tabellenbedingung) kann auch als Column-Constraint (Spaltenbedingung) geschrieben werden.", "explanation": "Ein COLUMN-Constraint kann sich nur auf eine Spalte beziehen, ein TABLE-Constraint auch auf mehrere Spalten. Der einzige Column-Constraint, der nicht als TABLE-Constraint geschrieben werden kann, ist der (NOT)-NULL-CONSTRAINT.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2017, "category": 5, "difficulty": 1, "text": "Welche Aussagen \u00fcber Beziehungen in ER-Modellen sind wahr?", "explanation": "In ERM ist eine Beziehung als Teilmenge des kartesischen Produkts der beteiligten Entity-Mengen definiert.", "type": "multiple-choice", "answers": [{"text": "Eine Beziehung ist eine Obermenge des kartesischen Produkts von Entity-Mengen.", "solution": "false"}, {"text": "Eine Beziehung ist eine Teilmenge des kartesischen Produkts von Entity-Mengen.", "solution": "true"}, {"text": "Eine Beziehung ist das kartesischen Produkts von Entity-Mengen.", "solution": "false"}]}, {"id": 2019, "category": 7, "difficulty": 2, "text": "Welche Aussagen \u00fcber Normalformen sind wahr?", "explanation": "Wiederherstellbarkeit: Eine Zerlegung einer Relation ist verlustfrei, wenn sich alle Tupel der urspr\u00fcnglichen Relation durch einen Join aus den abgeleiteten Relationen wiederherstellen lassen. Eine verlustfreie Zerlegung stellt damit die Wiederherstellbarkeit der urspr\u00fcnglichen Relation sicher. \nAbh\u00e4ngigkeitswahrung: Die Zerlegung einer Relation ist abh\u00e4ngigkeitstreu, wenn jede funktionale Abh\u00e4ngigkeit der Ausgangsrelation in einer der resultierenden Relationen erhalten bleibt. Eine abh\u00e4ngigkeitstreue Zerlegung stellt damit die Wiederherstellbarkeit der urspr\u00fcnglichen funktionalen Abh\u00e4ngigkeiten sicher. \nEine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "Eine Zerlegung einer Relation ist abh\u00e4ngigkeitstreu, wenn sich alle Tupel der urspr\u00fcnglichen Relation durch einen Join aus den abgeleiteten Relationen wiederherstellen lassen.", "solution": "false"}, {"text": "Eine Zerlegung einer Relation ist verlustfrei, wenn sich alle Tupel der urspr\u00fcnglichen Relation durch einen Join aus den abgeleiteten Relationen wiederherstellen lassen.", "solution": "true"}, {"text": "Die 2NF beseitigt alle partiellen Abh\u00e4ngigkeiten", "solution": "true"}, {"text": "Die 3NF beseitigt alle partiellen Abh\u00e4ngigkeiten", "solution": "false"}, {"text": "Die 2NF beseitigt alle transitiven Abh\u00e4ngigkeiten", "solution": "false"}, {"text": "Die 3NF beseitigt alle transitiven Abh\u00e4ngigkeiten", "solution": "true"}]}, {"id": 1927, "category": 5, "difficulty": 1, "text": "Rekursive Beziehungen sind immer un\u00e4r.", "explanation": "Da rekursive Beziehungen von einer Entity-Menge auf sich selber definiert sind, sind sie un\u00e4r, d.h. nur eine Entity-Menge ist beteiligt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2015, "category": 5, "difficulty": 1, "text": "Eine Aggregation ist ein Spezialfall einer 1:c-Beziehung", "explanation": "Die Aggregation beschreibt eine \"Ist Teil von-Beziehung\" und ist daher \nein Spezialfall einer 1:n-Modellierung mit eigener Semantik.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2016, "category": 5, "difficulty": 1, "text": "Eine Aggregation ist ein Spezialfall einer 1:n-Beziehung", "explanation": "Die Aggregation beschreibt eine \"Ist Teil von-Beziehung\" und ist daher \nein Spezialfall einer 1:n-Modellierung mit eigener Semantik.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1987, "category": 9, "difficulty": 1, "text": "In der relationalen Algebra gibt es wie unter SQL die M\u00f6glichkeit, Daten \u00fcber eine dem ORDER-BY \u00e4hnlichem Konstrukt zu sortieren.", "explanation": "Neben dem zentralen Unterschied zwischen Relationaler Algebra und SQL\n\nRA: nur Mengen von Datens\u00e4tzen mit automatischer Duplikatelimination\nSQL: Multimengen von Datens\u00e4tzen mit Duplikaten\n\ngibt es einen weiteren: \n\nSQL: Sortierung m\u00f6glich\nRA:  keine Sortierung m\u00f6glich", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1908, "category": 11, "difficulty": 1, "text": "Bei welcher Sperrstrategie l\u00f6sen lesende Zugriffe keine Sperren aus?", "explanation": "Optimistisches Sperrverfahren \n\nMan nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden.\nLesende Zugriffe (SELECT) l\u00f6sen keine Sperren aus.\nJeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird.\nBei \u00c4nderungen wird zun\u00e4chst gepr\u00fcft, ob der Zeitstempel unver\u00e4ndert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unver\u00e4ndert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.\n\n\nPessimistisches Sperrverfahren\nMan nimmt an, dass viele schreibende Zugriffe auf der Datenbank stattfinden.\nAuch lesende Zugriffe (SELECT FOR UPDATE statt SELECT) l\u00f6sen Sperren f\u00fcr andere Benutzer aus.\nDie Daten werden erst wieder freigegeben, wenn alle \u00c4nderungen abgespeichert sind.", "type": "multiple-choice", "answers": [{"text": "Optimistische Sperrstrategie", "solution": "true"}, {"text": "Pessimistische Sperrstrategie", "solution": "false"}]}, {"id": 2108, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche SELECT-Abfrage entspricht dem nat\u00fcrlichen Join?", "explanation": "RICHTIG sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist ein Natural Join, weil \u00fcber die einzige Spalte dieser Tabellen, die gleich hei\u00dft, Abt_Nr, auf Gleichheit verglichen wird. \n\nWie das Schl\u00fcsselwort es sagt, hier wird ein nat\u00fcrlicher JOIN ausgef\u00fchrt: \"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\" \n\nDie Semantik dieses nat\u00fcrlichen Joins hei\u00dft: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\" \n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verkn\u00fcpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN weil \u00fcber zwei Spalten verkn\u00fcpft wird, die nicht gleich hei\u00dfen: \"Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr\".", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen;", "solution": "false"}, {"text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "true"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2344, "category": 42, "difficulty": 1, "text": "Ein innerer Knoten mit n Eintr\u00e4gen eines B-Baums vom Typ k hat wie viele Nachfolger?", "explanation": "Nach Definition des B-Baumes hat ein Knoten mit n Eintr\u00e4gen (n+1) Nachfolger.", "type": "text", "answers": [{"text": "Die Anzahl der Nachfolger ist:", "solution": "n+1"}]}, {"id": 2346, "category": 9, "difficulty": 3, "text": "Nach einer objektorientierten Analyse z.B. mit UML wird mittels einem objektorientiertem DBS implementiert.", "explanation": "Dieser Weg (OO-Analyse/Design -> OO-Implementierung) ist in der Tat in der Praxis recht selten. Meist nur dort, wo die OO-Anforderungen absolut zentral und zwingend sind, wie z.B. bei GIS (geo information system) und CAD (computer aidet design), ...\nDie Gr\u00fcnde sind vielf\u00e4ltig. Datenbanksysteme spielen eine sehr zentrale Rolle im unternehmerischen und beh\u00f6rdlichen Alltag, die tauscht man nicht mal eben so aus - nur wegen eines Paradigmenwechsels. Die Hersteller relationer DBS erweitern ihre Systeme ja auch immer mehr in Richtung OR/OO, so dass die Diskrepanz zwischen Design und Implementierung nicht mehr so gro\u00df ist.", "type": "multiple-choice", "answers": [{"text": "Dieser Weg ist in der Praxis kaum zu finden.", "solution": "true"}, {"text": "Dieser Weg ist relativ unproblematisch.", "solution": "true"}, {"text": "Dieser Weg beinhaltet das Impendance Mismatch-Problem und erfordert OR-Mapping.", "solution": "false"}]}, {"id": 2347, "category": 9, "difficulty": 1, "text": "F\u00fcr VARRAY-Datentypen wird bei der Definition eine maximale Anzahl an Eintr\u00e4gen vorgegeben.", "explanation": "Das ist die Definition eines Oracle-VARRAYS.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2348, "category": 9, "difficulty": 1, "text": "F\u00fcr NESTED TABLE-Datentypen wird bei der Definition eine maximale Anzahl an Eintr\u00e4gen vorgegeben.", "explanation": "NESTED TABLE \nMit der STORE-Klausel k\u00f6nnen tabellenwertige Spalten beschrieben werden. F\u00fcr jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher inneren Tabelle die tabellenwertigen Spalten abgelegt werden. Der Kollektionstyp kann dabei wieder auf einem benutzerdefinierten Datentyp aufsetzen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2357, "category": 9, "difficulty": 3, "text": "Mit welchem Methodenaufruf wird bei JDBC eine Verbindung zur Datenbank hergestellt? Bitte geben Sie den f\u00fcr den Aufruf notwendigen Klassennamen, Methodennamen, sowie die Parameter (in englisch) in der Aufrufreihenfolge.", "explanation": "import java.sql; \ntry{ \n//1. Oracle JDBC Treiber laden bzw. dem DriverManager bekannt machen \nClass.forName(\"oracle.jdbc.driver.OracleDriver\"); \n//2. Verbindung herstellen \nConnection v_connection =  \n  DriverManager.getConnection( \n         \"jdbc:oracle:thin:@localhost:1521:dbname\");", "type": "text", "answers": [{"text": "Das ist der Methodenaufruf:", "solution": "DriverManager.getConnection(url,user,password)"}]}, {"id": 2371, "category": 42, "difficulty": 1, "text": "Was passiert bei B-B\u00e4umen, wenn neue Datens\u00e4tze in einen vollen Knoten eingef\u00fcgt werden?", "explanation": "Bei B-B\u00e4umen entstehen keine \u00dcberlaufseiten (wie bei der ISAM- und der HASH-Speicherstruktur) und es gibt auch keine verketteten Listen wie bei der HEAP-Speicherstruktur.", "type": "multiple-choice", "answers": [{"text": "Wenn der Knoten voll ist, wird eine zus\u00e4tzliche \u00dcberlaufseite angelegt.", "solution": "false"}, {"text": "Wenn der Knoten voll ist, wird der Knoten \"gesplittet\".", "solution": "true"}, {"text": "Das ist kein Problem, da Datens\u00e4tze als verkettete Liste immer hinten angef\u00fcgt werden.", "solution": "false"}]}, {"id": 2372, "category": 42, "difficulty": 1, "text": "Was passiert bei der Speicherart HEAP, wenn neue Datens\u00e4tze eingef\u00fcgt werden?", "explanation": "Bei der HEAP-Struktur gibt es keine \u00dcberlaufseiten und auch kein Splitten von Bl\u00f6cken, da die Datens\u00e4tze einfach in Form einer verketteten Liste angef\u00fcgt werden.", "type": "multiple-choice", "answers": [{"text": "Wenn der Block voll ist, wird eine zus\u00e4tzliche \u00dcberlaufseite angelegt.", "solution": "false"}, {"text": "Wenn der Block voll ist, wird der Block \"gesplittet\".", "solution": "false"}, {"text": "Das ist kein Problem, da Datens\u00e4tze als verkettete Liste immer hinten angef\u00fcgt werden.", "solution": "true"}]}, {"id": 2373, "category": 42, "difficulty": 1, "text": "Was passiert bei der Speicherstruktur ISAM, wenn neue Datens\u00e4tze in einen vollen Block eingef\u00fcgt werden?", "explanation": "Die Daten werden bei dwr ISAM-Speicherstruktur \u00fcber die Indexspalte(n) aufsteigend sortiert. Aus jedem Block wird der gr\u00f6\u00dfte Schl\u00fcsselwert als Repr\u00e4sentant vermerkt und in einer gesonderten Struktur, dem Index abgelegt. Der Index ordnet also jedem Block ein Intervall der m\u00f6glichen Schl\u00fcsselwerte zu. Wenn auf der Seite noch Platz ist, wird der Datensatz einfach einsortiert und gespeichert. Wenn die Seite schon gef\u00fcllt ist, wird ein noch freier Block aus einem \u00dcberlaufbereich als \u00dcberlaufseite angekettet. Weitere neue Datens\u00e4tze, die zu diesem Schl\u00fcsselbereich geh\u00f6ren, werden dann unsortiert in die \u00dcberlaufseite geschrieben.", "type": "multiple-choice", "answers": [{"text": "Es wird eine zus\u00e4tzliche \u00dcberlaufseite angelegt.", "solution": "true"}, {"text": "Es wird der Block \"gesplittet\".", "solution": "false"}, {"text": "Das ist kein Problem, da Datens\u00e4tze als verkettete Liste immer hinten angef\u00fcgt werden.", "solution": "false"}]}, {"id": 2374, "category": 42, "difficulty": 1, "text": "Was passiert bei der Speicherstruktur HASH, wenn neue Datens\u00e4tze in einen vollen Block eingef\u00fcgt werden?", "explanation": "Das Splitten von Bl\u00f6cken geschieht in der B-Baum-Speicherstruktur, HEAP-Strukturen sind als lineare Liste angelegt.", "type": "multiple-choice", "answers": [{"text": "Es wird eine zus\u00e4tzliche \u00dcberlaufseite angelegt.", "solution": "true"}, {"text": "Es wird der Block \"gesplittet\".", "solution": "false"}, {"text": "Das ist kein Problem, da Datens\u00e4tze als verkettete Liste immer hinten angef\u00fcgt werden.", "solution": "false"}]}, {"id": 2376, "category": 9, "difficulty": 3, "text": "Es sei folgende Methodendefinition gegeben:\n  CREATE OR REPLACE TYPE BODY kdtm AS\n  STATIC FUNCTION get_plzort (p_plz IN NUMBER, p_ort IN VARCHAR2) \n  RETURN VARCHAR2 IS \n  BEGIN      RETURN (p_plz || p_ort);      END;\n  END;\nMit welchem/n Befehl/en kann man bei Oracle diese Methode aufrufen?", "explanation": "SELECT kdtm.get_plzort(k.plz,k.ort) FROM kunden k WHERE name = \"Meier\";   ist der korrekte Aufruf einer Static-Funktion.", "type": "multiple-choice", "answers": [{"text": "SELECT kdtm.get_plzort(k.plz,k.ort) FROM kunden k WHERE name = \"Meier\";", "solution": "true"}, {"text": "SELECT k.get_plzort(k.plz, k.ort) FROM kunden k WHERE name = \"Meier\";", "solution": "false"}, {"text": "SELECT k.get_plzort() FROM kunden k WHERE name = \"Meier\";", "solution": "false"}, {"text": "SELECT k.get_plzort FROM kunden k WHERE name = \"Meier\";", "solution": "false"}]}, {"id": 2377, "category": 9, "difficulty": 2, "text": "Welche Eigenschaften hat eine relationale Tabelle?", "explanation": "Welche Tabellenformen kann es in einem ORDBMS geben?\n\nDefinitionsart: untypisiert vs. typisiert \n- Untypisiert: die Struktur ergibt sich direkt aus den Attributstrukturen (RM)\n- Typisiert: Tabellendefinition basiert auf benutzerdefinierten Typ (OR)\n\nZeilentyp: tupelwertig vs. objektwertig \n- Tupelwertig: keine Methodenaufrufe f\u00fcr ein konkretes Tupel (RM)\n- Objektwertig: Methodenaufrufe des zugeh\u00f6rigen Objekttyps direkt \u00fcber die Zeilenvariable (OR)\n\nReferenzierbarkeit: nicht referenzierbar vs. referenzierbar  \n- Nicht referenzierbar: Zeilen sind nicht referenzierbar (RM)\n- Referenzierbar: Zeilen sind mittels Referenzspalten (OIDs) referenzierbar; setzt OIDs voraus (OR)\n\n\nRelationale Tabellen sind: \n- tupelwertig, \n- untypisiert, \n- nicht referenzierbar\n\nObjektorientierte/objektrelationale Klassen/Tabellen sind: \n- objektwertig, \n- typisiert, \n- referenzierbar", "type": "multiple-choice", "answers": [{"text": "Typisiert", "solution": "false"}, {"text": "Untypisiert", "solution": "true"}, {"text": "Tupelwertig", "solution": "true"}, {"text": "Objektwertig", "solution": "false"}, {"text": "Referenzierbar", "solution": "false"}, {"text": "Nicht referenzierbar", "solution": "true"}]}, {"id": 2392, "category": 9, "difficulty": 3, "text": "Die Definition objektrelationaler Sichten kann basieren auf:", "explanation": "RICHTIG sind: OR-Sichten lassen sich auf relationalen Tabellen und Sichten sowie auch auf objektrelationalen Tabellen und Sichten definieren. \n \nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht \u00fcber beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "Relationalen Tabellen", "solution": "true"}, {"text": "Objektrelationalen Tabellen", "solution": "true"}, {"text": "Relationalen Sichten", "solution": "true"}, {"text": "Objektrelationalen Sichten", "solution": "true"}, {"text": "Keine dieser Antworten ist richtig.", "solution": "false"}]}, {"id": 418, "category": 5, "difficulty": 1, "text": "ER-Modell: Um welchen Beziehungstyp handelt es sich hier?\nEin Student kann keine oder nur eine Vorlesung h\u00f6ren und eine Vorlesung kann von keinem oder nur von einem Studenten besucht werden.", "explanation": "Das ist die Definition einer c:c-Beziehung, auch wenn dieser Beziehungstyp im Beispiel wenig Sinn als Abbild der Realit\u00e4t macht.", "type": "multiple-choice", "answers": [{"text": "1:1", "solution": "false"}, {"text": "c:1", "solution": "false"}, {"text": "1:c", "solution": "false"}, {"text": "c:c", "solution": "true"}]}, {"id": 422, "category": 5, "difficulty": 1, "text": "Rekursive Beziehungen sind in ER-Diagrammen erlaubt.", "explanation": "Im ER-Modell sind auch rekursive Beziehungen erlaubt, d.h. Beziehungen einer Entity-Menge auf sich selbst. Rekursive Beziehungen sind also immer un\u00e4r, da nur eine Entity-Menge beteiligt ist.  Mittels der Rekursion lassen sich z.B. Vorgesetzte, St\u00fccklisten oder Stammb\u00e4ume mit unbekannter Tiefe modellieren.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1119, "category": 5, "difficulty": 1, "text": "In obligatorischen Attributen (ER-Modell) sind NULL-Werte erlaubt.", "explanation": "Obligatorisch bedeutet, dass das Attribut einen Wert haben muss, also nicht NULL sein darf.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1576, "category": 42, "difficulty": 2, "text": "Welche Speicherstruktur eignet sich gut f\u00fcr gro\u00dfe Datenbest\u00e4nde, die h\u00e4ufig \u00c4nderungen unterworfen sind?", "explanation": "Die B-B\u00e4ume und B+-B\u00e4ume passen sich bei ver\u00e4nderlichen Daten optimal an den Datenbestand an, da die Indexb\u00e4ume dynamisch nach oben wachen und keine \u00dcberlaufseiten entstehen.", "type": "multiple-choice", "answers": [{"text": "HEAP", "solution": "false"}, {"text": "ISAM", "solution": "false"}, {"text": "B+ -Baum", "solution": "true"}, {"text": "HASH", "solution": "false"}, {"text": "B-Baum", "solution": "true"}]}, {"id": 1578, "category": 42, "difficulty": 2, "text": "Welche Speicherstruktur wird bei Oracle automatisch angelegt, wenn eine Tabelle ohne Prim\u00e4rschl\u00fcssel erzeugt wird?", "explanation": "Bei HEAP wird in der zeitlichen Reihenfolge gespeichert, mit der die Daten erfasst werden. Eine Ordnung gem\u00e4\u00df einem Schl\u00fcssel ist nicht m\u00f6glich. \nBei den drei anderen Speicherformen B-Baum, HASH, ISAM wird ein Schl\u00fcssel ben\u00f6tigt.", "type": "multiple-choice", "answers": [{"text": "ISAM", "solution": "false"}, {"text": "HEAP", "solution": "true"}, {"text": "HASH", "solution": "false"}, {"text": "B-Baum", "solution": "false"}]}, {"id": 1579, "category": 42, "difficulty": 3, "text": "Welche Speicherstruktur wird automatisch angelegt, wenn eine Tabelle mit Prim\u00e4rschl\u00fcssel unter ORACLE erzeugt wird?", "explanation": "Bei Oracle wird f\u00fcr eine Tabelle mit Prim\u00e4rschl\u00fcssel automatisch B+-Baum als Speicherstruktur angewendet. Hier wird vor allem Wert auf einen \u00e4u\u00dferst schnellen Zugriff f\u00fcr imens gro\u00dfe Datenmengen gelegt. Da beim B+-Baum ja nur die Schl\u00fcsselinformationen im Baum gespeichert werden, ist das ein Vorteil gegen\u00fcber B-B\u00e4umen.", "type": "multiple-choice", "answers": [{"text": "HEAP", "solution": "false"}, {"text": "B-Baum", "solution": "false"}, {"text": "B+-Baum", "solution": "true"}, {"text": "ISAM", "solution": "false"}, {"text": "HASH", "solution": "false"}]}, {"id": 1581, "category": 42, "difficulty": 3, "text": "Wie nennt man ein Verzeichnis der Gestalt: (Wert, physikalische Adresse)?", "explanation": "Ein Index ist ein separates Verzeichnis der Gestalt \"Wert, Adresse\", wobei der Wert aus einem oder mehreren Spaltenwerten (ein oder mehrdimensionaler Index) bestehen kann. Die Adresse verweist auf den Platz, an dem die Daten auf der Platte gespeichert sind. In einem dichten Index sind alle Datens\u00e4tze eingetragen, in einem d\u00fcnnen Index dagegen nur einige ausgew\u00e4hlte Datens\u00e4tze.", "type": "text", "answers": [{"text": "Das ist ein", "solution": "Index"}]}, {"id": 1582, "category": 9, "difficulty": 2, "text": "Es soll folgende Spieler-Tabelle angelegt werden:  spieler (spieler_id, name, handy) mit dem Prim\u00e4rschl\u00fcssel: spieler_id.\n\n    Mit welchem/n Befehl/en kann zus\u00e4tzlich ein zusammengesetzter, eindeutiger Zweitschl\u00fcssel f\u00fcr die Tabelle \"spieler\" \u00fcber die beiden Attribute \"name, handy\" definiert werden, der zum Transaktionsende gepr\u00fcft werden soll?", "explanation": "Nur der Ausdruck\n\n    \n\n    CREATE TABLE spieler\n\n    (spieler_id NUMBER(9) PRIMARY KEY,\n\n    name VARCHAR2(50),\n\n    handy NUMBER(11),\n\n    UNIQUE (name, handy) INITIALLY DEFERRED);\n\n    \n\n    ist syntaktisch richtig und entspricht der Fragestellung.", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \nname VARCHAR2(50), \nhandy    NUMBER(11), \nUNIQUE (name, handy) INITIALLY DEFERRED);", "solution": "true"}, {"text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \n name VARCHAR2(50) UNIQUE INITIALLY DEFERRED, \n handy NUMBER(11) UNIQUE INITIALLY DEFERRED);", "solution": "false"}, {"text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \nname VARCHAR2(50), \nhandy    NUMBER(11), \nUNIQUE (name, handy) INITIALLY IMMEDIATE);", "solution": "false"}, {"text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \n name VARCHAR2(50) UNIQUE INITIALLY IMMEDIATE, \n handy NUMBER(11) UNIQUE INITIALLY IMMEDIATE);", "solution": "false"}]}, {"id": 1605, "category": 9, "difficulty": 2, "text": "Welcher Teil von SQLJ beinhaltet die Einbindung von statischen SQL Statements in ein Java-Programm?", "type": "multiple-choice", "answers": [{"text": "Part 0", "solution": "true"}, {"text": "Part 1", "solution": "false"}, {"text": "Part 2", "solution": "false"}]}, {"id": 1585, "category": 7, "difficulty": 1, "text": "Eine Relation in der zweiten Normalform mit zwei Attributen ist auch immer in der dritten Normalform.", "explanation": "Ja, denn f\u00fcr die Verletzung der 3. NF werden wenigstens drei Attribute ben\u00f6tigt, je eines f\u00fcr X,Y und Z. \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist. \nMit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist. \nAlso X \u2192Y \u2192Z, aber nicht Y \u2192X.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1587, "category": 7, "difficulty": 2, "text": "Eine Relation in der zweiten Normalform mit nur zwei funktionalen\nAbh\u00e4ngigkeiten ist immer in der dritten Normalform.", "explanation": "Mit nur einer funktionalen Abh\u00e4ngigkeit, w\u00e4re keine M\u00f6glichkeit zur Transitiviti\u00e4t gegeben. z.B. a->b,c. \nAber mit zwei funktionalen Abh\u00e4ngigkeiten ist als Mindestvoraussetzung grunds\u00e4tzlich die M\u00f6glichkeit gegeben, dass es sich dabei um transitive Abh\u00e4ngigkeiten handeln k\u00f6nnte. z.B. a->b,c. und b->c.", "type": "multiple-choice", "answers": [{"text": "Dieser Sachverhalt spielt in diesem Zusammenhang keine Rolle.", "solution": "false"}, {"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1589, "category": 9, "difficulty": 1, "text": "SQL-Befehle in  SQLJ-Klauseln schlie\u00dfen mit einem Semikolon innerhalb der geschweiften Klammern ab.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1590, "category": 10, "difficulty": 3, "text": "Betrachten Sie die folgende Definition einer Sequence: CREATE SEQUENCE Kun_seq INCREMENT BY 1 START WITH 1 NOMAXVALUE NOCYCLE CACHE 10;", "explanation": "Der n\u00e4chste Wert einer Sequenz wird mit <sequence_name>NEXTVAL abgerufen..\n\n    Ein solcher INSERT, der nur einen Datensatz einf\u00fcgt, wird mit dem Schl\u00fcsselwort VALUES( ) fortgesetzt.\n\n    INSERT INTO Kunden (Kun_Nr, Nachname) VALUES (Kun_seq.NEXTVAL, \"Vogt\")", "type": "text", "answers": [{"text": "Mit welchem Befehl wird ein Datensatz (Kunden_Nr, Nachname: 'Vogt') zu dieser Sequenz in eine Tabelle 'Kunden' angelegt? Vervollst\u00e4ndigen Sie den folgenden SQL-Befehl (ohne abschlie\u00dfendes Komma): \n\nINSERT INTO Kunden (Kun_Nr, Nachname)", "solution": "VALUES (Kun_seq.NEXTVAL, 'Vogt')"}]}, {"id": 1592, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden PL/SQL-Code\n\n    PACKAGE xyz\n    IS\n      PROCEDURE b (p1 VARCHAR2);\n    END;\n\n    CREATE PACKAGE BODY xyz\n    IS \n      PRODEDURE a (p1 NUMBER) IS ...\n        \n    END; \n\nWelche Methode ist privat?", "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder \u00f6ffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind \u00f6ffentlich und k\u00f6nnen damit von au\u00dferhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und k\u00f6nnen damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.\na ist daher privat, da die Prozedur a innerhalb des BODY-Teils, also im Paketrumpf definiert ist.", "type": "multiple-choice", "answers": [{"text": "a", "solution": "true"}, {"text": "b", "solution": "false"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 1595, "category": 11, "difficulty": 2, "text": "Welche Aussagen \u00fcber \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?", "explanation": "Alle drei Antworten sind richtig.", "type": "multiple-choice", "answers": [{"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.", "solution": "true"}, {"text": "Beim \"pessimistischen\" LOCK-Verfahren l\u00f6sen auch lesende Zugriffe Sperren f\u00fcr andere Benutzer aus. Die Daten werden erst wieder freigegeben, wenn alle \u00c4nderungen gespeichert sind. Nachteil des pessimistischen Verfahrens ist, dass andere Transaktionen oft unn\u00f6tig lange auf die Freigabe von Daten warten m\u00fcssen. Das parallele Arbeiten vieler Benutzer kann dadurch sehr eingeschr\u00e4nkt sein.", "solution": "true"}, {"text": "Beim \"optimistischen\" LOCK-Verfahren l\u00f6sen lesende Zugriffe keine Sperren aus. Jede Tabelle verf\u00fcgt \u00fcber einen Zeitstempel, der den Zeitpunkt der letzten \u00c4nderung angibt. Bei Daten\u00e4nderungen wird zun\u00e4chst gepr\u00fcft, der Zeitstempel der Tabelle noch der gleiche ist wie beim Lesen der Daten. Ist dies der Fall, dann sind die Daten der Tabelle seit dem Lesen unver\u00e4ndert und die \u00c4nderungen k\u00f6nnen gespeichert werden.", "solution": "true"}]}, {"id": 1599, "category": 9, "difficulty": 3, "text": "Welche der JDBC-Objekte sind Interfaces?", "explanation": "Alle diese  Objekte sind Interfaces  bzw. Schnittstellen unter Java, von denen keine Objekte gebildet werden k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "Connection", "solution": "true"}, {"text": "Statement", "solution": "true"}, {"text": "Driver", "solution": "true"}, {"text": "PreparedStatement", "solution": "true"}]}, {"id": 1602, "category": 9, "difficulty": 2, "text": "Was versteht man unter", "explanation": "DAL ist der administrative Teil, wie z.B. GRANT, REVOKE f\u00fcr die Rechte,...\n\n    DML ist die Datenmanipulationssprache mit INSERT, UPDATE, DELETE.\n\n    DDL ist die Datendefinitionssprache, um \"Objekte\" wie z.B. Tabellen, Indexe, Sequenzen, Trigger, Constraints im DBS anlegen zu k\u00f6nnen und umfasst im Wesentlichen CREATE, ALTER, DROP.\n\n    DQL ist die Anfragesprache, die nur aus dem SELECT-Befehl besteht.", "type": "text", "answers": [{"text": "DAL=", "solution": "Data Administration Language"}, {"text": "DML=", "solution": "Data Manipulation Language"}, {"text": "DDL=", "solution": "Data Definition Language"}]}, {"id": 1603, "category": 9, "difficulty": 2, "text": "Wie k\u00f6nnen Sie den Java Datentyp \"float\" in den meisten relationalen Datenbanken ablegen?", "explanation": "INTEGER hat keine Nachkommastellen.", "type": "multiple-choice", "answers": [{"text": "FLOAT", "solution": "true"}, {"text": "DOUBLE", "solution": "true"}, {"text": "INTEGER", "solution": "false"}]}, {"id": 1604, "category": 7, "difficulty": 1, "text": "Eine Relation in der zweiten Normalform, in der keine transitiven Abh\u00e4ngigkeiten auftreten, ist immer in der dritten Normalform.", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1606, "category": 10, "difficulty": 3, "text": "Wie fragt man in PL/SQL ab, ob ein Datenbanktrigger durch einen INSERT angestossen wurde?", "explanation": "Mit IF INSERTING THEN   \n     ELSIF DELETING THEN  \n     ELSIF UPDATING THEN  \nkann unter PL/SQL ein Trigger f\u00fcr mehrere DML-Ereignisse definiert werden und dann dieses Ereignis im Action-Teil des Triggers abgefragt werden.  \n\nDies ist eine PL/SQL-spezifische Syntax, die nicht zum SQL-Standard geh\u00f6rt.", "type": "text", "answers": [{"text": "Das ist:", "solution": "IF INSERTING THEN"}]}, {"id": 1619, "category": 42, "difficulty": 2, "text": "Wie viele Datens\u00e4tze sind in einem B-Baum vom Typ 3 auf einem Blatt h\u00f6chstens enthalten?", "explanation": "Die Anzahl der Datens\u00e4tze, die auf einem Blatt bei einem B-Baum vom Typ k enthalten sein d\u00fcrfen, ist 2 * k, also hier 6.", "type": "text", "answers": [{"text": "Die Zahl ist", "solution": "6"}]}, {"id": 1616, "category": 42, "difficulty": 2, "text": "Beim L\u00f6schen in einem B-Baum wird", "explanation": "Kleben, Schmieren und Vertuschen kommen nur im wirklichen Leben oder in der Bastelstunde vor. B-B\u00e4ume werden verschmolzen oder ausgeglichen, wenn das L\u00f6schen eine Unterbesetzung eines Blattes verursacht..", "type": "multiple-choice", "answers": [{"text": "verklebt", "solution": "false"}, {"text": "verschmiert", "solution": "false"}, {"text": "verschmolzen", "solution": "true"}, {"text": "vertuscht", "solution": "false"}, {"text": "ausgeglichen", "solution": "true"}]}, {"id": 1614, "category": 42, "difficulty": 1, "text": "Betrachten Sie die folgende SELECT-Abfrage:\n\nSELECT *\nFROM Tabelle 1\nWHERE Schl\u00fcssel BETWEEN 1 AND 100;\n\nWelche Speicherstruktur liefert das Ergebnis schneller?", "explanation": "Bei einer Hash-Speicherstruktur kann sehr schnell der Datensatz gefunden werden, wenn man den Prim\u00e4rschl\u00fcssel, nicht einen Prim\u00e4rschl\u00fcsselbereich vorgibt. F\u00fcr einen einzelnen Wert wird dann nur die Hash-Funktion ohne zus\u00e4tzliche Lesezugriffe ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "B- Baum", "solution": "true"}, {"text": "HASH", "solution": "false"}]}, {"id": 1615, "category": 42, "difficulty": 1, "text": "Nach welchem Informatiker sind die B-B\u00e4ume benannt?", "explanation": "Ein B-Baum ist eine Indexstruktur, die h\u00e4ufig in Datenbanken und Dateisystemen eingesetzt wird. Ein B-Baum ist ein immer vollst\u00e4ndig balancierter Baum, der Daten sortiert nach Schl\u00fcsseln speichert.B-B\u00e4ume wachsen und schrumpfen von den Bl\u00e4ttern hin zur Wurzel. Der B-Baum wurde 1972 von Rudolf Bayer und Edward M. McCreight entwickelt.", "type": "text", "answers": [{"text": "Der Autor hei\u00dft", "solution": "Bayer"}]}, {"id": 547, "category": 8, "difficulty": 3, "text": "Wie nennt man die Anzahl der Attribute einer Relation in der relationalen Algebra? (englischer Ausdruck)", "explanation": "Man schreibt auch: R(A1,...,An). Eine Relation entspricht dabei einer Tabelle mit den Attributen als Spalten\u00fcberschriften. Der Degree ist die Anzahl der Attribute der Relation.", "type": "text", "answers": [{"text": "Die Anzahl der Attribute hei\u00dft:", "solution": "Degree"}]}, {"id": 548, "category": 8, "difficulty": 1, "text": "In einer Relation ist die Tupelreihenfolge definiert.", "explanation": "Dies ist ein sehr zentraler Grundsatz des relationalen Modells: die Reihenfolgeunabh\u00e4ngigkeit. \nAngewendet auf relationale Datenbanksysteme hei\u00dft das u.a. dass das Ergebnis einer Datenverarbeitung unabh\u00e4ngig davon ist, in welcher Reihenfolge die Tupel/Datens\u00e4tze auf der Platte gespeichert sind. Stellen Sie sich vor, dem w\u00e4re nicht so:  das System w\u00e4re \u00fcberhaupt nicht beherrschbar, wenn der Entwickler wissen m\u00fcsste, in welcher Reihenfolge Tupel/Datens\u00e4tze gespeichert sind. Diese Annahme widerspricht auch dem ANSI-3-Ebenen Modell und der physischen Datenunabh\u00e4ngigkeit.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 550, "category": 8, "difficulty": 2, "text": "Bei einer Selektion wird eine n-stellige Relation auf eine n-stellige Relation abgebildet.", "explanation": "Mit Hilfe der Selektion werden einzelne Tupel ausgew\u00e4hlt, die Attributstruktur der Relation bleibt jedoch unver\u00e4ndert. Es ist die Projektion, die einzelne Attribute ausw\u00e4hlt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1122, "category": 8, "difficulty": 1, "text": "Es wird ein algebraischer Ausdruck der relationalen Algebra auf einen \u00e4quivalenten Ausdruck transformiert, der weniger Laufzeit ben\u00f6tigt.", "explanation": "Grundlage der logischen Optimierung sind \u00c4quivalenzen in der relationalen Algebra: \nDie Operationen der relationalen Algebra gen\u00fcgen bestimmten mathematischen Rechengesetzen. Unter Ausnutzung dieser Gesetze gelangt man zu einem optimierten algebraischen Ausdruck, der \u00e4quivalent zum urspr\u00fcnglichen Ausdruck in dem Sinne ist, dass er das gleiche Anfrageergebnis liefert.", "type": "multiple-choice", "answers": [{"text": "Das ist die logische Optimierung.", "solution": "true"}, {"text": "Das ist die physische Optimierung.", "solution": "false"}]}, {"id": 556, "category": 8, "difficulty": 3, "text": "Wie hei\u00dft ein Natural Join, bei dem alle Tupel am Verbund der beiden Relationen teilnehmen?", "explanation": "Eine Join-Operation (Theta-Join, Equi-Join oder Natural-Join) zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.", "type": "text", "answers": [{"text": "Solch ein Join hei\u00dft", "solution": "verlustfrei"}]}, {"id": 557, "category": 8, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber Join-Operatoren sind wahr?", "explanation": "Die drei Grundoperatoren, die man f\u00fcr die Simulation von Join-Operatoren ben\u00f6tigt, sind:  Selektion, Projektion und kartesisches Produkt. \nJede Relation kann mit einer anderen Relation gejoint werden (auch mit sich selber). \nDie Restriktion: \"Alle Attribute der beiden betroffenen Relationen m\u00fcssen \u00fcber die gleichen Namen verf\u00fcgen.\" gilt nur f\u00fcr die Mengenoperatoren Differenz, Durchschnitt, Vereinigung und ist eine Teilbedingung der \"Vereinigungskonformit\u00e4t\". \nEs kann in der Relationalen Algebra \u00fcber jedes beliebige Attribut \"gejoint\" werden, es muss kein Schl\u00fcsselattribut sein. In relationalen Datenbanksystemen dienen Schl\u00fcssel lediglich zur Beschleunigung des Zugriffs, aber nicht zur Einschr\u00e4nkung der Verkn\u00fcpfungsm\u00f6glichkeiten.", "type": "multiple-choice", "answers": [{"text": "Der Join-Operationen lassen sich nicht aus Selektion, Projektion und kartesischem Produkt ableiten.", "solution": "false"}, {"text": "Jede Relation kann mit einer anderen Relation gejoint werden (auch mit sich selber).", "solution": "true"}, {"text": "Alle Attribute der beiden betroffenen Relationen m\u00fcssen f\u00fcr eine Join-Operation \u00fcber die gleichen Namen verf\u00fcgen.", "solution": "false"}, {"text": "Die Attribute, \u00fcber die der Join ausgef\u00fchrt wird m\u00fcssen eine Schl\u00fcsselattribute sein.", "solution": "false"}]}, {"id": 561, "category": 7, "difficulty": 2, "text": "Welche Integrit\u00e4tsarten gibt es in relationalen Datenbanksystemen/im relationalen Modell?", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrit\u00e4t, wenn jeder Wert eines Fremdschl\u00fcssels einer Relation Ri Wert eines Prim\u00e4rschl\u00fcssels in einer anderen Relation Rj\nist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt. \nEine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt. \nEine Menge von Relationen R1,...,Rk besitzt die semantische Integrit\u00e4t, wenn die Korrektheit der Eingaben der Benutzer gew\u00e4hrleistet ist. \nDie \u00fcrbrigen Integrit\u00e4tsbegriffe gibt es nicht in diesem Zusammenhang.", "type": "multiple-choice", "answers": [{"text": "Entity-Integrit\u00e4t", "solution": "true"}, {"text": "referentielle Integrit\u00e4t", "solution": "true"}, {"text": "semantische Integrit\u00e4t", "solution": "true"}, {"text": "differenzielle Integrit\u00e4t", "solution": "false"}, {"text": "divergente Integrit\u00e4t", "solution": "false"}, {"text": "resorbierende Integrit\u00e4t", "solution": "false"}]}, {"id": 559, "category": 8, "difficulty": 3, "text": "Welche der folgenden Operationen aus der relationalen Algebra sind kommutativ?", "explanation": "W\u00e4hrend die beiden Mengenoperationen Vereinigung und Durchschnitt kommutativ sind, ist es die Differenz nicht, weil das Ergebnis davon abh\u00e4ngt, welche Relation von der anderen abgezogen wird. \nKartesisches Produkt und Join-Operation sind kommutativ (vertauschbar), das einzige, was sich \u00e4ndert ist die Attributreihenfolge und das spielt keine Rolle.  \nHingegen sind die Left und Right Outer-Joins nicht kommutativ, da geht es ja gerade um die Anforderung, entweder die Tupel der linken oder rechten Relation vollst\u00e4ndig in die Ergebnismenge aufzunehmen.", "type": "multiple-choice", "answers": [{"text": "Durchschnitt", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Union", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Join-Operationen (Theta, Natural, Equi)", "solution": "true"}, {"text": "Outer Join-Operatoren (Left, Right)", "solution": "false"}]}, {"id": 560, "category": 8, "difficulty": 1, "text": "Wie hei\u00dft eine Attributkombination, die Prim\u00e4rschl\u00fcssel einer anderen Relation ist?", "explanation": "Eine Attributkombination einer Relation hei\u00dft Fremdschl\u00fcssel (foreign key), wenn diese Kombination Prim\u00e4rschl\u00fcssel in einer anderen Relation ist. Ein Fremdschl\u00fcssel darf Null-Werte besitzen.", "type": "text", "answers": [{"text": "Sie hei\u00dft  (deutscher Begriff):", "solution": "Fremdschl\u00fcssel"}]}, {"id": 563, "category": 11, "difficulty": 3, "text": "Welcher Lock-Typ erlaubt anderen Benutzern nicht, weitere Sperren auf eine Tabelle zu setzen, die mit diesem Lock-Typ gesperrt wurden?", "explanation": "1. Typ: XLOCKS oder EXKLUSIVE LOCKS\nEin XLOCK bewirkt, dass keine andere Transaktion eine Sperrung auf ein Objekt, das schon einen XLOCK hat, absetzen kann. Der XLOCK wird bis zum Ende der Transaktion gehalten.\n\n2.Typ: SHARED LOCKS oder SLOCKS (geteilte LOCKS )\nFalls eine Transaktion T1 einen SLOCK auf eine Tabelle h\u00e4lt, hei\u00dft das, dass sie nur lesend zugreifen wird. Eine andere Transaktion T2 kann parallel auch einen SLOCK absetzen, wenn nur Lesezugriffe beabsichtigt sind. Allerdings kann eine Transaktion T3 keinen XLOCK auf die betroffene Tabelle absetzen, bis alle SLOCKS wieder gel\u00f6scht sind.", "type": "multiple-choice", "answers": [{"text": "SLOCK", "solution": "false"}, {"text": "XLOCK", "solution": "true"}, {"text": "EXCLUSIVE LOCK", "solution": "true"}]}, {"id": 1123, "category": 8, "difficulty": 3, "text": "Es wird zur Optimierung eines Ausdrucks auf unterschiedliche Implementierungen der relationale Algebra zur\u00fcckgegriffen, um eine Laufzeitverbesserung zu erreichen.", "explanation": "Bei der physischen Optimierung wird dagegen auf unterschiedliche Implementierungen der relationalen Algebra zur\u00fcckgegriffen, d.h., unter mehreren \u00dcbersetzungsm\u00f6glichkeiten wird die performanteste herausgesucht. Dabei gehen Wissen \u00fcber das Datenbankschema, die Gr\u00f6\u00dfe der einzelnen Relationen und Statistiken \u00fcber die erfolgten Datenzugriffe ein.", "type": "text", "answers": [{"text": "Das ist die ...", "solution": "physische Optimierung"}]}, {"id": 1124, "category": 8, "difficulty": 1, "text": "Alle Natural-Joins sind verlustfrei.", "explanation": "Eine Join-Operation zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 569, "category": 8, "difficulty": 3, "text": "Welche Operationen der relationalen Algebra sind assoziativ?", "explanation": "Kartesisches Produkt, Union, Durchschnitt und Join-Operation sind assoziativ, d. h., Klammern k\u00f6nnen beliebig gesetzt werden.", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Selektion", "solution": "false"}, {"text": "kartesisches Produkt", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Union", "solution": "true"}]}, {"id": 1112, "category": 11, "difficulty": 1, "text": "Welche Aussagen \u00fcber Transaktionen und Integrit\u00e4tspr\u00fcfung in SQL sind richtig?", "explanation": "RICHTIG sind:\n\"IMMEDIATE bezeichnet die Integrit\u00e4tspr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung des DML-Befehls und DEFERRED erst zum Transaktionsende.\"\n\n\"In SQL gibt es 5 CONSTRAINTs mittels denen die Datenintegrit\u00e4t gesichert werden kann: [NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.\"\n\nFALSCH sind: \n\"Wird vom DBMS ein Fehler bei der IMMEDIATE-Integrit\u00e4tspr\u00fcfung erkannt, so wird die gesamte Transaktion zur\u00fcckgerollt.\" Bei einem IMMEDIATE-Fehler wird nur die eine fehlerhafte DML-Anweisung r\u00fcckg\u00e4ngig gemacht. \n\n\"Wird vom DBMS ein Fehler bei der DEFERRED-Integrit\u00e4tspr\u00fcfung erkannt, so wird nur der fehlerhafte DML-Befehl zur\u00fcckgerollt.\" Bei einem DEFERRED-Fehler wird die gesamte Transaktion zur\u00fcckgerollt.", "type": "multiple-choice", "answers": [{"text": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integrit\u00e4tspr\u00fcfung erkannt, so wird die gesamte Transaktion zur\u00fcckgerollt.", "solution": "false"}, {"text": "Wird vom DBMS ein Fehler bei der DEFERRED-Integrit\u00e4tspr\u00fcfung erkannt, so wird nur der fehlerhafte DML-Befehl zur\u00fcckgerollt.", "solution": "false"}, {"text": "IMMEDIATE bezeichnet die Integrit\u00e4tspr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung des DML-Befehls und DEFERRED erst zum Transaktionsende.", "solution": "true"}, {"text": "In SQL gibt es 5 CONSTRAINTs mittels denen die Datenintegrit\u00e4t gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.", "solution": "true"}]}, {"id": 414, "category": 1, "difficulty": 1, "text": "ANSI-3-Ebenen-Modell: Die Organisation der physischen Speicherung wird ge\u00e4ndert.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft keine Ebene.", "solution": "false"}]}, {"id": 415, "category": 1, "difficulty": 2, "text": "In welchem Teilsystem eines DBMS werden Daten \u00fcber Tabellenstrukturen, Benutzerrechte, Beziehungen der Tabellen untereinander etc. gespeichert?\nDieses System hei\u00dft", "explanation": "Das Data Dictionary enth\u00e4lt Daten (sogenannte Metadaten), die die Datenbasis, z.B. Tabellenstrukturen, definieren. Es umfasst au\u00dferdem Daten \u00fcber die Verwendung und Bedeutung des Datenmodells, die Beziehungen der Daten untereinander und Integrit\u00e4tsbedingungen.", "type": "multiple-choice", "answers": [{"text": "Datenbasis", "solution": "false"}, {"text": "Metadatenbank", "solution": "true"}, {"text": "Data Dictionary", "solution": "true"}, {"text": "Transaktionsverwaltung", "solution": "false"}]}, {"id": 417, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgende Frage an eine Auftrags-/Kunden-Tabelle:\nWelche Kunden haben einen Auftrag aufgegeben?\nWelche der folgenden Abfragen liefert das gew\u00fcnschte Ergebnis?", "explanation": "Eine Exists-Bedingung liefert den Wahrheitswert wahr, wenn der SELECT (hier SELECT * FROM auftraege) mindestens einen Datensatz ergibt. \nDas ist hier der Fall, falls die Auftraege-Relation nicht leer ist, beantwortet aber nicht die oben gestellte Frage.", "type": "multiple-choice", "answers": [{"text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE EXISTS\n(SELECT * FROM Auftraege\nWHERE  Kunden.Kun_Nr = Auftraege.Kun_Nr);", "solution": "true"}, {"text": "SELECT    DISTINCT Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege\nWHERE    Auftraege.Kun_Nr=Kunden.Kun_Nr;", "solution": "true"}, {"text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE EXISTS\n(SELECT * FROM Auftraege)", "solution": "false"}, {"text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege\nWHERE    Auftraege.Kun_Nr=Kunden.Kun_Nr;", "solution": "true"}, {"text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE Kunden_nr IN\n(SELECT DISTINCT Kun_Nr FROM Auftraege);", "solution": "true"}, {"text": "SELECT    DISTINCT Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege;", "solution": "false"}]}, {"id": 419, "category": 5, "difficulty": 1, "text": "ER-Modell: Um welchen Beziehungstyp handelt es sich hier?\nEin Student kann keine/eine/mehrere Vorlesungen h\u00f6ren und eine Vorlesung kann von keinem/nur von einem Studenten besucht werden.", "explanation": "Das ist die Definition einer c:cm-Beziehung.", "type": "multiple-choice", "answers": [{"text": "1:n", "solution": "false"}, {"text": "c:n", "solution": "false"}, {"text": "c:cn", "solution": "true"}]}, {"id": 1110, "category": 9, "difficulty": 1, "text": "Wie viele Datens\u00e4tze darf eine SELECT-Anweisung ohne CURSOR mit der INTO-Klausel unter PL/SQL liefern, ohne dass eine Exception erzeugt wird?", "explanation": "SELECT INTO \u00fcbergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datens\u00e4tze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datens\u00e4tze verarbeiten kann.", "type": "multiple-choice", "answers": [{"text": "mehrere Datens\u00e4tze", "solution": "false"}, {"text": "keinen Datensatz", "solution": "false"}, {"text": "einen Datensatz", "solution": "true"}]}, {"id": 1111, "category": 9, "difficulty": 3, "text": "Mit welcher PL/SQL-Prozedur initialisiert man einen BLOB-Wert?", "explanation": "Bevor man einen BLOB-Datentyp benutzen kann, muss er mit EMPTY_BLOB() initialisiert werden.", "type": "text", "answers": [{"text": "Das ist (mit Klammern schreiben):", "solution": "EMPTY_BLOB()"}]}, {"id": 1114, "category": 9, "difficulty": 2, "text": "Mit welchem Cursor-Attribut fragt man ab, ob ein Cursor ge\u00f6ffnet ist?", "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR ge\u00f6ffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen", "type": "text", "answers": [{"text": "Das ist", "solution": "%ISOPEN"}]}, {"id": 1115, "category": 9, "difficulty": 2, "text": "Mit welchem Cursor-Attribut fragt man ab, ob die letzte FETCH-Anweisung keine Zeile mehr liefert?", "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR ge\u00f6ffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen", "type": "text", "answers": [{"text": "Das ist", "solution": "%NOTFOUND"}]}, {"id": 1116, "category": 9, "difficulty": 2, "text": "Mit welchem Cursor-Attribut fragt man die Gesamtanzahl der bisher gelesenen Zeilen ab?", "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR ge\u00f6ffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen", "type": "text", "answers": [{"text": "Das ist", "solution": "%ROWCOUNT"}]}, {"id": 1117, "category": 9, "difficulty": 3, "text": "Welche Datentypen oder zusammengesetzte Datentypen sind unter PL/SQL erlaubt?", "explanation": "PL/SQL kennt neben den SQL-Datentypen die eigenen Typen BOOLEAN und sogenannte Collections, die \u00fcber TYPE ... is VARRAY OF ..., TYPE ... is TABLE  OF ... oder TYPE ... is RECORD OF ... definiert werden.", "type": "multiple-choice", "answers": [{"text": "DATE", "solution": "true"}, {"text": "BOOLEAN", "solution": "true"}, {"text": "TIMESTAMP", "solution": "true"}, {"text": "TYPE ... is RECORD OF ...", "solution": "true"}, {"text": "TYPE ... is TABLE  OF ...", "solution": "true"}, {"text": "TYPE ... is VARRAY OF ...", "solution": "true"}]}, {"id": 1120, "category": 10, "difficulty": 1, "text": "Das Mutating Table-Problem tritt auf", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "multiple-choice", "answers": [{"text": "Im  ORACLE PL/SQL", "solution": "true"}, {"text": "in SQL 1999", "solution": "false"}, {"text": "in IBM-DB2", "solution": "false"}]}, {"id": 1135, "category": 10, "difficulty": 1, "text": "ORACLE-Trigger mit einer WHEN-Bedingung sind immer zeilenorientiert.", "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugeh\u00f6rigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgef\u00fchrt (bei FALSE und NULL nicht). Sie muss immer in Klammern stehen.  \n\nZu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung gepr\u00fcft, ob der Aktionsteil ausgef\u00fchrt wird. \n\nDa Oracle keine Transitionstabellen kennt und Transitionsvariablen zu zeilenorienterten Triggern mit einer WHEN -Bedingung geh\u00f6ren, sind ORACLE-Trigger mit einer WHEN-Bedingung immer zeilenorientiert.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 918, "category": 11, "difficulty": 1, "text": "Welcher Pr\u00fcfungszeitpunkt (CONSTRAINT_CHARACTERISTICA) f\u00fchrt dazu, dass beim Erkennen eines Fehlers die gesamte Transaktion zur\u00fcckgerollt wird (Fehlerreaktion entspricht der ROLLBACK-Anweisung)?", "explanation": "Werden Daten\u00e4nderungen ausgef\u00fchrt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integrit\u00e4tsbedingung gepr\u00fcft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung r\u00fcckg\u00e4ngig gemacht. Die \u00fcbrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen.\n\n\nDer COMMIT-Befehl l\u00f6st das Transaktionsende aus und damit die Pr\u00fcfung aller CONSTRAINTs (Integrit\u00e4tsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden w\u00e4hrend einer Transaktion erst mal akzeptiert und erst zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs gepr\u00fcft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, f\u00fchrt dies zur Anzeige einer Fehlermeldung und zum Zur\u00fcckrollen der gesamten Transaktion.", "type": "multiple-choice", "answers": [{"text": "INITIALLY DEFERRED", "solution": "true"}, {"text": "INITIALLY IMMEDIATE", "solution": "false"}]}, {"id": 970, "category": 42, "difficulty": 3, "text": "\u00dcberlaufseiten", "explanation": "\u00dcberlaufseiten verlangsamen den Lesezugriff, da die urspr\u00fcngliche Speicherstruktur (ISAM oder HASH) zu einer linearen Liste ausarten kann, die sequentiell beim Lesen durchsucht werden muss.", "type": "multiple-choice", "answers": [{"text": "verlangsamen den Lesezugriff", "solution": "true"}, {"text": "beschleunigen den Lesezugriff", "solution": "false"}, {"text": "verlangsamen den Schreibzugriff", "solution": "false"}, {"text": "beschleunigen den Schreibzugriff", "solution": "false"}]}, {"id": 1245, "category": 11, "difficulty": 3, "text": "Wie hei\u00dft ein Ausf\u00fchrungsplan, der zu einem seriellen Ausf\u00fchrungsplan \u00e4quivalent ist?", "explanation": "Ein Ausf\u00fchrungsplan definiert eine (partielle) Reihenfolge der Operationen von verschiedenen Transaktionen.\n\nZwei Ausf\u00fchrungspl\u00e4ne hei\u00dfen \u00e4quivalent, wenn die Ergebnisse ihrer Operationen in der Datenbasis gleich sind.\n\nBei einem seriellen Ausf\u00fchrungsplan wird jede Transaktion vollst\u00e4ndig hintereinander ausgef\u00fchrt.\n\nEin serialisierbarer Ausf\u00fchrungsplan ist ein geschachtelter Ausf\u00fchrungsplan, der zu einem seriellen Ausf\u00fchrungsplan \u00e4quivalent ist.", "type": "text", "answers": [{"text": "Das ist ein _____ Ausf\u00fchrungsplan.", "solution": "serialisierbarer"}]}, {"id": 921, "category": 11, "difficulty": 3, "text": "Wie hei\u00dfen die Regeln, deren Einhaltung durch die Transaktionen die Serialisierbarkeit der Ausf\u00fchrungspl\u00e4ne garantieren?", "explanation": "Um nun f\u00fcr eine Menge von Transaktionen einen serialisierbaren Ausf\u00fchrungsplan zu finden, ist eine rege wissenschaftliche Diskussion8 gef\u00fchrt worden. Als Ergebnis wurden eine Vielzahl von Methoden entwickelt, die einen Test auf Serialisierbarkeit erm\u00f6glichen. Diese Verfahren haben im Wesentlichen zwei Nachteile. Zum einen sind sie sehr aufw\u00e4ndig, da sie meist auf graphentheoretischen Beweisen basieren. Zum anderen k\u00f6nnen sie erst im Nachhinein feststellen, ob der bereits ausgef\u00fchrte Plan \u00fcberhaupt serialisierbar ist, weil ihre Grundidee die Entdeckung von Fehlern ist. \n\n\nAus diesen beiden Gr\u00fcnden werden in kommerziellen Datenbanksystemen Protokolle wie z.B. das Zwei-Phasen-Sperr-Protokoll, das Zeitstempelordnungsprotokoll und das Multiversionsprotokoll verwendet, deren Einhaltung Serialisierbarkeit garantieren. Es werden also nicht im Nachhinein Fehler gesucht, sondern im Vorfeld Regeln definiert, deren Einhaltung die Serialisierbarkeit gew\u00e4hrleistet.\n\n\nNebenl\u00e4ufigkeitsprotokolle sind Regeln, deren Einhaltung durch alle beteiligten Transaktionen die Serialisierbarkeit garantiert. Damit ist eine hinreichende Voraussetzung f\u00fcr eine \"korrekte\" nebenl\u00e4ufige Ausf\u00fchrung garantiert.", "type": "text", "answers": [{"text": "Das sind", "solution": "Nebenl\u00e4ufigkeitsprotokolle"}]}, {"id": 922, "category": 11, "difficulty": 3, "text": "Welche der aufgelisteten Verfahren sind Nebenl\u00e4ufigkeitsprotokolle?", "explanation": "Um nun f\u00fcr eine Menge von Transaktionen einen serialisierbaren Ausf\u00fchrungsplan zu finden, ist eine rege wissenschaftliche Diskussion gef\u00fchrt worden. Als Ergebnis wurden eine Vielzahl von Methoden entwickelt, die einen Test auf Serialisierbarkeit erm\u00f6glichen. Diese Verfahren haben im Wesentlichen zwei Nachteile. Zum einen sind sie sehr aufw\u00e4ndig, da sie meist auf graphentheoretischen Beweisen basieren. Zum anderen k\u00f6nnen sie erst im Nachhinein feststellen, ob der bereits ausgef\u00fchrte Plan \u00fcberhaupt serialisierbar ist, weil ihre Grundidee die Entdeckung von Fehlern ist.\n\n\nAus diesen beiden Gr\u00fcnden werden in kommerziellen Datenbanksystemen Protokolle wie z.B. das Zwei-Phasen-Sperr-Protokoll, das Zeitstempelordnungsprotokoll und das Multiversionsprotokoll verwendet, deren Einhaltung Serialisierbarkeit garantieren. Es werden also nicht im Nachhinein Fehler gesucht, sondern im Vorfeld Regeln definiert, deren Einhaltung die Serialisierbarkeit gew\u00e4hrleistet.", "type": "multiple-choice", "answers": [{"text": "2-Phasen-Sperrprotokoll", "solution": "true"}, {"text": "Zeitstempel-Verfahren", "solution": "true"}, {"text": "Lost-Update-Verfahren", "solution": "false"}, {"text": "Multiversionsprotokolle", "solution": "true"}]}, {"id": 925, "category": 11, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber Lese/Schreibsperren ist wahr?", "explanation": "Grundidee des Zwei-Phasen-Sperr-Protokolls ist das Sperren von Daten, auf die von verschiedenen Transaktionen gleichzeitig zugegriffen wird. Das einfache \"bin\u00e4re\" Sperren mit den beiden Zust\u00e4nden \"gesperrt\" (lock) und \"entsperrt\" (unlock) ist dabei zu grob. Es l\u00e4sst zu wenig paralleles Arbeiten zu. Da dabei nicht zwischen der Art des Zugriffs unterschieden wird, kann sogar nicht mehr als ein Anwender lesend zugreifen, obwohl gem\u00e4\u00df obiger Konfliktdefinition paralleles Lesen ja ungef\u00e4hrlich ist. Stattdessen wird eine verfeinerte Sperrtechnik mit drei Sperrzust\u00e4nden verwendet, die die\nArt des Zugriffs ber\u00fccksichtigt: \n\n1. lesend gesperrt (read_lock)\n2. schreibend gesperrt (write_lock)\n3. entsperrt (unlock)", "type": "multiple-choice", "answers": [{"text": "Ein Objekt wird exklusiv von einer Schreib-Transaktion gesperrt.", "solution": "true"}, {"text": "Ein Objekt kann von mehreren Lese-Transaktionen gleichzeitig gesperrt werden.", "solution": "true"}, {"text": "Ein Objekt wird exklusiv von einer Lese-Transaktion gesperrt.", "solution": "false"}, {"text": "Ein Objekt kann von mehreren Schreib-Transaktionen gleichzeitig gesperrt werden.", "solution": "false"}]}, {"id": 926, "category": 11, "difficulty": 2, "text": "Dirty-Read ist m\u00f6glich", "explanation": "Die Unterschiede bei den Isolationsgraden zwischen SQL2003 und Oracle basieren im Wesentlichen darauf, dass Oracle unsauberes Lesen (DIRTY READ) grunds\u00e4tzlich ausschlie\u00dft, womit der Isolationsgrad READ UNCOMMITTED entf\u00e4llt. Zudem wird von Oracle der Unterschied zwischen den beiden Problemen Phantome und nicht wiederholbares Lesen als eher akademischer Natur betrachtet, womit der Isolationsgrad REPEATABLE READ ebenfalls entf\u00e4llt.", "type": "multiple-choice", "answers": [{"text": "unter ORACLE-SQL", "solution": "false"}, {"text": "im SQL-Standard", "solution": "true"}]}, {"id": 927, "category": 11, "difficulty": 3, "text": "Bei welchem Konsistenzgrad unter ORACLE hat jede Anfrage der Transaktion eine eigene SCN (System change number)?", "explanation": "Konsistenzgrade sind bei Oracle realisiert mittels Multiversionsprotokollen: \n\nEs wird eine system change number (SCN) f\u00fcr jede Transaktion (Startzeit) vergeben.\nDie Rollback-Segmente enthalten ge\u00e4nderte Datens\u00e4tze einer Tabelle (noch nicht 'committed' oder erst k\u00fcrzlich) mit SCN. \nBeim Lesen von Datens\u00e4tzen wird auch in den Rollback-Segmenten\nnach 'passenden Versionen' nachgeschaut.'Passende Versionen' sind 'committede' Datens\u00e4tze mit SCN kleiner als SCN der Anfrage.\nBeim Konsistenzgrad 'transaction level' wird f\u00fcr jede Anfrage der Transaktion die SCN der Transaktion verwendet. \nBeim Konsistenzgrad 'statement level' wird f\u00fcr jede Anfrage der Transaktion eine eigene SCN vergeben.\nDie Konsistenzgrade werden \u00fcber die SET TRANSACTION-Anweisung gesetzt. \n", "type": "multiple-choice", "answers": [{"text": "transaction level", "solution": "false"}, {"text": "statement level", "solution": "true"}]}, {"id": 928, "category": 11, "difficulty": 2, "text": "Bei welchem Konsistenzgrad unter ORACLE verwendet jede Anfrage der Transaktion die SCN (System change number) der Transaktion, also die gleiche SCN?", "explanation": "Konsistenzgrade sind bei Oracle realisiert mittels Multiversionsprotokollen: \n\nEs wird eine system change number (SCN) f\u00fcr jede Transaktion (Startzeit) vergeben.\nDie Rollback-Segmente enthalten ge\u00e4nderte Datens\u00e4tze einer Tabelle (noch nicht 'committed' oder erst k\u00fcrzlich) mit SCN.\nBeim Lesen von Datens\u00e4tzen wird auch in den Rollback-Segmenten\nnach 'passenden Versionen' nachgeschaut.'Passende Versionen' sind 'committede' Datens\u00e4tze mit SCN kleiner als SCN der Anfrage.\nBeim Konsistenzgrad 'transaction level' wird f\u00fcr jede Anfrage der Transaktion die SCN der Transaktion verwendet.\nBeim Konsistenzgrad 'statement level' wird f\u00fcr jede Anfrage der Transaktion eine eigene SCN vergeben.\nDie Konsistenzgrade werden \u00fcber die SET TRANSACTION-Anweisung gesetzt.\n", "type": "multiple-choice", "answers": [{"text": "transaction level", "solution": "true"}, {"text": "statement level", "solution": "false"}]}, {"id": 929, "category": 11, "difficulty": 1, "text": "Bei welchem UPDATE-Verfahren werden \u00c4nderungen auf der Festplatte erst nach der COMMIT-Anweisung durchgef\u00fchrt?", "explanation": "Recovery Basis-Techniken (f\u00fcr 'Nicht-Katastrophen-Fehler'): \nDeferred Update: \n\n \u00c4nderungen w\u00e4hrend der Transaktion nur in System-Log protokolliert \nauf der Platte werden sie erst beim COMMIT physisch aktualisiert \nbeim Zur\u00fcckrollen kein R\u00fcckg\u00e4ngigmachen n\u00f6tig \nNO-UNDO/REDO-Algorithmus\n\n\nImmediate Update:\n\n\u00c4nderungen werden in System-Log protokolliert und unmittelbar auf der Platte physisch aktualisiert \nbeim Zur\u00fcckrollen ist R\u00fcckg\u00e4ngigmachen notwendig  \nUNDO/NO-REDO-Algorithmus\n\n", "type": "multiple-choice", "answers": [{"text": "Deferred Update", "solution": "true"}, {"text": "Immediate Update", "solution": "false"}]}, {"id": 234, "category": 9, "difficulty": 2, "text": "Mit welchem SQL-Befehl werden Daten in Tabellen ver\u00e4ndert?", "explanation": "Mit der UPDATE-Anweisung k\u00f6nnen Mengen von Daten oder einzelne Datens\u00e4tze in Tabellen ver\u00e4ndert werden. Die Suchbedingung ist wie in der SELECT-Anweisung definiert. Die Wertzuweisung l\u00e4sst einen NULL-Wert zu, einen Ausdruck wie bei der Default-Option der CREATE TABLE-Anweisung, oder einen Anfrageausdruck. Der Anfrageausdruck darf hier keine Datensatzmenge als Ergebnis liefern, sondern nur einen Datensatz. Je nachdem, ob in der SET-Klausel nur eine einzelne oder mehrere Spalten ge\u00e4ndert werden, k\u00f6nnen inden Anfrageausdruck eine oder entsprechend auch mehrere Spalten selektiert werden.", "type": "text", "answers": [{"text": "Der Befehl hei\u00dft:", "solution": "UPDATE"}]}, {"id": 241, "category": 9, "difficulty": 3, "text": "Welcher SQL-Befehl kann eine SELECT-Abfrage enthalten?", "explanation": "Es gibt einen Befehl zum Einf\u00fcgen von mehreren Datens\u00e4tzen aus anderen Tabellen oder Sichten: \nINSERT INTO tabellenname AS SELECT (spaltenwert_1, ..., spaltenwert_n) FROM ... WHERE ...; \nBei den DML-Befehlen UPDATE und DELETE kann die SELECT-Anweisung in der WHERE-Klausel auftreten, um nur bestimmte Datens\u00e4tze zu \u00e4ndern bzw. zu l\u00f6schen. Beim UPDATE k\u00f6nnen zudem SELECT-Anweisungen auch in der SET-Klausel verwendet werden, um neue Werte f\u00fcr den zu \u00e4ndernden Datensatz zu ermitteln. \nBeim CREATE TABLE kann eine neue Tabellenstruktur erstellt und gleichzeitig mit Daten aus anderen Tabellen oder Sichten gef\u00fcllt werden. \nBeim DROP TABLE gibt es keine Verwendungsm\u00f6glichkeit f\u00fcr einen SELECT und ist daher auch nicht m\u00f6glich. Eine Tabellen wird als Ganzes gel\u00f6scht, inklusive dem Tabelleninhalt.", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE", "solution": "true"}, {"text": "INSERT", "solution": "true"}, {"text": "UPDATE", "solution": "true"}, {"text": "DELETE", "solution": "true"}, {"text": "DROP TABLE", "solution": "false"}]}, {"id": 240, "category": 9, "difficulty": 2, "text": "Die folgende UPDATE-Anweisung ist syntaktisch korrekt:\nUPDATE TABELLE1 SET SPALTE1 = (SELECT SPALTE2 FROM TABELLE2);", "explanation": "Ein UPDATE_Befehl kann auch eine SELECT-Anweisung enthalten, wenn die Spalten der SET-Zuweisung mit der Spaltenliste der SELECT-Anweisung \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 238, "category": 9, "difficulty": 1, "text": "Ein UPDATE-Befehl kann eine SELECT-Anweisung enthalten.", "explanation": "Die Wert-Zuweisung \"SET Spalte = ...\"  kann auch mit dem Ergebnis einer SELECT-Anweisung gef\u00fcllt werden, wenn die Datentypen \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 242, "category": 9, "difficulty": 2, "text": "Der Datentyp \"Boolean\" wurde mit dem folgenden JDBC-Standard eingef\u00fchrt:", "explanation": "Mit JDBC 2.0 wurden folgende Datentypen eingef\u00fchrt: \n\nBLOB    in java.sql.Blob\nCLOB    in java.sql.Clob \nSTRUCT    in java.sql.Struct \nARRAY    in java.sql.Array \nREF    in java.sql.Ref", "type": "multiple-choice", "answers": [{"text": "JDBC 1.0", "solution": "false"}, {"text": "JDBC 2.0", "solution": "true"}, {"text": "JDBC 3.0", "solution": "false"}]}, {"id": 253, "category": 9, "difficulty": 2, "text": "Bei SQLJ wird die \u00dcberpr\u00fcfung des eingebetteten SQL-Codes erst zur Laufzeit vorgenommen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 254, "category": 9, "difficulty": 3, "text": "Mit welchem Schl\u00fcsselwort werden SQLJ-Klauseln eingeleitet?", "type": "text", "answers": [{"text": "Das Schl\u00fcsselwort ist", "solution": "#sql"}]}, {"id": 255, "category": 9, "difficulty": 3, "text": "Welche Endung besitzen SQLJ-Quelltexte?", "type": "text", "answers": [{"text": "Die Endung ist", "solution": ".sqlj"}]}, {"id": 258, "category": 9, "difficulty": 2, "text": "Welcher Treibertyp ist komplett in JAVA geschrieben und erfordert keinen zus\u00e4tzlichen Bin\u00e4rcode auf dem CLIENT?", "explanation": "Treiber vom Typ 1: \n\nJDBC-ODBC-Bridge Bei diesem Treibertyp greift der JDBC-Treiber \u00fcber die ODBC-Schnittstelle auf die Datenbank zu. Nat\u00fcrlich muss dazu auf jedem Client ein ODBC-Treiber installiert sein. Dieser Treibertyp bietet sich daher haupts\u00e4chlich in lokalen Netzwerken an, bei denen auf dem einzelnen Client leicht ODBC installiert werden kann. Au\u00dferdem ist durch den Zwischenschritt ODBC der Zugriff verh\u00e4ltnism\u00e4\u00dfig langsam.\n\nDa in der Frage explizit nach Bin\u00e4rcode auf dem Client gefragt ist, muss hier der Typ3  Treiber ebenfalls eine richtige Antwort sein, da der ben\u00f6tigte Anwendungsserver nicht auf dem Client vorhanden sein muss.\n\n\n\nTreiber vom Typ 2: \nNative-API partly-Java-Treiber Bei diesem Ansatz werden die JDBC-Aufrufe in ein datenbankspezifisches API auf dem Client weitergeben. Daher sind auch bei diesem Typ zus\u00e4tzliche Installationen auf dem Client notwendig.\n\nTreiber vom Typ 3: \nJDBC-Net pure Java-Treiber Treiber vom Typ 3 \u00fcbersetzen die JDBC-Aufrufe in ein vom DBMS unabh\u00e4ngiges Netzprotokoll und benutzen einen Anwendungsserver. Der Server \u00fcbersetzt die Aufrufe in das jeweilige DBMS-Protokoll und \u00fcber die CLI-Schnittstelle wird auf die Datenbank zugegriffen. Bei Treibern vom Typ 3 ist keine zus\u00e4tzliche Client-Installation notwendig, aber ein Anwendungsserver.\n\n\nTreiber vom Typ 4:\nNative-Protocol pure Java-Treiber Bei diesem Treibertyp werden die JDBC-Aufrufe in ein datenbankeigenes Protokoll \u00fcbersetzt, welches \u00fcber das Netzwerk direkt auf den Datenbankserver zugreift. Es ist auch keine zus\u00e4tzliche Client- Installation notwendig.  \n\n\nTreiber von Typ 3 und 4 sind appletf\u00e4hig, die anderen beiden Typen nicht, da sie nicht komplett in Java geschrieben sind.", "type": "multiple-choice", "answers": [{"text": "Das ist ein Treiber vom Typ 1", "solution": "false"}, {"text": "Das ist ein Treiber vom Typ 2", "solution": "false"}, {"text": "Das ist ein Treiber vom Typ 3", "solution": "true"}, {"text": "Das ist ein Treiber vom Typ 4", "solution": "true"}]}, {"id": 259, "category": 9, "difficulty": 1, "text": "Mit welchem Interface unter JDBC kann man Stored Routines (Procedures, Functions) in einer Datenbank aufrufen?", "explanation": "Das CallableStatement-Interface  dient zum Aufruf von Stored Procedures und Functions in der Datenbank. Diese Prozeduren und Funktionen k\u00f6nnen in Java selbst oder in einer Erweiterung von SQL wie PL/SQL von Oracle geschrieben sein. Das CallableStatement-Interface erbt vom PrepareStatement-Interface.", "type": "multiple-choice", "answers": [{"text": "PreparedStatement", "solution": "false"}, {"text": "CallableStatement", "solution": "true"}, {"text": "Statement", "solution": "false"}]}, {"id": 260, "category": 9, "difficulty": 2, "text": "Von welchem Typ ist der R\u00fcckgabewert der Methode executeUpdate() des Interfaces \"Statement\"?", "explanation": "Das ResultSet hat den R\u00fcckgabewert int, in den eingetragen wird, ob der Datenbankzugriff erfolgreich war (1)  oder nicht(0)  oder je nach SQL-Anweisung auch die Anzahl der ge\u00e4nderten Datens\u00e4tze.", "type": "multiple-choice", "answers": [{"text": "boolesch", "solution": "false"}, {"text": "ResultSet", "solution": "false"}, {"text": "int", "solution": "true"}]}, {"id": 262, "category": 9, "difficulty": 2, "text": "Welcher der folgenden CHECK-Constraints ist korrekt?", "explanation": "RICHTIG ist: \ngeschlecht VARCHAR2(1) CHECK (geschlecht IN ('W', 'M'))\nDa die CHECK-Bedingung f\u00fcr Tabellen- und Spalten-Constraints die gleiche Syntax aufweist, startet die Bedingung nach der \u00f6ffenenden Klammer immer mit einem Spaltennamen. Der IN-Operator erwartet als zweiten Operanden eine Komma getrennte Liste konstanter Werte (unterschiedliche Werte gleichen Datentyps ohne Wiederholungen) oder eine SELECT-Anfrage, daher sind die OR-Operatoren dort v\u00f6llig fehl am Platze.", "type": "multiple-choice", "answers": [{"text": "geschlecht VARCHAR2(1) CHECK (IN ('W', 'M'))", "solution": "false"}, {"text": "geschlecht VARCHAR2(1) CHECK (geschlecht IN ('W', 'M'))", "solution": "true"}, {"text": "geschlecht VARCHAR2(1) CHECK (geschlecht IN ('W' OR 'M'))", "solution": "false"}]}, {"id": 265, "category": 9, "difficulty": 1, "text": "Welche SELECT-Komponenten sind obligatorisch?", "explanation": "Eine SELECT-Anweisung muss mindestens eine Spalte aus einer Tabelle selektieren, also eine SELECT-Klausel und eine FROM-Klausel enthalten.\n Alle anderen Klauseln sind optional.", "type": "multiple-choice", "answers": [{"text": "FROM", "solution": "true"}, {"text": "WHERE", "solution": "false"}, {"text": "GROUP BY", "solution": "false"}, {"text": "HAVING", "solution": "false"}, {"text": "ORDER BY", "solution": "false"}, {"text": "SELECT", "solution": "true"}]}, {"id": 269, "category": 9, "difficulty": 1, "text": "Was versteht man unter SQLJ unter eine HOST-Variablen?", "type": "multiple-choice", "answers": [{"text": "HOST-Variable sind alle JAVA-Variablen, die static definiert sind.", "solution": "false"}, {"text": "HOST Variablen sind JAVA-Variablen, die in einer SQLJ-Klausel auftreten.", "solution": "true"}, {"text": "HOST-Variable gibt es unter SQLJ nicht.", "solution": "false"}]}, {"id": 270, "category": 9, "difficulty": 1, "text": "Durch welches Zeichen wird eine HOST-Variable in einer SQLJ-Klausel gekennzeichnet?", "type": "multiple-choice", "answers": [{"text": "!", "solution": "false"}, {"text": "*", "solution": "false"}, {"text": ":", "solution": "true"}]}, {"id": 275, "category": 9, "difficulty": 3, "text": "Mit welchem Schl\u00fcsselwort werden in SQLJ gespeicherte Funktionen (aus der Datenbank) aufgerufen?", "type": "text", "answers": [{"text": "Das Schl\u00fcsselwort ist:", "solution": "VALUES"}]}, {"id": 272, "category": 9, "difficulty": 1, "text": "Eine SQLJ-Klausel kann auch Werte zur\u00fcckliefern", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 276, "category": 9, "difficulty": 3, "text": "Welches Konstrukt ist unter SQLJ mit dem ResultSet aus JDBC bzw. dem CURSOR in PL/SQL vergleichbar?", "type": "text", "answers": [{"text": "Das Konstrukt hei\u00dft:", "solution": "Iterator"}]}, {"id": 634, "category": 4, "difficulty": 2, "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung wird ein ER-Modell erstellt?", "explanation": "In der Analysephase werden die Systemfunktionen und Daten in groben Z\u00fcgen geplant und festgelegt. Es wird eine explizite Systemdefinition in Form eines Lastenhefts vorgenommen. Dies geschieht umgangssprachlich in einer auch f\u00fcr Laien lesbaren Form. Au\u00dferdem werden die Daten mit Mitteln der Softwaretechnik, hier mit dem Entity-Relationship-Modell (kurz: ERM oder ER-Modell), genau beschrieben. Das ERM entspricht dem konzeptionellen Modell aus dem ANSI-3-Ebenen-Modell.", "type": "multiple-choice", "answers": [{"text": "Implementierungsphase", "solution": "false"}, {"text": "Analysephase", "solution": "true"}, {"text": "Entwurfsphase", "solution": "false"}]}, {"id": 277, "category": 9, "difficulty": 1, "text": "Es gibt folgende Iteratortypen unter SQLJ", "type": "multiple-choice", "answers": [{"text": "benannte Iteratoren", "solution": "true"}, {"text": "unbenannte Iteratoren", "solution": "true"}, {"text": "Iteratoren gibt es in SQLJ nicht.", "solution": "false"}]}, {"id": 279, "category": 9, "difficulty": 3, "text": "Durch welche Klasse werden in SQLJ Default-Verbindungen zu einer  Datenbank aufgebaut?", "type": "text", "answers": [{"text": "Die Klasse hei\u00dft:", "solution": "DefaultContext"}]}, {"id": 280, "category": 9, "difficulty": 2, "text": "Bei welchem JAVA-Programmtyp sind SQL-Fehlererkennungen schon zur \u00dcbersetzungszeit m\u00f6glich?", "explanation": "null", "type": "multiple-choice", "answers": [{"text": "JDBC", "solution": "false"}, {"text": "SQLJ", "solution": "true"}]}, {"id": 291, "category": 9, "difficulty": 3, "text": "Welche der folgenden DELETE-Anweisungen ist korrekt?", "explanation": "Eine DELETE-Anweisung kann nur komplette Zeilen einer Tabelle, keine einzelnen Spaltenwerte, l\u00f6schen.", "type": "multiple-choice", "answers": [{"text": "DELETE FROM Abteilungen;", "solution": "true"}, {"text": "DELETE Abt_nr, Bezeichnung\nFROM Abteilungen;", "solution": "false"}, {"text": "DELETE FROM TABLE Abteilungen;", "solution": "false"}]}, {"id": 284, "category": 9, "difficulty": 1, "text": "Mit welcher SELECT-Abfrage stellt man fest, ob eine Spalte vom Typ VARCHAR einen NULL-Wert hat?", "explanation": "Die einzige M\u00f6glichkeit, abzufragen, ob eine Spalte keinen Wert hat, ist im SQL-Standard \"IS NULL\".", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Tabelle\nWHERE Spalte <> '';\n", "solution": "false"}, {"text": "SELECT * FROM Tabelle\nWHERE Spalte IS NULL;", "solution": "true"}, {"text": "SELECT * FROM Tabelle\nWHERE Spalte > 0;", "solution": "false"}]}, {"id": 292, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Befehl l\u00f6scht man Tabellendefinitionen und gleichzeitig die Daten einer Tabelle?", "explanation": "Mit DELETE werden nur (einige) Datens\u00e4tze gel\u00f6scht, die Struktur der Tabelle bleibt erhalten. \nMit DROP werden die Datens\u00e4tze gel\u00f6scht und die Tabeellenstruktur zerst\u00f6rt, d.h. die Tabellendefinition aus dem Dictionary entfernt.", "type": "multiple-choice", "answers": [{"text": "DROP", "solution": "true"}, {"text": "DELETE", "solution": "false"}]}, {"id": 293, "category": 9, "difficulty": 3, "text": "Welchem Operator aus der relationalen Algebra entspricht der SQL-Ausdruck \"SELECT * FROM Teile, Artikel\"?", "explanation": "Eine SELECT-Anweisung auf mehreren Tabellen ohne WHERE-Klausel entspricht einen kartesischen Produkt bzw. einem Cross-Join. \n\nRA    SQL\n---------------\nProjektion     SELECT\nSelektion      WHERE \nKart. Produkt  FROM\nTheta Join     FROM + WHERE\nNatural Join   FROM + WHERE + ELECT\nVereinigung    UNION\nDifferenz      EXCEPT / MINUS / NOT IN / NOT EXISTS\nDurchschnitt    INTERSECTION\nDivision        \"doppeltes NOT EXISTS\" / \"Z\u00e4hlen\"", "type": "text", "answers": [{"text": "Dieser Operator hei\u00dft:", "solution": "kartesisches Produkt"}]}, {"id": 290, "category": 9, "difficulty": 2, "text": "Welche der folgenden Abfragen ist in SQL syntaktisch korrekt?", "explanation": "Eine Spalte, die nicht in der GROUP-BY-Klausel vorkommt, muss in der SELECT-Klausel eine Gruppenfunktion (AVG, SUM , MIN, MAX oder COUNT) haben.", "type": "multiple-choice", "answers": [{"text": "SELECT      Abt_Nr\nFROM       Angestellte\nGROUP BY  Abt_Nr\nWHERE     COUNT(*) > = 5;", "solution": "false"}, {"text": "SELECT      Abt_Nr\nFROM       Angestellte\nGROUP BY  Abt_Nr\nHAVING COUNT(*) > = 5;", "solution": "true"}, {"text": "SELECT      Abt_Nr\nFROM       Angestellte\nWHERE     COUNT(*) > = 5;\nGROUP BY  Abt_Nr;", "solution": "false"}]}, {"id": 294, "category": 9, "difficulty": 1, "text": "In Unterabfragen ist die ORDER-BY-Komponente vorgesehen.", "explanation": "Unterabfragen mit ORDER-BY machen keinen Sinn, da sie als ungeordnete Ergebnismenge genutzt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 295, "category": 9, "difficulty": 1, "text": "Womit wird in einer SQL-Abfrage der Existenzquantor umgesetzt?", "explanation": "Der Existenzquantor wird mit dem EXISTS-Operator umgesetzt. \nBeim Allquantor wird es etwas schwieriger. In der Relationalen Algebra gibt es die Division, In SQL gibt es daf\u00fcr gibt es keinen eigenen Operator. Man kann den Allquantor simulieren, entweder mittels einem \"doppelten NOT EXISTS\" oder durch z\u00e4hlen.", "type": "text", "answers": [{"text": "Der Ausdruck ist", "solution": "EXISTS"}]}, {"id": 660, "category": 9, "difficulty": 1, "text": "CONSTRAINTS sind eigene Datenbankobjekte, die unabh\u00e4ngig von einer Tabelle existieren.", "explanation": "Constraints werden nicht mit einem eigenen CREATE-Table-Befehl, sondern \u00fcber ein ALTER-Table oder CREATE-Table angelegt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 682, "category": 7, "difficulty": 1, "text": "Bei welchem Beziehungstyp eines ER-Diagramms entsteht bei der Abbildung auf ein relationales Datenbankschema immer eine neue Relation?", "explanation": "F\u00fcr n:m, cn:m, n:cm, cn:cm-Beziehungen im ERD gilt: \nF\u00fcr beide (bzw. drei bei einer tern\u00e4ren Beziehung) Entity-Mengen und die Beziehung werden je eine Relation mit entsprechenden verbindenden Beziehungen erzeugt.", "type": "multiple-choice", "answers": [{"text": "1:1-Beziehung", "solution": "false"}, {"text": "1:n-Beziehung", "solution": "false"}, {"text": "n:m-Beziehung", "solution": "true"}]}, {"id": 685, "category": 1, "difficulty": 1, "text": "Das konzeptionelles Schema ist", "explanation": "Das konzeptionelle Schema ist Bestandteil der konzeptionenn Ebene des ANSI-3-Ebenen-Modells und daher unabh\u00e4ngig vom eingesetzten konkreten Datenbanksystem.", "type": "multiple-choice", "answers": [{"text": "unabh\u00e4ngig vom eingesetzten Datenbanksystem", "solution": "true"}, {"text": "abh\u00e4ngig vom eingesetzten Datenbanksystem", "solution": "false"}]}, {"id": 663, "category": 9, "difficulty": 2, "text": "Bei einer materialisierten View (MV) wird nur der SELECT-Ausdruck der Sichtdefinition gespeichert. Die Daten werden also nicht redundant gespeichert.", "explanation": "Das ist die Definition der virtuellen View (VV).", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 664, "category": 9, "difficulty": 2, "text": "Durch welches Zeichen wird in SQL die Konkatenation von Zeichenketten dargestellt?", "explanation": "In SQL ist es das Pipe-Zeichen: || ", "type": "text", "answers": [{"text": "Das Zeichen ist:", "solution": "||"}]}, {"id": 665, "category": 9, "difficulty": 1, "text": "Mit welchem Zeichen in der SELECT-Klausel werden alle Spalten einer Tabelle bei einer SELECT-Anfrage ausgegeben?", "explanation": "SELECT * FROM tabellen WHERE ...; \nMit * werden immer alle Spalten aller Tabellen der FROM-Klausel ausgegeben.", "type": "text", "answers": [{"text": "Das Zeichen ist:", "solution": "*"}]}, {"id": 671, "category": 11, "difficulty": 2, "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Scenario verletzt?\n\nEine Transaktion enth\u00e4lt drei Update-Anweisungen. Nach der zweiten Update-Anweisung st\u00fcrzt der Rechner ab. Nach dem erneuten Hochfahren des Rechners sind die \u00c4nderungen der ersten beiden Update-Anweisungen sichtbar, nicht jedoch die der dritten Update-Anweisung.", "explanation": "Es ist die \"Atomicity\"-Eigenschaft verletzt. \nDie Atomarit\u00e4t besagt, dass entweder alle Manipulationen einer Transaktion persistent in der DB gespeichert werden - oder gar nicht. Hier wird nur eine Teilmenge der Aktionen in der DB ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "Das verletzt die Eigenschaft A Atomicity.", "solution": "true"}, {"text": "Das verletzt die Eigenschaft I Isolation", "solution": "false"}, {"text": "Das verletzt die Eigenschaft C Conistency.", "solution": "false"}, {"text": "Das verletzt die Eigenschaft D Durability.", "solution": "false"}]}, {"id": 672, "category": 11, "difficulty": 1, "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Scenario verletzt?\n\nEine Transaktion f\u00fcgt einen Satz mit einem Fremdschl\u00fcssel-Wert in eine Relation ein, der nicht als Prim\u00e4rschl\u00fcsselwert in der referenzierten Relation auftaucht.", "explanation": "Es ist die \"Consistency\"-Eigenschaft verletzt. \nDie Datenintegrit\u00e4t ist verletzt, denn die Fremdschl\u00fcssel-Eigenschaft stellt sicher, dass Fremdschl\u00fcsselwerte der einen Tabelle als Prim\u00e4rschl\u00fcsselwerte einer anderen Tabelle bereits vorhanden sind. Ist dies nicht der Fall, so muss das DBS die \u00c4nderung mit dem ung\u00fcltigen Fremdschl\u00fcsselwert als fehlerhaft melden und zur\u00fcckweisen.", "type": "multiple-choice", "answers": [{"text": "Das verletzt die Eigenschaft I Isolation.", "solution": "false"}, {"text": "Das verletzt die Eigenschaft C Consistency.", "solution": "true"}, {"text": "Das verletzt die Eigenschaft A Atomicity.", "solution": "false"}, {"text": "Das verletzt die Eigenschaft D Durability.", "solution": "false"}]}, {"id": 669, "category": 11, "difficulty": 2, "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Scenario verletzt?\n\nEine Transaktion A \u00e4ndert zwei S\u00e4tze S1 und S2. Eine zweite Transaktion B liest den Satz S1, bevor die Transaktion A einen Commit durchgef\u00fchrt hat, und erh\u00e4lt den von der Transaktion A ge\u00e4nderten Wert des Satzes S1.", "explanation": "Es ist die \"Isolation\"-Eigenschaft verletzt. \nDie zweite Transaktion liest ge\u00e4nderte Werte der ersten Transaktion, ohne das die diese \u00c4nderungen bereits dauerhaft in der DB gespeichert hat (\"commited\") hat. Beide Transaktionen laufen also nicht isoliert nebeneinander ab, sondern beeinflussen sich.", "type": "multiple-choice", "answers": [{"text": "Das verletzt die Eigenschaft A Atomicity.", "solution": "false"}, {"text": "Das verletzt die Eigenschaft I Isolation.", "solution": "true"}, {"text": "Das verletzt die Eigenschaft C Consistency.", "solution": "false"}, {"text": "Das verletzt die Eigenschaft D Durability.", "solution": "false"}]}, {"id": 670, "category": 11, "difficulty": 2, "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Scenario verletzt?\n\nEine Transaktion enth\u00e4lt zwei Insert-Anweisungen und wird mit Commit abgeschlossen. Anschlie\u00dfend passiert ein Plattenfehler. Nach den Recovery-Ma\u00dfnahmen sind die eingef\u00fcgten S\u00e4tze nicht mehr vorhanden.", "explanation": "Es ist die \"Durability\"-Eigenschaft verletzt. \nEs wurden Datens\u00e4tze persistent gespeichert (\"commited\"), die nach dem Fehler nicht wieder rekonstruiert werden konnten, somit wurde die Anforderung der \"Dauerhaftigkeit\" verletzt.", "type": "multiple-choice", "answers": [{"text": "Das verletzt die Eigenschaft C Consistency.", "solution": "false"}, {"text": "Das verletzt die Eigenschaft I Isolation.", "solution": "false"}, {"text": "Das verletzt die Eigenschaft A Atomicity.", "solution": "false"}, {"text": "Das verletzt die Eigenschaft D Durability.", "solution": "true"}]}, {"id": 102, "category": 10, "difficulty": 3, "text": "In welchen Data-Dictionary-Tabellen sind unter ORACLE Informationen zu CONSTRAINTS enthalten?", "explanation": "Das Dictionary von Oracle umfasst eine Vielzahl von Tabellen bzw. Sichten. Sie sind in verschiedene Gruppen aufgeteilt, die im Namen deutlich werden:\n\n    USER_...: Sichten f\u00fcr alle DB-Objekte, die ein Benutzer selbst angelegt hat.\n\n    ALL_...: Sichten f\u00fcr alle DB-Objekte, die ein Benutzer selbst angelegt hat bzw. f\u00fcr die er von anderen Anwendern Zugriffsrechte bekommen hat.\n\n    DBA_...: Sichten f\u00fcr alle DB-Objekte, die \u00fcberhaupt in der Datenbank existieren. Auf diese Sichten hat nur ein Benutzer mit Administrationsrechten Zugriff.\n\n    V$-Views: Sichten mit statistischen Informationen.\n\n    \n\n    USER_CONSTRAINTS gibt Auskunft \u00fcber die vom Anwender angelegten Constraints.\n\n    USER_CONS_COLUMNS gibt Auskunft \u00fcber die von den Constraints betroffenen Spalten.", "type": "multiple-choice", "answers": [{"text": "USER_CONSTRAINTS", "solution": "true"}, {"text": "CONSTRAINT_INFO", "solution": "false"}, {"text": "USER_CONS_COLUMNS", "solution": "true"}]}, {"id": 108, "category": 9, "difficulty": 2, "text": "Was bedeutet die folgende Abk\u00fcrzung (JDBC)?", "explanation": "Wer n\u00e4heres Wissen will, sollte bei SUN selber nachschlagen: \n\n<a href= \"http://java.sun.com/j2se/1.4.2/docs/api/java/sql/package-summary.html\"> JDBC-Dokumentation bei Sun .", "type": "text", "answers": [{"text": "JDBC =", "solution": "Java Database Connectivity"}]}, {"id": 930, "category": 11, "difficulty": 1, "text": "Bei welchem UPDATE-Verfahren werden \u00c4nderungen auf der Festplatte unmittelbar physisch durchgef\u00fchrt?", "explanation": "Recovery Basis-Techniken (f\u00fcr 'Nicht-Katastrophen-Fehler'): \nDeferred Update: \n\n \u00c4nderungen w\u00e4hrend der Transaktion nur in System-Log protokolliert\nauf der Platte werden sie erst beim COMMIT physisch aktualisiert \nbeim Zur\u00fcckrollen kein R\u00fcckg\u00e4ngigmachen n\u00f6tig\nNO-UNDO/REDO-Algorithmus\n\n\nImmediate Update:\n\n\u00c4nderungen werden in System-Log protokolliert und unmittelbar auf der Platte physisch aktualisiert\nbeim Zur\u00fcckrollen ist R\u00fcckg\u00e4ngigmachen notwendig \nUNDO/NO-REDO-Algorithmus\n", "type": "multiple-choice", "answers": [{"text": "Deferred Update", "solution": "false"}, {"text": "Immediate Update", "solution": "true"}]}, {"id": 971, "category": 42, "difficulty": 1, "text": "Welche Aussage ist korrekt?", "explanation": "Die Daten werden \u00fcber die Indexspalte(n) aufsteigend sortiert. Aus jedem Block wird der gr\u00f6\u00dfte Schl\u00fcsselwert als Repr\u00e4sentant vermerkt und in einer gesonderten Struktur, dem Index abgelegt. Der Index ordnet also jedem Block ein Intervall der m\u00f6glichen Schl\u00fcsselwerte zu. Der ISAM-Index ist ein d\u00fcnner Index mit logischen Adressen.", "type": "multiple-choice", "answers": [{"text": "Der ISAM-Index ist ein d\u00fcnner Index mit logischen Adressen.", "solution": "true"}, {"text": "Der ISAM-Index ist ein dichter Index mit logischen Adressen.", "solution": "false"}, {"text": "Der ISAM-Index ist ein d\u00fcnner Index mit physischen Adressen.", "solution": "false"}, {"text": "Der ISAM-Index ist ein dichter Index mit physischen Adressen.", "solution": "false"}]}, {"id": 932, "category": 11, "difficulty": 2, "text": "Die SET-Transaction-Anweisung unter ORACLE und SQL haben die gleiche Syntax.", "explanation": "SQL-Anweisung SET TRANSACTION (Oracle Auszug): \nSET TRANSACTION { { READ { ONLY | WRITE } \n                  | ISOLATION LEVEL {SERIALIZABLE | READ COMMITTED}};\n  \n\nSQL-Anweisung SET TRANSACTION (SQL-Standard Auszug): \nSET TRANSACTION { READ UNCOMMITTED \n                | READ COMMITTED \n                | REPEATABLE READ \n                | SERIALIZABLE } } ;", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 935, "category": 9, "difficulty": 2, "text": "Welches Interface bietet in JDBC die M\u00f6glichkeit, Parameter zu verarbeiten?", "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface. CallableStatement  und PreparedStatement  k\u00f6nnen Parameter mit dem Platzhalter \"?\" aufnehmen.", "type": "multiple-choice", "answers": [{"text": "CallableStatement", "solution": "true"}, {"text": "PreparedStatement", "solution": "true"}, {"text": "Statement", "solution": "false"}]}, {"id": 1240, "category": 9, "difficulty": 3, "text": "Welcher Parametertyp unter PL/SQL erm\u00f6glicht eine Wertzuweisung?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. Bei IN OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "false"}, {"text": "OUT", "solution": "true"}, {"text": "IN OUT", "solution": "true"}]}, {"id": 976, "category": 42, "difficulty": 1, "text": "Berechnen Sie die HASH-Funktion 28 modulo 9!", "explanation": "Die Modul-Funktion ist das Teilen mit Rest, also hier der Rest der beim Teilen von 28 durch 9 entsteht: Das ist 1.", "type": "text", "answers": [{"text": "Das Ergebnis ist", "solution": "1"}]}, {"id": 983, "category": 10, "difficulty": 1, "text": "Welche Transitionsvariablen gibt es unter PL/SQL?", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": ":BIG", "solution": "false"}, {"text": ":SMALL", "solution": "false"}, {"text": ":OLD", "solution": "true"}, {"text": ":NEW", "solution": "true"}]}, {"id": 1241, "category": 9, "difficulty": 1, "text": "Welche Parametertypen gibt es unter PL/SQL?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "TO", "solution": "false"}, {"text": "OUT", "solution": "true"}, {"text": "IN OUT", "solution": "true"}, {"text": "OUT IN", "solution": "false"}]}, {"id": 1242, "category": 9, "difficulty": 1, "text": "Was versteht man unter \"Impendence Mismatch\" ?", "explanation": "Das ist der grunds\u00e4tzliche Widerspruch zwischen der mengenorientierten Verarbeitung in SQL und der Einzelverarbeitung von Datens\u00e4tzen in einer prozeduralen Programmiersprache, der zwischen . JAVA oder PL/SQL und SQL auftritt. W\u00e4hrend in SQL eine mengenorienterte Verarbeitung erfolgt, muss das in einer Progerammiersprache \u00fcber Konstrukte wie einen Cursor oder ein RESULT-Set nachgebaut werden", "type": "multiple-choice", "answers": [{"text": "Das ist der grunds\u00e4tzliche Widerspruch zwischen der mengenorientierten Verarbeitung in SQL und der Einzelverarbeitung von Datens\u00e4tzen in einer prozeduralen Programmiersprache.", "solution": "true"}, {"text": "Das sind Erweiterungen von prozeduralen Programmiersprachen um datenbankspezifische Sprachkonstrukte.", "solution": "false"}, {"text": "Diesen Begriff gibt es im Zusammenhang mit Datenbanken nicht.", "solution": "false"}]}, {"id": 985, "category": 10, "difficulty": 1, "text": "Rekursive Trigger sind unter ORACLE-PL/SQL nicht zugelassen.", "explanation": "Trigger k\u00f6nnen durch DML-Anweisungen oder eben auch durch Datenbanktrigger ausgel\u00f6st werden, wobei auch rekursive Trigger syntaktisch zugelassen sind. F\u00fcr die Semantik ist dann der Programmierer selber zust\u00e4ndig.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 984, "category": 10, "difficulty": 1, "text": "Ein Trigger kann sich selber oder einen anderen Trigger ansto\u00dfen.", "explanation": "Trigger k\u00f6nnen durch DML-Anweisungen oder eben auch durch Datenbanktrigger ausgel\u00f6st werden, wobei auch rekursive Trigger syntaktisch zugelassen sind. F\u00fcr die Semantik ist dann der Programmierer selber zust\u00e4ndig.", "type": "multiple-choice", "answers": [{"text": "Stimmt", "solution": "true"}, {"text": "Stimmt nicht", "solution": "false"}]}, {"id": 993, "category": 9, "difficulty": 3, "text": "In welcher Sprache k\u00f6nnen die Methoden zu einem benutzerdefinierten Typ unter ORACLE programmiert werden?", "explanation": "PL/SQL ist hier Standardsprache, Java ist auch m\u00f6glich, da in der Datenbankserver eine virtuelle JAVA-Maschine integriert ist.", "type": "multiple-choice", "answers": [{"text": "PL/SQL", "solution": "true"}, {"text": "JAVA", "solution": "true"}, {"text": "PHP", "solution": "false"}, {"text": "C", "solution": "true"}, {"text": "C++", "solution": "false"}]}, {"id": 1244, "category": 11, "difficulty": 1, "text": "Was versteht man beim Transaktionshandling unter einem Konflikt von Datenbankoperationen?", "explanation": "RICHTIG ist:\n\"Ein Konflikt liegt vor, wenn die Operationen unterschiedlichen Transaktionen T1, ..,Tn angeh\u00f6ren, sie auf das gleiche Objekt zugreifen und mindestens eine Operation eine Schreiboperation ist.\"\n\nDie anderen beiden Definitionen sind insofern falsch, als die eine gar keine Schreiboperation vorgibt und die andere h\u00f6chstens eine Schreiboperation. Die Schreiboperation ist die kritische Aktion bei einem Konflikt, Leseoperationen k\u00f6nnen beliebig paralell ausgef\u00fchrt werden, und davon kann es beliebig viele geben, die koordiniert werden m\u00fcssen.", "type": "multiple-choice", "answers": [{"text": "Ein Konflikt liegt vor, wenn die Operationen unterschiedlichen Transaktionen T1,...,Tn angeh\u00f6ren, sie auf das gleiche Objekt zugreifen und h\u00f6chsten eine Operation eine Schreiboperation ist.", "solution": "false"}, {"text": "Ein Konflikt liegt vor, wenn die Operationen unterschiedlichen Transaktionen T1,...,Tn angeh\u00f6ren, sie auf das gleiche Objekt zugreifen und keine Operation eine Schreiboperation ist.", "solution": "false"}, {"text": "Ein Konflikt liegt vor, wenn die Operationen unterschiedlichen Transaktionen T1, ..,Tn angeh\u00f6ren, sie auf das gleiche Objekt zugreifen und mindestens eine Operation eine Schreiboperation ist.", "solution": "true"}]}, {"id": 395, "category": 9, "difficulty": 1, "text": "Welche Priorit\u00e4tsreihenfolge habe die logischen Operatorn unter SQL? \nTragen Sie bitte 1, 2, 3 oder 4 ein!", "explanation": "Priorit\u00e4tenreihenfolge der Operatoren (es ist die gleiche wie bei der Relationalen Algebra)\nPriorit\u00e4t Operator\n1         Alle Vergleichsoperatoren\n2         NOT\n3         AND\n4         OR", "type": "text", "answers": [{"text": "OR", "solution": "4"}, {"text": "Vergleichssoperatoren", "solution": "1"}, {"text": "AND", "solution": "3"}, {"text": "NOT", "solution": "2"}]}, {"id": 404, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgende Abfrage an einen Angestellten / Abteilungs -Tabelle:\nMan finde die Abteilungsnummern von Abteilungen in Dortmund, in denen es Angestellten gibt, die weniger als 2000 verdienen. Welche Abfrage liefert das gew\u00fcnschte Ergebnis?", "explanation": "Wenn die Tabellen der FROM-Klausel nicht mit einer Join-Bedingungen (hier AB.Abt_NR = a.Abt_Nr ) verkn\u00fcft sind, liefert die SELECT-Anweisung das kartesische Produkt der beteiligten Tabellen.", "type": "multiple-choice", "answers": [{"text": "SELECT A.Abt_NR \nFROM Angestellte A, Abteilungen AB\nWHERE AB.Ort = 'Dortmund' \nAND a.Gehalt < 2000;\n", "solution": "false"}, {"text": "SELECT A.Abt_NR \nFROM Angestellte A, Abteilungen AB\nWHERE AB.Abt_NR = a.Abt_NR\nAND AB.Ort = 'Dortmund' \nAND a.Gehalt < 2000;\n", "solution": "true"}]}, {"id": 400, "category": 9, "difficulty": 1, "text": "Bei einem  COLUMN-CONSTRAINT", "explanation": "Ein COLUMN-Constraint kann sich nur auf eine Spalte beziehen, ein TABLE-Constraint auch auf mehrere Spalten.", "type": "multiple-choice", "answers": [{"text": "k\u00f6nnen mehrere Spalten betroffen sein", "solution": "false"}, {"text": "sind immer mehrere Spalten betroffen", "solution": "false"}, {"text": "kann nur eine Spalte betroffen sein", "solution": "true"}, {"text": "ist \u00fcberhaupt keine Spalte betroffen", "solution": "false"}]}, {"id": 406, "category": 1, "difficulty": 2, "text": "In einer Datenbank sollen alle Daten widerspruchsfrei gespeichert werden.", "explanation": "Das ist die Definition von konsistenten Daten.", "type": "text", "answers": [{"text": "Diese Eigenschaft nennt man:", "solution": "Konsistenz"}]}, {"id": 407, "category": 1, "difficulty": 1, "text": "Bei welchem Datenmodell werden die Daten in einem Baum gespeichert?", "explanation": "Ein hierarchisches Datenbankmodell ist historisch gesehen das \u00e4lteste Datenbankmodell, es bildet die reale Welt durch eine hierarchische Baumstruktur ab und wurde sp\u00e4ter Grundlage des Netzwerkdatenmodells. Es entstand schon in den 50er Jahren und wurde Grundlage des Systems IMS/DB der Firma IBM. \nHeutzutage erlebt die hierarchische Datenspeicherung eine Renaissance in Verbindung mit XML-Datenbanken.", "type": "multiple-choice", "answers": [{"text": "Relationales Datenmodell", "solution": "false"}, {"text": "Hierarchisches Datenmodell", "solution": "true"}, {"text": "Netzwerkdatenmodell", "solution": "false"}]}, {"id": 473, "category": 11, "difficulty": 1, "text": "In einer Datenbank k\u00f6nnen Daten zeitweise auf verschiedenen Ebenen gesperrt werden, damit der einzelne Benutzer ungest\u00f6rt und vollst\u00e4ndig seine Transaktionen abschlie\u00dfen kann.", "explanation": "Das LOGGING-System ist daf\u00fcr zust\u00e4ndig, alle Informationen zu protokollieren, die f\u00fcr ein Zur\u00fcckrollen von Transaktionen aber auch zur Rekonstruktion nach DBS-Abst\u00fcrzen notwendig sind. \nDas LOCKING-System sorgt daf\u00fcr, dass Datens\u00e4tze f\u00fcr \u00c4nderungen exklusiv gesperrt werden.", "type": "multiple-choice", "answers": [{"text": "Diese Aufgabe leistet das Locking-System.", "solution": "true"}, {"text": "Diese Aufgabe leistet das Logging-System.", "solution": "false"}]}, {"id": 481, "category": 9, "difficulty": 3, "text": "Folgende Aussagen treffen auf virtuelle VIEWS zu:", "explanation": "Nur auf einfachen Views, z.B. ohne GROUP-BY, k\u00f6nnen UPDATE-Operationen durchgef\u00fchrt werden.", "type": "multiple-choice", "answers": [{"text": "Auf Views k\u00f6nnen Benutzerrechte vergeben werden.", "solution": "true"}, {"text": "In VIEWS k\u00f6nnen die gleichen UPDATE-Operationen durchgef\u00fchrt werden, wie auf Tabellen.", "solution": "false"}, {"text": "Auf Views k\u00f6nnen Abfragen (SELECT) gestartet werden", "solution": "true"}]}, {"id": 496, "category": 8, "difficulty": 3, "text": "Bei welchen Operatoren der relationalen Algebra m\u00fcssen alle Attribute der beteiligten Relationen \u00fcbereinstimmen, d.h. die gleiche Anzahl an Attributen, die gleiche Reihenfolge der Attribute, gleicher Datentyp/vergleichbarer Inhalt sowie gleicher Attributname? (vereinigungskonform)", "explanation": "Die Bedingung der \"Vereinigungskonformit\u00e4t\" gilt f\u00fcr alle drei Mengenoperatoren, nicht aber f\u00fcr die Join-Operatoren, die ja auf dem Kartesischen Produkt basieren und auch nicht f\u00fcr die Division. Bei der Division gilt die syntaktische Restriktion, dass die Attribute der Relation, durch die geteilt wird, eine echte Teilmenge der Attribute der Relation sein m\u00fcssen, die dividiert wird.", "type": "multiple-choice", "answers": [{"text": "UNION", "solution": "true"}, {"text": "JOIN", "solution": "false"}, {"text": "DIFFERENZ", "solution": "true"}, {"text": "DURCHSCHNITT", "solution": "true"}, {"text": "DIVISION", "solution": "false"}]}, {"id": 497, "category": 8, "difficulty": 1, "text": "Welcher Join-Operator unterdr\u00fcckt doppelte Join-Attribute?", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit gepr\u00fcft und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "multiple-choice", "answers": [{"text": "EQUI-Join", "solution": "false"}, {"text": "Natural-Join", "solution": "true"}, {"text": "Outer-Join", "solution": "false"}, {"text": "Theta-Join", "solution": "false"}]}, {"id": 499, "category": 8, "difficulty": 1, "text": "Welcher Join-Operator kommt in der relationalen Algebra nicht vor?", "explanation": "Den SuperJoin gibt es nicht. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. \nEin Equi-Join ist ein Theta-Join, der im Selektionspr\u00e4dikat nur den Vergleichsoperator \"=\" zul\u00e4sst. \nDer Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgef\u00fcllt\nwerden, die beim nat\u00fcrlichen Join herausfallen w\u00fcrden.   \nZudem gibt es noch die linken und rechten Outer Join-Operatoren. Der linke Outer-Join (linker \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R2 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden. \nDer rechte Outer-Join (rechter \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R1 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "Natural Join", "solution": "false"}, {"text": "Equi Join", "solution": "false"}, {"text": "Super Join", "solution": "true"}, {"text": "Outer Join", "solution": "false"}]}, {"id": 507, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgende Frage an die beiden Tabellen Angestellten und Abteilungen: In welchen Abteilungen sind alle Berufe der Unternehmung vertreten? Welche der folgenden Abfragen liefert das gew\u00fcnschte Ergebnis?", "explanation": "Da es hier darum geht, die Abteilungen mit \"ALLEN\" Berufen zu ermitteln, handelt es sich um eine sogennate  Allaussage (Allquantor) und der wird ja bekanntlich in der Relationalen Algebra mittels der Division realisiert. In SQL fehlt ein solcher Operator leider. Aber wie aus der Logik bekannt, kann ein Allquantor mittels einem \"doppelte negierten Existenzquantor\" simuliert werden. Diese Anfrage hat w\u00f6rtlich genommen die Semantik: \"Zeigen Sie die Abteilungen, f\u00fcr die es KEINE Berufe gibt, die es NICHT in der Firma gibt\" (vgl. mit Originalanfrage: semantisch \u00e4quivalent)\n\n    \n\n    Ein alternativer L\u00f6sungsansatz z\u00e4hlt die verschiedenen Berufe und ermittelt dann die Abteilungen mit der gleichen Anzahl an verschiedenen Berufen.\n\n    \n\n    SELECT A.Abt_NR, MAX(COUNT(A.Beruf))\n\n    FROM Angestellte A , Abteilungen B\n\n    WHERE A.Abt_Nr = B.Abt_Nr\n\n    GROUP BY A.Abt_nr\n\n    Diese Anfrage ist syntaktisch nicht ausf\u00fchrbar, da bei der Verwendung der MAX-Funktion in der SELECT-Klausel keine weiteren Spalten zul\u00e4ssig sind. MAX liefert nur einen Datensatz, es k\u00f6nnten aber durchaus mehrere Abteilungen alle Berufe enthalten.\n\n    \n\n    SELECT Abt_NR, Beruf\n\n    FROM Angestellte\n\n    WHERE beruf = ALL\n\n    (SELECT DISTINCT Beruf FROM Angestellte)\n\n    Diese Anfrage liefert immer die leere Menge, sobald mehr als zwei verschiedene Berufe in der Angestellten-Tabelle vorkommen. Denn f\u00fcr jeden Angestellten wird sein eingetragener Beruf verglichen, ob er gleich allen Datens\u00e4tzen der Unteranfrage ist. Ein Wert kann aber niemals GLEICH mit mehreren unterschiedlichen Werten sein.", "type": "multiple-choice", "answers": [{"text": "SELECT A1.Abt_Nr, A1.Name FROM Abteilungen A1\n\n      WHERE NOT EXISTS ( SELECT * FROM Angestellte A2\n\n          WHERE NOT EXISTS ( SELECT * FROM Angestellte A3 WHERE a2.Beruf = a3.Beruf AND a1.Abt_NR = a3.Abt_nr))", "solution": "true"}, {"text": "SELECT Abt_NR, Beruf\nFROM Angestellte \nwhere beruf = ALL \n  (SELECT Beruf FROM Angestellte)", "solution": "false"}, {"text": "SELECT Abt_NR, COUNT( DISTINCT Beruf) FROM Angestellte\n\n       GROUP By Abt_NR HAVING COUNT ( DISTINCT beruf) = (SELECT COUNT ( DISTINCT Beruf) FROM angestellte)", "solution": "true"}, {"text": "SELECT A.Abt_NR, MAX(COUNT(A.Beruf))\nFROM Angestellte A , Abteilungen B\nWHERE A.Abt_Nr = B.Abt_Nr\nGROUP BY A.Abt_nr", "solution": "false"}]}, {"id": 501, "category": 9, "difficulty": 1, "text": "Welche der folgenden Aussagen ist wahr?", "explanation": "Die GROUP BY-Klausel sorgt f\u00fcr die Gruppierung entsprechend den Werten in den aufgef\u00fchrten Spalten. Nachdem gruppiert wurde, kann - muss aber nicht - mittels der HAVING-Klausel eine Bedingung f\u00fcr diese Gruppen formuliert werden, die diese erf\u00fcllen m\u00fcssen. Da die HAVING-Klausel eine Bedingung f\u00fcr die Gruppen formuliert, macht eine HAVING-Klausel ohne GROUP BY keinen Sinn.", "type": "multiple-choice", "answers": [{"text": "Nach jeder GROUP-BY-Klausel muss eine HAVING-Klausel folgen", "solution": "false"}, {"text": "Nach einer GROUP-BY-Klausel kann eine HAVING-Klausel folgen", "solution": "true"}, {"text": "Eine HAVING-Klausel kann auch ohne GROUP BY vorkommen.", "solution": "false"}]}, {"id": 505, "category": 9, "difficulty": 3, "text": "Welche SELECT-Anweisung beantwortet die folgende Frage an die be\u00edden Tabellen \"Auto\" und \"Sonderausstattung\":\nWelche Autos haben keine Sonderausstattung?", "explanation": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr\nDieses SELECT hat eine so unsinnige Semantik, dass sie sich kaum in Worte fassen l\u00e4sst: Formal ist es die \"Komplementmenge des Natural Joins zum kartesischen Produkt\". Wem daf\u00fcr eine Semantik einf\u00e4llt, darf sich gerne melden - wird honoriert :-) versprochen :-) \n\nSELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)\nDer NOT IN w\u00e4re ja gut, wenn da nicht vorher der Natural Join zwischen Auto und Sonderausstattung w\u00e4re. Mit dem Natural Join werden alle Autos mit Sonderausstattung ermittelt und anschlie\u00dfend gepr\u00fcft, ob sie keine Sonderaustattung haben. Da wird wohl immer die leere Menge herauskommen.", "type": "multiple-choice", "answers": [{"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   B.Sonderausstattung IS NULL", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A\nWHERE A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)", "solution": "true"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr NOT EXISTS(\n      SELECT SerienNr FROM Sonderausstattung)", "solution": "false"}]}, {"id": 553, "category": 8, "difficulty": 3, "text": "Wie hei\u00dft die Mengenoperation, die mit Einschr\u00e4nkungen die gleiche Ergebnismenge liefert wie der Natural Join?", "explanation": "Natural Join und Intersection (Durchschnitt) sind beides Operationen, die nur die Tupel zur\u00fcckliefern, die in beiden Relationen vorhanden sind. \nZu den Unterschieden zwischen beiden Operationen geh\u00f6rt, dass beim Natural Join die Ergebnisdatenmenge aus den Attributen beider Relationen besteht, w\u00e4hrend beim Intersection die Attributstrukturen der beiden Relationen <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  sein m\u00fcssen.", "type": "text", "answers": [{"text": "Die Operation hei\u00dft (englische Bezeichung)", "solution": "Intersection"}]}, {"id": 1105, "category": 9, "difficulty": 1, "text": "Unter PL/SQL gibt es \u00f6ffentliche und private Prozeduren.", "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder \u00f6ffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind \u00f6ffentlich und k\u00f6nnen damit von au\u00dferhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und k\u00f6nnen damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 511, "category": 1, "difficulty": 2, "text": "Daten sollen in einer Datenbank nicht mehrfach gespeichert werden.", "explanation": "Unter Redundanz versteht man die Mehrfachspeicherung von Daten in unterschiedlichen Dateien. Werden an unterschiedlichen Stellen in einem Unternehmen entsprechende Daten dezentral erfasst und verarbeitet, lassen sich diese Anspr\u00fcche ohne zus\u00e4tzliche Logistik kaum realisieren.", "type": "text", "answers": [{"text": "Diese Eigenschaft nennt man:", "solution": "redundanzfrei"}]}, {"id": 512, "category": 1, "difficulty": 3, "text": "Ein Datenbanksystem besteht aus", "explanation": "Ein Datenbanksystem (DBS) ist eine Ansammlung von Daten, die allen Benutzern bzw. Anwendungen zur Verf\u00fcgung steht und in der die Daten nach einheitlichen Regeln abgespeichert werden. Ein Datenbanksystem besteht aus einer Datenbasis und einem Datenbankmanagementsystem. Der Begriff der Datenbank wird synonym verwendet.", "type": "multiple-choice", "answers": [{"text": "Datenbasis", "solution": "true"}, {"text": "Datenmodell", "solution": "false"}, {"text": "Anwendungsprogrammen", "solution": "false"}, {"text": "Data Dictionary", "solution": "true"}, {"text": "Verwaltungssoftware f\u00fcr die Datenbasis (DBMS)", "solution": "true"}, {"text": "Metadaten", "solution": "true"}]}, {"id": 515, "category": 1, "difficulty": 1, "text": "Welches Datenmodell ist in einer Baumstruktur organisiert?", "explanation": "Das hierarchisches Datenbankmodell ist das \u00e4lteste Datenbankmodell, es bildet die reale Welt durch eine hierarchische Baumstruktur ab und wurde sp\u00e4ter Grundlage des Netzwerkdatenmodells. Es entstand schon in den 60erJahren und wurde Grundlage des Systems IMS/DB der Firma IBM. Heutzutage erlebt die hierarchische Datenspeicherung eine Renaissance in Verbindung mit XML.", "type": "multiple-choice", "answers": [{"text": "Relationales Modell", "solution": "false"}, {"text": "Netzwerkdatenmodell", "solution": "false"}, {"text": "Hierarchisches Datenmodell", "solution": "true"}, {"text": "B-Baum-Modell", "solution": "false"}]}, {"id": 530, "category": 1, "difficulty": 2, "text": "Die Programme sind von der internen Organisation der Daten und den Zugriffsm\u00f6glichkeiten \u00fcber Zugriffspfade unabh\u00e4ngig.", "explanation": "Das ist die Definition der physische Datenunabh\u00e4ngigkeit.", "type": "multiple-choice", "answers": [{"text": "Diese Eigenschaft nennt man vertikale, logische  Datenunabh\u00e4ngigkeit.", "solution": "false"}, {"text": "Diese Eigenschaft nennt man horizontale, logische Datenunabh\u00e4ngigkeit.", "solution": "false"}, {"text": "Diese Eigenschaft nennt man physische Datenunabh\u00e4ngigkeit.", "solution": "true"}]}, {"id": 517, "category": 1, "difficulty": 2, "text": "Bei welchem Datenmodell werden Adressverweise in der Datenbank gespeichert?", "explanation": "Bis auf die relationalen Datenbanken war es bei \u00e4lteren Systemen, also den Netzwerkdatenbanken und den hierachischen Datenbanken, \u00fcblich, neben den Daten selber auch phyikalische Adressverweise in der Datenbank zu speichern.", "type": "multiple-choice", "answers": [{"text": "Hierarchisches Modell", "solution": "true"}, {"text": "Objektorientiertes Modell", "solution": "false"}, {"text": "Relationales Modell", "solution": "false"}, {"text": "Netzwerk-Datenmodell", "solution": "true"}]}, {"id": 529, "category": 1, "difficulty": 1, "text": "Programme sind stabil gegen\u00fcber \u00c4nderungen in anderen Programmen, die Anwendungsprogramme sind untereinander unabh\u00e4ngig.", "explanation": "Diese Eigenschaft ist die Definition der horizontalen, logischen Datenunabh\u00e4ngigkeit.", "type": "multiple-choice", "answers": [{"text": "Diese Eigenschaft nennt man vertikale, logische  Datenunabh\u00e4ngigkeit.", "solution": "false"}, {"text": "Diese Eigenschaft nennt man horizontale, logische  Datenunabh\u00e4ngigkeit.", "solution": "true"}, {"text": "Diese Eigenschaft nennt man physische Datenunabh\u00e4ngigkeit.", "solution": "false"}]}, {"id": 531, "category": 9, "difficulty": 3, "text": "In welche Richtung k\u00f6nnen HOST-Variable unter SQLJ Daten austauschen?", "type": "multiple-choice", "answers": [{"text": "von SQL nach JAVA", "solution": "true"}, {"text": "in beiden Richtungen", "solution": "true"}, {"text": "von JAVA nach SQL", "solution": "true"}]}, {"id": 521, "category": 1, "difficulty": 3, "text": "Welche Aufgaben hat ein Datenbankadministrator?", "explanation": "Die Hauptaufgaben des Datenbankadministrators sind:\n\nDatenbankdesign, Anlegen der Datenbank \nSoftwareinstallation und -wartung \nSpeicherplatzverwaltung \nImplementierung von Sicherheitsmechanismen \nLaden von Daten\nBackup und Recovery\nReorganisation von Datenbest\u00e4nden\nSystembeobachtung und -Tuning", "type": "multiple-choice", "answers": [{"text": "Datenbankdesign", "solution": "true"}, {"text": "Systemanalyse", "solution": "false"}, {"text": "Anwendungsentwicklung", "solution": "false"}, {"text": "Backup und Recovery", "solution": "true"}, {"text": "Tuning", "solution": "true"}, {"text": "Speicherplatzverwaltung", "solution": "true"}, {"text": "Beantwortung von Ad-Hoc-Abfragen an die Datenbank", "solution": "false"}]}, {"id": 522, "category": 1, "difficulty": 2, "text": "Welche Aufgaben hat ein Datenbankentwickler?", "explanation": "SystemanalyseUnter Systemanalyse versteht man den Entwurf des konzeptionellen Datenbankmodells,\nz.B. die Erstellung eines ER-Modells, die Erstellung einer kompletten Aufgabenbeschreibung\nund die Abstimmung von Lasten- und Pflichtenheften, sowie die Abstimmung mit\nbestehenden Applikationen und die Einbindung in ein komplexes Datenmodell.\nAd-hoc-AbfragenSystementwickler haben die Aufgabe, den Datenbestand zu beobachten, zu analysieren\nund Benutzeranfragen, die nicht fest programmiert werden m\u00fcssen, auszuwerten.\nDazu werden verschiedene SQL-Werkzeuge, die f\u00fcr den Endanwender nicht geeignet\nsind, eingesetzt.\nAnwendungsentwicklungHierzu geh\u00f6ren die Entwicklung von Masken und Reports und die Programmierung\nvon schriftlichen Dokumenten. Zum Einsatz kommen Programmiersprachen der\n4. Generation, wie PL/SQL von Oracle, Java oder C, auch um die Datenbank an das\nInternet anzubinden. Daneben ist eine Hauptaufgabe die Erstellung von Datenbankprozeduren\nund Datenbanktriggern, die in der Datenbank selbst abgespeichert werden.", "type": "multiple-choice", "answers": [{"text": "Softwareinstallation und Wartung", "solution": "false"}, {"text": "Systemanalyse", "solution": "true"}, {"text": "Backup und Recovery", "solution": "false"}, {"text": "Anwendungsentwicklung", "solution": "true"}, {"text": "Beantwortung von Benutzerfragen, die nicht fest programmiert werden sollen", "solution": "true"}, {"text": "Speicherplatzverwaltung", "solution": "false"}]}, {"id": 525, "category": 1, "difficulty": 2, "text": "Zu welcher Ebene einer Datenbankarchitektur geh\u00f6rt die Integrit\u00e4tspr\u00fcfung?", "explanation": "Die Integrit\u00e4tspr\u00fcfung ist Bestandteil der Anfrageverarbeitungsebene.", "type": "multiple-choice", "answers": [{"text": "1. Ebene: Verarbeitung von Benutzereingaben", "solution": "false"}, {"text": "2. Ebene: Anfrageverarbeitung", "solution": "true"}, {"text": "3. Ebene: Zugriffsstrukturen und Codeerzeugung", "solution": "false"}, {"text": "4. Ebene: Synchronisation paralleler Zugriffe", "solution": "false"}, {"text": "5. Ebene: Speicherverwaltung", "solution": "false"}]}, {"id": 526, "category": 1, "difficulty": 1, "text": "Zu welcher Ebene einer Datenbankarchitektur geh\u00f6rt der Parser?", "explanation": "Das ist die Ebene der Verarbeitung von Benutzereingaben.", "type": "multiple-choice", "answers": [{"text": "3. Ebene: Zugriffsstrukturen und Codeerzeugung", "solution": "false"}, {"text": "4. Ebene: Synchronisation paralleler Zugriffe", "solution": "false"}, {"text": "5. Ebene: Speicherverwaltung", "solution": "false"}, {"text": "1. Ebene: Verarbeitung von Benutzereingaben", "solution": "true"}, {"text": "2. Ebene: Anfrageverarbeitung", "solution": "false"}]}, {"id": 1107, "category": 9, "difficulty": 1, "text": "Wo deklariert man eine \u00f6ffentliche Prozedur unter PL/SQL?", "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder \u00f6ffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind \u00f6ffentlich und k\u00f6nnen damit von au\u00dferhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und k\u00f6nnen damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.", "type": "multiple-choice", "answers": [{"text": "im Package Header einer Paketdefinition", "solution": "true"}, {"text": "im Package Body einer Paketdefinition", "solution": "false"}, {"text": "solch einen Typ gibt es unter PL/SQL nicht", "solution": "false"}]}, {"id": 420, "category": 5, "difficulty": 1, "text": "ER-Modell: Um welchen Beziehungstyp handelt es sich hier?\nEin Student kann eine, keine oder mehrere Vorlesungen h\u00f6ren und eine Vorlesung kann von keinem, einem oder mehreren Studenten besucht werden.", "explanation": "Das ist die Definition einer cn:cm-Beziehung.", "type": "multiple-choice", "answers": [{"text": "m:n", "solution": "false"}, {"text": "1:n", "solution": "false"}, {"text": "cn:cm", "solution": "true"}]}, {"id": 425, "category": 9, "difficulty": 2, "text": "Der Datentyp \"K\u00fcnstlicher Schl\u00fcssel / Surrogate-Key\" geh\u00f6rt zum SQL2003-Standard.", "explanation": "So einen Datentypen gibt es gar nicht. \"Surrogate Keys/K\u00fcnstliche Prim\u00e4rschl\u00fcssel\" ist ein Konzept f\u00fcr kleine, effiziente Prim\u00e4rschl\u00fcssel, die die Vorteile haben, platzsparend beim Speichern und schnell beim Suchen und Lesen zu sein. Gemeint sind damit Prim\u00e4rschl\u00fcssel, die der Anwender gar nicht zu Gesicht bekommt, also rein anwendungsintern verwaltet werden, die aus nur einer Spalte bestehen, die einen numerischen Datentyp hat und, die mit einer fortlaufenden Nummer gef\u00fcllt wird. Diese fortlaufende Nummer kann in SQL mittels einer SEQUENCE generiert werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 426, "category": 11, "difficulty": 3, "text": "Was versteht man unter den ACID-Eigenschaften einer Transaktion? (Begriffe bitte in Englisch eintragen)", "explanation": "A \u0096 Atomicity Transaktionen sind atomar, also als unteilbare Einheiten zu betrachten. Transaktionen werden ganz oder gar nicht ausgef\u00fchrt.\nC \u0096 Consistency Eine Transaktion \u00fcberf\u00fchrt eine Datenbank von einem konsistenten Zustand in einen anderen konsistenten Zustand. Ein Datenzustand hei\u00dft konsistent, wenn alle Daten semantisch richtig, also im Anwendungskontext korrekt sind.\nI \u0096 Isolation Transaktionen laufen isoliert ab. Obwohl im Mehrbenutzerbetrieb gleichzeitig mehrere Transaktionen abgearbeitet werden, l\u00e4uft jede einzelne Transaktion wie in einem simulierten Einbenutzerbetrieb ab.\nD \u0096 Durability Die Ergebnisse einer Transaktion werden dauerhaft (persistent) in der Datenbank gespeichert.", "type": "text", "answers": [{"text": "A steht f\u00fcr", "solution": "Atomicity"}, {"text": "C steht f\u00fcr", "solution": "Consistency"}, {"text": "I steht f\u00fcr", "solution": "Isolation"}, {"text": "D steht f\u00fcr", "solution": "Durability"}]}, {"id": 428, "category": 11, "difficulty": 2, "text": "Um Datensicherheit zu gew\u00e4hrleisten und ein Zur\u00fcckfahren der Datenbank nach Datenbankfehlern zu erm\u00f6glichen, werden alle Transaktionen, die in der Datenbank ablaufen, mitprotokolliert.", "explanation": "Das LOGGING-System ist daf\u00fcr zust\u00e4ndig, alle Informationen zu protokollieren, die f\u00fcr ein Zur\u00fcckrollen von Transaktionen aber auch zur Rekonstruktion nach DBS-Abst\u00fcrzen notwendig sind. \nDas LOCKING-System sorgt daf\u00fcr, das Datens\u00e4tze f\u00fcr \u00c4nderungen exclusiv gesperrt werden.", "type": "multiple-choice", "answers": [{"text": "Diese Aufgabe leistet das Locking-System.", "solution": "false"}, {"text": "Diese Aufgabe leistet das Logging-System.", "solution": "true"}]}, {"id": 431, "category": 11, "difficulty": 2, "text": "Welcher Lock-Typ erlaubt anderen Benutzern lesende Zugriffe auf die Tabellen, die mit diesem Lock-Typ gesperrt wurden?", "explanation": "1. Typ: XLOCKS oder EXKLUSIVE LOCKS\nEin XLOCK bewirkt, dass keine andere Transaktion eine Sperrung auf ein Objekt, das schon einen XLOCK hat, absetzen kann. Der XLOCK wird bis zum Ende der Transaktion gehalten.\n\n2.Typ: SHARED LOCKS oder SLOCKS (geteilte LOCKS )\nFalls eine Transaktion T1 einen SLOCK auf eine Tabelle h\u00e4lt, hei\u00dft das, dass sie nur lesend zugreifen wird. Eine andere Transaktion T2 kann parallel auch einen SLOCK absetzen, wenn nur Lesezugriffe beabsichtigt sind. Allerdings kann eine Transaktion T3 keinen XLOCK auf die betroffene Tabelle absetzen, bis alle SLOCKS wieder gel\u00f6scht sind.", "type": "multiple-choice", "answers": [{"text": "XLOCK", "solution": "false"}, {"text": "SLOCK", "solution": "true"}, {"text": "EXCLUSIVE LOCK", "solution": "false"}]}, {"id": 433, "category": 11, "difficulty": 1, "text": "Wie nennt man das Verfahren, das nach folgender Methode verf\u00e4hrt:\n\n- Man nimmt an, dass viele schreibende Zugriffe auf die Datenbank stattfinden. \n- Auch lesende Zugriffe l\u00f6sen Sperren f\u00fcr andere Benutzer aus. \n- Die Daten werden erst wieder freigegeben, wenn alle \u00c4nderungen abgespeichert sind.", "explanation": "Passive und dynamische Sperrverfahren gibt es nicht.\n\nOptimistisches Sperrverfahren \nMan nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden. Lesende Zugriffe (SELECT) l\u00f6sen keine Sperren aus.\nJeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird. Bei \u00c4nderungen wird zun\u00e4chst gepr\u00fcft, ob der Zeitstempel unver\u00e4ndert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unver\u00e4ndert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.\n\nPessimistisches Sperrverfahren\nMan nimmt an, dass viele schreibende Zugriffe auf der Datenbank stattfinden.Auch lesende Zugriffe (SELECT FOR UPDATE statt SELECT) l\u00f6sen Sperren f\u00fcr andere Benutzer aus.Die Daten werden erst wieder freigegeben, wenn alle \u00c4nderungen abgespeichert sind.", "type": "multiple-choice", "answers": [{"text": "optimistisch", "solution": "false"}, {"text": "pessimistisch", "solution": "true"}, {"text": "dynamisch", "solution": "false"}, {"text": "passiv", "solution": "false"}]}, {"id": 2488, "category": 8, "difficulty": 3, "text": "Bei der Ausf\u00fchrung welcher Operatoren k\u00f6nnen Duplikate (doppelte Tupel) auftreten, die aber in der RA automatisch unterdr\u00fcckt werden (automatische Duplikatelimination)?", "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen, diese automatisch eliminiert werden. Zu diesen Operatoren geh\u00f6ren Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA.", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "true"}, {"text": "Selektion", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Join (NATURAL, THETA, EQUI, )", "solution": "false"}, {"text": "OUTER JOIN (LEFT, RIGHT, FULL)", "solution": "false"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Division", "solution": "true"}, {"text": "Es gibt keinen solchen Operator in der RA.", "solution": "false"}]}, {"id": 2489, "category": 8, "difficulty": 3, "text": "Welche der folgenden Operatoren der relationalen Algebra m\u00fcssen der Anforderung gen\u00fcgen, \"vereinigungskonform\" zu sein?", "explanation": "Die Forderung in der Relationalen Algebra <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Relationen (Eingangsdatenmengen) m\u00fcssen die gleichen Attributdefinitionen aufweisen: \nDie Anzahl der Attribute muss \u00fcbereinstimmen. \nDie Attribute m\u00fcssen gleich hei\u00dfen.  \nDie Datentypen der der Attribute m\u00fcssen gleich sein.  \nDie Reihenfolge der Attribute muss \u00fcbereinstimmen. \nAchtung: In SQL wird diese Definition leicht variieren (keine gleichen Attributnamen).", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Selektion", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Join (NATURAL, THETA, EQUI, )", "solution": "false"}, {"text": "OUTER JOIN (LEFT, RIGHT, FULL)", "solution": "false"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Differenz", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Es gibt keine solche Anforderung in der RA.", "solution": "false"}]}, {"id": 2490, "category": 8, "difficulty": 3, "text": "Welche der folgende Aussagen \u00fcber den Natural Join sind wahr?", "explanation": "Der Natural Join ist ableitbar aus dem kartesischen Produkt mit anschlie\u00dfender Selektion gem\u00e4ss der implizit definierten Natural Join-Bedingung \u00fcber alle Attribute, die gleichhei\u00dfen, und abschlie\u00dfender Projektion, so dass die gleichhei\u00dfenden Attribute nur einmal in der Ergebnismenge vorkommen. \nGrundoperatoren sind Operatoren, die nicht simuliert werden k\u00f6nnen und damit ist der Natural Join keiner.", "type": "multiple-choice", "answers": [{"text": "F\u00fcr die Verkn\u00fcpfungsbedingung werden nur die Fremd- und Prim\u00e4rschl\u00fcsselattribute, die gleich hei\u00dfen, auf Gleichheit mit einander verglichen.", "solution": "false"}, {"text": "Die Attribute, die in beiden Relationen namensgleich vorkommen, treten in der Ergebnismenge nur einmal auf.", "solution": "true"}, {"text": "Er kann simuliert werden durch die RA-Operatoren kartesisches Produkt, Selektion, Projektion.", "solution": "true"}, {"text": "Er ist kein Grundoperator der relationalen Algebra.", "solution": "true"}]}, {"id": 544, "category": 5, "difficulty": 1, "text": "Von welchem Grad sind bin\u00e4re Beziehungen?", "explanation": "Das ist eine schwierige Frage :-), die an die  philosophische Fakult\u00e4t weitergegeben wurde.", "type": "text", "answers": [{"text": "Sie sind vom Grad (als Zahl eintragen):", "solution": "2"}]}, {"id": 434, "category": 11, "difficulty": 2, "text": "Bei welchem LOCK-Verfahren wird ein Zeitstempel verwendet?", "explanation": "Passive und dynamische Sperrverfahren gibt es nicht.\n\nOptimistisches Sperrverfahren \nMan nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden. Lesende Zugriffe (SELECT) l\u00f6sen keine Sperren aus.\nJeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird. Bei \u00c4nderungen wird zun\u00e4chst gepr\u00fcft, ob der Zeitstempel unver\u00e4ndert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unver\u00e4ndert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.\n\nPessimistisches Sperrverfahren\nMan nimmt an, dass viele schreibende Zugriffe auf der Datenbank stattfinden.Auch lesende Zugriffe (SELECT FOR UPDATE statt SELECT) l\u00f6sen Sperren f\u00fcr andere Benutzer aus.Die Daten werden erst wieder freigegeben, wenn alle \u00c4nderungen abgespeichert sind.", "type": "multiple-choice", "answers": [{"text": "pessimistische Verfahren", "solution": "false"}, {"text": "optimistische Verfahren", "solution": "true"}, {"text": "dynamische Verfahren", "solution": "false"}, {"text": "passive Verfahren", "solution": "false"}]}, {"id": 1093, "category": 42, "difficulty": 1, "text": "Welche Speicherstruktur hat folgende Eigenschaften:\n\nDie Daten werden \u00fcber die Indexspalte(n) aufsteigend sortiert. \nAus jedem Block wird der gr\u00f6\u00dfte Schl\u00fcsselwert als Repr\u00e4sentant vermerkt und in einer gesonderten Tabelle abgelegt.\nDer Index ordnet jedem Block ein Intervall der m\u00f6glichen Schl\u00fcsselwerte zu.", "explanation": "Das ist die Definition des ISAM-Index, der z.B. bei Mysql mit MyISAM verwendet wird.", "type": "multiple-choice", "answers": [{"text": "HEAP", "solution": "false"}, {"text": "ISAM", "solution": "true"}, {"text": "B+ Baum", "solution": "false"}, {"text": "HASH", "solution": "false"}]}, {"id": 444, "category": 9, "difficulty": 3, "text": "Mit welcher Erg\u00e4nzung zu DROP TABLE... l\u00f6scht man alle Fremdschl\u00fcssel-CONSTRAINTS, die diese Tabelle referenzieren?", "explanation": "Specify CASCADE CONSTRAINTS to drop all referential integrity constraints that refer to primary and unique keys in the dropped table. If you omit this clause, and such referential integrity constraints exist, then the database returns an error and does not drop the table.", "type": "text", "answers": [{"text": "Der Befehl hei\u00dft:", "solution": "CASCADE CONSTRAINTS"}]}, {"id": 445, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN ORDER BY Nachname DESC\"", "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel-", "type": "multiple-choice", "answers": [{"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "true"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine Gruppierung", "solution": "false"}]}, {"id": 450, "category": 5, "difficulty": 1, "text": "In ER-Diagrammen k\u00f6nnen Beziehungen auch Attribute haben.", "explanation": "Beziehungen in ER-Modellen k\u00f6nnen Attribute haben, auch wenn das viele grafische ER-Zeichentools leider nicht unterst\u00fctzen", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 452, "category": 9, "difficulty": 2, "text": "Mit der Methode getString des ResultSets kann man", "explanation": "getXXX(), z.B. getString(...),  liefern im ResultSet den Wert einer Spalte zur\u00fcck, wobei man \u00fcber die Spaltennummer oder \u00fcber den Spaltennamen zugreifen kann.", "type": "multiple-choice", "answers": [{"text": "\u00fcber die Spaltennummer zugreifen", "solution": "true"}, {"text": "\u00fcber den Spaltenname zugreifen", "solution": "true"}]}, {"id": 453, "category": 9, "difficulty": 2, "text": "Zur DML-Sprache geh\u00f6ren die folgenden Befehle:", "explanation": "DDL (Data Definition Language): CREATE, ALTER, DROP, RENAME, ... \nDML (Data Manipulation Language): INSERT, UPDATE, DELETE \nDQL (Data Query Language): SELECT", "type": "multiple-choice", "answers": [{"text": "CREATE", "solution": "false"}, {"text": "INSERT", "solution": "true"}, {"text": "UPDATE", "solution": "true"}, {"text": "ALTER", "solution": "false"}, {"text": "RENAME", "solution": "false"}]}, {"id": 455, "category": 9, "difficulty": 3, "text": "In welcher SELECT-Klausel sind Gruppenfunktionen (COUNT, MIN, MAX, AVG, SUM) erlaubt, wenn der SELECT keinen SUBSELECT enth\u00e4lt?", "explanation": "In der WHERE-Klausel sind keine Gruppenfunktionen erlaubt, da sich die Where-Klausel auf einzelne Zeilen, nicht auf eine Menge von Zeilen bezieht.", "type": "multiple-choice", "answers": [{"text": "In der FROM-Klausel", "solution": "false"}, {"text": "In der WHERE-Klausel", "solution": "false"}, {"text": "In der GROUP-BY-Klausel", "solution": "false"}, {"text": "in der HAVING-Klausel", "solution": "true"}, {"text": "In der ORDER-BY-Klausel", "solution": "true"}, {"text": "In der SELECT-Klausel", "solution": "true"}]}, {"id": 458, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren der relationalen Algebra l\u00e4sst sich der Natural-Join-Operator simulieren?", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. \n \nDas erreicht man damit, dass zuerst ein Kartesisches Produkt ausgef\u00fchrt wird (damit hat man alle Attribute beider Relationen nebeneinander stehen), dann werden nur die Tupel in die Ergebnismenge \u00fcbernommen f\u00fcr die die Join-Bedingung zu \"wahr\" ausgewertet wird (die Inhalte aller gleichlautenden Attribute werden auf Gleichheit gepr\u00fcft). Abschlie\u00dfend m\u00fcssen noch die doppelten gleichlautenden Attribute entfernt werden aus der Ergebnismenge und das kann mit einer Projektion erreichen.", "type": "multiple-choice", "answers": [{"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "true"}]}, {"id": 462, "category": 8, "difficulty": 2, "text": "Jemand schl\u00e4gt vor, als Prim\u00e4rschl\u00fcssel einer Auftragspositionen-Relation nicht die Kombination von AuftragsNr und und ArtikelNr (wie bisher) zu w\u00e4hlen, sondern nur die AuftragsNr. Was w\u00fcrde das bedeuten?", "explanation": "Ist nur die AuftragsNr Prim\u00e4rschl\u00fcsselattribut, so kann in der Auftragspositionen-Relation jede Auftragsnummer nur einmal vorkommen, mit der Konsequenz, dass es je Auftrag nur einen Artikel geben kann. \nGrund daf\u00fcr ist die Eigenschaft der Eindeutigkeit bei (Prim\u00e4r-)Schl\u00fcsseln.", "type": "multiple-choice", "answers": [{"text": "Ein Auftrag besteht h\u00f6chsten aus einem Artikel.", "solution": "true"}, {"text": "Ein Artikel kann insgesamt nur einmal bestellt werden.", "solution": "false"}, {"text": "Es macht keinen Unterschied zur anderen L\u00f6sung.", "solution": "false"}, {"text": "Keine dieser Antworten ist korrekt.", "solution": "false"}]}, {"id": 465, "category": 9, "difficulty": 2, "text": "Mit welchem Aufruf werden in SQLJ in der Datenbank gespeicherte Prozeduren aufgerufen?", "type": "multiple-choice", "answers": [{"text": "execute", "solution": "false"}, {"text": "call", "solution": "true"}, {"text": "start", "solution": "false"}]}, {"id": 466, "category": 9, "difficulty": 3, "text": "Mit welchem Isolationsgrad (Konstante der Methode setTransactionIsolation des Interfaces connection) werden im Datenbanksystem unter JDBC keine Sperren mehr gesetzt?", "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgef\u00fchrt.", "type": "text", "answers": [{"text": "Der Isolationsgrad hei\u00dft", "solution": "TRANSACTION_NONE"}]}, {"id": 468, "category": 8, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber die relationale Algebra ist wahr?", "explanation": "Selektion ist die Auswahl von Tupeln und Projektion die Auswahl von Attributen. \nDie Ergebnismenge eines kartesischen Produkts angewendet auf zwei Relationen mit je n bzw. m Tupeln umfasst n x m Tupel. \nDie Division (Allaussage, Allquantor) k\u00f6nnte man zwar analog zu SQL mittels einer doppelten Differenz und vielen anderen Operatoren simulieren, aber als eine spezielle Form der Differenz kann sie wahrlich nicht bezeichnet werden. \nDie beiden Operatoren Selektion und der Projektion als Grundoperationen reichen nicht, um alle Operatoren der relationalen Algebra abzuleiten. Es fehlt u.a. ein so wichtiger Operator wie das Kartesische Produkt, dem einzigen Grundoperator, mit dem man die Tupel \"nebeneinander verkn\u00fcpfen kann\".", "type": "multiple-choice", "answers": [{"text": "Selektion ist die Auswahl von Attributen und Projektion die Auswahl von Tupeln.", "solution": "false"}, {"text": "Die Ergebnismenge eines kartesischen Produkts angewendet auf zwei Relationen mit je n bzw. m Tupeln umfasst n x m Tupel.", "solution": "true"}, {"text": "Die Division ist eine spezielle Form der Differenz.", "solution": "false"}, {"text": "Alle Operatoren der relationalen Algebra lassen sich aus der Selektion und der Projektion als Grundoperationen ableiten.", "solution": "false"}]}, {"id": 469, "category": 8, "difficulty": 2, "text": "Betrachten Sie zwei Relationen Artikel(ArtikelNr, Bezeichnung...)und Auftragspositionen (AuftragsNr, ArtikelNr, Menge...). Die Relation Auftragspositionen enth\u00e4lt einen Fremdschl\u00fcssel zu dem Attribut ArtikelNr in der Relation Artikel. Die Relation Artikel soll jetzt nur noch Eintr\u00e4ge enthalten, die auch wenigstens einmal gekauft wurden. Kann man das Problem l\u00f6sen, indem man ArtikelNr in ARTIKEL als zus\u00e4tzlichen Fremdschl\u00fcssel deklariert, der auf das Attribut ArtikelNr in der Relation Auftragspositionen referenziert?", "explanation": "An dieser Stelle l\u00f6sen Fremdschl\u00fcssel, die man in beiden Richtungen vereinbaren kann, nicht das Problem, da sie sich gegenseitig behindern und so das Einf\u00fcgen von Daten generell verhindern w\u00fcrden. Denkbar sind allerdings Datenbanktrigger zur L\u00f6sung dieses Problems.", "type": "multiple-choice", "answers": [{"text": "Nein. Das w\u00e4re kein g\u00fcltiger Fremdschl\u00fcssel.", "solution": "false"}, {"text": "Man kann den Fremdschl\u00fcssel deklarieren, aber er w\u00fcrde das Problem nicht l\u00f6sen.", "solution": "true"}, {"text": "Ja", "solution": "false"}]}, {"id": 470, "category": 9, "difficulty": 1, "text": "Welche SQL-Abfragen liefern das gleiche Ergebnis?", "explanation": "Der BETWEEN-Vergleichsoperator schlie\u00dft die Grenzwerte beim Vergleich mit ein, so dass die WHERE-Klausel \"Gehalt >= 3000  AND  Gehalt <= 3600\" die gleichen Datens\u00e4tze in der Ergebnisdatenmenge liefert. \nIN vergleicht nur mit den beiden Werten 3000 und 3600, aber nicht die Zwischenwerte 3001 ... 3599.", "type": "multiple-choice", "answers": [{"text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt BETWEEN 3000 AND 3600;", "solution": "true"}, {"text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt > 3000 \nAND     Gehalt < 3600", "solution": "false"}, {"text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt >= 3000 \nAND     Gehalt <= 3600", "solution": "true"}, {"text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt IN (3000, 3600)", "solution": "false"}]}, {"id": 472, "category": 9, "difficulty": 3, "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nDer Vertriebsleiter Dr. Guck der Firma Byce & Co. m\u00f6chte herausfinden, f\u00fcr welche Artikel \u00fcberhaupt Auftr\u00e4ge vorliegen. Er stellt diese Anfrage an die EDV-Abteilung. Welche der folgenden Anfragen liefert das gew\u00fcnschte Ergebnis?", "explanation": "Man kann diese Anfrage mittels Natural Join, IN-, EXISTS-Operator l\u00f6sen. Mann kann auch eine Anfrage in einer FROM-Klausel formulieren. \n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN (SELECT * FROM Auftraege b \n        WHERE a.TNr = b.TNr); \nDiese Anfrage ist falsch, weil sie syntaktisch nicht richtig ist. Wenn der linke Operand des IN-Operators die TNR ist, dann k\u00f6nnen beim rechten Operanden nicht alle Spalten f\u00fcr die Ergebnismenge selektiert werden. Statt SELECT * m\u00fcsste hier SELECT TNR stehen. Und dann w\u00e4re die WHERE-Klausel beim Sub-SELECT \u00fcberfl\u00fcssig. \n\n\nSELECT      DISTINCT a.TNr,  a.Bezeichnung\nFROM         Artikel a, (SELECT * FROM Auftragspositionen) b;\nDiese Anfrage ist falsch, weil statt einem Natural Join nur ein kartesisches Produkt formuliert wurde. Es fehlt z.B. eine WHERE-Klausel mit  WHERE      a.Tnr = b.Tnr; \n\n\nSELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;\nDiese Anfrage ist falsch, weil sie syntaktisch nicht richtig ist. \nDie Spalte Bezeichnung gibt es nicht in der Auftragspositionen-Tabelle, sondern nur in der Artikel-Tabelle.", "type": "multiple-choice", "answers": [{"text": "SELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;", "solution": "true"}, {"text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN (SELECT * FROM Auftraege b \n        WHERE a.TNr = b.TNr);", "solution": "false"}, {"text": "SELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS \n        (SELECT b.TNR FROM Auftragspositionen b \n                  WHERE a.TNR = b.TNR);", "solution": "true"}, {"text": "SELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;", "solution": "true"}, {"text": "SELECT      DISTINCT a.TNr,  a.Bezeichnung\nFROM         Artikel a, (SELECT * FROM Auftragspositionen) b;", "solution": "false"}, {"text": "SELECT      a.TNr, a.Bezeichnung\nFROM         Artikel a\nWHERE       TNR IN (SELECT TNr FROM Auftragspositionen);", "solution": "true"}, {"text": "SELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;", "solution": "false"}]}, {"id": 1098, "category": 42, "difficulty": 1, "text": "Welche Speicherstruktur ist bei einem direkten Zugriff \u00fcber den Prim\u00e4rschl\u00fcssel schneller?", "explanation": "Da bei einer HASH-Struktur ist beim Zugriff \u00fcber den Prim\u00e4rschl\u00fcsssel am schnellsten, da keine zus\u00e4tzlichen Daten von der Festplatte gelesen werden m\u00fcssen. Der HASH-Algorithmus liefert direkt die Adresse des zugeordneten Blocks.", "type": "multiple-choice", "answers": [{"text": "B+ Baum", "solution": "false"}, {"text": "HASH", "solution": "true"}]}, {"id": 220, "category": 9, "difficulty": 3, "text": "Das \"IN\"-Pr\u00e4dikat hat unter der SELECT-Anweisung in SQL folgende Eigenschaften:", "explanation": "Die rechte Vergleichsmenge des IN-Operators kann entweder eine Menge konstanter Werte gleichen Typs aber ohne Duplikate sein oder es wird an dieser Stelle eine SELECT-Anfrage ausgef\u00fchrt und mit deren Ergebnismenge verglichen.", "type": "multiple-choice", "answers": [{"text": "Die rechte Vergleichsmenge darf Konstanten gleichen Typs enthalten.", "solution": "true"}, {"text": "Die rechte Vergleichsmenge darf Operatoren wie \"+, - , *  und / \" enthalten.", "solution": "false"}, {"text": "Die rechte Vergleichsmenge darf Konstanten unterschiedlichen Typs enthalten.", "solution": "false"}, {"text": "Die rechte Vergleichsmenge darf eine SELECT-Anweisung enthalten.", "solution": "true"}, {"text": "Die rechte Vergleichsmenge darf zwei gleiche Konstanten enthalten.", "solution": "true"}]}, {"id": 221, "category": 9, "difficulty": 1, "text": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX)", "explanation": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX) geh\u00f6ren zum SQL-Standard.", "type": "multiple-choice", "answers": [{"text": "geh\u00f6ren zum SQL-Standard.", "solution": "true"}, {"text": "sind ORACLE-spezifisch.", "solution": "false"}]}, {"id": 223, "category": 9, "difficulty": 1, "text": "Mit welcher SQL-Gruppenfunktion berechnet man den Mittelwert einer Spalte?", "explanation": "Die SQL-Gruppenfunktion AVG(spaltenname) berechnet den Mittelwert einer Spalte \"spaltenname\".", "type": "text", "answers": [{"text": "Die Funktion hei\u00dft:", "solution": "AVG"}]}, {"id": 224, "category": 9, "difficulty": 1, "text": "NULL-Werte werden bei den Gruppenfunktionen in SQL (z.B. COUNT) ber\u00fccksichtigt.", "explanation": "NULL-Werte werden bei den Gruppenfunktionen in SQL (z.B. COUNT) nicht ber\u00fccksichtigt. \nGehen Sie z.B. von folgenden Datens\u00e4tzen aus: \nspalte1  spalte2\n   ab,       123,  \n   cd,       NULL, \n   df,       234, \nWird nun mit SELECT COUNT(spalte2) \u00fcber Spalte2 gez\u00e4hlt, so lautet das Ergebnis: 2 Datens\u00e4tze. \nWird aber mit SELECT COUNT(spalte1) \u00fcber Spalte1 gez\u00e4hlt, so lautet das Ergebnis: 3 Datens\u00e4tze. \nDie Semantik beider SELECTs ist sehr unterschiedlich. \nZ\u00e4hlt man \u00fcber Spalte2, so hat die Ergebnismenge die Semantik:  \"Wieviele Datens\u00e4tze sind in Spalte2 nicht leer?\"\nZ\u00e4hlt man \u00fcber Spalte1, so hat die Ergebnismenge die Semantik:  \"Wieviele Datens\u00e4tze hat die Tabelle?\"", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 227, "category": 9, "difficulty": 2, "text": "In der Ausgabe wird \u00fcber die GROUP-BY-Spalten aufsteigend sortiert.\nDiese Aussage", "explanation": "In der Ausgabe wird \u00fcber die GROUP BY-Spalten aufsteigend sortiert. \nAber eigentlich ist f\u00fcr die Sortierung die ORDER BY-Klausel zust\u00e4ndig mit den beiden Optionen ASC und DESC. Die Sortierung bei der Gruppierung ist nur ein Nebenprodukt der eigentlichen Aufgabe, der Guppenbildung.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 264, "category": 9, "difficulty": 2, "text": "Der Vergleichsoperator \"ungleich\" hei\u00dft in SQL:", "explanation": "Die Vergleichsoperatoren f\u00fcr Ungleicheit sind: <> oder !=", "type": "multiple-choice", "answers": [{"text": "=!", "solution": "false"}, {"text": "<>", "solution": "true"}, {"text": "!=", "solution": "true"}, {"text": "UNLIKE", "solution": "false"}, {"text": "UNEQUAL", "solution": "false"}]}, {"id": 233, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Befehl werden Daten in Tabellen eingef\u00fcgt? Bitte geben Sie nur einen Ausdruck, nicht den kompletten Befehl  ein!", "explanation": "Es gibt einen Befehl zum Einf\u00fcgen von genau einem Datensatz:\n\n    INSERT INTO tabellenname VALUES (spaltenwert_1, ..., spaltenwert_n);\n\n    Und es  gibt einen Befehl zum Einf\u00fcgen von mehreren Datens\u00e4tzen aus anderen Tabellen oder Sichten:\n\n    INSERT INTO tabellenname AS SELECT (spaltenwert_1, ..., spaltenwert_n) FROM ... WHERE ...;", "type": "text", "answers": [{"text": "Der Befehl hei\u00dft:", "solution": "INSERT"}]}, {"id": 231, "category": 9, "difficulty": 2, "text": "Bei einer \"CREATE VIEW AS SELECT * FROM TABLE TEST\" - Anweisung", "explanation": "Mit \"CREATE VIEW AS SELECT..\" wird eine virtuelles View nach SQL-Standard, keine materialisierte View, angelegt.", "type": "multiple-choice", "answers": [{"text": "werden auch die Daten der Tabelle Test kopiert", "solution": "false"}, {"text": "wird nur die SELECT-Anweisung in der Datenbank gespeichert.", "solution": "true"}]}, {"id": 101, "category": 9, "difficulty": 2, "text": "In CHECK-Constraints sind unter ORACLE-SQL auch Abfragen m\u00f6glich.", "explanation": "Leider entspricht Oracle hier nicht dem SQL2-Standard, unter dem solche CHECK-Constraints mit SELECT-Anfragen schon 1992 vorgesehen waren.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "false"}, {"text": "nein", "solution": "true"}]}, {"id": 103, "category": 9, "difficulty": 2, "text": "Mit welchem Befehl l\u00f6scht man einen CONSTRAINT?", "explanation": "Constraints sind keine eigenen Datenbankobjekte, sie der geh\u00f6ren zu einer Tabelle und werden daher auch nicht mit einem eigenen DROP-Befehl gel\u00f6scht, sondern mit einem ALTER TABLE-Befehl.", "type": "multiple-choice", "answers": [{"text": "ALTER TABLE XYZ DELETE CONSTRAINT ...", "solution": "false"}, {"text": "DELETE CONSTRAINT ...", "solution": "false"}, {"text": "ALTER TABLE XYZ DROP CONSTRAINT ...", "solution": "true"}, {"text": "DROP CONSTRAINT ...", "solution": "false"}]}, {"id": 107, "category": 9, "difficulty": 1, "text": "Was bedeutet die Abk\u00fcrzung (DML)?", "explanation": "DML ist die Abk\u00fcrzung f\u00fcr Data Manipulation Language und meint die SQL-Befehle INSERT, UPDATE, DELETE. Manche z\u00e4hlen auch noch SELECT dazu. Aber bei uns geh\u00f6rt SELECT zur DQL: Data Query Language.", "type": "text", "answers": [{"text": "DML =", "solution": "Data Manipulation Language"}]}, {"id": 112, "category": 9, "difficulty": 2, "text": "Objekttypen und benutzerdefinierte Datentypen wurden im folgenden SQL-Standard definiert:", "explanation": "Die objektrelationalen Erweiterungen kommen mit SQL3 auch SQL:1999/2003 genannt.", "type": "multiple-choice", "answers": [{"text": "SQL 1", "solution": "false"}, {"text": "SQL 2", "solution": "false"}, {"text": "SQL 3", "solution": "true"}]}, {"id": 113, "category": 9, "difficulty": 2, "text": "Welche Ausgabe erzeugt die Formatierung NUMBER(7,-2) der Zahl 7456123.89 ?", "explanation": "Die negative zweite Zahl, besagt, dass die entsprechenden letzten Vorkommastellen, durch numerische Nullen ersetzt werden.", "type": "multiple-choice", "answers": [{"text": "Diese Syntax ist nicht korrekt", "solution": "false"}, {"text": "Die Ausgabe ist 7456100", "solution": "true"}, {"text": "Die Ausgabe ist 7456200", "solution": "false"}, {"text": "Die Ausgabe ist 7456123.89", "solution": "false"}, {"text": "Die Ausgabe ist 7456123.8900", "solution": "false"}]}, {"id": 118, "category": 9, "difficulty": 1, "text": "Die Programmierung von SQL-Befehlen muss case-sensitive erfolgen.", "explanation": "Der SQL-\u00dcbersetzer arbeitet nicht case-sensitiv, so dass bei der Programmierung von SQL-Befehlen die Gro\u00df-/Kleinschreibung von reservierten W\u00f6rtern v\u00f6llig irrelevant ist. \nLediglich bei Vergleichen z.B. in der WHERE-Klausel muss jedoch sehr wohl auf die passende Gro\u00df-/Kleinschreibung geachtet werden, da hier case-sensitiv die Inhalte von Datenspalten verglichen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 121, "category": 9, "difficulty": 1, "text": "Mit dem DROP TABLE - Befehl werden Tabellen-Definition und Daten der Tabelle gel\u00f6scht.", "explanation": "Mit dem DROP TABLE-Befehl werden die Daten, die Tabelle selbst und alle abh\u00e4ngigen Datenbankobjekte, wie z.B. Constraints und  Trigger gel\u00f6scht.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "false"}, {"text": "stimmt", "solution": "true"}]}, {"id": 124, "category": 9, "difficulty": 3, "text": "Der RENAME-Befehl geh\u00f6rt zum SQL2003-Standard", "explanation": "<RENAME Anweisung> ::= RENAME Alter Tabellenname TO Neuer Tabellenname;\n\nDiese Anweisung geh\u00f6rt nicht zum SQL2003-Sprachumfang und ist auch nicht in allen Systemen verf\u00fcgbar, wohl aber bei Oracle.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 125, "category": 9, "difficulty": 2, "text": "Mit welchem SQL-Befehl vergibt man Rechte auf einer Tabelle?", "explanation": "Mit dieser Anweisung lassen sich sehr differenziert auf einzelnen Tabellen Benutzerrechte vergeben. \n\n<GRANT Anweisung> ::= \nGRANT  [ ON { Tabellenname | Sichtname } ] TO ;\n ::= { PUBLIC | Benutzername }\n ::= \n{ ALL | SELECT | DELETE | INSERT \n  | UPDATE [Spaltenname [, Spaltenname ]...] }", "type": "text", "answers": [{"text": "Der Befehl hei\u00dft", "solution": "GRANT"}]}, {"id": 126, "category": 9, "difficulty": 2, "text": "Mit welchem SQL-Befehl l\u00f6scht man Rechte auf einer Tabelle?", "explanation": "Mit der REVOKE-Anweisung werden Datenbankprivilegien wieder aus der Datenbank entfernt: \n<REVOKE Anweisung> ::= \nREVOKE  ON [ Tabellenname | Sichtname ] FROM ;", "type": "text", "answers": [{"text": "Der Befehl ist", "solution": "REVOKE"}]}, {"id": 133, "category": 9, "difficulty": 3, "text": "Mit welchem Befehl l\u00f6scht man alle Rechte auf einer Tabelle XYZ f\u00fcr den Benutzer Emil?", "explanation": "RICHTIG ist: \nREVOKE ALL ON XYZ FROM EMIL;  \nweil die Syntaxvorgabe folgende ist: <revoke anweisung=\"\">REVOKE  ON [ Tabellenname | Sichtname ] FROM tabellenname;  \nFALSCH ist: \nREVOKE ALL FROM XYZ OF Hugo; weil  FROM und OF falsche Schl\u00fcsselw\u00f6rter sind.<revoke anweisung=\"\">\nGRANT ALL FROM XYZ OF HUGO; weil mit GRANT Rechtevergeben werden und die Schl\u00fcsselw\u00f6rter FROM und OF falsch sind. \nDROP ALL ON XYZ; weil DROP ein Befehl zum L\u00f6schen von DB-Objekten wie Tabellen, Sichten, Sequenzen, Indexen etc. ist, aber nicht zum L\u00f6schen von Rechtezuordnungen zwischen Benutzern und DB-Objekten ist.\nDELETE ALL FROM XYZ; weil DELETE ein DML-Befehl zum L\u00f6schen von Datens\u00e4tzen ist.", "type": "text", "answers": [{"text": "Der SQL-Ausdruck (ohne Semikolon, inGro\u00dfbuchstaben) lautet:", "solution": "\r\n    REVOKE ALL ON XYZ FROM EMIL\r"}]}, {"id": 168, "category": 9, "difficulty": 2, "text": "Mit welcher Ausnahme wird in JDBC ein SQL-Fehler geworfen?", "explanation": "Da in JDBC erst zur Laufzeit eine \u00dcbersetzung der SQL-Anweisungen erfolgt, ist mit\nLaufzeitfehlern zu rechnen, die eine SQLException verursachen. Die Ausf\u00fchrung\neines SQL-Befehls muss daher immer in einem try/catch-Block erfolgen. Der catch-\nBlock enth\u00e4lt die Fehlerbehandlung und das Auffangen einer SQLException.", "type": "text", "answers": [{"text": "Die Ausnahme hei\u00dft:", "solution": "SQLException"}]}, {"id": 177, "category": 9, "difficulty": 2, "text": "Mit welcher Methode des Interfaces Statement f\u00fchrt man in JDBC eine SELECT-Abfrage aus?", "explanation": "Die Methode executeQuery des Statement-Objekts f\u00fchrt Abfragen durch, die \u00fcber einen SQL-String \u00fcbergeben werden und zur Laufzeit ausgef\u00fchrt werden.", "type": "text", "answers": [{"text": "Die Methode (ohne Klammern geschrieben) hei\u00dft", "solution": "executeQuery"}]}, {"id": 184, "category": 9, "difficulty": 1, "text": "Von welchem JDBC-Interfaces erben die anderen Interfaces?", "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface.", "type": "multiple-choice", "answers": [{"text": "PreparedStatement", "solution": "false"}, {"text": "Statement", "solution": "true"}, {"text": "CallableStatement", "solution": "false"}]}, {"id": 186, "category": 9, "difficulty": 2, "text": "Welches Konstrukt in PL/SQL bietet eine \u00e4hnliche Funktion wie das ResultSet in JDBC?", "explanation": "Der Cursor unter  PL/SQL  entspricht einem ResultSet, welches nur in einer Richtung durchlaufen werden kann.", "type": "text", "answers": [{"text": "Das ist ein", "solution": "Cursor"}]}, {"id": 192, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Befehl werden tempor\u00e4re \u00c4nderungen endg\u00fcltig in die Datenbank geschrieben?", "explanation": "Die COMMIT-Anweisung macht Datenbankzugriffe erst dauerhaft wirksam, die ROLLBACK-Anweisung spielt tempor\u00e4re Anweisungen wieder auf einen konsistenten Zustand zur\u00fcck. Beide Anweisungen geh\u00f6ren zur DAL-Sprache.", "type": "text", "answers": [{"text": "Der SQL-Befehl hei\u00dft:", "solution": "commit"}]}, {"id": 196, "category": 9, "difficulty": 1, "text": "Unter JDBC wird der SQL-Code schon zur \u00dcbersetzungszeit auf Syntax und Semantikfehler gepr\u00fcft.", "explanation": "Der SQL-Code zur \u00dcbersetzungszeit als String betrachtet, der erst zur Laufzeit gegen die Datenbank geschickt wird. Daher treten SQL-Fehler auch erst zur Laufzeit auf.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 198, "category": 9, "difficulty": 1, "text": "Der aktuelle, letzte JDBC-Standard ist:", "explanation": "\n    JDBC 4.0 wurde 2006 ver\u00f6ffentlicht", "type": "multiple-choice", "answers": [{"text": "JDBC 1.0", "solution": "false"}, {"text": "JDBC 2.0", "solution": "false"}, {"text": "JDBC 3.0", "solution": "false"}, {"text": "JDBC 4.0", "solution": "true"}, {"text": "JDBC 5.0", "solution": "false"}, {"text": "JDBC 6.0", "solution": "false"}]}, {"id": 199, "category": 9, "difficulty": 2, "text": "Welche Konstanten repr\u00e4sentieren Isolationsgrade unter JDBC?", "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "TRANSACTION_READ_UNCOMMITTED", "solution": "true"}, {"text": "TRANSACTION_READ_COMMITTED", "solution": "true"}, {"text": "TRANSACTION_SERIALIZABLE", "solution": "true"}, {"text": "TRANSACTION_NONE", "solution": "true"}, {"text": "TRANACTION_ALL", "solution": "false"}]}, {"id": 203, "category": 9, "difficulty": 1, "text": "Mit welchem Schl\u00fcsselwort werden in SQL doppelte Datens\u00e4tze unterdr\u00fcckt?", "explanation": "Anders als bei der Relationalen Algebra, in der Duplikate nicht zugelassen sind und daher automatisch eliminieren werden, sind in SQL Duplikate zugelassen. Um Duplikate in SQL zu unterdr\u00fccken, muss man in der SELECT-Anweisung explizit die Option DISTINCT verwenden: SELECT DISTINCT spaltenname, .... FROM ....;", "type": "text", "answers": [{"text": "Das Schl\u00fcsselwort hei\u00dft", "solution": "DISTINCT"}]}, {"id": 2382, "category": 9, "difficulty": 3, "text": "Wozu braucht man objektrelationale Sichten?", "explanation": "Alle Antworten sind richtig! ;-)", "type": "multiple-choice", "answers": [{"text": "Zu all den Verwendungszwecken, zu denen man auch die relationalen Sichten ben\u00f6tigt.", "solution": "true"}, {"text": "Sie sind hilfreich, um objektrelationales Verhalten auszuprobieren bzw. zu simulieren, ohne, dass man die relationalen Tabellen transformieren muss.", "solution": "true"}, {"text": "Sei k\u00f6nnen Performance-Vorteile mit sich bringen, wenn man nur ein Objekt statt mehrerer Datens\u00e4tze \u00fcber das Netz schicken muss.", "solution": "true"}]}, {"id": 2413, "category": 10, "difficulty": 2, "text": "Ein Oracle-Trigger kann ein COMMIT oder ROLLBACK enthalten", "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten.", "type": "multiple-choice", "answers": [{"text": "keine von beiden", "solution": "false"}, {"text": "stimmt", "solution": "false"}, {"text": "stimmt  nicht", "solution": "true"}]}, {"id": 2452, "category": 7, "difficulty": 1, "text": "Das relationale Modell kann wie folgt definiert werden: MULTISET ( ROW ( Basisdatentyp ) )", "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt  nicht", "solution": "true"}]}, {"id": 2454, "category": 5, "difficulty": 3, "text": "Bei welchen Beziehungen tauchen Fremdschl\u00fcsselattribute in den Entity-Mengen des ERDs auf, die an der Beziehung beteiligt sind?", "explanation": "Bei n-m-Beziehungen entstehen die Fremdschl\u00fcsselattribute beim Aufl\u00f6sen in einer neuen Entity-Menge, nicht in den urspr\u00fcnglicheen Entity-Mengen.", "type": "multiple-choice", "answers": [{"text": "1:1-Beziehungen", "solution": "true"}, {"text": "1:n-Beziehungen", "solution": "true"}, {"text": "m:n-Beziehungen", "solution": "false"}]}, {"id": 2471, "category": 9, "difficulty": 3, "text": "Wie verh\u00e4lt sich ein DEFERRED-Constraint bei einem Integrit\u00e4tsfehler?", "explanation": "Bei einem Deferred-Constraint wird der Fehler erst angezeigt, wenn die Transaktion z.B. mit COMMIT oder ROLLBACk abgeschlossen wird. \nEs wird nicht nur die fehlerhafte Manipulation, sondern alle Manipulationen, die zur Transaktion geh\u00f6ren, zur\u00fcckgerollt.", "type": "multiple-choice", "answers": [{"text": "Unmittelbar nach der Manipulation eines Datensatzes wird der Fehler angezeigt und der fehlerhafte Datensatz wird nicht angenommen.", "solution": "false"}, {"text": "Zum Transaktionsende wird der Fehler angezeigt und die fehlerhafte Manipulation r\u00fcckg\u00e4ngig gemacht.", "solution": "false"}, {"text": "Keine von diesen Reaktionen", "solution": "true"}]}, {"id": 2472, "category": 9, "difficulty": 2, "text": "Um welchen Typ einer Integrit\u00e4tsbedingung handelt es sich hier?\n\nInnerhalb eines Jahres d\u00fcrfen die Ausgaben der Abteilung nicht st\u00e4rker steigen, als die vom Bundesministerium prognostizierte Preissteigerungsrate.", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingung", "solution": "false"}, {"text": "dynamische, transitionale Bedingung", "solution": "false"}, {"text": "statische, transitionale Bedingung", "solution": "false"}, {"text": "dynamische, temporale Bedingung", "solution": "true"}, {"text": "statische, temporale Bedingung", "solution": "false"}]}, {"id": 204, "category": 9, "difficulty": 1, "text": "Mit welchem Operator werden unter ORACLE-SQL Zeichenketten aneinandergeh\u00e4ngt?", "explanation": "In SQL ist es das Pipe-Zeichen: || ", "type": "multiple-choice", "answers": [{"text": "+", "solution": "false"}, {"text": "||", "solution": "true"}]}, {"id": 206, "category": 9, "difficulty": 1, "text": "Mit welchem WHERE-Ausdruck pr\u00fcft man, ob eine Spalte NULL-Werte hat?", "explanation": "Der \"IS [NOT] NULL\"-Vergleichsoperator bietet als einziger Vergleichsoperator die M\u00f6glichkeit, leere Spaltenwerte in Bedingungen zu TRUE resp. FALSE zu transformieren. Wenn bei einem der \u00fcbrigen Vergleichsoperatoren wie z.B. =, <>, >=, LIKE, BETWEEN, ... einer der Operanden leer (NULL) ist, dann ist das Ergebnis der Auswertung dieser Bedingung immer UNKNOWN.", "type": "text", "answers": [{"text": "Der WHERE - Ausdruck hei\u00dft:", "solution": "IS NULL"}]}, {"id": 208, "category": 9, "difficulty": 3, "text": "Welche SQL-Ausdr\u00fccke liefern das gleiche Ergebnis?", "explanation": "Bei einem IN-Operator wird nicht ein Intervall, sondern nur die Eckwerte abgefragt, bei einem BETWEEN-Operator geh\u00f6ren die Eckwerte (hier 1000 und 2000) mit zur L\u00f6sungsmenge.", "type": "multiple-choice", "answers": [{"text": "SELECT gehalt FROM Angestellte WHERE gehalt > 1000 AND gehalt < 2000", "solution": "false"}, {"text": "SELECT gehalt FROM Angestellte WHERE gehalt in (1000, 2000)", "solution": "false"}, {"text": "SELECT gehalt FROM Angestellte WHERE gehalt >= 1000 AND gehalt <= 2000", "solution": "true"}, {"text": "SELECT gehalt FROM Angestellte WHERE gehalt between 1000 and 2000", "solution": "true"}]}, {"id": 212, "category": 9, "difficulty": 2, "text": "Sortieren Sie die Verlgleichs- und logischen Operatoren nach der Priorit\u00e4t unter SQL ( Zahlen 1-4 eintragen)!", "explanation": "Die Ausf\u00fchrungsreihenfolge bei den Verlgleichs- und logischen Operatoren ist folgende: \n1. Vergleichsoperatoren (=, <=, >=, ...) \n2. NOT \n3. AND \n4. OR  \n\nAm einfachsten ist es jedoch, man setzt Klammern, da kann man bei der Ausf\u00fchrungsreihenfolge nichts falsch machen ;-)", "type": "text", "answers": [{"text": "OR", "solution": "4"}, {"text": "Vergleichoperatoren ( <, > , ...)", "solution": "1"}, {"text": "AND", "solution": "3"}, {"text": "NOT", "solution": "2"}]}, {"id": 211, "category": 9, "difficulty": 1, "text": "Welcher der folgenden logischen Operatoren hat in SQL die h\u00f6chste Priorit\u00e4t?", "explanation": "Die Ausf\u00fchrungsreihenfolge bei den logischen Operatoren ist folgende: \n1. NOT \n2. AND \n3. OR  \n\nAm einfachsten ist es jedoch, man setzt Klammern, dann kann man bei der Ausf\u00fchrungsreihenfolge nichts falsch machen ;-)", "type": "multiple-choice", "answers": [{"text": "OR", "solution": "false"}, {"text": "NOT", "solution": "true"}, {"text": "AND", "solution": "false"}]}, {"id": 217, "category": 9, "difficulty": 2, "text": "Mit dem Wildcard \"%\" und LIKE selektiert man unter SQL:", "explanation": "Mit dem LIKE-Operator wird die \u00dcbereinstimmung mit einem Zeichenmuster gesucht. Zul\u00e4ssige Wildcards sind: \"%\" f\u00fcr kein, ein, oder mehrere Zeichen und \"_\" f\u00fcr genau ein Zeichen.", "type": "multiple-choice", "answers": [{"text": "kein, ein oder mehrere Zeichen", "solution": "true"}, {"text": "ein oder mehrere Zeichen", "solution": "false"}, {"text": "genau ein Zeichen", "solution": "false"}]}, {"id": 214, "category": 9, "difficulty": 2, "text": "Mit welchem Wildcard wird unter SQL mit LIKE genau ein Zeichen selektiert ?", "explanation": "Mit dem LIKE-Operator wird die \u00dcbereinstimmung mit einem Zeichenmuster gesucht. Zul\u00e4ssige Wildcards sind: \"%\" f\u00fcr kein, ein, oder mehrere Zeichen und \"_\" f\u00fcr genau ein Zeichen.", "type": "multiple-choice", "answers": [{"text": "%", "solution": "false"}, {"text": "_", "solution": "true"}, {"text": "Solch einen Wildcard gibt es nicht.", "solution": "false"}]}, {"id": 218, "category": 9, "difficulty": 3, "text": "Mit welchem Wildcard werden unter SQL mit LIKE ein oder mehrere  Zeichen selektiert ?", "explanation": "Mit dem LIKE-Operator wird die \u00dcbereinstimmung mit einem Zeichenmuster gesucht. Zul\u00e4ssige Wildcards sind: \"%\" f\u00fcr kein, ein, oder mehrere Zeichen und \"_\" f\u00fcr genau ein Zeichen.", "type": "multiple-choice", "answers": [{"text": "%", "solution": "false"}, {"text": "-", "solution": "false"}, {"text": "solch einen Wildcard gibt es nicht.", "solution": "true"}]}, {"id": 216, "category": 9, "difficulty": 1, "text": "Mit welchem Wildcard werden unter SQL mit LIKE kein, ein oder mehrere Zeichen selektiert ?", "explanation": "Mit dem LIKE-Operator wird die \u00dcbereinstimmung mit einem Zeichenmuster gesucht. Zul\u00e4ssige Wildcards sind: \"%\" f\u00fcr kein, ein, oder mehrere Zeichen und \"_\" f\u00fcr genau ein Zeichen.", "type": "multiple-choice", "answers": [{"text": "%", "solution": "true"}, {"text": "_", "solution": "false"}, {"text": "solch einen Wildcard gibt es nicht.", "solution": "false"}]}, {"id": 996, "category": 9, "difficulty": 2, "text": "Was versteht man unter einer Objekttabelle (object table) bei Oracle?", "explanation": "Tabellen, bei den die benutzerdefinierten Typen als Datentypen eingetragen sind, hei\u00dfen relationale Tabellen. Bei den Objekttabellen dagegen basieren die Tabellen komplett auf einem Typ: CREATE TABLE xyz of Typ_xyz;", "type": "multiple-choice", "answers": [{"text": "Eine Objekttabelle ist eine Tabelle, in der jede Spaltendefinition ein benutzerdefinierter Typ ist.", "solution": "false"}, {"text": "Eine Objekttabelle ist eine Tabelle, in der jeder Datensatz ein Objekt repr\u00e4sentiert.", "solution": "true"}, {"text": "Eine Objekttabelle ist eine Tabelle, in der eine Spaltendefinition ein benutzerdefinierter Typ ist.", "solution": "false"}]}, {"id": 997, "category": 9, "difficulty": 3, "text": "Welche Alternativen gibt es, um in einer Objekttabelle unter ORACLE ein Objekt eindeutig zu identifizieren?", "explanation": "Primary Key und eine weltweit eindeutige OID sind beide als M\u00f6glichkeiten vorgesehen.", "type": "multiple-choice", "answers": [{"text": "Die OID, eine weltweit eindeutige Kennung", "solution": "true"}, {"text": "einen Prim\u00e4rschl\u00fcssel", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 1271, "category": 9, "difficulty": 3, "text": "Welcher Code zum Aufruf einer PL/SQL-Funktion Gehaltssumme ist korrekt?", "explanation": "call   l\u00e4\u00dft sich nicht als Funktionsaufruf verwenden und Gehaltssumme(); ist falsch, da Gehaltssumme als Funktion, nicht als Prozedur, definiert ist.", "type": "multiple-choice", "answers": [{"text": "EXECUTE :Gehaltssumme:= Gehaltssumme();", "solution": "true"}, {"text": "CALL :Gehaltssumme:= Gehaltssumme();", "solution": "false"}, {"text": "Gehaltssumme();", "solution": "false"}, {"text": "SELECT Gehaltssumme() FROM dual;", "solution": "true"}]}, {"id": 1008, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft eine Methode, die mit dem Objekttyp assoziiert ist? Der typischer Aufruf ist \"type_name.method()\".", "explanation": "Das ist die Definition einer Static-Methode. Der zweite Methodentyp sind Member-Methoden, die einem einzelnen Objekt zugeordnet sind.", "type": "text", "answers": [{"text": "Das ist eine", "solution": "STATIC METHOD"}]}, {"id": 1028, "category": 9, "difficulty": 3, "text": "Mit welcher Inherritance-Klausel kann ein Typ unter ORACLE als Supertyp deklariert werden, der Methoden und Attribute vererben kann?", "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "text", "answers": [{"text": "Das ist", "solution": "NOT FINAL"}]}, {"id": 1001, "category": 9, "difficulty": 1, "text": "Mit ORACLE k\u00f6nnen Typhierarchien aufgebaut werden.", "explanation": "Von einem Supertyp kann ein Suptyp mit dem Schl\u00fcsselwort \"Under\" abgeleitet werden. Attribute und Methoden werden dabei vom Supertyp \u00fcbernommen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1002, "category": 9, "difficulty": 1, "text": "Bei REF-Beziehungen m\u00fcssen bei Foreign Keys die Join-Bedingungen selber programmiert werden.", "explanation": "Die Foreign-Key-Beziehungen werden automatisch erzeugt und m\u00fcssen nicht selber programmiert werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1003, "category": 9, "difficulty": 2, "text": "Wird bei einer bestehenden REF-Beziehung das referenzierte Objekt gel\u00f6scht, dann verweist die bestehende Referenz auf ein nicht mehr existierendes Objekt.", "explanation": "Die Beziehung bleibt bestehen, obwohl das Objekt gel\u00f6scht wird und kann mit   WHERE spaltenreferenz IS DANGLING; abgefragt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1738, "category": 9, "difficulty": 3, "text": "Welche CONSTRAINT-Typen k\u00f6nnen auf ORACLE-OBJECT-Tabellen definiert werden?", "explanation": "USER-CONSTRAINTS gibt es nicht, ansonsten k\u00f6nnen alle CONSTRAINTS wie im relationalen Modell auch definiert werden. MIT REF-CONSTRAINTS werden zus\u00e4tzlich Zeiger auf anderen OIDS von Objekten realisiert.", "type": "multiple-choice", "answers": [{"text": "COLUMN-CONSTRAINTS", "solution": "true"}, {"text": "TABLE-CONSTRAINTS", "solution": "true"}, {"text": "DBS-CONSTRAINTS", "solution": "false"}, {"text": "REF-CONSTRAINTS", "solution": "true"}, {"text": "USER-CONSTRAINTS", "solution": "false"}]}, {"id": 1015, "category": 9, "difficulty": 1, "text": "Unter ORACLE gilt: F\u00fcr einen Subtypen sind mehrere Eltern m\u00f6glich.", "explanation": "Mehrfachvererbung ist bei Typen hier nicht vorgesehen.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 1013, "category": 9, "difficulty": 3, "text": "Mit welcher Anweisung wird in SQL 2003 ein benutzerdefinierter Datentyp festgelegt?", "explanation": "CREATE TYPE geh\u00f6rt zum SQL-Standard seit SQL:2003.", "type": "text", "answers": [{"text": "Die Anweisung hei\u00dft", "solution": "CREATE TYPE"}]}, {"id": 1011, "category": 9, "difficulty": 3, "text": "Wie nennt man den folgenden Zugriff in einer Objekt-Tabelle?", "explanation": "Das ist die Definition des Single Column-Zugriffs.Die Alternative ist der Zugriff auf eine mehrspaltige Tabelle, in der jedes Attribut des Objekttypes die Anwendung von relationalen Operationen erlaubt. Dieser Zugriff hei\u00dft Multi-Column_Zugriff.", "type": "text", "answers": [{"text": "Die Objekttabelle wird als einspaltige Tabelle betrachtet, bei der jeder Datensatz ein Objekt darstellt, das die Anwendung objektorientierter Operationen erlaubt. F\u00fcr den Zugriff auf Instanzwerte eines Objekts muss die VALUE-Funktion verwendet werden, der als Parameter der Tabellenalias \u00fcbergeben wird und die dann als R\u00fcckgabewert eine Objektinstanz liefert. \n\n(ohne Bindestrich schreiben)", "solution": "Single Column"}]}, {"id": 1031, "category": 9, "difficulty": 3, "text": "Welche Aussage ist wahr?", "explanation": "Die Normalformen (1NF, 2NF und 3NF) spielen in objektrelationalem SQL keine Rolle, ihre Verletzung relationalen Tabellen sind solche, die nicht auf einem Typ basieren, CREATE TABLE OF typname.... Sie k\u00f6nnen aber sehr wohl einen selbstdefiniereten  Datentypen benutzen.", "type": "multiple-choice", "answers": [{"text": "Werden in relationalen Tabellen Collection-Types (varrays, nested tables) angewendet, dann wird automatisch die erste Normalform verletzt.", "solution": "true"}, {"text": "Werden in relationalen Tabellen Collection-Types (varrays, nested tables) angewendet, dann wird automatisch die dritte Normalform verletzt.", "solution": "true"}, {"text": "Werden in relationalen Tabellen Collection-Types (varrays, nested tables) angewendet, dann wird automatisch die zweite Normalform verletzt.", "solution": "true"}, {"text": "Collectiions-Typen (varrays, nested tables) k\u00f6nnen in relationalen Tabellen gar nicht angewendet werden.", "solution": "false"}]}, {"id": 1029, "category": 9, "difficulty": 2, "text": "Wie kann man auf die Daten einer Objekttabelle zugreifen?", "explanation": "Eine mehrspaltige Tabelle,  bei der jedes Attribut des benutzerdefinierten Datentyps die Anwendung relationaler Operationen erlaubt, hei\u00dft Tupeltabelle.", "type": "multiple-choice", "answers": [{"text": "Die Objekttabelle wird als einspaltige Tabelle betrachtet, bei der jeder Datensatz ein Objekt darstellt, das die Anwendung objektorientierter Operationen erlaubt. F\u00fcr den Zugriff auf Instanzwerte eines Objekts muss die VALUE-Funktion verwendet werden, der als Parameter der Tabellenalias \u00fcbergeben wird und die dann als R\u00fcckgabewert eine Objektinstanz (Datensatz) liefert.", "solution": "true"}, {"text": "Die Objekttabelle wird als mehrspaltige Tabelle betrachtet, bei der jedes Attribut des benutzerdefinierten Datentyps die Anwendung relationaler Operationen erlaubt.", "solution": "false"}]}, {"id": 1016, "category": 9, "difficulty": 3, "text": "Welche Parameter kann die Inheritance-Klausel zu Definition von Subtypen unter ORACLE haben?", "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt \u00fcber die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "multiple-choice", "answers": [{"text": "OVERRIDING", "solution": "true"}, {"text": "OVERLOADING", "solution": "false"}, {"text": "STATIC", "solution": "false"}, {"text": "FINAL", "solution": "true"}, {"text": "INSTANTIABLE", "solution": "true"}]}, {"id": 1018, "category": 9, "difficulty": 3, "text": "Wie hei\u00dfen die Beziehungen unter ORACLE, die Foreign Keys ersetzen k\u00f6nnen?", "explanation": "Die REF-Beziehung ersetzt einen Fremdschl\u00fcsselverweis wie im relationalenModell \u00fcblich. Es wird ein Zeiger auf das Referenzobjekt in der Master-Tabelle angelegt. Erstaunlicherweise wird hier zugelassen, dass Zeiger ins Leere verweisen, wenn das Master-Objekt gel\u00f6scht wird. Es k\u00f6nnen also sogenannte \"Dangling-Tupel\" entstehen, die sich auch mit IS [NOT] DANGLING abfragen lassen.", "type": "text", "answers": [{"text": "Das sind (mit Bindestrich schreiben):", "solution": "REF-Beziehungen"}]}, {"id": 1019, "category": 9, "difficulty": 3, "text": "Die unter ORACLE 9i aufgenommenen REF-Beziehungen (REF-Klausel) k\u00f6nnen verwendet werden", "explanation": "Die REF-Beziehung ersetzt einen Fremdschl\u00fcsselverweis wie im relationalenModell \u00fcblich und k\u00f6nnen zwischen Objekttabellen und Objekt-Views verwendet werden.  Es wird ein Zeiger auf das Referenzobjekt in der Master-Tabelle angelegt. Erstaunlicherweise wird hier zugelassen, dass Zeiger ins Leere verweisen, wenn das Master-Objekt gel\u00f6scht wird. Es k\u00f6nnen also sogenannte \"Dangling-Tupel\" entstehen, die sich auch mit IS [NOT] DANGLING abfragen lassen.", "type": "multiple-choice", "answers": [{"text": "zwischen Objekttabellen", "solution": "true"}, {"text": "zwischen allen mit CREATE TABLE definierten Tabellen", "solution": "false"}, {"text": "zwischen Object Views", "solution": "true"}]}, {"id": 1032, "category": 8, "difficulty": 3, "text": "Was versteht man unter \"Dangling Tuples\" in der relationalen Algebra?", "explanation": "Gibt es Tupel in einer Relation, deren Werte in den Fremdschl\u00fcssel-Attributen auf Werte in der anderen Relation verweisen, die dort nicht (mehr) existieren, so sind dies die sog. \"dangling tuples\", die Probleme hinsichtlich der referenziellen Integrit\u00e4t darstellen. \nEbenso werden auch Tupel, die bei Join-Operationen nicht mit entsprechenden Tupeln aus der anderen Relation verkn\u00fcpft werden k\u00f6nnen, als \"dangling tuples\" bezeichnet.", "type": "multiple-choice", "answers": [{"text": "Tupel, die nicht gesichert werden.", "solution": "false"}, {"text": "Tupel, denen bei Join-Operationen die entsprechenden Tupel in der anderen Relation fehlen, mit denen sie verkn\u00fcpft werden k\u00f6nnten.", "solution": "true"}, {"text": "Tupel, denen Attributwerte fehlen.", "solution": "false"}, {"text": "Tupel in einer Relation, deren Werte in den Fremdschl\u00fcssel-Attributen auf Werte in der anderen Relation verweisen, die dort nicht (mehr) existieren.", "solution": "true"}]}, {"id": 1021, "category": 9, "difficulty": 1, "text": "Welche Aussage ist wahr?", "explanation": "F\u00fcr eine geordnete Menge von Datenelementen unterschiedlichen Typs k\u00f6nnen unter Oracle strukturierte Datentypen (create type...) verwendet werden, die dann mit einem TABLE-Konstruktur als nested Table eingebettet werden.", "type": "multiple-choice", "answers": [{"text": "VARRAYS k\u00f6nnen eine geordnete Menge von Datenelementen, die alle den gleichen Datentyp haben, aufnehmen.", "solution": "true"}, {"text": "VARRAYS k\u00f6nnen eine geordnete Menge von Datenelementen, die nicht den gleichen Datentyp besitzen m\u00fcssen, aufnehmen.", "solution": "false"}]}, {"id": 1022, "category": 9, "difficulty": 1, "text": "Unter Oracle muss eine maximale VARRAY-Gr\u00f6\u00dfe definiert werden, unterhalb der die VARRAY-Gr\u00f6\u00dfe variabel sein kann.", "explanation": "Ein VARRAY hat eine maximale Gr\u00f6\u00dfe n, die \u00fcber \nCREATE OR REPLACE TYPE varray_typ  AS VARRAY(n) OF Datentyp; \nfestgelegt wird.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1023, "category": 9, "difficulty": 1, "text": "Bei welchem Modus werden die VARRAY/NESTED TABLE-Werte unter Oracle mittels der \"Konstruktor\"-Methode angezeigt?", "explanation": "Bei einer NESTED QUERY wird der Tabelleninhalt mit den eingebetteten Kollektionen und zugeh\u00f6rigen Konstruktoren komplett ausgegeben.", "type": "multiple-choice", "answers": [{"text": "NESTED QUERY", "solution": "true"}, {"text": "UNNESTED QUERY", "solution": "false"}]}, {"id": 1024, "category": 9, "difficulty": 3, "text": "Welche Zugriffsarten gibt es bei einer UNNESTED QUERY auf einen Collection-Typ (VARRAY oder NESTED TABLE) unter Oracle?", "explanation": "Bei einer  \"unnested Query\" wird die enthaltene geschachtelte Tabelle mit dem Operator TABLE  flachgeklopft und auf eine relationale\nTabelle abgebildet wird. Die Benutzung eines Tabellenalias (k und a) ist bei geschachtelten Tabellen obligatorisch. \n\nDer  CURSOR-Zugriff  z\u00e4hlt die Anzahl der Zeilen eines SELECTs an eine eingebettete Tabelle.", "type": "multiple-choice", "answers": [{"text": "USER", "solution": "false"}, {"text": "TABLE", "solution": "true"}, {"text": "FINAL", "solution": "false"}, {"text": "CURSOR", "solution": "true"}]}, {"id": 1026, "category": 9, "difficulty": 1, "text": "Die \u00c4nderung des Wertes einer einzelnen Spalte unter Oracle-SQL ist m\u00f6glich bei", "explanation": "Bei VARRAYS kann unter Oracle leider kein einzelner Wert, sondern nur das komplette VARRAY ge\u00e4ndert werden.", "type": "multiple-choice", "answers": [{"text": "VARRAYS", "solution": "false"}, {"text": "NESTED TABLES", "solution": "true"}]}, {"id": 876, "category": 9, "difficulty": 1, "text": "Welcher PL/SQL-Block ermittelt einen Wert und gibt ihn als RETURN-Wert zur\u00fcck?", "explanation": "PL/SQL unterscheidet vier Typen von Bl\u00f6cken: \n\nEin Anonymer Block ist ein unbenannter PL/SQL-Block, der in einer Anwendung (Prozedur, Funktion ) eingebettet ist oder interaktiv eingegeben wird. \nEine Stored ist ein benannter PL/SQL-Block, der Parameter haben kann und als Prozedur oder Funktion definiert ist. Er wird im Datenbanksystem gespeichert und auf dem Server von der PL/SQL-Engine ausgef\u00fchrt. Stored Functions geben \u00fcber RETURN einen Wert an das aufrufende Programm zur\u00fcck\nEin PACKAGE ist ein benannter PL/SQL-Block, der logisch verwandte Prozeduren und Funktionen, Deklarationen etc. zu einer Bibliothek zusammenfasst. \nEin Datenbanktrigger ist ein PL/SQL-Block, der zu einem definierten Ereignis (INSERT, UPDATE oder DELETE) automatisch vom Datenbankmanagementsystem aktiviert und ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "eine Prozedur", "solution": "false"}, {"text": "eine Funktion", "solution": "true"}, {"text": "ein Paket", "solution": "false"}, {"text": "ein Datenbanktrigger", "solution": "false"}]}, {"id": 845, "category": 9, "difficulty": 1, "text": "Welcher Parametertyp unter PL/SQL erm\u00f6glicht einen DEFAULT -Wert?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. bei IN OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten\nWerts an das aufrufende Objekt. \n\nEin Defaultwert ist nur  bei der IN-Parameter\u00fcbergabe m\u00f6glich, da bei den anderen Typen ein im Programm erzeugter Wert zur\u00fcckgegeben wird.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "OUT", "solution": "false"}, {"text": "IN OUT", "solution": "false"}]}, {"id": 847, "category": 9, "difficulty": 3, "text": "Welcher Parametertyp verh\u00e4lt sich wie eine initialisierte Variable?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten.  \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann  \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "false"}, {"text": "OUT", "solution": "false"}, {"text": "IN OUT", "solution": "true"}]}, {"id": 848, "category": 9, "difficulty": 2, "text": "Welcher Parametertyp verh\u00e4lt sich wie eine nicht initialisierte Variable?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "false"}, {"text": "OUT", "solution": "true"}, {"text": "IN OUT", "solution": "false"}]}, {"id": 850, "category": 9, "difficulty": 1, "text": "Welcher Parametertyp verh\u00e4lt sich wie eine Konstante in einer Prozedur?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "OUT", "solution": "false"}, {"text": "IN OUT", "solution": "false"}]}, {"id": 851, "category": 9, "difficulty": 1, "text": "Mit welcher PL/SQL-Prozedur schreibt man Text in das Ausgabefenster?", "explanation": "Die umfangreiche Oracle-Bibliothek besteht aus einer ganzen Reihe mitgelieferter Pakete, zu denen auch DBMS_OUTPUT geh\u00f6rt. Die Funktion DBMS_OUTPUT.PUT_LINE(Text) nutzen wir sehr h\u00e4ufig zur Ausgabe in SQL*PLUS oder anderen Client-Applikationen und DBMS_OUTPUT.ENABLE(Buffergr\u00f6\u00dfe) zum Einstellen der Gr\u00f6\u00dfe des Bildschirmbuffers.", "type": "multiple-choice", "answers": [{"text": "DBMS_OUTPUT.PUT_LINE(..)", "solution": "true"}, {"text": "DBMS_OUTPUT.PUTLINE(..)", "solution": "false"}, {"text": "DBMSOUTPUT.PUT_LINE(..)", "solution": "false"}, {"text": "DBMSOUTPUT.PUTLINE(..)", "solution": "false"}]}, {"id": 852, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber PL/SQL-Funktionen sind wahr?", "explanation": "Der R\u00fcckgabeparameter der Funktionen erfordert eine andere Aufrufart als die Prozeduren. Es gibt drei M\u00f6glichkeiten, Funktionen aufzurufen:\n\n1. M\u00f6glichkeit: in SQL-Anweisungen Funktionen k\u00f6nnen grunds\u00e4tzlich in jedem SQL-Anfrage- und Manipulationsbefehl aufgerufen und ausgef\u00fchrt werden. Sie k\u00f6nnen \u00fcberall dort aufgerufen werden, wo SINGLE ROW-Funktionen aufrufbar sind, z.B. SELECT function(...) FROM dual; \n\n2. M\u00f6glichkeit: In PL/SQL-Anweisungen kann man iterativ die Funktion auch mittels eines geeigneten PL/SQL-Befehls ausf\u00fchren. Geeignete Anweisungen sind z.B. Zuweisungen oder als Parameter eines Prozedur- oder Funktionsaufrufs. Eine andere M\u00f6glichkeit ist die Verwendung der Anzeigefunktion PUT_LINE aus dem Bibliothekspaket\nDBMS_OUTPUT. \n\n3. M\u00f6glichkeit (mit SQL*PLUS-Variabeln): Dieser Aufruf funktioniert nur unter SQL*PLUS. Eine Sessionvariable wird definiert, mit dem Funktionswert \u00fcber die EXECUTE-Anweisung gef\u00fcllt und \u00fcber den PRINT-Befehl auf dem Bildschirm ausgegeben \n\nVARIABLE Gehaltssumme NUMBER; \nEXECUTE :Gehaltssumme:= Func_Gehaltssumme(); \nPRINT Gehaltssumme;", "type": "multiple-choice", "answers": [{"text": "Im SQL-Developer  k\u00f6nnen PL/SQL-Funktionen direkt aufgerufen werden.", "solution": "false"}, {"text": "PL/SQL-Funktionen k\u00f6nnen \u00fcber Session-Variablen ausgef\u00fchrt werden, deren Wert mit PRINT ausgegeben wird.", "solution": "true"}, {"text": "PL/SQL-Funktionen k\u00f6nnen wie die Single-Row_Funktionen (SQRT, TO_Char, etc...), die zum Funktionsumfang von ORACLE-SQL-geh\u00f6ren, in SQL-Anweisungen eingebunden werden.", "solution": "true"}]}, {"id": 878, "category": 9, "difficulty": 1, "text": "EXCEPTION-Handling unter PL/SQL ist", "explanation": "Die kleinste Einheit von PL/SQL ist ein sogenannter PL/SQL-Block, der aus bis zu drei PL/SQL-Abschnitten bestehen kann. \n\nDer Deklarationsabschnitt  enth\u00e4lt Deklarationen von benutzerdefinierten Datentypen, Variablen, Konstanten, CURSOR und\nbenutzerdefinierte EXCEPTIONS, Unterprozedurenund -funktionen und ist optional. \nDer Ausf\u00fchrungsabschnitt   enth\u00e4lt PL/SQL-Anweisungen und bestimmte SQL-Anweisungen\nwie INSERT, UPDATE, DELETE, SELECT,\nCOMMIT, ROLLBACK und ist obligatorisch. \n\nDer Fehlerbehandlungsabschnitt (EXCEPTION-Handling)   gibt an, welche Aktionen ausgef\u00fchrt werden sollen, wenn im Ausf\u00fchrungsabschnitt  Fehler auftreten und ist optional.", "type": "multiple-choice", "answers": [{"text": "obligatorisch", "solution": "false"}, {"text": "optional", "solution": "true"}]}, {"id": 861, "category": 9, "difficulty": 1, "text": "In PL/SQL-Bl\u00f6cken k\u00f6nnen Sie", "explanation": "In PL/SQL-Bl\u00f6cken sind aus Sicherheitsgr\u00fcnden keine DDL-Anweisungen zugelassen. Um diese Einschr\u00e4nkung zu umgehen, kann man allerdings dynamischen SQL mit EXECUTE IMMEDIATE '--DDL-ANWEISUNG--' nutzen.", "type": "multiple-choice", "answers": [{"text": "DML-Anweisungen wie INSERT, UPDATE und DELETE schreiben.", "solution": "true"}, {"text": "COMMIT und ROLLBACK absetzen, falls es sich nicht um einen Trigger handelt.", "solution": "true"}, {"text": "DDL-Anweisungen wie CREATE TABLE, DROP TABLE etc. schreiben.", "solution": "false"}]}, {"id": 859, "category": 9, "difficulty": 1, "text": "Welche Schleifentypen gibt es in PL/SQL?", "explanation": "In PL/SQL gibt es bedingte Verzweigungen mit IF und CASE, Basisschleifen ohne Bedingung mit LOOP, FOR-, WHILE- und CURSOR-Schleifen sowie eine EXIT-Anweisung zum Verlassen von Schleifen.", "type": "multiple-choice", "answers": [{"text": "DO_NEXT-Schleifen", "solution": "false"}, {"text": "LOOP-Schleifen", "solution": "true"}, {"text": "FOR-Schleifen", "solution": "true"}, {"text": "WHILE-Schleifen", "solution": "true"}]}, {"id": 860, "category": 9, "difficulty": 1, "text": "Der Zuweisungsoperator unter PL/SQL", "explanation": "Das \":=\" stimmt leider nicht mit dem \"=\" aus anderen Programmiersprachen \u00fcberein.", "type": "text", "answers": [{"text": "ist", "solution": ":="}]}, {"id": 862, "category": 9, "difficulty": 2, "text": "Welche PL/SQL-Anweisungen werden aus SQL unver\u00e4ndert \u00fcbernommen?", "explanation": "DDL-Anweisungen wie GRANT und CREATE sind in PL/SQL aus Sicherheitsgr\u00fcnden nicht zugelassen. Die SELECT-Anweisung kann nicht direkt, sondern nur \u00fcber einen Cursor ausgef\u00fchrt werden, der das Ergebnis der SELECT-Anweisung zur Weiterverarbeitung aufnimmt oder besitzt zus\u00e4tzlich zum interaktiven SQL eine INTO-Klausel.", "type": "multiple-choice", "answers": [{"text": "INSERT", "solution": "true"}, {"text": "DELETE", "solution": "true"}, {"text": "SELECT", "solution": "false"}, {"text": "UPDATE", "solution": "true"}, {"text": "CREATE", "solution": "false"}, {"text": "GRANT", "solution": "false"}]}, {"id": 863, "category": 9, "difficulty": 1, "text": "Welche Komponente kommt bei SELECT-Anweisungen unter PL/SQL neu hinzu?", "explanation": "Das Ergebnis eines SELECTS wird mit SELECT ... INTO ... in eine PL/SQL-Variable \u00fcbergeben, was bei interaktivem SQL nicht notwendig ist.", "type": "text", "answers": [{"text": "Das ist", "solution": "INTO"}]}, {"id": 864, "category": 9, "difficulty": 1, "text": "In welcher Reihenfolge erscheinen die folgenden Komponenten eines PL/SQL-Cursors? Tragen Sie die Zahlen 1-4 ein!", "explanation": "DECLARE: Als erstes wird der CURSOR im Deklarationsteil des PL/SQL-Blocksdefiniert, das hei\u00dft, er bekommt einen Namen und eine SELECT-Anweisung, diebeliebig komplex sein kann. Eine INTO-Klausel ist weder erlaubt noch notwendig.Damit verbunden ist intern das Anlegen eines benannten Zwischenspeicherbereichsf\u00fcr die Aufnahme der Ergebnismenge. Alle weiteren Schritte werden imAusf\u00fchrungsteil durchgef\u00fchrt.  \nOPEN: Beim \u00d6ffnen eines CURSOR wird die zugeh\u00f6rige SELECT-Anfrage an das Datenbankmanagementsystem geschickt und dort ausgewertet. Von dort wird die Ergebnismenge in den benannten Speicherbereich geladen, was hei\u00dft, dass w\u00e4hrend der gesamten Zeit der CURSOR-Verarbeitung die Ergebnisdatenmenge unver\u00e4ndert bleibt. Nach der OPEN-Anweisung parallel von anderen Transaktionen durchgef\u00fchrte Manipulationen haben keinen Einfluss mehr auf die Ergebnisdaten, die ja bereits als Kopie im Zwischenspeicherbereich vorliegen. \nFETCH: In PL/SQL ist ein Zeiger (CURSOR) nach dem \u00d6ffnen sofort auf den ersten Datensatz dieser Ergebnismenge positioniert, so dass mit einer FETCH-Anweisung dieser Satz aus dem benannten Speicherbereich in die lokalen PL/SQL-Variablen hinein ausgelesen werden kann. Als zus\u00e4tzliche Funktion positioniert die FETCH-Anweisung den Zeiger auch noch auf den n\u00e4chsten Datensatz im Zwischenspeicher. \nCLOSE: War der letzte FETCH nicht erfolgreich, d.h., sind die lokalen Variablen leer, dann hei\u00dft dass, dass alle Datens\u00e4tze abgearbeitet sind und die Schleife verlassen werden kann. Beim Schlie\u00dfen des CURSOR wird der damit verbundene Zwischenspeicherbereich wieder freigegeben.", "type": "text", "answers": [{"text": "OPEN", "solution": "2"}, {"text": "CLOSE", "solution": "4"}, {"text": "FETCH", "solution": "3"}, {"text": "DECLARE", "solution": "1"}]}, {"id": 865, "category": 9, "difficulty": 2, "text": "Welches Cursor-Attribut liefert die Gesamtanzahl der bisher gelesenen Zeilen?", "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR ge\u00f6ffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen", "type": "text", "answers": [{"text": "Das ist", "solution": "%ROWCOUNT"}]}, {"id": 866, "category": 9, "difficulty": 2, "text": "Womit fragt man ab, ob ein CURSOR schon ge\u00f6ffnet ist?", "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR ge\u00f6ffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen", "type": "text", "answers": [{"text": "Mit dem CURSOR-Attribut", "solution": "%ISOPEN"}]}, {"id": 867, "category": 9, "difficulty": 2, "text": "Womit fragt man ab, ob die Fetch-Anweisung schon die letzte Zeile eines Cursors erreicht hat?", "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR ge\u00f6ffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen", "type": "text", "answers": [{"text": "Mit dem Cursor-Attribut", "solution": "%NOTFOUND"}]}, {"id": 869, "category": 9, "difficulty": 2, "text": "Welche EXCEPTION wird unter PL/SQL geworfen, wenn ein SELECT kein Ergebnis liefert?", "explanation": "IN PL/SQL verursacht eine SELECT-Anweisung, die nicht in einem Cursor definiert ist, die EXCEPTION NO_DATA_FOUND, wenn der SELECT keine Zeilen liefert. Ausweg ist die Verwendung eines Cursors.", "type": "text", "answers": [{"text": "Das ist:", "solution": "NO_DATA_FOUND"}]}, {"id": 870, "category": 9, "difficulty": 3, "text": "Welche EXCEPTION wird unter PL/SQL geworfen, wenn die Konvertierung eines Strings in eine Zahl fehlschlug?", "explanation": "INVALID NUMBER ist in PL/SQL die vordefinierte EXCEPTION f\u00fcr diesen Konvertierungsfehler.", "type": "text", "answers": [{"text": "Das ist:", "solution": "INVALID_NUMBER"}]}, {"id": 872, "category": 9, "difficulty": 3, "text": "Welche Exception wird in PL/SQL geworfen, wenn die Anmeldung an die Datenbank fehlschlug?", "explanation": "LOGIN_DENIED ist in PL/SQL die vordefinierte EXCEPTION f\u00fcr diesen Anmeldungsfehler.", "type": "text", "answers": [{"text": "Das ist", "solution": "LOGIN_DENIED"}]}, {"id": 873, "category": 9, "difficulty": 3, "text": "Welche Exception wird geworfen, wenn der Fehler nicht explizit vom Exception-Handler aufgerufen wurde?", "explanation": "OTHERS steht in PL/SQL f\u00fcr alle EXCEPTIONS, die nicht explizit im\nEXECPTION-Handler aufgef\u00fchrt wurden.", "type": "text", "answers": [{"text": "Das ist", "solution": "OTHERS"}]}, {"id": 874, "category": 9, "difficulty": 1, "text": "Welche Parametertypen gibt es unter PL/SQL?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "OUT", "solution": "true"}, {"text": "IN OUT", "solution": "true"}, {"text": "OUT IN", "solution": "false"}]}, {"id": 875, "category": 9, "difficulty": 2, "text": "In welcher Reihenfolge m\u00fcssen in einem SELECT-Befehl die folgenden Klauseln stehen? (Geben Zahlen von 1 bis 6 an)", "explanation": "Die Reihenfolge der Klauseln einer SELECT-Anfrage sind: \nSELECT ...\nFROM ...\n[ WHERE ... ]\n[ GROUP BY ... ]\n[ HAVING ... ]\n[ ORDER BY ... ]\nDie eckigen Klammern geben die Optionalit\u00e4t der Klauseln an.", "type": "text", "answers": [{"text": "WHERE", "solution": "3"}, {"text": "FROM", "solution": "2"}, {"text": "ORDER BY", "solution": "6"}, {"text": "HAVING", "solution": "5"}, {"text": "GROUP BY", "solution": "4"}, {"text": "SELECT", "solution": "1"}]}, {"id": 881, "category": 9, "difficulty": 2, "text": "Womit kann man in PL/SQL eine Variable definieren, deren Datentyp einer Spalte einer Tabelle entspricht?", "explanation": "MitTabellenname.Spaltenname%TYPE;  wird eine PL/SQL-Variable entsprechend eines zuvor definierten Attributs (Spalte) einer Tabelle definiert. Alternativ kann man auch mit Tabellenname%ROWTYPE die Attributstruktur der Tabelle komplett an einen Variable in PL/SQL \u00fcbertragen.", "type": "text", "answers": [{"text": "Das ist", "solution": "%TYPE"}]}, {"id": 882, "category": 9, "difficulty": 1, "text": "Unter PL/SQL gibt es den Datentyp BOOLEAN.", "explanation": "W\u00e4hrend in PL/SQL und in Standard -SQL der Datentyp Boolean schon seit SQL2 existiert, ist dies in Oracle SQL bis zur Version 11g leider nicht der Fall.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 683, "category": 9, "difficulty": 1, "text": "Bei einer INSERT-Anweisung kann man die Spaltennamen hinter \"INSERT INTO Tabellenname (...)\" unter bestimmten Bedingungen weglassen.", "explanation": "In einer INSERT-Anweisung kann man die Spaltennamen nach INSERT weglassen, wenn alle Spalten der Tabelle mit Werten gef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 684, "category": 9, "difficulty": 1, "text": "Die Pflichteingabebedingung kann mit der NOT-NULL-Klausel nur als COLUMN-Constraint definiert werden.", "explanation": "Die Funktionalit\u00e4t des NULL-Constraints ist als einziges Constraint ausschlie\u00dflich als Spalten-Constraint zu haben. Die Funktionalit\u00e4t der anderen Constraints (Prim\u00e4r-, Eindeutigkeit-, Fremdschl\u00fcssel und CHECK) sind sowohl als Spalten- wie auch Tabellen-Constraint definierbar. Beim Fremdschl\u00fcssel muss auf eine unterschiedliche Syntax geachtet werden: Als Spalten-Constraint hei\u00dft es \"REFERENCES\" und als Tabellen-Constraint \"FOREIGN KEY\" \n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... )\n\n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 701, "category": 9, "difficulty": 1, "text": "Der Datentyp BOOLEAN geh\u00f6rt zum SQL2003-Standard.", "explanation": "Ja, endlich gibt es dort einen BOOLEAN-Datentyp mit den Zust\u00e4nden: TRUE, FALSE, NULL/UNKNOWN. Denken Sie immer daran, SQL liegt eine dreiwertige Logik zugrunde mit \"wahr\", \"falsch\", \"unbekannt\"! \nLeider ist dieser Datentyp immer noch nicht bei Oracle und anderen Datenbankherstellern implementiert.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "true"}, {"text": "nein", "solution": "false"}]}, {"id": 911, "category": 10, "difficulty": 1, "text": "Transitionale Integrit\u00e4tsbedingungen k\u00f6nnen definiert werden", "explanation": "In CONSTRAINTS sind nur sehr einfache Integrit\u00e4tsbedingungen formulierbar, die Werte mit Konstanten oder Werten in anderen Spalten vergleichen. Transitionale Integrit\u00e4tsbedingungen  geh\u00f6ren nicht dazu und m\u00fcsssen in Triggern formuliert werden.", "type": "multiple-choice", "answers": [{"text": "In CONSTRAINTS", "solution": "false"}, {"text": "In Datenbanktriggern", "solution": "true"}]}, {"id": 914, "category": 10, "difficulty": 2, "text": "Auf einer Tabelle sei ein AFTER-ROW-Trigger f\u00fcr eine UPDATE-Anweisung definiert. Es wird eine UPDATE - Anweisung ausgef\u00fchrt, die keinen Datensatz ver\u00e4ndert.", "explanation": "Da kein Datensatz ver\u00e4ndert wird, wird der AFTER-ROW-Trigger auch nicht angestossen.", "type": "multiple-choice", "answers": [{"text": "Der ROW-Trigger wird trotzdem ausgef\u00fchrt.", "solution": "false"}, {"text": "Der ROW-Trigger wird nicht ausgef\u00fchrt.", "solution": "true"}]}, {"id": 915, "category": 10, "difficulty": 1, "text": "Auf einer Tabelle sei ein STATEMENT-Trigger f\u00fcr eine UPDATE-Anweisung definiert. Es wird eine UPDATE - Anweisung ausgef\u00fchrt, die keinen Datensatz ver\u00e4ndert.", "explanation": "Bei einem Statement-Trigger wird der Trigger ausgef\u00fchrt, auch wenn kein Datensatz ver\u00e4ndert wurde. Bei AFTER-ROW-Triggern ist das nicht der Fall.", "type": "multiple-choice", "answers": [{"text": "Der Trigger wird ausgef\u00fchrt.", "solution": "true"}, {"text": "Der Trigger wird nicht ausgef\u00fchrt.", "solution": "false"}]}, {"id": 1764, "category": 9, "difficulty": 2, "text": "Wodurch ist eine dynamische SQL-Anweisung gekennzeichnet?", "explanation": "Dynamisch bedeutet gerade, dass ein Inhalt einer Textvariable erst zur Laufzeit dem Datenbanksystem \u00fcbergeben und dann auch \u00fcbersetzt wird.", "type": "multiple-choice", "answers": [{"text": "Der Inhalt der SQL-Anweisung ist schon zur \u00dcbersetzungszeit bekannt.", "solution": "false"}, {"text": "Der Inhalt der SQL-Anweisung wird zur Laufzeit erstellt.", "solution": "true"}, {"text": "Der Inhalt der SQL-Anweisung ist zur \u00dcbersetzungszeit unbekannt.", "solution": "true"}]}, {"id": 961, "category": 11, "difficulty": 3, "text": "Welches Problem taucht unter ORACLE-SQL nicht auf?", "explanation": "Die Unterschiede bei den Isolationsgraden zwischen SQL2003 und Oracle basieren im Wesentlichen darauf, dass Oracle unsauberes Lesen (DIRTY READ) grunds\u00e4tzlich ausschlie\u00dft, womit der Isolationsgrad READ UNCOMMITTED entf\u00e4llt.", "type": "multiple-choice", "answers": [{"text": "DIRTY READ", "solution": "true"}, {"text": "LOST UPDATE", "solution": "true"}, {"text": "PHANTOM", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 964, "category": 9, "difficulty": 3, "text": "Autos mit ihren Sonderausstattungen werden in zwei Tabellen Auto und Sonderausstattung gespeichert. Welche SELECT-Anweisung befriedigt die folgende Anfrage: \nErstellen Sie eine Liste aller Autos, die keine Sonderausstattung haben!", "explanation": "Die Abfrage\n\nSELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr \n\ngibt aus dem kartesischen Produkt alle Autos mit allen Sonderausstattungen diejenigen aus, deren Seriennummer verschieden ist. \n\nSELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung) \n\nliefert alle Autos, da der NOT EXIST immer erf\u00fcllt ist.", "type": "multiple-choice", "answers": [{"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A\nWHERE A.SerienNr NOT IN \n   (SELECT SerienNr FROM Sonderausstattung)", "solution": "true"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung B\n WHERE A.SerienNr = B.SerienNr)", "solution": "true"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A LEFT JOIN Sonderausstattung B ON (A.SerienNr = B.SerienNr) GROUP BY A.SerienNr, A.Modell\nHAVING count(B.Sonderausstattung) = 0", "solution": "true"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung)", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung\n WHERE A.SerienNr = B.SerienNr)", "solution": "false"}, {"text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr", "solution": "false"}]}, {"id": 967, "category": 42, "difficulty": 2, "text": "Es gibt", "explanation": "Ein Index ist ein separates Verzeichnis der Gestalt \"Wert, Adresse\",  wobei der Wert aus einem oder mehreren Spaltenwerten (ein oder mehrdimensionaler Index) bestehen kann. Die Adresse verweist auf den Platz, an dem die Daten auf der Platte gespeichert sind. In einem dichten Index sind alle Datens\u00e4tze eingetragen, in einem d\u00fcnnen Index dagegen nur einige ausgew\u00e4hlte Datens\u00e4tze.", "type": "multiple-choice", "answers": [{"text": "d\u00fcnne Indizes", "solution": "true"}, {"text": "dicke Indizes", "solution": "false"}, {"text": "dichte Indizes", "solution": "true"}, {"text": "undichte Indizes", "solution": "false"}, {"text": "lange Indizes", "solution": "false"}, {"text": "kurze Indizes", "solution": "false"}]}, {"id": 1320, "category": 11, "difficulty": 2, "text": "Welche Aussagen \u00fcber \"Transaktionen und Lesekonsistenz in SQL\" sind richtig?", "explanation": "Richtig ist, dass bei Oracle zwei Konsistenzgrade unterschieden werden: \"statement level\" und \"transaction level\", richtig ist auch, das bei Oracle \"dirty reads\" grunds\u00e4tzlich ausgeschlossen sind. \n\nBeim SQL-Standard hingegen ist es anders, dort sind \"dirty reads\" grunds\u00e4tzlich m\u00f6glich und m\u00fcssen durch einen passenden Isolationsgrad ausgeschlossen werden (READ COMMITTED und h\u00f6her).", "type": "multiple-choice", "answers": [{"text": "Im SQL-Standard sind keine \"dirty reads\" m\u00f6glich.", "solution": "false"}, {"text": "Bei Oracle werden zwei Konsistenzgrade unterschieden: \"statement level\" und \"transaction level\".", "solution": "true"}, {"text": "Im SQL-Standard sind \"dirty reads\" m\u00f6glich. Bei Oracle wird die Grundannahme getroffen, dass keine \"dirty reads\" m\u00f6glich sind.", "solution": "true"}]}, {"id": 1763, "category": 10, "difficulty": 1, "text": "Bei welchem Trigger-Ausf\u00fchrungsmodell richtet sich die Reihenfolge der Ausf\u00fchrung der Trigger, die f\u00fcr eine bestimmte Tabelle definiert sind, nach der \"creation time\"?", "explanation": "Im Ausf\u00fchrungsmodell von Oracle werden die ROW-Trigger um das DML-Ereignis gruppiert, so dass die creation-Time nicht notwendig ist.", "type": "multiple-choice", "answers": [{"text": "Ausf\u00fchrungsmodell von ORACLE", "solution": "false"}, {"text": "Ausf\u00fchrungsmodell von SQL:1999 und DB2", "solution": "true"}]}, {"id": 1319, "category": 11, "difficulty": 3, "text": "Welche Aussagen \u00fcber \"Transaktionen und Lesekonsistenz in SQL\" sind richtig?", "explanation": "Lesekonsistenz ist ein weiteres Problem, welches beim Mehrbenutzerbetrieb auftritt. Bei l\u00e4nger andauernden Transaktionen stellt sich die Frage, auf welchem Datenbankzustand die Anfragen eigentlich ausgewertet werden, wenn parallel andere Benutzer die zu lesenden Daten \u00e4ndern.\n\nDaraus resultieren mehrere Probleme: \n\nBei innerhalb einer Transaktion wiederholten Anfragen k\u00f6nnen bei der Wiederholung Datens\u00e4tze angezeigt werden, die vorher nicht da waren, also \"Phantome\", bzw. es werden Datens\u00e4tze nicht mehr angezeigt oder mit ge\u00e4nderten Inhalt, also \"nicht wiederholbares Lesen\".  Grund daf\u00fcr sind jeweils andere Transaktionen, die ihre \u00c4nderungen persistent gespeichert haben (COMMIT).\n\nEin anderes Problem stellt sich bei langandauernden Anfragen, was passiert mit den \u00c4nderungen parallel ausgef\u00fchrter Transaktionen, die zwischenzeitlich ihre \u00c4nderungen persistent gespeichert haben. (COMMIT).\n\n\"Dirty Read\" ist ein Problem, das beiden Aufgabenstellungen, Nebenl\u00e4ufigkeitskontrolle wie auch Lesekonsistenz betrifft. \n\n\"Lost Update\" ist ein Problem der Nebenl\u00e4ufigkeitskontrolle weniger der Lesekonsistenz.", "type": "multiple-choice", "answers": [{"text": "Dauert eine Anfrage l\u00e4nger, so kann im Multi User-Betrieb u.a. das \"Lost Update-Problem\" auftreten.", "solution": "false"}, {"text": "Dauert eine Anfrage l\u00e4nger, so kann im Multi User-Betrieb u.a. das \"Dirty Read-Problem\" auftreten.", "solution": "true"}, {"text": "F\u00fchrt eine Transaktion eine Anfrage mehrfach aus, so k\u00f6nnen u.a. \"non repeatable reads\" und \"phantome\" auftreten.", "solution": "true"}, {"text": "F\u00fchrt eine Transaktion eine Anfrage mehrfach aus, so k\u00f6nnen u.a. \"lost updates\", \"non repeatable reads\" und \"phantome\" auftreten.", "solution": "false"}, {"text": "Bei der Lesekonsistenz geht es prim\u00e4r um das Problem: \"Auf welchem Datenbankzustand werden die Transaktionen ausgef\u00fchrt, wenn z.B. eine Anfrage l\u00e4nger dauert oder aber w\u00e4hrend einer Transaktion eine Anfrage mehrfach ausgef\u00fchrt wird.\"", "solution": "true"}]}, {"id": 1765, "category": 9, "difficulty": 3, "text": "Welche EXCEPTIONS k\u00f6nnen speziell bei einem impliziten Cursor (SELECT  INTO ) geworfen werden? Bitte in alphabetischer Reihenfolge schreiben!", "explanation": "SELECT INTO \u00fcbergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datens\u00e4tze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datens\u00e4tze verarbeiten kann.", "type": "text", "answers": [{"text": "Das ist", "solution": "NO_DATA_FOUND"}, {"text": "und", "solution": "TOO_MANY_ROWS"}]}, {"id": 1291, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Operator wird der F\u00fcr-Alle-Quantor umgesetzt?", "explanation": "Der F\u00fcr-Alle-Quantor kann in SQL nicht direkt umgesetzt werden, sondern nur \u00fcber zwei m\u00f6gliche Umwege: \u00dcber ein doppeltes NOT EXISTS oder durch ein GROUP-BY/HAVING mit Z\u00e4hlen \u00fcber COUNT(*).", "type": "multiple-choice", "answers": [{"text": "Mit einem NOT EXISTS", "solution": "false"}, {"text": "Mit zwei NOT EXISTS", "solution": "true"}, {"text": "Mit FORALL", "solution": "false"}, {"text": "Mit keinem dieser Operatoren", "solution": "false"}]}, {"id": 1293, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank:\n\n    Spieler (Spieler_id, Name, Adresse, Geburtsdatum) Vereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr )\n\n    Spiele (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\n\n    Spieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\n    Welche der angegeben SQL-Abfragen beantwortet/en die Frage: Welche Vereine (K\u00fcrzel, Name) haben wenigstens ein Ausw\u00e4rtsspiel, also wenigstens ein als Spiel als Gastmannschaft in der R\u00fcckrunde (Spieltag 18-34) absolviert?", "explanation": "SELECT v_kuerzel, vereinsname\n\n    FROM verein, spiele\n\n    WHERE spieltag BETWEEN 18 AND 34;\n\n    \n\n    ist semantisch falsch: Es wird hier das kartesische Produkt zwischen den beiden Tabellen ausgef\u00fchrt und nicht der Natural Join.\n\n    \n\n    Die \u00fcbrigen Anfragen sind alle richtig.", "type": "multiple-choice", "answers": [{"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND  spieltag BETWEEN 18 AND 34;", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND spieltag >= 18 AND <= 34;", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele  \nWHERE  spieltag BETWEEN 18 AND 34;", "solution": "false"}, {"text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34);", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34\n GROUP BY gast_v_kuerzel \n  HAVING COUNT (*) >=1);", "solution": "true"}]}, {"id": 1294, "category": 7, "difficulty": 3, "text": "Welche Aussagen \u00fcber Normalformen sind wahr?", "explanation": "In der 3. NF sind partielle (2.NF) und transitive funktionale Abh\u00e4ngigkeiten (3. NF) aufgel\u00f6st, so dass jedes Nichtschl\u00fcsselattribut nur einmal auftritt in allen Relationen. Lediglich Schl\u00fcsselattribute der einen Relation k\u00f6nnen in anderen Relationen als Fremdschschl\u00fcssel-Attribute auftreten, somit liegen nur noch in diesen Fremdschl\u00fcsselattributen Redundanzen vor. \nFalsch ist \"Redundanzen vermeiden Einf\u00fcge-/L\u00f6sch- und \u00c4nderungsanomalien.\", weil Redundanzen Grundvoraussetzungen f\u00fcr diese Anomalien sind. \nFalsch ist \"Eine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der ersten Normalform, wenn jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.\", weil dies die Definition der 2. NF ist. Die 1. NF schlie\u00dft mengenwertige (nicht atomare) Attribute aus. \nEine Relation ist in der dritten Normalform, wenn sie in der 1. und 2. NF ist und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig ist von einem Schl\u00fcsselattribut.", "type": "multiple-choice", "answers": [{"text": "Ein Datenmodell in 3. Normalform enth\u00e4lt keine Redundanzen au\u00dfer Schl\u00fcsselredundanzen (Fremdschl\u00fcsselbeziehungen).", "solution": "true"}, {"text": "Redundanzen vermeiden Einf\u00fcge-/L\u00f6sch- und \u00c4nderungsanomalien.", "solution": "false"}, {"text": "Eine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der ersten Normalform, wenn jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.", "solution": "false"}, {"text": "Eine Relation ist in der dritten Normalform, wenn sie in der 1. und 2. NF ist und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig ist von einem Schl\u00fcsselattribut.", "solution": "true"}]}, {"id": 1322, "category": 11, "difficulty": 2, "text": "Welche Aussagen \u00fcber \"Transaktionen und Fehlererholung in SQL\" sind richtig?", "explanation": "FALSCH ist: \n\"Recovery\" meint das Einspielen eines physisch gesicherten Datenbestands.\" Diese Definition ist nicht umfassend genug. Das Einspielen gesicherter Daten ist nur ein Teil des RECOERY-Prozesses. \n \nEine umfassende Beschreibung liefert die Antwort: \n\"Recovery\" meint das Wiederherstellen eines m\u00f6glichst aktuellen DB-Zustands vor Abbruch des DBS. Ein erster Schritt kann ggf. das Zur\u00fcckspielen eines extern gesicherten Datenbestands sein. Ausgehend von diesem DB-Zustand wird dann anhand von System-Log-Datei-Eintr\u00e4gen ein m\u00f6glichst aktueller DB-Zustand rekonstruiert.\"\n \nEbenfalls richtig ist:\n\"Zentrale Werkzeuge der Fehlererholung sind \"Backup-\" (physische Datensicherung) und \"Recovery\"-Strategien (Wiederherstellung eines m\u00f6glichst aktuellen DB-Zustands vor Abbruch i.d.R. ausgehend von einem gesicherten Datenbestand).\"", "type": "multiple-choice", "answers": [{"text": "Zentrale Werkzeuge der Fehlererholung sind \"Backup-\" (physische Datensicherung) und \"Recovery\"-Strategien (Wiederherstellung eines m\u00f6glichst aktuellen DB-Zustands vor Abbruch i.d.R. ausgehend von einem gesicherten Datenbestand).", "solution": "true"}, {"text": "\"Recovery\" meint das Einspielen eines physisch gesicherten Datenbestands.", "solution": "false"}, {"text": "\"Recovery\" meint das Wiederherstellen eines m\u00f6glichst aktuellen DB-Zustands vor Abbruch des DBS. Ein erster Schritt kann ggf. das Zur\u00fcckspielen eines extern gesicherten Datenbestands sein. Ausgehend von diesem DB-Zustand wird dann anhand von System-Log-Datei-Eintr\u00e4gen ein m\u00f6glichst aktueller DB-Zustand rekonstruiert.", "solution": "true"}]}, {"id": 1323, "category": 11, "difficulty": 1, "text": "Welche Aussagen \u00fcber \"Transaktionen und Fehlererholung in SQL\" sind richtig?", "explanation": "RICHTIG ist: \n\"System-Log-Dateien sind Protokolle \u00fcber alle durchgef\u00fchrten Transaktionen und die Informationen werden ohne Pufferung direkt auf der Platte gespeichert.\" Wichtig ist, dass diese Informationen nicht im Hauptspeicher gehalten werden, denn es geht ja gerade darum, dass diese Informationen f\u00fcr etwaige Rekonstruktionen von Transaktionen zur Verf\u00fcgung stehen - auch im Falle eines Systemabsturzes und Verlust der HSP-Daten, daher immer persistent auf Platte.  \n\nAus diesem Grunde ist die andere Aussage dann auch FALSCH.", "type": "multiple-choice", "answers": [{"text": "System-Log-Dateien sind Protokolle \u00fcber alle durchgef\u00fchrten Transaktionen und die Informationen werden f\u00fcr einen schnellen Zugriff m\u00f6glichst lange im Hauptspeicher gepuffert.", "solution": "false"}, {"text": "System-Log-Dateien sind Protokolle \u00fcber alle durchgef\u00fchrten Transaktionen und die Informationen werden ohne Pufferung direkt auf der Platte gespeichert.", "solution": "true"}]}, {"id": 1324, "category": 11, "difficulty": 2, "text": "Welche der folgenden Punkte sind Inhalte von System-Log-Dateien?", "explanation": "Es muss zwischen den beiden Systemen f\u00fcr das LOGGING und das LOCKING differenziert werden: \nDas LOCKING-System sorgt f\u00fcr ein exclusives Sperren von Datens\u00e4tzen f\u00fcr \u00c4nderungen und daher werden dort Informationen wie z.B.\n\nArt des Locks (SLOCK, XLOCK)\nLOCK-Ebene.\n\n\nDas LOGGING-System sorgt daf\u00fcr, dass Transaktionen zur\u00fcckgerollt und ggf. auch wieder rekonstruiert werden k\u00f6nnen. Daf\u00fcr werden u.a. folgende Informationen ben\u00f6tigt: \n\nTransaktions-ID\nArt der \u00c4nderung (Insert / Update / Delete)\nAlter/neuer Wert der Daten des Datensatzes (physikalische Adresse)\nStartzeitpunkt der \u00c4nderung\nArt der Beendigung (COMMIT, ROLLBACK, noch nicht beendet)\nBenutzerkennung bzw. verwendetes Programm", "type": "multiple-choice", "answers": [{"text": "Transaktions-ID", "solution": "true"}, {"text": "LOCK-Ebene", "solution": "false"}, {"text": "Art der \u00c4nderung (Insert / Update / Delete)", "solution": "true"}, {"text": "Alter/neuer Wert der Daten des Datensatzes (physikalische Adresse)", "solution": "true"}, {"text": "Startzeitpunkt der \u00c4nderung", "solution": "true"}, {"text": "Art des Locks (SLOCK, XLOCK)", "solution": "false"}, {"text": "Art der Beendigung (COMMIT, ROLLBACK, noch nicht beendet)", "solution": "true"}, {"text": "Benutzerkennung bzw. verwendetes Programm", "solution": "true"}]}, {"id": 1325, "category": 9, "difficulty": 2, "text": "In welchem JAVA-Package befinden sich die Klassen von JDBC?", "explanation": "Wer n\u00e4heres Wissen will, sollte bei SUN selber nachschlagen: \n\n<a href= \"http://java.sun.com/j2se/1.4.2/docs/api/java/sql/package-summary.html\"> JDBC-Dokumentation bei Sun", "type": "text", "answers": [{"text": "Das ist", "solution": "java.sql"}]}, {"id": 1326, "category": 9, "difficulty": 1, "text": "Von der executeQuery() Methode wird ein ResultSet-Objekt erzeugt. Wo steht der Cursor zu Beginn?", "explanation": "Der Cursor steht vor dem ersten Datensatz und muss dann mit next() auf den ersten Datensatz bewegt werden.", "type": "multiple-choice", "answers": [{"text": "Vor dem ersten Datensatz", "solution": "true"}, {"text": "Auf dem ersten Datensatz", "solution": "false"}, {"text": "Auf dem zweiten Datensatz", "solution": "false"}]}, {"id": 1327, "category": 9, "difficulty": 3, "text": "Wie k\u00f6nnen Sie den Java Datentyp \"boolean\" in den meisten relationalen Datenbanken ablegen?", "explanation": "Obwohl der Datentyp boolean im SQL-Standard seid SQL:2003 vorgesehen ist, wird er nur von wenigen Datenbankherstellern implementiert.", "type": "multiple-choice", "answers": [{"text": "\"boolean\" hat in dem meisten SQL-Dialekten keine Entsprechung.", "solution": "true"}, {"text": "boolean entspricht dem SQL-Standard-Datentyp \"boolean\" seid SQL:2003.", "solution": "true"}, {"text": "Oracle besitzt einen Datentyp boolean gem\u00e4\u00df dem SQL-Standard SQL:2003.", "solution": "false"}, {"text": "Postgres besitzt einen Datentyp boolean gem\u00e4\u00df dem SQL-Standard SQL:2003.", "solution": "true"}]}, {"id": 1328, "category": 9, "difficulty": 2, "text": "Wie k\u00f6nnen Sie den Java Datentyp \"String\" in den meisten relationalen Datenbanken ablegen?", "explanation": "Standardm\u00e4\u00dfig wird der Datentyp varchar benutzt, char kann auch angegeben werden, ist aber nicht der default.", "type": "text", "answers": [{"text": "Das entspricht im SQL-Standard", "solution": "varchar"}]}, {"id": 1373, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft die Default-Verbindung, mit der man unter SQLJ und JDBC eine Verbindung in einer ORACLE-Datenbank selber als gespeicherte Prozedur aufbauen kann?", "type": "text", "answers": [{"text": "Das ist", "solution": "jdbc:default:connection"}]}, {"id": 1376, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber CONSTRAINTS sind wahr?", "explanation": "Die zwei richtigen Aussagen erkl\u00e4ren sich selbst. \nFALSCH ist: \nDie Sache mit dem \"MANDATORY-CONSTRAINT\". Ein Constraint dieses Namens gibt es nicht. Das Constraint mit der gew\u00fcnschten Funktion hei\u00dft: NOT NULL bei SQL.", "type": "multiple-choice", "answers": [{"text": "F\u00fcr im ER-Modell als \"obligatorisch\" (Pflichteingabe) deklarierte Attribute werden im Datenmodell MANDATORY-CONSTRAINTS definiert.", "solution": "false"}, {"text": "Die Standardreaktion auf einen Integrit\u00e4tsfehler beim \"integrity checking\" mittels Constraints ist das Zur\u00fcckrollen des fehlerhaften DML-Befehls (Pr\u00fcfungsmodus IMMEDIATE) bzw. der gesamten Transaktion beim Pr\u00fcfungsmodus DEFERRED.", "solution": "true"}, {"text": "Transitionale Integrit\u00e4tsbedingungen k\u00f6nnen in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Referenzvariablen (:OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.", "solution": "true"}]}, {"id": 1392, "category": 9, "difficulty": 1, "text": "Wenn ein CONSTRAINT existiert, kann der Anwender sicher sein, dass alle in der Datenbank gespeicherten Daten die Bedingung erf\u00fcllen, die durch den CONSTRAINT definiert ist.", "explanation": "Genau das ist der 100% Schutz, den Datenbanksysteme bei Constraints bieten. Wenn man in der USER_CONSTRAINTS des Dictionary sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabh\u00e4ngig vom Zeitpunkt der Speicherung korrekt sind. \nDas ist einer der Punkte, bei dem sich Integrit\u00e4tspr\u00fcfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden dort nur f\u00fcr alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1461, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgende Package-Definition in PL/SQL:\n\nCREATE OR REPLACE PACKAGE Math_Pack AS\n      PROCEDURE Mitteln (x IN NUMBER, y IN NUMBER);\n      PROCEDURE Root    (x IN NUMBER, y IN NUMBER);\n      Ergebnis NUMBER;\nEND Math_Pack;", "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder \u00f6ffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind \u00f6ffentlich und k\u00f6nnen damit von au\u00dferhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und k\u00f6nnen damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.  \n\nDaher ist die Variable \"Ergebnis\" ist \u00f6ffentlich.", "type": "multiple-choice", "answers": [{"text": "Die Variable \"Ergebnis\" ist privat.", "solution": "false"}, {"text": "Die Variable \"Ergebnis\" ist \u00f6ffentlich.", "solution": "true"}]}, {"id": 1397, "category": 42, "difficulty": 3, "text": "Bei welchen Speicherstrukturen sind die Nutzdaten von den Schl\u00fcsseldaten getrennt?", "explanation": "Die Hash-Speicherstruktur beinhaltet keinen Index und ISAM und B+-Baum haben einen Index, der getrennt von den Nutzdaten gespeichert wird.", "type": "multiple-choice", "answers": [{"text": "HEAP", "solution": "false"}, {"text": "ISAM", "solution": "true"}, {"text": "B-Baum", "solution": "false"}, {"text": "B+-Baum", "solution": "true"}, {"text": "HASH", "solution": "false"}]}, {"id": 1411, "category": 1, "difficulty": 1, "text": "Was versteht man unter der Abk\u00fcrzung QBE?", "explanation": "QBE steht f\u00fcr Query By Example und ist eine Anfragesprache, die schon in den 70er Jahren parallel zu SQL und System R bei der IBM entwickelt wurde.", "type": "text", "answers": [{"text": "Das ist", "solution": "Query By Example"}]}, {"id": 1446, "category": 9, "difficulty": 2, "text": "Mit welchem Zeichen werden Paramater an eine SQLJ Prozedur von au\u00dfen \u00fcbergeben?", "type": "multiple-choice", "answers": [{"text": "Das ist \":\"", "solution": "false"}, {"text": "Das ist \"?\"", "solution": "true"}]}, {"id": 1448, "category": 9, "difficulty": 3, "text": "Wo sind SQL-Aggregatfunktionen (SUM, MIN, MAX, COUNT, AVG) erlaubt?", "explanation": "Die SQL-Gruppenfunktionen SUM,MIN, MAX, AVG und COUNT machen in der WHERE-Klausel keinen Sinn, da sie sich auf Gruppen von Werten, nicht auf einzelne Werte, beziehen.", "type": "multiple-choice", "answers": [{"text": "SELECT-Klausel ohne SUBSELECT", "solution": "true"}, {"text": "FROM-Klausel ohne SUBSELECT", "solution": "false"}, {"text": "WHERE-Klausel ohne SUBSELECT", "solution": "false"}, {"text": "GROUP BY-Klausel", "solution": "false"}, {"text": "HAVING-Klausel ohne SUBSELECT", "solution": "true"}, {"text": "ORDER BY-Komponente", "solution": "true"}]}, {"id": 1456, "category": 9, "difficulty": 1, "text": "Welche PL/SQL-Syntax ist korrekt?", "explanation": "OPEN Cursorname; reicht hier aus.", "type": "multiple-choice", "answers": [{"text": "OPEN CURSOR Cursorname;", "solution": "false"}, {"text": "OPEN Cursorname;", "solution": "true"}]}, {"id": 1742, "category": 11, "difficulty": 2, "text": "Welche Aussagen \u00fcber \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?", "explanation": "RICHTIG ist: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.\"\n\nFALSCH ist: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion keine SLOCKs auf das gesperrte Objekt absetzen.\"\nEs ist ja gerade Sinn und Zweck der SLOCKs parallleles Lesen zuzulassen und daher sind mehrere SLOCKs auf einer Tabelle m\u00f6glich. \nXLOCKS hingegen k\u00f6nnen erst wieder gesetzt werden, wenn keine SLOCKs mehr vorliegen und auch keine anderen XLOCKs.", "type": "multiple-choice", "answers": [{"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.", "solution": "true"}, {"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion keine SLOCKs auf das gesperrte Objekt absetzen.", "solution": "false"}]}, {"id": 1741, "category": 9, "difficulty": 3, "text": "Mit welchem CONSTRAINT_CHARACTERISTICA  kann man den Pr\u00fcfungszeitpunkt bis zum Ende der Transaktion verz\u00f6gern?", "explanation": "<CONSTRAINT Characteristika> ::= \n{ INITIALLY DEFERRED | INITIALLY IMMEDIATE } [ [ NOT ] DEFERRABLE ]\n\nMit DEFERRED (verz\u00f6gert) wird die Pr\u00fcfung der Integrit\u00e4tsbedingung zum Ende der Transaktion (COMMIT) bezeichnet. IMMEDIATE (unmittelbar) beschreibt die Pr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung einer einzelnen \u00c4nderungsanweisung. \nIMMEDIATE hat den Vorteil, dass Integrit\u00e4tsfehler so fr\u00fch wie m\u00f6glich erkannt werden, und DEFERRED, dass w\u00e4hrend der laufenden Transaktion durch nachfolgende Anweisungen ein zwischenzeitlich inkonsistenter Zustand wieder korrigiert werden kann.", "type": "text", "answers": [{"text": "CONSTRAINT_CHARACTERISTICA  =", "solution": "INITIALLY DEFERRED"}]}, {"id": 2465, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Sichten sind wahr?", "explanation": "Sichten k\u00f6nnen auf Tabellen oder anderen Sichten definiert sein, das snd die sogenannten Sichthierarchien. \nAufrund der redundanten Datenspeicherung in den materialisierten Sichten sind diese schneller bei Anfragen, haben jedoch das Problem, dass sich Tabellendaten \u00e4ndern und die Sichtdaten dann veraltet sind. \nEs ist der Nachteil der virtuellen Sichten, dass sie l\u00e4ngere Antwortzeiten haben, da die Anfrage erst \u00fcber allen Tabellen ausgewertet werden muss. \n\nDML-Befehle (INSERT, UPDATE,DELETE) k\u00f6nnen auf Sichten ausgef\u00fchrt werden. Und daraus resultiert das \"view updating\"-Problem, bei dem es darum geht, das das DBMS in der Lage ist, eine Manipulation des View-Datensatzes nur mit Hilfe der Sichtdefinition vollautomatisch auf die Datens\u00e4tze in den zugrunde liegenden Tabellen zu transformieren. Dieses \"view updating\"-Problem ist in der Wissenschaft bislang nur f\u00fcr einige F\u00e4lle gel\u00f6st und f\u00fcr einen kleinen Teil davon haben die DBMS-Hersteller die L\u00f6sungen auch implementiert. Wenn es nicht mehr \"automatisch\" geht, dann muss der Entwickler einen INSTEAD OF-Trigger programmieren.", "type": "multiple-choice", "answers": [{"text": "Sichten k\u00f6nnen auf Tabellen oder anderen Sichten definiert sein.", "solution": "true"}, {"text": "Bei virtuellen Sichten tritt das Problem gro\u00dfer Antwortzeiten auf.", "solution": "true"}, {"text": "Bei materialisierten Sichten tritt das Problem der Datenaktualit\u00e4t auf.", "solution": "true"}, {"text": "Bei Sichten tritt das Problem des \"View Updatings\" auf.", "solution": "true"}, {"text": "DML-Befehle (INSERT, UPDATE,DELETE) k\u00f6nnen auf Sichten ausgef\u00fchrt werden.", "solution": "true"}]}, {"id": 2467, "category": 7, "difficulty": 1, "text": "Welche der folgenden Aussagen \u00fcber Normalformen sind wahr?", "explanation": "FALSCH ist:\n\n    Die 1NF ist immer verschieden von der 2NF.\n\n    Wenn es keine partiellen funktionalen Abh\u00e4ngigkeiten gibt vom Prim\u00e4rschl\u00fcssel in der 1.NF, dann gilt: 1.NF = 2.NF.\n\n    FALSCH ist:\n\n    Die 2NF ist immer verschieden von der 3NF.\n\n    Wenn es keine transitiven funktionalen Abh\u00e4ngigkeiten gibt, dann gilt: 2.NF = 3.NF.", "type": "multiple-choice", "answers": [{"text": "Die 1NF ist immer verschieden von der 2NF.", "solution": "false"}, {"text": "keine von beiden", "solution": "true"}, {"text": "Die 2NF ist immer verschieden von der 3NF.", "solution": "false"}]}, {"id": 954, "category": 11, "difficulty": 3, "text": "Mit welcher Oracle-SQL-Anweisung kann man Isolationsgrade \"transaction level\" und \"statement level\" setzen?", "explanation": "Unterschiede zwischen SQL2003 und Oracle \nDie Unterschiede bei den Isolationsgraden zwischen SQL2003 und Oracle basieren im Wesentlichen darauf, dass Oracle unsauberes Lesen grunds\u00e4tzlich ausschlie\u00dft, womit der Isolationsgrad READ UNCOMMITTED entf\u00e4llt. Zudem wird von Oracle der Unterschied zwischen den beiden Problemen Phantome und nicht wiederholbares Lesen als eher akademischer Natur betrachtet, womit der Isolationsgrad REPEATABLE READ ebenfalls entf\u00e4llt.\n\nStatement Level \nDie Daten, die eine Anfrage ermittelt, sind alle vom gleichen Zeitpunkt und zwar vom Start der Anfrageauswertung. Es werden keine \"unsauberen\" Daten gelesen und keine \u00c4nderungen, die w\u00e4hrend der Anfrageauswertung von anderen Transaktionen mit COMMIT persistent gespeichert wurden. Dieser Lesekonsistenzgrad wird durch die Option READ COMMITTED spezifiziert und ist die Voreinstellung. \n\nTransaction Level \nDie Daten aller Anfragen einer Transaktion stammen vom gleichen Zeitpunkt und zwar vom Start der Transaktion. Es k\u00f6nnen weder das nicht wiederholbare Lesen noch Phantome auftreten. Dieser Zustand wird durch die Option SERIALIZABLE eingestellt.\n\n<SET TRANSACTION Anweisung (Oracle)> ::=\n  SET TRANSACTION { READ { ONLY | WRITE }  } ;\n\n ::= ISOLATION LEVEL { READ COMMITTED | SERIALIZABLE }", "type": "text", "answers": [{"text": "Das ist die Anweisung (ohne Parameter)", "solution": "SET TRANSACTION"}]}, {"id": 586, "category": 7, "difficulty": 2, "text": "Attribute in der ersten Normalform d\u00fcrfen Wiederholungsgruppen von Attributen haben.", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 571, "category": 7, "difficulty": 2, "text": "Jedes Nicht-Schl\u00fcssel-Attribut ist in einer Relation R voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S.", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "Das ist die erste Normalform.", "solution": "false"}, {"text": "Das ist die zweite Normalform.", "solution": "true"}, {"text": "Das ist die dritte Normalform.", "solution": "false"}, {"text": "Das entspricht keiner Normalform.", "solution": "false"}]}, {"id": 959, "category": 11, "difficulty": 2, "text": "Wie nennt man das folgende Problem:\nEine Verklemmung entsteht, wenn eine Transaktion A ein Objekt X gesperrt h\u00e4lt und im weiteren Verlauf ein Objekt Y sperren m\u00f6chte. Zudem h\u00e4lt eine Transaktion B das Objekt Y gesperrt und will sp\u00e4ter noch Objekt X sperren. Somit warten beide Transaktionen jeweils auf das Objekt, das die andere Transaktion gesperrt h\u00e4lt. Eine Freigabe durch eine der beiden Transaktionen ist ohne Eingriff von Au\u00dfen nicht m\u00f6glich.", "explanation": "Da bei Transaktionen die beteiligten Relationen im Vorfeld nicht bekannt sind, tritt das Problem der Verklemmung (Deadlock) durchaus schon mal auf und ist wie oben definiert.", "type": "text", "answers": [{"text": "Das ist ein", "solution": "DEADLOCK"}]}, {"id": 580, "category": 7, "difficulty": 2, "text": "Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation bezeichnet. Y sei funktional abh\u00e4ngig von X und Z funktional abh\u00e4ngig von Y, und X sei funktional abh\u00e4ngig von Y.", "explanation": "Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist. \nAlso X ->Y ->Z, aber nicht Y ->X.", "type": "multiple-choice", "answers": [{"text": "Das ist die transitive Abh\u00e4ngigkeit.", "solution": "false"}, {"text": "Das ist nicht die transitive Abh\u00e4ngigkeit.", "solution": "true"}]}, {"id": 581, "category": 7, "difficulty": 3, "text": "Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation bezeichnet. Y sei funktional abh\u00e4ngig von X und Z funktional abh\u00e4ngig von Y, aber X sei nicht funktional abh\u00e4ngig von Y.", "explanation": "Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist. \nAlso X ->Y ->Z, aber nicht Y ->X.", "type": "text", "answers": [{"text": "Diese Eigenschaft nennt man:", "solution": "Transitive Abh\u00e4ngigkeit"}]}, {"id": 588, "category": 7, "difficulty": 3, "text": "Welche Aktion geh\u00f6rt nicht in die Transformation eines konzeptionellen Schemas auf ein Datenbankschema?", "explanation": "Bei der Transformation vom konzeptionellen Schema zum Datenbankschema gibt es zwei Hauptregeln: \nRegel 1: Die Entity-Mengen des ER-Modells werden auf Relationen abgebildet. \nRegel 2: Beziehungen werden auf Fremdschl\u00fcsselattribute oder Relationen abgebildet. \n\nAnschlie\u00dfend wird noch eine \u00dcberf\u00fchrung des Datenbankschemas in die dritte Normalform durchgef\u00fchrt und das entstandene Datenbankschema verfeinert. Dazu geh\u00f6ren: \n1. Prim\u00e4rschl\u00fcssel + Fremdschl\u00fcssel: Jede Relation muss einen Prim\u00e4rschl\u00fcssel haben. Fremdschl\u00fcssel werden verwendet, um die referentielle Integrit\u00e4t zu sichern, und m\u00fcssen daher nicht in jeder Relation existieren. \n2. Wertebereiche der Attribute: Neben den Basisdatentypen sind endliche Wertebereiche und Dom\u00e4nen (z.B. weiblich, m\u00e4nnlich) festzulegen. \n3. Semantische Integrit\u00e4tsbedingungen (vgl. Abschnitt 4.1) werden in Textform beschrieben. \n4. Views stellen Daten aus einer oder auch verschiedenen Relationen f\u00fcr bestimmte Benutzersichten, die f\u00fcr spezielle Funktionen verwendet werden, zur Verf\u00fcgung. \n5. Indizes beschreiben Zweitschl\u00fcssel. \n6. Zugriffsrechte werden auf den Relationen oder Sichten f\u00fcr einzelne Benutzer oder Gruppen von Benutzern erkl\u00e4rt.", "type": "multiple-choice", "answers": [{"text": "Aufl\u00f6sung der Entit\u00e4ten und Beziehungen auf Relationen", "solution": "false"}, {"text": "\u00dcberf\u00fchrung in die dritte Normalform", "solution": "false"}, {"text": "Festlegung der Wertebereiche der Attribute", "solution": "false"}, {"text": "Festlegung der Benutzersichten", "solution": "false"}, {"text": "Festlegung der Benutzerschnittstellen", "solution": "true"}, {"text": "Festlegung der Speicherstrukturen", "solution": "false"}, {"text": "Festlegung der Benutzerrechte", "solution": "false"}]}, {"id": 579, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation, deren Prim\u00e4rschl\u00fcssel aus drei Attributen besteht. Wie viele Relationen k\u00f6nnen bei der \u00dcberf\u00fchrung in die zweite Normalform h\u00f6chstens entstehen? Zwei Relationen, die sich nur in der Spaltenreihenfolge unterscheiden, sollen als gleich betrachtet werden", "explanation": "Die Anzahl der Relationen ist 7, da man die Potenzmenge, das ist die Anzahl der Teilmengen einer elementigen Menge betrachten muss. In unserem Beispiel ist das  2 hoch 3, also 8. Da die leere Menge mit zur Potenzmenge geh\u00f6rt, bleiben 7 Relationen \u00fcbrig, die maximal entstehen k\u00f6nnen, wenn von der jeweiligen Teilmenge der Prim\u00e4rschl\u00fcsselattribute weitere Nichtschl\u00fcsselattribute abh\u00e4ngen. N\u00e4here Einzelheiten findet man in <a href=\"http://de.wikipedia.org/wiki/Potenzmenge\">Wikipedia: Potenzmenge", "type": "text", "answers": [{"text": "Die Anzahl ist:", "solution": "7"}]}, {"id": 584, "category": 7, "difficulty": 1, "text": "In einer Relation sei kein Sekund\u00e4rattribut (Nicht-Schl\u00fcsselattribut) transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut.", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "Das ist die dritte Normalform.", "solution": "true"}, {"text": "Das ist die erste Normalform.", "solution": "false"}, {"text": "Das ist die zweite Normalform.", "solution": "false"}]}, {"id": 957, "category": 11, "difficulty": 2, "text": "Wie nennt man das folgende Problem:\nA liest und \u00e4ndert Objekt X und \u00e4ndert dann noch weitere Objekte. B liest nach der \u00c4nderung von A den neuen Wert von Objekt X und \u00e4ndert diesen wiederum. Anschlie\u00dfend wird die Transaktion A zur\u00fcckgerollt, womit auch die \u00c4nderungen an Objekt X r\u00fcckg\u00e4ngig gemacht werden. Aber B hat bereits den ge\u00e4nderten Wert weiter verarbeitet, obwohl er noch nicht dauerhaft g\u00fcltig war.", "explanation": "LOST UPDATE (verlorene \u00c4nderungen) ist das Problem, das auf dem \u00dcberschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgef\u00fchrter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn \u00c4nderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zu\u00fcckgerollt werden (ROLLBACK, Integrit\u00e4tsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgef\u00fchrte Transaktionen die Daten zwischenzeitlich ge\u00e4ndert bzw. gel\u00f6scht haben (NON REPEATABLE READ) oder neue Datens\u00e4tze eingef\u00fcgt wurden (PHANTOME).", "type": "multiple-choice", "answers": [{"text": "LOST UPDATE", "solution": "false"}, {"text": "DIRTY READ", "solution": "true"}, {"text": "PHANTOM", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 632, "category": 4, "difficulty": 1, "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung werden Pflichtenhefte erstellt?", "explanation": "In der Analysephase werden die Systemfunktionen und Daten in groben Z\u00fcgen geplant und festgelegt. Es wird eine explizite Systemdefinition in Form eines Lastenhefts vorgenommen. Dies geschieht umgangssprachlich in einer auch f\u00fcr Laien lesbaren Form. Au\u00dferdem werden die Daten mit Mitteln der Softwaretechnik, hier mit dem Entity-Relationship-Modell (kurz: ERM oder ER-Modell), genau beschrieben. Das ERM entspricht dem konzeptionellen Modell aus dem ANSI-3-Ebenen-Modell.", "type": "multiple-choice", "answers": [{"text": "Analysephase", "solution": "true"}, {"text": "Entwurfsphase", "solution": "false"}, {"text": "Implementierungsphase", "solution": "false"}]}, {"id": 636, "category": 4, "difficulty": 1, "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung wird eine Normalisierung durchgef\u00fchrt?", "explanation": "In der Entwurfsphase wird das konzeptionelle Schema auf ein relationales Datenbankschema abgebildet und eine Normalisierung durchgef\u00fchrt. Au\u00dferdem wird bei einer geplanten Anwendungsentwicklung ein objektorientiertes Klassenmodell erstellt, das die f\u00fcr die Datensicht erforderlichen Methoden und Funktionen enth\u00e4lt.", "type": "multiple-choice", "answers": [{"text": "Analysephase", "solution": "false"}, {"text": "Entwurfsphase", "solution": "true"}, {"text": "Implementierungsphase", "solution": "false"}]}, {"id": 635, "category": 4, "difficulty": 1, "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung wird das ER-Modell auf ein relationales Datenbankschema abgebildet?", "explanation": "In der Entwurfsphase wird das konzeptionelle Schema auf ein relationales Datenbankschema abgebildet und eine Normalisierung durchgef\u00fchrt. Au\u00dferdem wird bei einer geplanten Anwendungsentwicklung \nein objektorientiertes Klassenmodell erstellt, das die f\u00fcr die Datensicht erforderlichen Methoden und Funktionen enth\u00e4lt.", "type": "multiple-choice", "answers": [{"text": "Analysephase", "solution": "false"}, {"text": "Entwurfsphase", "solution": "true"}, {"text": "Implementierungsphase", "solution": "false"}]}, {"id": 639, "category": 8, "difficulty": 1, "text": "In der relationalen Algebra sind Null-Werte f\u00fcr Attribute nicht zul\u00e4ssig.", "explanation": "In der relationalen Algebra sind Null-Werte f\u00fcr Attribute zugelassen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 958, "category": 11, "difficulty": 2, "text": "Wie nennt man das folgende Problem:\nZuerst liest A das Objekt X, dann B. Anschlie\u00dfend schreibt erst A seinen neuen Wert f\u00fcr zur\u00fcck, anschlie\u00dfend B. In der Datenbasis wurde mit dem neuen Wert von B der neue Wert von A \u00fcberschrieben, ohne dass B diesen Wert gesehen hat.", "explanation": "LOST UPDATE (verlorene \u00c4nderungen) ist das Problem, das auf dem \u00dcberschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgef\u00fchrter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn \u00c4nderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zu\u00fcckgerollt werden (ROLLBACK, Integrit\u00e4tsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgef\u00fchrte Transaktionen die Daten zwischenzeitlich ge\u00e4ndert bzw. gel\u00f6scht haben (NON REPEATABLE READ) oder neue Datens\u00e4tze eingef\u00fcgt wurden (PHANTOME).", "type": "multiple-choice", "answers": [{"text": "LOST UPDATE", "solution": "true"}, {"text": "DIRTY READ", "solution": "false"}, {"text": "PHANTOM", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 644, "category": 7, "difficulty": 3, "text": "Jeder Wert eines Fremdschl\u00fcssels einer Relation A ist Wert eines Prim\u00e4rschl\u00fcssel in einer anderen Relation. Diese Eigenschaft hei\u00dft", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrit\u00e4t, wenn jeder Wert eines Fremdschl\u00fcssels einer Relation Ri Wert eines Prim\u00e4rschl\u00fcssels in einer anderen Relation Rj ist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt.", "type": "text", "answers": [{"text": "Diese Integrit\u00e4t hei\u00dft:", "solution": "referentielle Integrit\u00e4t"}]}, {"id": 647, "category": 8, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber Zweitschl\u00fcssel treffen zu?", "explanation": "Zweitschl\u00fcssel werden als separate Speicherstrukturen (Index) gespeichert, um das Auffinden von Informationen und damit das Lesen zu beschleunigen. Beim Einf\u00fcgen von Tupeln bzw. \u00c4ndern von Schl\u00fcsselwerten dauert es dann nat\u00fcrlich l\u00e4nger, weil die Werte im Tupel und in der separaten Speicherstruktur eingef\u00fcgt bzw. gepflegt werden muss.", "type": "multiple-choice", "answers": [{"text": "Zweitschl\u00fcssel erzeugen Zeitgewinn beim Schreiben.", "solution": "false"}, {"text": "Zweitschl\u00fcssel erzeugen Zeitverlust beim Schreiben.", "solution": "true"}, {"text": "Zweitschl\u00fcssel erzeugen Zeitgewinn beim Lesen.", "solution": "true"}, {"text": "Zweitschl\u00fcssel erzeugen Zeitverlust beim Lesen.", "solution": "false"}, {"text": "Zweitschl\u00fcssel haben gar keinen Einfluss auf die Zugriffszeiten beim Lesen/Schreiben.", "solution": "false"}]}, {"id": 649, "category": 7, "difficulty": 1, "text": "Bei der Abbildung eines ER-Diagramms auf ein relationales Datenbankschema werden generell alle Entit\u00e4ten auf Relationen abgebildet.", "explanation": "Bei der Transformation, die auch maschinell erfolgen kann, gibt es zwei Hauptregeln: \nRegel 1: Die Entity-Mengen des ER-Modells werden auf Relationen abgebildet. \nRegel 2: Beziehungen werden auf Fremdschl\u00fcsselattribute oder Relationen abgebildet.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 654, "category": 5, "difficulty": 1, "text": "Wann hei\u00dft eine 1:n-Beziehung identifizierend?", "explanation": "Bei identifizierenden Beziehungen wird in der Detail-Entitymenge der Fremdschl\u00fcssel zum Prim\u00e4rschl\u00fcssel hinzugenommen, bei nicht identifizierenden Beziehungen wird der Fremdschl\u00fcssel nur als Attribut eingetragen, welches nicht zum Prim\u00e4rschl\u00fcssel der Relation geh\u00f6rt.", "type": "multiple-choice", "answers": [{"text": "Die Prim\u00e4rschl\u00fcsselattribute der Detail-Entity-Menge treten als Bestandteile des Prim\u00e4rschl\u00fcssels bei der Master-Entity-Menge auf.", "solution": "false"}, {"text": "Die Prim\u00e4rschl\u00fcsselattribute der Master-Entity-Menge treten als Bestandteile des Prim\u00e4rschl\u00fcssels bei der Detail-Entity-Menge auf.", "solution": "true"}, {"text": "Die Prim\u00e4rschl\u00fcsselattribute der Master-Entity-Menge treten als Fremdschl\u00fcssel-Attribute bei der Detail-Entity-Menge auf und sind aber kein Bestandteil des Prim\u00e4rschl\u00fcssels.", "solution": "false"}]}, {"id": 626, "category": 9, "difficulty": 1, "text": "Welche SELECT-Ausdr\u00fccke liefern das gleiche Ergebnis?", "explanation": "Der logische Operator OR ist assoziativ und daher liefert er die gleichen Ergebnisse, unabh\u00e4ngig davon, ob ein Operator rechts oder links steht. \nDie Semantik dieser beiden Anfragen ist: \"Welche Kunden wohnen nicht in Gummersbach oder in K\u00f6ln?\". \nDie Anfrage ohne \"Gummersbach\" hat die Semantik: \"Welche Kunden wohnen in K\u00f6ln?\".", "type": "multiple-choice", "answers": [{"text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'K\u00f6ln'\nOR    NOT (Ort = 'Gummersbach')\n", "solution": "true"}, {"text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'K\u00f6ln'\n", "solution": "false"}, {"text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     NOT (Ort = 'Gummersbach')\nOR      Ort = 'K\u00f6ln'", "solution": "true"}]}, {"id": 627, "category": 9, "difficulty": 3, "text": "Mit welcher SELECT-Komponente kann man die Reihenfolge der Datens\u00e4tze der Ergebnismenge einer SELECT-Abfrage festlegen?", "explanation": "Mit der ORDER BY-Klausel kann auf- (ASC) oder absteigend (DESC) sortiert werden. Die GROUP BY-Klausel sortiert als \"Nebenergebnis\" der Gruppierung die Gruppen auch, aber nur aufsteigend. \nMit den WHERE- und HAVING-Klauseln k\u00f6nnen einzelne Datens\u00e4tze bzw. Gruppen selektiert werden, aber nicht sortiert. \nDie FROM-Klausel verkn\u00fcpft die angegebenen Tabellen mittels kartesischem Produkt bzw. Join, sortiert aber nicht.", "type": "multiple-choice", "answers": [{"text": "WHERE", "solution": "false"}, {"text": "HAVING", "solution": "false"}, {"text": "FROM", "solution": "false"}, {"text": "ORDER BY", "solution": "true"}, {"text": "GROUP BY", "solution": "true"}, {"text": "solch eine Komponente gibt es nicht.", "solution": "false"}]}, {"id": 629, "category": 1, "difficulty": 3, "text": "Welche Datenbanksysteme sind auf das Suchen in unformatierten Datenbest\u00e4nden spezialisiert?", "explanation": "Information Retrieval ist ein Fachgebiet, das sich mit computergest\u00fctztem inhaltsorientiertem Suchen in unfomatierten Daten besch\u00e4ftigt. \nEs ist ein Teilgebiet der Informationswissenschaft, der Computerlinguistik wie auch der Informatik.", "type": "text", "answers": [{"text": "Das ist ein (englischer Begriff)", "solution": "Information Retrieval System"}]}, {"id": 630, "category": 8, "difficulty": 1, "text": "Welche der folgenden Operationen geh\u00f6rt nicht zur relationalen Algebra?", "explanation": "Projektion (attributweise Auswahl), Division (Allquantor) und Differenz (Anfragen mit \"Keine\"/\"Ohne-Aussagen\") geh\u00f6ren zur Relationalen Algebra, die Addition aber nicht.", "type": "multiple-choice", "answers": [{"text": "Division", "solution": "false"}, {"text": "Addition", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Projektion", "solution": "false"}]}, {"id": 759, "category": 8, "difficulty": 3, "text": "Wie viele Tupel hat die Ergebnismenge des kartesischen Produkts von zwei Relationen, die 18 bzw. 20 Tupel beinhalten, wobei es f\u00fcr 14 Tupel der einen Relation Tupel der anderen Relation gibt, die in einem gleichhei\u00dfenden Attribut die gleichen Werte aufweisen?", "explanation": "Das Kartesische Produkt \"verbindet jedes Tupel der einen Relation mit jedem Tupel aus der anderen Relation unabh\u00e4ngig von irgendwelchen passenden oder nichtpassenden Werten\" und somit ergeben sich 18*20 = 360 Tupel in der Ergebnismenge. \nDas nur bei 14 Tupeln \u00fcbereinstimmende Werte gegeben sind, spielt f\u00fcr das kartesische Produkt keine Rolle, sondern nur f\u00fcr den Natural Join.", "type": "text", "answers": [{"text": "Das kartesische Produkt hat ... Tupel.", "solution": "360"}]}, {"id": 760, "category": 8, "difficulty": 1, "text": "Jede n-stellige Relation R ist eine Teilmenge des kartesischen Produkts der Wertebereiche der Attribute.", "explanation": "Sei (A1,..., An) eine Menge von Attributen mit den Wertebereichen Mi. Die Elemente der Mi sind Basisdatentypen und beschreiben die Werte, die die Attribute annehmen k\u00f6nnen. Eine n-stellige Relation R ist eine Teilmenge des kartesischen Produkts M1\u00d7...\u00d7Mn. Rn bezeichne die Menge aller n-stelligen Relationen. Man schreibt auch: R(A1,...,An).", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 783, "category": 8, "difficulty": 3, "text": "Aus welchen Operatoren l\u00e4sst sich der Theta-Join ableiten?", "explanation": "Der Theta-Join ist gem\u00e4\u00df seiner Definition eine Operation, die sich aus Selektion und kartesischem Produkt ableiten l\u00e4sst. Wird zuerst das kartesische Produkt R1 \u00d7 R2 ausgef\u00fchrt und auf dieser Zwischenergebnismenge die Selektion der Bedingung B, dann erh\u00e4lt man das gleiche Ergebnis wie beim Theta-Join(R1, R2, B).", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Selektion", "solution": "true"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Division", "solution": "false"}]}, {"id": 763, "category": 8, "difficulty": 2, "text": "Relationale Operatoren sind immer Abbildungen, die zwei Relationen eine Ergebnis-Relation zuordnen.", "explanation": "Un\u00e4r:  F1 : Rn \u2192 Rm      mit n , m \u2208 N \nBin\u00e4r: F2 : Rn \u00d7 Rm \u2192 Rk mit n , m , k \u2208 N\nUn\u00e4re Operatoren: Selektion, Projektion\nBin\u00e4re Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 781, "category": 8, "difficulty": 3, "text": "Selektionspr\u00e4dikate k\u00f6nnen in der relationalen Algebra enthalten:", "explanation": "Bestandteile eines Selektionspr\u00e4dikats sind: \n1. Attribute einer Relation und Konstanten als Operanden, \n2. Vergleichsoperatoren = <, \u2264, >, \u2265 , <> und != (ungleich), \n3. die logischen Operatoren UND, ODER und NICHT und \n4. Berechnungen mit Konstanten und Spaltenwerten (z.B. Gehalt*1,.045)  \n5. eine beliebige Kombination aus den oben genannten M\u00f6glichkeiten, die durch Klammerung (..) erzeugt wird.", "type": "multiple-choice", "answers": [{"text": "Konstante Werte", "solution": "true"}, {"text": "Klammern ()", "solution": "true"}, {"text": "Attributnamen einer Relation", "solution": "true"}, {"text": "Vergleichsoperatoren", "solution": "true"}, {"text": "logische Operatoren", "solution": "true"}, {"text": "Berechnungen", "solution": "true"}]}, {"id": 767, "category": 8, "difficulty": 1, "text": "Welcher Operator der relationalen Algebra w\u00e4hlt Tupel aus einer Relation aus?", "explanation": "Die Selektion erzeugt eine n-stellige Relation mit der gleichen Attributanzahl, aber mit weniger oder gleich viel Tupeln als die urspr\u00fcngliche Relation. Sie extrahiert aufgrund des Selektionspr\u00e4dikats Tupel aus einer vorgegebenen Relation.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "false"}]}, {"id": 782, "category": 8, "difficulty": 2, "text": "Welche Eigenschaften haben Relationen in der relationalen Algebra resp. dem relationalen Modell? Kreuzen Sie die korrekten Antworten an!", "explanation": "Eine zentrale Eigenschaft der RA ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen (Projektion, Vereinigung, Durchschnitt und Division), diese Duplikate automatisch eliminiert werden. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA. \n \nEine zweite zentrale Eigenschaft des relationalen Modells ist die Reihenfolgeunabh\u00e4ngigkeit. Sie bedeutet, dass das Ergebnis der\ndeklarativ formulierten Anweisungen (RA: Anfrageausdr\u00fccke / SQL: SELECT, INSERT, UPDATE, DELETE), immer gleich sein muss, unabh\u00e4ngig davon, in welcher Reihenfolge die Tupel gelesen oder verarbeitet wurden. \n,   \nDie Wertebereiche Mi hei\u00dfen Dom\u00e4nen. Dom\u00e4nen sind atomar, d.h. keine zusammengesetzten Datentypen. Bei der Definition von Dom\u00e4nen muss angegeben werden, ob NULL-Werte, also einzelne Attribute ohne Werteintrag, zugelassen sind.\n \nDie zusammengesetzten Datentypen sind nicht Bestandteil des relationalen Modells. Sie werden erst mit den objektrelationalen Erweiterungen eingef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "F\u00fcr die Attribute sind NULL-Werte erlaubt.", "solution": "true"}, {"text": "Eine Relation hat keine doppelten Tupel, d.h. Zeilen mit komplett den gleichen Werten werden unterdr\u00fcckt.", "solution": "true"}, {"text": "Die Tupelreihenfolge ist fest definiert.", "solution": "false"}, {"text": "Neben atomaren Attributen sind auch selbstdefinierte zusammengesetzte Datentypen zugelassen.", "solution": "false"}]}, {"id": 769, "category": 8, "difficulty": 2, "text": "Bei der Projektion werden identische Tupel automatisch eliminiert.", "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen, diese Duplikate automatisch eliminiert werden. Zu diesen Operatoren geh\u00f6ren Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 784, "category": 8, "difficulty": 2, "text": "Wie hei\u00dft ein Theta-Join, bei dem nur der Gleichheitsoperator als Vergleichsoperator zugelassen ist?", "explanation": "Ein Equi-Join ist ein Theta-Join, der im Selektionspr\u00e4dikat nur den Vergleichsoperator \"=\"\nzul\u00e4sst.\nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "text", "answers": [{"text": "Das ist ein", "solution": "Equi-Join"}]}, {"id": 786, "category": 8, "difficulty": 2, "text": "Mit welchem Operator der relationalen Algebra wird der F\u00fcr-Alle-Quantor (die Allaussage) umgesetzt?", "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.", "type": "text", "answers": [{"text": "Der Operator hei\u00dft", "solution": "Division"}]}, {"id": 773, "category": 8, "difficulty": 1, "text": "Ein Outer-Join ist immer verlustfrei.", "explanation": "Eine Join-Operation zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.", "type": "multiple-choice", "answers": [{"text": "Stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 789, "category": 7, "difficulty": 3, "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass jede Relation einen Prim\u00e4rschl\u00fcssel besitzt.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt.", "type": "text", "answers": [{"text": "Diese Eigenschaft hei\u00dft", "solution": "Entity-Integrit\u00e4t"}]}, {"id": 826, "category": 9, "difficulty": 1, "text": "Welches Pr\u00e4dikat in einer SELECT-WHERE-Bedingung mit Unterabfrage wird als wahr erkannt, wenn die Unterabfrage mindestens einen Datensatz selektiert?", "explanation": "Das EXISTS-Pr\u00e4dikat liefert TRUE, wenn die Ergebnismenge der Unterabfrage wenigstens einen Datensatz enth\u00e4lt. \nDas IN-Pr\u00e4dikat liefert TRUE, wenn der Wert des linken Operators in der Ergebnismenge des rechten Operators der Unteranfrage enthalten ist.", "type": "multiple-choice", "answers": [{"text": "EXISTS", "solution": "true"}, {"text": "solche ein Pr\u00e4dikat gibt es nicht", "solution": "false"}, {"text": "IN", "solution": "false"}]}, {"id": 888, "category": 10, "difficulty": 1, "text": "Der DEFAULT-Typ eines Datenbanktriggers ist", "explanation": "Ein Befehlstrigger  (STATEMENT TRIGGER, befehlsorientiert, default) wird genau einmal vor oder nach der Ausf\u00fchrung des feuernden Ereignisses ausgef\u00fchrt, auch dann, wenn kein Datensatz von der feuernden Anweisung manipuliert wird.  \nEin Zeilentrigger (ROW TRIGGER, zeilenorientiert) wird dagegen f\u00fcr jeden von der feuernden Datenmanipulation betroffenen Datensatz je einmal ausgef\u00fchrt. Wird kein Datensatz\nvon der Anweisung ge\u00e4ndert, dann wird auch kein Zeilentrigger ausgef\u00fchrt. Nur bei den Zeilentriggern sind die Transitionsvariablen zugreifbar, die Transitionstabellen hingegen sind es bei beiden Triggertypen.", "type": "multiple-choice", "answers": [{"text": "befehlsorientiert", "solution": "true"}, {"text": "zeilenorientiert", "solution": "false"}]}, {"id": 758, "category": 9, "difficulty": 1, "text": "Mit welcher Komponente kann man in einer SELECT-Anweisung Spalten absteigend sortieren?", "explanation": "Mit der ORDER BY-Klausel kann auf- (ASC) oder absteigend (DESC) sortiert werden. Die GROUP BY-Klausel sortiert als \"Nebenergebnis\" der Gruppierung die Gruppen auch, aber nur aufsteigend. \nMit den WHERE- und HAVING-Klauseln k\u00f6nnen einzelne Datens\u00e4tze bzw. Gruppen selektiert werden, aber nicht sortiert. \nDie FROM-Klausel verkn\u00fcpft die angegebenen Tabellen mittels kartesischem Produkt bzw. Join, sortiert aber nicht.", "type": "multiple-choice", "answers": [{"text": "ORDER BY", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}, {"text": "GROUP BY", "solution": "false"}]}, {"id": 884, "category": 9, "difficulty": 1, "text": "Womit wird in PL/SQL ein Vektor fester L\u00e4nge definiert?", "explanation": "VARRAY und TABLE geh\u00f6ren zu den Kollektionstypen, wobei varray definiert ist \u00fcber:  \n\n<CREATE TYPE Anweisung VARRAY> ::=\nCREATE OR REPLACE TYPE Typname AS VARRAY () OF ;  \n \nIm Unterschied zum TABLE-Kollektionstypen hat VARRAY eine fest definierte L\u00e4nge.", "type": "multiple-choice", "answers": [{"text": "TYPE ... is TABLE OF ...", "solution": "false"}, {"text": "TYPE ... is VARRAY OF ...", "solution": "true"}, {"text": "TYPE ... is RECORD OF ...", "solution": "false"}]}, {"id": 903, "category": 10, "difficulty": 2, "text": "Welche der ECMA-Bestandteile eines Datenbanktriggers sind unverzichtbar?", "explanation": "Jeder Trigger muss mindestens auf einen Event reagieren (E) und eine Action-Teil (A) haben, alle anderen Bestandteile sind optional.", "type": "multiple-choice", "answers": [{"text": "E", "solution": "true"}, {"text": "C", "solution": "false"}, {"text": "M", "solution": "false"}, {"text": "A", "solution": "true"}]}, {"id": 906, "category": 11, "difficulty": 1, "text": "Bei welchem Pr\u00fcfungszeitpunkt (= CONSTRAINT_CHARACTERISTICA ) wird die Datenpr\u00fcfung zum Transaktionsende durchgef\u00fchrt?", "explanation": "Werden Daten\u00e4nderungen ausgef\u00fchrt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integrit\u00e4tsbedingung gepr\u00fcft.  \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung r\u00fcckg\u00e4ngig gemacht. Die \u00fcbrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl l\u00f6st das Transaktionsende aus und damit die Pr\u00fcfung aller CONSTRAINTs (Integrit\u00e4tsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden.  \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden w\u00e4hrend f\u00fcr eine Transaktion erst mal akzeptiert und erst zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs gepr\u00fcft und die Fehler erkannt.  \nWenn ein DEFERRED-Fehler auftritt, f\u00fchrt dies zur Anzeige einer Fehlermeldung und zum Zur\u00fcckrollen der gesamten Transaktion.", "type": "multiple-choice", "answers": [{"text": "INITIALLY IMMEDIATE", "solution": "false"}, {"text": "INITIALLY DEFERRED", "solution": "true"}]}, {"id": 890, "category": 10, "difficulty": 1, "text": "Triggerereignisse k\u00f6nnen sich beziehen auf", "explanation": "Bei SQL sind drei Ereignisse zugelassen, und zwar die Manipulationsanweisungen INSERT, UPDATE, DELETE. Ein Trigger kann nur zu einem einzigen Ereignis bzw, f\u00fcr eine einzigen Tabelle programmiert werden. Die Ereignisse gelten nur f\u00fcr die in der ON Klausel mit \"Tabellenname\" spezifizierten Tabelle. Das UPDATE-Ereignis l\u00e4sst sich f\u00fcr die \u00c4nderung ganz bestimmter Spalten weiter eingrenzen, wobei die Spalten nat\u00fcrlich Spalten der Tabelle aus der ON-Klausel sein m\u00fcssen.", "type": "multiple-choice", "answers": [{"text": "mehrere Tabellen", "solution": "false"}, {"text": "genau eine Tabelle", "solution": "true"}]}, {"id": 894, "category": 10, "difficulty": 1, "text": "Bei einem INSERT-Ereignis eines Datenbanktriggers sind belegt", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": "Die Transitionsvariable :NEW", "solution": "true"}, {"text": "Die Transitionsvariable :OLD", "solution": "false"}]}, {"id": 892, "category": 10, "difficulty": 3, "text": "Ein PL/SQL-DML-Datenbanktrigger hat drei Ausf\u00fchrungszeitpunkte. Bitte in alphabetischer Reihenfolge angeben:", "explanation": "Der Ausf\u00fchrungszeitpunkt (AFTER oder BEFORE) legt fest, ob ein DML-Trigger vor oder nach dem feuernden (aktivierenden) Ereignis ausgef\u00fchrt werden soll. Je nach Aufgabenstellung kann der BEFORE- oder der AFTER-Zeitpunkt sinnvoll oder gar notwendig sein. Sind Folgeverarbeitungen durchzuf\u00fchren, so bieten sich AFTER TRIGGER an, da bei deren Ausf\u00fchrung die Integrit\u00e4tsbedingungen bereits\ngepr\u00fcft wurden. Sollen die Werte des neuen Datensatzes ge\u00e4ndert oder erg\u00e4nzt werden, so bietet es sich hingegen an, in den BEFORE TRIGGER die NEW-Variablen mit entsprechenden Werten zu belegen.\n\nDie INSTEAD OF-DML-Trigger werden anstelle des feuernden Befehls (INSERT, UPDATE, DELETE) ausgef\u00fchrt. Diese werden vor allem angewendet, wenn DML-Operationen auf nicht \u00e4nderbaren Sichten ausgef\u00fchrt werden sollen. Dann \u00fcbernimmt der Entwickler im INSTEAD OF-Trigger die Aufgabe, die Manipulation der Sichtdaten in die zugeh\u00f6rigen Manipulationen von zugrundeliegenden Tabellendaten zu transformieren.", "type": "text", "answers": [{"text": "Das sind", "solution": "AFTER"}, {"text": "und", "solution": "BEFORE"}, {"text": "und", "solution": "INSTEAD OF"}]}, {"id": 893, "category": 10, "difficulty": 1, "text": "Bei einem UPDATE -Ereignis eines Datenbanktriggers sind belegt", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": "die Transitionsvariable :OLD", "solution": "true"}, {"text": "die Transitionsvariable :NEW", "solution": "true"}]}, {"id": 895, "category": 10, "difficulty": 1, "text": "Bei einem DELETE-Ereignis eines Datenbanktriggers sind belegt", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": "die Transitionsvariable :NEW", "solution": "false"}, {"text": "die Transitionsvariable :OLD", "solution": "true"}]}, {"id": 896, "category": 10, "difficulty": 3, "text": "Transitionstabellen geh\u00f6ren zum Funktionsumfang von", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": "ORACLE-PL/SQL", "solution": "false"}, {"text": "SQL 1999", "solution": "true"}, {"text": "IBM-DB2", "solution": "true"}]}, {"id": 897, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Ausdruck werden in einer Gruppenfunktion ( z.B. COUNT)  auch Werte, die mehrfach vorkommen, ber\u00fccksichtigt?", "explanation": "Bei \"ALL\"  werden alle Werte ber\u00fccksichtigt, bei \"DISTINCT\" nur unterschiedliche Werte.", "type": "text", "answers": [{"text": "Der SQL-Ausdruck, der vor der Gruppenfunktion steht, hei\u00dft:", "solution": "ALL"}]}, {"id": 898, "category": 7, "difficulty": 1, "text": "Eine Relation, deren Prim\u00e4rschl\u00fcssel nur aus einem Attribut besteht, ist immer in der dritten Normalform.", "explanation": "Der Sachverhalt aus der Fragestellung hat nichts mit der 3. NF zu tun.\n\nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist. \nMit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist. \nAlso X ->Y \u2192Z, aber nicht Y \u2192X.  \n\nDamit eine Relation \u00fcberhaupt die 3. NF verletzen kann, muss sie \u00fcber wenigstens 3 Attribute verf\u00fcgen, von denen ein Attribut zum Prim\u00e4rschl\u00fcssel geh\u00f6rt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 899, "category": 7, "difficulty": 1, "text": "Eine Relation, deren Prim\u00e4rschl\u00fcssel nur aus einem Attribut besteht, ist immer in der ersten Normalform.", "explanation": "Wenn das Atrribut nicht atomar ist, ist die 1. NF trotzdem verletzt. \nEine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 900, "category": 7, "difficulty": 3, "text": "In einer Menge von Relationen besitzt jede Relation einen Prim\u00e4rschl\u00fcssel.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt.", "type": "text", "answers": [{"text": "Das ist die ...", "solution": "Entity-Integrit\u00e4t"}]}, {"id": 901, "category": 9, "difficulty": 2, "text": "Unter PL/SQL (ab ORACLE 9) gibt es einen REF-Datentypen", "explanation": "REF ist kein eigener PL/SQL-Datentyp, sondern wird in PL/SQL in Cursor-Variablen benutzt bzw. in den objektrelationalen Erweiterungen von Oracle/SQL.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 908, "category": 11, "difficulty": 3, "text": "Welche Phasen hat das 2-Phasen-Sperrprotokoll?", "explanation": "Die zentrale Anforderung, damit das Zwei-Phasen-Sperr-Protokoll die Serialisierbarkeit gew\u00e4hrleisten kann, lautet, dass bei Transaktionen alle Sperroperationen vor der ersten Entsperroperation ausgef\u00fchrt werden. Somit entstehen bei der Ausf\u00fchrung der Transaktion zwei Phasen: \n\n\neine Anforderungsphase oder Wachstumsphase, in der alle Schreiblesesperren (read_lock, write_lock) gesetzt werden, und \n\neine Schrumpfungsphase, in der alle Objekte wieder freigegeben werden (unlock).  \nAus diesen zwei Phasen ergibt sich der Name des Protokolls.", "type": "text", "answers": [{"text": "Das sind die", "solution": "Wachstumsphase"}, {"text": "und die", "solution": "Schrumpfungsphase"}]}, {"id": 989, "category": 9, "difficulty": 1, "text": "Normalisierung im Sinne der ersten, zweiten und dritten Normalform wird auch in der objektorientierten Analyse angewendet.", "explanation": "Normalformen spielen in der objektorientierten Analyse keine Rolle, da die Modellierung sich danach richtet, wie Objekte als Abbild der Realit\u00e4t modelliert werden sollen. Logisch zusammenh\u00e4ngende Attribute verbleiben dann in der gleichen Klasse.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1006, "category": 9, "difficulty": 1, "text": "F\u00fcr den Zugriff auf einzelne ausgew\u00e4hlte Spalten des benutzerdefinierten Datentyps muss in der FROM-Klausel ein Tabellenalias als eine Art Instanzvariable vergeben werden.", "explanation": "Ohne Tabellenalias ist hier kein Zugriff m\u00f6glich.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 992, "category": 9, "difficulty": 1, "text": "In objektorientierten Datenbanken gibt es", "explanation": "Wertidentit\u00e4t bedeutet, dass Objekte \u00fcber einen Wert in einem Prim\u00e4rschl\u00fcssel identifiziert werden. Dies ist in einem relationalen Datenbanksystem der Fall.", "type": "multiple-choice", "answers": [{"text": "Wertindentit\u00e4t", "solution": "false"}, {"text": "Objektidentit\u00e4t", "solution": "true"}]}, {"id": 994, "category": 9, "difficulty": 1, "text": "F\u00fcr jeden bei Oracle definierten instantiierbaren benutzerdefinierten Typ wird automatisch ein Konstruktor definiert.", "explanation": "Der Konstruktor hei\u00dft wie der Typ und wird automatisch angelegt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1007, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft eine Methode unter ORACLE-SQL, die als Attribut referenziert wird? Der typische Aufruf erfolgt im sogennanten \"selfish\" Stil: \"object_expression.method()\".", "explanation": "Das ist die Definition einer Oracle-Member-Methode. Der zweite Methodentyp sind STATIC-Methoden, die einer Klasse zugeordnet sind.", "type": "text", "answers": [{"text": "Das ist eine", "solution": "Member Method"}]}, {"id": 1701, "category": 9, "difficulty": 2, "text": "Mit dem RENAME-Befehl kann man unter ORACLE-SQL", "explanation": "Die RENAME-Anweisung \u00e4ndert den Namen einer Tabelle.  \n<RENAME Anweisung> ::= RENAME Alter Tabellenname TO Neuer Tabellenname;", "type": "multiple-choice", "answers": [{"text": "keins von beiden", "solution": "false"}, {"text": "eine Tabelle umbenennen", "solution": "true"}, {"text": "eine Spalte umbenennen", "solution": "false"}]}, {"id": 1705, "category": 9, "difficulty": 2, "text": "Betrachten Sie die Tabelle Test(NR1 number, NR2 number), wobei nur ein Tupel existiert. NR1 hat den Wert 1, NR2 hat einen NULL-Wert, also keinen Eintrag.\n\nWelches Ergebnis hat die folgende SQL-Abfrage?\n\nSELECT NR1 + NR2 FROM Test;", "explanation": "Die Summe aus einer Zahl und einem NULL-Wert ist unter SQL wieder NULL.", "type": "multiple-choice", "answers": [{"text": "1", "solution": "false"}, {"text": "2", "solution": "false"}, {"text": "NULL", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1703, "category": 9, "difficulty": 2, "text": "Welche \u00c4nderungen kann man mit ALTER TABLE auf den Spalten einer Tabelle durchf\u00fchren, wenn die Spalten leer sind (NULL)?", "explanation": "Weil die Spalten leer sind, ist vieles m\u00f6glich. All diese Dinge sind bei Spalten mit Daten nicht durchf\u00fchrbar, weil sie u.U. zu Konfikten mit den gespeicherten Daten f\u00fchren k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "die Nachkomma-Stellen einer NUMBER-Spalte erh\u00f6hen", "solution": "true"}, {"text": "den Datentyp der Spalte \u00e4ndern", "solution": "true"}, {"text": "die Breite einer Text-Spalte im CHARACTER-oder VARCHAR-Format reduzieren", "solution": "true"}, {"text": "Anzahl-Ziffern in einer NUMBER-Spalte reduzieren", "solution": "true"}, {"text": "Text-Spalten im CHARACTER-oder VARCHAR-Format vergr\u00f6\u00dfern", "solution": "true"}, {"text": "Anzahl-Ziffern in einer NUMBER-Spalte erh\u00f6hen", "solution": "true"}]}, {"id": 1704, "category": 10, "difficulty": 1, "text": "Betrachten Sie einen zeilenorientierten Trigger auf der Tabelle \nText (nr1 number, nr2  number) der Gestalt:\n\nCREATE OR REPLACE TRIGGER test_update\nAFTER UPDATE ON text\nFOR EACH ROW\nBEGIN       \n   ......END;\n\nWelche Aussagen \u00fcber diesen Trigger unter ORACLE-PL/SQL sind wahr?", "explanation": "Es werden alle Transitionsvariablen gef\u00fcllt, wenn der Trigger als Row-Trigger definiert ist.", "type": "multiple-choice", "answers": [{"text": "die Transaktionsvariabale :NEW.nr2 ist auch gef\u00fcllt, wenn sich nur die Spalte nr1 mittels UPDATE \u00e4ndert", "solution": "true"}, {"text": "die Transaktionsvariabale :NEW.nr2 ist nicht gef\u00fcllt, wenn sich nur die Spalte nr1 mittels UPDATE \u00e4ndert", "solution": "false"}]}, {"id": 1709, "category": 9, "difficulty": 2, "text": "Es sei folgende Kunden-Tabelle gegeben:\n            Kunden( Kunden_id, Name, Handy ) \nMit welchem/n Befehl/en kann ein Prim\u00e4rschl\u00fcssel f\u00fcr die Kunden_Id sowie ein zusammengesetzter, eindeutiger Zweitschl\u00fcssel f\u00fcr die Tabelle \"Kunden\" \u00fcber die beiden Attribute \"Name\" und \"Handy\" definiert werden?", "explanation": "Eine Tabelle kann nur einen Primary Key haben und CONSTRAINT-Namen sind eindeutig.", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE Kunden  \n(Kunden_Id    NUMBER(9) PRIMARY KEY,     \n Name              VARCHAR2(50),    \n Handy        NUMBER(11), \nCONSTRAINT Kunden_uk  UNIQUE (Name, Handy));", "solution": "true"}, {"text": "CREATE TABLE Kunden  \n(Kunden_I NUMBER(9) PRIMARY KEY,     \nName VARCHAR2(50)  CONSTRAINT Kunden_uk  UNIQUE, \nHandy      NUMBER(11) CONSTRAINT Kunden_uk  UNIQUE);", "solution": "false"}, {"text": "CREATE TABLE Kunden  \n(Kunden_Id NUMBER(9) PRIMARY KEY,     \n Name  VARCHAR2(50), \n Handy NUMBER(11), \n CONSTRAINT Kunden_pk2  PRIMARY KEY (Name, Handy));", "solution": "false"}, {"text": "CREATE TABLE Kunden  \n(Kunden_Id NUMBER(9) PRIMARY KEY,     \nName  VARCHAR2(50) CONSTRAINT Kunden_pk2 PRIMARY KEY), \nHandy  NUMBER(11)CONSTRAINT Kunden_pk2 PRIMARY KEY));", "solution": "false"}]}, {"id": 1707, "category": 9, "difficulty": 2, "text": "Mit welcher ORACLE -Funktion kann man einen NULL-Wert durch einen beliebigen anderen Wert in einer SELECT-Abfrage ersetzen?", "explanation": "Z.B: \nNVL(spalte1, 7)  \nliefert den Wert von spalte1 zur\u00fcck, wenn dieser ungleich NULL ist, also wenn spalte1 gef\u00fcllt ist. Ist spalte1 leer/NULL, dann liefert NVL den Wert 7 zur\u00fcck. Das funktioniert mit Spalten/Ausdr\u00fccken beliebigen Datentyps.", "type": "text", "answers": [{"text": "Die Funktion hei\u00dft (ohne Klammern)", "solution": "NVL"}]}, {"id": 1708, "category": 9, "difficulty": 2, "text": "FOREIGN-KEY-Constraints k\u00f6nnen unter ORACLE-SQL mit einer ON UPDATE CASCADE-Option versehen werden.", "explanation": "Nein, das ist leider nur beim SQL-Standard vorgesehen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1710, "category": 9, "difficulty": 3, "text": "Wie k\u00f6nnen Sie reagieren, wenn Sie beim L\u00f6schen eines Datensatzes (DELETE-Befehl) die Fehlermeldung bekommen, dass noch abh\u00e4ngige Datens\u00e4tze existieren?", "explanation": "Daten in Tabellen mit Primary-Key k\u00f6nnen nur gel\u00f6scht werden, wenn der Primary Key nicht mehr als Foreign-Key in einer anderen Tabelle verwendet wird.", "type": "multiple-choice", "answers": [{"text": "Zuerst den Master-Datensatz l\u00f6schen und dann die Detail-Datens\u00e4tze.", "solution": "false"}, {"text": "Zuerst die Detail-Datens\u00e4tze l\u00f6schen und dann den Master-Datensatz.", "solution": "true"}, {"text": "Zuerst die Werte der Fremdschl\u00fcsselspalten der betroffenen Detail-Datens\u00e4tze mittels eines UPDATE-Befehls auf die Schl\u00fcsselwerte eines noch existierenden Master-Datensatzes \u00e4ndern.", "solution": "true"}, {"text": "Wenn f\u00fcr die Fremdschl\u00fcsselspalten der betroffenen Detail-Datens\u00e4tze NULL-Constraints definiert sind, dann k\u00f6nnen, die bestehenden Werte aus den Fremdschl\u00fcsselspalten gel\u00f6scht werden.", "solution": "true"}]}, {"id": 1711, "category": 9, "difficulty": 1, "text": "Welcher SQL-Ausdruck zum Einf\u00fcgen eines Datensatzes mit einem Sequenz-Wert ist korrekt ?", "explanation": "Der n\u00e4chste Wert einer Sequenz wird mit <sequence_name>.NEXTVAL abgerufen.", "type": "multiple-choice", "answers": [{"text": "INSERT INTO Kunden (Kun_Nr, Nachname)\nVALUES (Kun_seq.NEXTVAL, 'Vogt');", "solution": "true"}, {"text": "INSERT INTO Kunden (Kun_Nr, Nachname)\nVALUES (Kun_seq.NEXTVALUE, 'Vogt');", "solution": "false"}]}, {"id": 1712, "category": 9, "difficulty": 2, "text": "Welche der folgenden Aussagen ist korrekt?", "explanation": "Die PL/SQL-Einheit steht in der Hierarchie \u00fcber den Bl\u00f6cken, d.h., kann aus mehreren untergeordneten Bl\u00f6cken bestehen.", "type": "multiple-choice", "answers": [{"text": "Ein PL/SQL-Block besteht aus mehreren PL/SQL-Einheiten.", "solution": "false"}, {"text": "Eine PL/SQL-Einheit besteht aus mehreren PL/SQL-Bl\u00f6cken.", "solution": "true"}, {"text": "keine der Antworten ist korrekt.", "solution": "false"}]}, {"id": 1779, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft die Operation der relationalen Algebra, die in SQL nicht direkt, sondern mit einer doppelten Verneinung und EXISTS abbildbar ist (doppeltes NOT EXISTS)?", "explanation": "Die Anfrage: \"Zeige die Kunden an, die ALLE Artikel gekauft haben\", wird in der relationalen Algebra mittels Division gel\u00f6st. \nDiese Anfrage kann man doppelt negiert umformulieren: \n\"Zeige die Kunden, f\u00fcr die gilt, das es KEINE Artikel gibt, die sie NICHT gekauft haben\". \nWenn es KEINE Artikel gibt, die sie NICHT gekauft haben, dann haben die Kunden doch ALLE Artikel gekauft. Ergo, die Allaussage kann in SQL mittels \"doppeltem NOT EXISTS\" programmiert werden. \nOder mit einem SELECT COUNT(..). \nBeispiele finden Sie im <a href =\"http:://edb.g,.fh-koeln.de\" edb-SQL-Trainer", "type": "text", "answers": [{"text": "Die Operation hei\u00dft", "solution": "Division"}]}, {"id": 1780, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren der relationalen Algebra l\u00e4sst sich der Vereinigungsoperator (UNION) simulieren?", "explanation": "Die Vereinigung (UNION) geh\u00f6rt zu den Grund-/Basisoperatoren, die sich nicht ableiten lassen, wie auch Selektion, Projektion, Kartesisches Produkt und Differenz.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Mit keinen anderen Operator der relationalen Algebra.", "solution": "true"}]}, {"id": 1781, "category": 8, "difficulty": 3, "text": "Welche der nachfolgenden Regeln sind Heuristiken der logischen Optimierung?", "explanation": "Heuristiken der logischen Optimierung: \n1. Konjunktionen in Selektionen werden gem\u00e4\u00df Regel 4 in einzelne Selektionen aufgebrochen.\n2. Selektionen werden im Operatorbaum so weit wie m\u00f6glich nach unten verschoben, um sie m\u00f6glichst fr\u00fchzeitig auszuf\u00fchren (Anwendung von Regel 6).\n3. Selektionen und kartesische Produkte werden zu Join-Operationen zusammengefasst (Regel 8).\n4. Die Reihenfolge der Join-Operationen wird so festgelegt, dass m\u00f6glichst kleine Zwischenergebnisse entstehen.\n5. Die Projektionen werden m\u00f6glichst weit nach unten im Operatorbaum verschoben. Dazu kann das Einf\u00fcgen weiterer Projektionen notwendig sein (Regel 7). \n6. Bei Mengenoperationen werden immer zuerst die kleinsten Relationen ber\u00fccksichtigt.", "type": "multiple-choice", "answers": [{"text": "Projektionen werden im Operatorbaum so weit wie m\u00f6glich nach unten verschoben.", "solution": "true"}, {"text": "Mengenoperationen werden immer zuerst auf kleinen Relationen angewendet.", "solution": "true"}, {"text": "Konjunktionen in Selektionsbedingungen werden in einzelne Selektionen aufgebrochen und im Operatorbaum so weit wie m\u00f6glich nach unten verschoben.", "solution": "true"}, {"text": "Die Bedingungen einzelner Selektionen werden nach M\u00f6glichkeit zusammengefasst in Konjunktionen dieser Selektionsbedingungen.", "solution": "false"}, {"text": "Selektionen werden im Operatorbaum so weit wie m\u00f6glich nach oben verschoben, um sie m\u00f6glichst sp\u00e4t ausf\u00fchren zu k\u00f6nnen.", "solution": "false"}]}, {"id": 1782, "category": 9, "difficulty": 3, "text": "Ein Spalten-Constraint (COLUMN CONSTRAINT) kann folgende Klauseln haben:", "explanation": "FALSCH ist: \nDie FOREIGN KEY-Klausel gibt es nur bei den Tabellen-Constraints, als Spalten-Constraint hei\u00dft diese Funktion REFERENCES. \n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "NULL", "solution": "true"}, {"text": "CHECK", "solution": "true"}, {"text": "UNIQUE", "solution": "true"}, {"text": "PRIMARY KEY", "solution": "true"}, {"text": "FOREIGN KEY", "solution": "false"}, {"text": "REFERENCES", "solution": "true"}]}, {"id": 1783, "category": 9, "difficulty": 3, "text": "Mit welchem Befehl vergibt man f\u00fcr jeden in der Datenbank angelegten Benutzer alle Rechte (z.B. Lesen, Schreiben, L\u00f6schen und \u00c4ndern) auf der Tabelle XYZ?", "explanation": "RICHTIG ist:\nGRANT ALL ON XYZ TO PUBLIC; \n\n<GRANT Anweisung> ::= \nGRANT  [ ON { Tabellenname | Sichtname } ] TO ;\n ::= { PUBLIC | Benutzername }\n ::= \n{ ALL | SELECT | DELETE | INSERT \n  | UPDATE [Spaltenname [, Spaltenname ]...] }", "type": "text", "answers": [{"text": "Der Befehl (ohne Semikolon) lautet :", "solution": "GRANT ALL ON XYZ TO PUBLIC"}]}, {"id": 1784, "category": 9, "difficulty": 2, "text": "In einer SQL-Anweisung an eine Tabelle \"Auto\" sollen alle Opel Corsa ausgegeben werden und alle VW Polo, wobei die letzteren weniger als 6000 Euro kosten sollen. Welche SELECT-Anweisung befriedigt diese Anfrage?", "explanation": "Die Abfrage \nSELECT Modell, Preis\nFROM Auto\nWHERE (Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO')\nAND Preis < 6000 \n\nist von der SQL-Syntax her richtig, gibt aber nur die Opel Corsa-Fahrzeuge mit einem Preis kleiner als 6000 \u0080 aus.", "type": "multiple-choice", "answers": [{"text": "SELECT Modell, Preis\nFROM Auto\nWHERE Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO'\nAND Preis < 6000", "solution": "true"}, {"text": "SELECT Modell, Preis\nFROM Auto\nWHERE (Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO')\nAND Preis < 6000", "solution": "false"}, {"text": "SELECT Modell, Preis\nFROM Auto\nWHERE Modell = 'OPEL CORSA'\nOR (Modell = 'VW POLO'\nAND Preis < 6000)", "solution": "true"}]}, {"id": 1785, "category": 42, "difficulty": 2, "text": "Betrachten Sie einen B-Baum vom Typ k mit der H\u00f6he h. Wie viele Lesezugriffe sind maximal notwendig, um einen Datensatz zu finden?", "explanation": "Nach h Zugriffen ist man bei einem Blatt des B-Baums.", "type": "text", "answers": [{"text": "Die Anzahl ist", "solution": "h"}]}, {"id": 1786, "category": 9, "difficulty": 2, "text": "Welche Datentypen werden unter ORACLE ab Version 8 f\u00fcr gro\u00dfe Dokumenten im nationalen Zeichensatz verwendet?", "explanation": "BLOB: Mit diesem Datentyp k\u00f6nnen entsprechend dem SQL-Standard bin\u00e4re Objekte (Oracle bis zu 4 Gbyte) f\u00fcr Grafiken oder Tonaufzeichnungen in der Datenbank gespeichert werden. Au\u00dferdem stehen einige Methoden zur Verf\u00fcgung, mit denen diese Objekte auf dem Server manipuliert werden k\u00f6nnen.\n\nCLOB und NCLOB:  Oracle CLOB ist eine Modifikation des Typs BLOB, er wird f\u00fcr gro\u00dfe Textobjekte mit den entsprechenden Methoden zur Verf\u00fcgung gestellt. NCLOB entspricht dem CLOB mit nationalem Zeichensatz. \n\nBFILE:ist ein Oracle-Datentyp f\u00fcr Bin\u00e4robjekte, der nur einen Zeiger (LOB-Locator) auf ein Verzeichnis im Dateisystem enth\u00e4lt, das die Bin\u00e4rdateien beihaltet.", "type": "multiple-choice", "answers": [{"text": "BLOB", "solution": "false"}, {"text": "LOB", "solution": "false"}, {"text": "CLOB", "solution": "false"}, {"text": "NCLOB", "solution": "true"}]}, {"id": 1270, "category": 8, "difficulty": 2, "text": "Relationale Operatoren sind immer Abbildungen, die aus einer Relation eine Ergebnis-Relation erzeugen.", "explanation": "Neben den un\u00e4ren (Selektion, Projektion) gibt es aber auch noch die bin\u00e4ren Operatoren (kartesisches Produkt, Joins, Mengenoperatoren, Division). \nDurch Anwendung einer dieser Operationen entsteht aus einer oder zwei Relationen wieder eine neue Relation. \nF1 : Rn -> Rm mit n , m \u2208 N \nF2 : Rn \u00d7 Rm -> Rk mit n , m , k \u2208 N", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1341, "category": 9, "difficulty": 2, "text": "Treiber von welchem Typ sind immer appletf\u00e4hig?", "explanation": "Treiber vom Typ 1: \n\nJDBC-ODBC-Bridge Bei diesem Treibertyp greift der JDBC-Treiber \u00fcber die ODBC-Schnittstelle auf die Datenbank zu. Nat\u00fcrlich muss dazu auf jedem Client ein ODBC-Treiber installiert sein. Dieser Treibertyp bietet sich daher haupts\u00e4chlich in lokalen Netzwerken an, bei denen auf dem einzelnen Client leicht ODBC installiert werden kann. Au\u00dferdem ist durch den Zwischenschritt ODBC der Zugriff verh\u00e4ltnism\u00e4\u00dfig langsam.\n\n\nTreiber vom Typ 2: \nNative-API partly-Java-Treiber Bei diesem Ansatz werden die JDBC-Aufrufe in ein datenbankspezifisches API auf dem Client weitergeben. Daher sind auch bei diesem Typ zus\u00e4tzliche Installationen auf dem Client notwendig.\n\nTreiber vom Typ 3: \nJDBC-Net pure Java-Treiber Treiber vom Typ 3 \u00fcbersetzen die JDBC-Aufrufe in ein vom DBMS unabh\u00e4ngiges Netzprotokoll und benutzen einen Anwendungsserver. Der Server \u00fcbersetzt die Aufrufe in das jeweilige DBMS-Protokoll und \u00fcber die CLI-Schnittstelle wird auf die Datenbank zugegriffen. Bei Treibern vom Typ 3 ist keine zus\u00e4tzliche Client-Installation notwendig, aber ein Anwendungsserver.\n\n\nTreiber vom Typ 4:\nNative-Protocol pure Java-Treiber Bei diesem Treibertyp werden die JDBC-Aufrufe in ein datenbankeigenes Protokoll \u00fcbersetzt, welches \u00fcber das Netzwerk direkt auf den Datenbankserver zugreift. Es ist auch keine zus\u00e4tzliche Client- Installation notwendig.  \n\n\nTreiber von Typ 3 und 4 sind appletf\u00e4hig, die anderen beiden Typen nicht, da sie nicht komplett in Java geschrieben sind.", "type": "multiple-choice", "answers": [{"text": "Typ 1", "solution": "false"}, {"text": "Typ 2", "solution": "false"}, {"text": "Typ 3", "solution": "true"}, {"text": "Typ 4", "solution": "true"}]}, {"id": 1351, "category": 8, "difficulty": 2, "text": "Bei welcher Operation der relationalen Algebra wird die Anzahl der Attribute nicht ver\u00e4ndert?", "explanation": "Eine n-stellige Relation wird mittels der Selektion auf eine n-stellige Relation abgebildet, denn damit werden nur die Tupel einer Relation ausgew\u00e4hlt und alle Attribute beibehalten. \nDie Projektion schr\u00e4nkt die Attribute der Ergebnisrelation auf eine Teilmenge der urspr\u00fcnglichen Attribute ein. \nDie Attributsstruktur der Ergebnismenge des Natural Joins besteht aus der Summe der Attribute beider Relationen abz\u00fcglich der Attribute, die mehrfach in den beiden Relationen auftreten.", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Selektion", "solution": "true"}]}, {"id": 1343, "category": 9, "difficulty": 2, "text": "Welcher JDBC-Treibertyp ist auf einer Middlewarekomponente aufgebaut?", "explanation": "Treiber vom Typ 1: \n\nJDBC-ODBC-Bridge Bei diesem Treibertyp greift der JDBC-Treiber \u00fcber die ODBC-Schnittstelle auf die Datenbank zu. Nat\u00fcrlich muss dazu auf jedem Client ein ODBC-Treiber installiert sein. Dieser Treibertyp bietet sich daher haupts\u00e4chlich in lokalen Netzwerken an, bei denen auf dem einzelnen Client leicht ODBC installiert werden kann. Au\u00dferdem ist durch den Zwischenschritt ODBC der Zugriff verh\u00e4ltnism\u00e4\u00dfig langsam.\n\n\nTreiber vom Typ 2: \nNative-API partly-Java-Treiber Bei diesem Ansatz werden die JDBC-Aufrufe in ein datenbankspezifisches API auf dem Client weitergeben. Daher sind auch bei diesem Typ zus\u00e4tzliche Installationen auf dem Client notwendig.\n\nTreiber vom Typ 3: \nJDBC-Net pure Java-Treiber Treiber vom Typ 3 \u00fcbersetzen die JDBC-Aufrufe in ein vom DBMS unabh\u00e4ngiges Netzprotokoll und benutzen einen Anwendungsserver. Der Server \u00fcbersetzt die Aufrufe in das jeweilige DBMS-Protokoll und \u00fcber die CLI-Schnittstelle wird auf die Datenbank zugegriffen. Bei Treibern vom Typ 3 ist keine zus\u00e4tzliche Client-Installation notwendig, aber ein Anwendungsserver.\n\n\nTreiber vom Typ 4:\nNative-Protocol pure Java-Treiber Bei diesem Treibertyp werden die JDBC-Aufrufe in ein datenbankeigenes Protokoll \u00fcbersetzt, welches \u00fcber das Netzwerk direkt auf den Datenbankserver zugreift. Es ist auch keine zus\u00e4tzliche Client- Installation notwendig.  \n\n\nTreiber von Typ 3 und 4 sind appletf\u00e4hig, die anderen beiden Typen nicht, da sie nicht komplett in Java geschrieben sind.", "type": "multiple-choice", "answers": [{"text": "Typ 1", "solution": "false"}, {"text": "Typ 2", "solution": "false"}, {"text": "Typ 3", "solution": "true"}, {"text": "Typ 4", "solution": "false"}]}, {"id": 1344, "category": 9, "difficulty": 1, "text": "Mit welchem Platzhalter werden unter JDBC einem PreparedStatement-Objekt Werte \u00fcbergeben?", "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface. CallableStatement  und PreparedStatement  k\u00f6nnen Parameter mit dem Platzhalter \"?\" aufnehmen.", "type": "text", "answers": [{"text": "Das ist", "solution": "?"}]}, {"id": 1345, "category": 9, "difficulty": 1, "text": "Welche Parametertypen gibt es unter JDBC und einem PreparedStatement- Objekt ?", "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface. CallableStatement  und PreparedStatement  k\u00f6nnen Parameter mit dem Platzhalter \"?\" aufnehmen. Man unterscheidet bei\nden Parametern folgende Typen:\n\n\nIN-Parameter: nehmen Werte auf, die weiterverarbeitet werden\nOUT-Parameter: enthalten R\u00fcckgabewerte; Beim Arbeiten mit OUT-Parametern bitte beachten, dass sie explizit mit  registriert werden m\u00fcssen, damit der Datentyp des OUT-Parameters im Programm bekannt ist.   \nIN OUT-Parameter: nehmen \u00dcbergabeparameter auf, deren Wert ver\u00e4ndert und an das aufrufende Programm zur\u00fcckgegeben werden kann", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "OUT", "solution": "true"}, {"text": "IN OUT", "solution": "true"}, {"text": "OUT IN", "solution": "false"}]}, {"id": 1346, "category": 9, "difficulty": 2, "text": "Welcher JDBC-Treibertyp verwendet ODBC?", "explanation": "Treiber vom Typ 1: \n\nJDBC-ODBC-Bridge Bei diesem Treibertyp greift der JDBC-Treiber \u00fcber die ODBC-Schnittstelle auf die Datenbank zu. Nat\u00fcrlich muss dazu auf jedem Client ein ODBC-Treiber installiert sein. Dieser Treibertyp bietet sich daher haupts\u00e4chlich in lokalen Netzwerken an, bei denen auf dem einzelnen Client leicht ODBC installiert werden kann. Au\u00dferdem ist durch den Zwischenschritt ODBC der Zugriff verh\u00e4ltnism\u00e4\u00dfig langsam.\n\n\nTreiber vom Typ 2: \nNative-API partly-Java-Treiber Bei diesem Ansatz werden die JDBC-Aufrufe in ein datenbankspezifisches API auf dem Client weitergeben. Daher sind auch bei diesem Typ zus\u00e4tzliche Installationen auf dem Client notwendig.\n\nTreiber vom Typ 3: \nJDBC-Net pure Java-Treiber Treiber vom Typ 3 \u00fcbersetzen die JDBC-Aufrufe in ein vom DBMS unabh\u00e4ngiges Netzprotokoll und benutzen einen Anwendungsserver. Der Server \u00fcbersetzt die Aufrufe in das jeweilige DBMS-Protokoll und \u00fcber die CLI-Schnittstelle wird auf die Datenbank zugegriffen. Bei Treibern vom Typ 3 ist keine zus\u00e4tzliche Client-Installation notwendig, aber ein Anwendungsserver.\n\n\nTreiber vom Typ 4:\nNative-Protocol pure Java-Treiber Bei diesem Treibertyp werden die JDBC-Aufrufe in ein datenbankeigenes Protokoll \u00fcbersetzt, welches \u00fcber das Netzwerk direkt auf den Datenbankserver zugreift. Es ist auch keine zus\u00e4tzliche Client- Installation notwendig.  \n\n\nTreiber von Typ 3 und 4 sind appletf\u00e4hig, die anderen beiden Typen nicht, da sie nicht komplett in Java geschrieben sind.", "type": "multiple-choice", "answers": [{"text": "Typ 2", "solution": "false"}, {"text": "Typ 3", "solution": "false"}, {"text": "Typ 4", "solution": "false"}, {"text": "Typ 1", "solution": "true"}]}, {"id": 2116, "category": 9, "difficulty": 2, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat der Durchschnitt der Tabelle Test mit sich selber?", "explanation": "Der Durchschnitt einer Tabelle mit sich selber ist die Ursprungstabelle selber.", "type": "text", "answers": [{"text": "", "solution": "3"}]}, {"id": 2117, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat der Durchschnitt der Tabelle Test mit sich selber?", "explanation": "Der Durchschnitt einer Tabelle mit sich selber ist die Ursprungstabelle selber.", "type": "text", "answers": [{"text": "", "solution": "5"}]}, {"id": 2118, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat die Differenz der Tabelle Test mit sich selber?", "explanation": "x-x = 0 :-), das gilt sogar f\u00fcr Relationen.", "type": "text", "answers": [{"text": "", "solution": "0"}]}, {"id": 2119, "category": 9, "difficulty": 2, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat die Vereinigungsmenge der Tabelle Test mit sich selber?", "explanation": "Die Vereinigungsmenge der Tabelle Test mit sich selber ist wieder die Tabelle Test.", "type": "text", "answers": [{"text": "", "solution": "5"}]}, {"id": 2120, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat die Projektion der Tabelle Test auf die Spalten Spalte_1, Spalte_2, wenn Spalte 2 der Prim\u00e4rschl\u00fcssel ist?", "explanation": "Prim\u00e4rschl\u00fcssel sind eindeutig.", "type": "text", "answers": [{"text": "", "solution": "5"}]}, {"id": 2121, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat die Projektion der Tabelle Test auf die Spalten Spalte_2, Spalte_3?", "explanation": "2 = 2.", "type": "text", "answers": [{"text": "", "solution": "2"}]}, {"id": 2122, "category": 9, "difficulty": 3, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind, die sich alle im Wert f\u00fcr Spalte_3 unterscheiden.\n\nWie viele Spalten hat die Selektion der Tabelle Test auf einen Wert der Spalte_3?\nBitte numerischen Wert azfschrieben!", "explanation": "Da in der Selektion keine Spalten ausgeschlossen werden, bleibt es bei urspr\u00fcnglichen Spalten Spalte_1, Spalte_2, Spalte_3, also 3.", "type": "text", "answers": [{"text": "", "solution": "3"}]}, {"id": 2123, "category": 9, "difficulty": 3, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind, die sich alle im Wert f\u00fcr Spalte_3 unterscheiden.\n\nWie viele Tupel hat die Selektion der Tabelle Test auf einen Wert der Spalte_3?\nBitte  numerischen Wert aufschreiben!", "explanation": "1 = 1 :-).", "type": "text", "answers": [{"text": "", "solution": "1"}]}, {"id": 1381, "category": 9, "difficulty": 1, "text": "Mit welcher SELECT-Komponente kann man die Reihenfolge der Ergebnisdatens\u00e4tze einer SELECT-Abfrage festlegen?", "explanation": "Neben ORDER BY sortiert auch GROUP By in der Reihenfolge der angegebenen Spalten.", "type": "multiple-choice", "answers": [{"text": "ORDER BY", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}, {"text": "GROUP BY", "solution": "false"}]}, {"id": 1386, "category": 11, "difficulty": 2, "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Szenarium verletzt?\n\nEine Transaktion A \u00e4ndert zwei S\u00e4tze S1 und S2. Beim Systemabsturz wird die Aktion S2 zur\u00fcckgerollt, w\u00e4hrend S1 weiterhin in ge\u00e4nderter Form vorliegt.", "explanation": "Es ist die \"Atomarit\u00e4t\" verletzt. \nDie Atomarit\u00e4t besagt, dass entweder alle Manipulationen einer Transaktion persistent in der DB gespeichert werden - oder gar nicht. Hier wird nur eine Teilmenge der Aktionen in der DB ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "Atomarit\u00e4t", "solution": "true"}, {"text": "Isolation", "solution": "false"}, {"text": "Konsistenz", "solution": "false"}, {"text": "Dauerhaftigkeit", "solution": "false"}]}, {"id": 1391, "category": 9, "difficulty": 1, "text": "Welcher CONSTRAINT-Typ kann sich auch auf mehrere Spalten beziehen?", "explanation": "Je nach Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung)\ndifferenziert. Die Spaltenbedingungen werden direkt bei der Spaltendefinition des CREATE TABLE-Befehls programmiert und k\u00f6nnen sich nur auf eine, die gerade definierte Spalte beziehen. Tabellenbedingungen werden auch beim CREATE TALBE-Befehl definiert, sind aber nicht Teil einer Spaltenspezifikation und k\u00f6nnen sich somit auf mehrere Spalten beziehen.", "type": "multiple-choice", "answers": [{"text": "ein COLUMN-CONSTRAINT", "solution": "false"}, {"text": "ein TABLE-CONSTRAINT", "solution": "true"}, {"text": "keiner von beiden", "solution": "false"}]}, {"id": 1441, "category": 9, "difficulty": 3, "text": "Mit welchem SQL-Befehl l\u00f6scht man die Daten einer Tabelle, ohne die Tabellendefinition zu l\u00f6schen?", "explanation": "Der DROP-Befehl l\u00f6scht auch die Tabellendefinitionen.", "type": "multiple-choice", "answers": [{"text": "DROP table...", "solution": "false"}, {"text": "DELETE FROM table ...", "solution": "true"}, {"text": "CANCEL table ..", "solution": "false"}, {"text": "truncate table ...", "solution": "true"}]}, {"id": 1431, "category": 42, "difficulty": 3, "text": "Welche Speicherstruktur eignet sich in erster Linie f\u00fcr gro\u00dfe Datenbest\u00e4nde, die sich wenig \u00e4ndern?", "explanation": "Die ISAM- und die  HASH-Speichersruktur sind f\u00fcr statische Daten die sich selten \u00e4ndern, sehr gut geeignet, da keine \u00dcberlaufseiten entstehen, die den Lesezugriff verlangsamen k\u00f6nnten.", "type": "multiple-choice", "answers": [{"text": "B+ Baum", "solution": "false"}, {"text": "HASH", "solution": "true"}, {"text": "HEAP", "solution": "false"}, {"text": "ISAM", "solution": "true"}]}, {"id": 1432, "category": 9, "difficulty": 1, "text": "Der CREATE SEQUENCE-Befehl geh\u00f6rt zum SQL:2003-Standard.", "explanation": "CREATE SEQUENCE geh\u00f6rt schon l\u00e4nger :-)  zum Standard.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "true"}, {"text": "nein", "solution": "false"}]}, {"id": 1433, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank:\n\nSpieler (Spieler_id, Name, Adresse, Geburtsdatum)\nVereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr)\nSpiele (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\nSpieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\nWelche der angegeben SQL-Abfragen beantwortet/en die Frage: \nWelche Spieler (Name, Adresse) haben noch nie in einem Spiel mit mehr als 30000 Zuschauern mitgespielt?", "explanation": "SELECT name, adresse FROM spieler se \nWHERE NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                  WHERE anzahl_zuschauer > 30000); \nist semantisch falsch: Der Unteranfrage fehlt die Korrelation zur oberen Anfragen (unkorrelierter EXISTS). So liefert die obere Anfrage immer die leere Menge als Ergebnis, sobald es wenigstens ein Spiel mit mehr als 3000 Zuschauern gibt, also wenn der untere SELECT wenigstens einen Datensatz liefert. \n\nSELECT name, adresse FROM spieler se \nWHERE  NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                   WHERE   anzahl_zuschauer > 30000) \nAND    se.spieler_id = sp.spieler_id;\nist semantisch und syntaktisch falsch: Die schlie\u00dfende Klammer steht falsch. Richtig w\u00e4re die Anfrage, wenn die AND-Bedingung zur Unteranfrage geh\u00f6ren w\u00fcrde. Aber so, geh\u00f6rt sie zur oberen Anfrage und damit ist das Ganze nicht ausf\u00fchrbar, denn z.B. der Tabellenalias se ist im oberen SELECT nicht bekannt, nur im unteren. \n\nSELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nHAVING COUNT(s.spieler_id ) = 0; \nist semantisch falsch: Mit dem Natural Join werden nur die Spiele mit mehr als 3000 Zuschauern ermittelt. Anschlie\u00dfend wird mit der HAVING-Bedingung versucht, die Spieler zu ermitteln, die kein solches Spiel haben. Ergebnis: aufgrund dieses Widerspruchs immer die leere Menge.  \n\nSELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nAND    COUNT(s.spieler_id ) IS NULL;   \nist syntaktisch falsch: Aggregatfunktionen k\u00f6nnen nicht in der WHERE-Klausel verwendet werden, nur in der SELECT-, GROUP BY, HAVING-Klausel.\n \n\n\nrichtig isz :\nSELECT name, adresse FROM spieler \nWHERE spieler_id NOT IN \n   (SELECT spieler_id \n    FROM   spieleinsatz, spiele \n    WHERE  anzahl_zuschauer > 30000\n    AND    spiele.spiel_id = spieleinsatz.spiel_id );", "type": "multiple-choice", "answers": [{"text": "SELECT name, adresse FROM spieler se \nWHERE NOT EXISTS (SELECT spieler_id \n                  FROM   spieleinsatz se \n                  WHERE  anzahl_zuschauer > 30000);", "solution": "false"}, {"text": "SELECT name, adresse FROM spieler \nWHERE spieler_id NOT IN \n   (SELECT spieler_id \n    FROM   spieleinsatz, spiele \n    WHERE  anzahl_zuschauer > 30000\n    AND    spiele.spiel_id = spieleinsatz.spiel_id );", "solution": "true"}, {"text": "SELECT name, adresse FROM spieler se \nWHERE  NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                   WHERE   anzahl_zuschauer > 30000) \nAND    se.spieler_id = sp.spieler_id;", "solution": "false"}, {"text": "SELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nHAVING COUNT(s.spieler_id ) = 0;", "solution": "false"}, {"text": "SELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nAND    COUNT(s.spieler_id ) IS NULL;", "solution": "false"}]}, {"id": 1443, "category": 9, "difficulty": 2, "text": "Welcher der folgenden SQL-Ausdr\u00fccke ist korrekt?", "explanation": "In der SELECT-Klausel d\u00fcrfen nur zwei Arten von Spalten vorkommen:\n\ndie, die mit einer Gruppenfunktion versehen sind (hier Gehalt) \ndie anderen Spalten m\u00fcssen in der GROUP-BY-Klausel enthalten sein.", "type": "multiple-choice", "answers": [{"text": "keine von allen", "solution": "false"}, {"text": "SELECT\n    Abt_Nr,\n    AVG(Gehalt)\nFROM     Angestellte\nGROUP BY Abt_Nr;", "solution": "true"}, {"text": "SELECT\n    Abt_Nr,\n    Nachname,\n    AVG(Gehalt)\nFROM     Angestellte\nGROUP BY Abt_Nr;", "solution": "false"}]}, {"id": 1445, "category": 9, "difficulty": 3, "text": "Mit welchem Interface kann man in JDBC auf Metadaten des Datenbanksystems zugreifen?", "explanation": "Die Informationen \u00fcber die Datenbank, welche Benutzer es gibt, welche Tabellen angelegt sind, die Datenbankversion etc., sind in relationalen Datenbanksystemen in der Datenbank selbst gespeichert. Diese Informationen k\u00f6nnen \u00fcber die Klasse DatabaseMetaData aus der Datenbank abgerufen werden. Insgesamt enth\u00e4lt diese Klasse seit JDBC 2.0 ca. 150 verschiedene Methoden, um Informationen abzurufen. Instanziert wird ein Objekt der Klasse DatabaseMetaData \u00fcber die Methode getMetaData der connection-Schnittstelle.", "type": "text", "answers": [{"text": "Die Klasse hei\u00dft", "solution": "DataBaseMetaData"}]}, {"id": 1299, "category": 11, "difficulty": 2, "text": "Wie viele Sperrzust\u00e4nde kennt das 2-Phasen-Sperrprotokoll?", "explanation": "Nur die beiden Zust\u00e4nde LOCK und UNLOCK sind sehr \"grob\" und lassen wenig parallelen Zugriff zu, da nicht zwischen \"schreiben\" und \"lesen\" differenziert wird. \nDaher wird mit drei Sperrzust\u00e4nden gearbeitet: \nUNLOCK - entsperrt\nWRITELOCK - exklusiv sperren f\u00fcr einen Schreibzugriff\nREADLOCK - sperren f\u00fcr parallele Lesezugriffe", "type": "multiple-choice", "answers": [{"text": "einen Zustand", "solution": "false"}, {"text": "zwei Zust\u00e4nde", "solution": "false"}, {"text": "drei Zust\u00e4nde", "solution": "true"}]}, {"id": 1144, "category": 9, "difficulty": 2, "text": "PL/SQL-Packages k\u00f6nnen enthalten", "explanation": "Pakete (PACKAGES) sind Oracle-Datenbankobjekte, mit denen logisch in Verbindung stehende Programmkonstrukte, wie\n\nProzeduren,\nFunktionen,\nCURSOR,\nVariablen und Konstanten sowie\nEXCEPTIONS \n\n\nzu einer Einheit zusammengefasst werden.", "type": "multiple-choice", "answers": [{"text": "Prozeduren", "solution": "true"}, {"text": "Funktionen", "solution": "true"}, {"text": "CURSOR", "solution": "true"}, {"text": "EXCEPTIONS", "solution": "true"}, {"text": "Variable", "solution": "true"}, {"text": "Konstanten", "solution": "true"}]}, {"id": 1145, "category": 9, "difficulty": 3, "text": "Wie laden Sie in JDBC eine Klasse des Datenbanktreibers ohne eine Instanz zu erzeugen?", "explanation": "Der JDBC-Treiber entstammt einer Klassenbibliothek, die die Verbindung mit dem aktuellen Datenbankserver herstellt. Um die Klasse zu laden und beim DriverManager zu registrieren, wird die Methode Class.forName verwendet. Damit kann man eine Klasse laden, ohne eine Instanz zu erzeugen, und eine Klasse referenzieren, deren Name noch nicht bekannt ist.", "type": "text", "answers": [{"text": "Die Methode (mit Angabe der Klasse) hei\u00dft", "solution": "Class.forName"}]}, {"id": 1301, "category": 11, "difficulty": 3, "text": "Welche Aussagen \u00fcber \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?", "explanation": "FALSCH ist:  \n\"Non repeatable read\" und \"phantome\" sind zwei eng verwandte Probleme. Bei beiden geht es darum, dass die eine Anwendung die gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausf\u00fchrt und dann ggf. auf unterschiedlichen Datenbankzust\u00e4nden ausf\u00fchrt, weil eine andere Transaktion Datens\u00e4tze eingef\u00fcgt oder ge\u00e4ndert hat.\"  \nDie Aussage ist richtig bis auf den Teil: \"...gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausf\u00fchrt...\" Ganz:-) richtig wird die Aussage, wenn man das \"zwei verschiedene Transaktionen\" durch \"eine Transaktion\" ersetzt.\n  \n\nRICHTIG sind die anderen beiden Aussagen.", "type": "multiple-choice", "answers": [{"text": "\"Non repeatable read\" und \"phantome\" sind zwei eng verwandte Probleme. Bei beiden geht es darum, dass die eine Anwendung die gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausf\u00fchrt und dann ggf. auf unterschiedlichen Datenbankzust\u00e4nden ausf\u00fchrt, weil eine andere Transaktion Datens\u00e4tze eingef\u00fcgt oder ge\u00e4ndert hat.", "solution": "false"}, {"text": "\"Dirty reads\" treten auf, wenn eine z.B. Transaktion T1 Datens\u00e4tze liest und verarbeitet, die eine andere Transaktion T2 zwar ge\u00e4ndert aber nicht \"committet\" hat und T2 sp\u00e4ter mit einem Rollback abgeschlossen wird.", "solution": "true"}, {"text": "Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und \u00fcberschreibt somit die \u00c4nderungen von T2 ungesehen.", "solution": "true"}]}, {"id": 1311, "category": 11, "difficulty": 3, "text": "Welche Aussagen \u00fcber \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?", "explanation": "RICHTIG sind: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"XLOCK\" gesperrt hat, kann keine andere Transaktion irgendeinen anderen LOCK absetzen auf diesen Datensatz bzw. diese Tabelle.\"\n\n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion ebenfalls SLOCKs absetzen und lesen auf das gesperrte Objekt zugreifen.\"\n\nFALSCH ist: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, kann keine andere Transaktion irgendeinen anderen LOCK absetzen auf diesen Datensatz bzw. diese Tabelle.\"", "type": "multiple-choice", "answers": [{"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"XLOCK\" gesperrt hat, kann keine andere Transaktion irgendeinen anderen LOCK absetzen auf diesen Datensatz bzw. diese Tabelle.", "solution": "true"}, {"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, kann keine andere Transaktion irgendeinen anderen LOCK absetzen auf diesen Datensatz bzw. diese Tabelle.", "solution": "false"}, {"text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, k\u00f6nnen  andere Transaktion ebenfalls SLOCKs absetzen und lesen auf das gesperrte Objekt zugreifen.", "solution": "true"}]}, {"id": 1310, "category": 11, "difficulty": 3, "text": "Welche Aussagen \u00fcber \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?", "explanation": "Beide Aussagen sind richtig:   \nBeim 2-Phasen-Sperrprotokoll werden eine Wachstumsphase, in der alle erforderlichen Sperren angefordert werden, und eine Schrumpfungsphase, in der alle gesperrten Datens\u00e4tze wieder freigegeben werden, unterschieden.   \nDamit beim 2-Phasen-Sperrprotokoll die Datens\u00e4tze nicht unn\u00f6tig lange gesperrt bleiben, werden drei Sperrzust\u00e4nde unterschieden: read_lock, write_lock, unlock.", "type": "multiple-choice", "answers": [{"text": "Beim 2-Phasen-Sperrprotokoll werden eine Wachstumsphase, in der alle erforderlichen Sperren angefordert werden, und eine Schrumpfungsphase, in der alle gesperrten Datens\u00e4tze wieder freigegeben werden, unterschieden.", "solution": "true"}, {"text": "Damit beim 2-Phasen-Sperrprotokoll die Datens\u00e4tze nicht unn\u00f6tig lange gesperrt bleiben, werden drei Sperrzust\u00e4nde unterschieden: read_lock, write_lock, unlock.", "solution": "true"}]}, {"id": 1150, "category": 42, "difficulty": 1, "text": "Bei welcher Speicherstruktur enthalten die Bl\u00e4tter ausschlie\u00dflich Nutzdaten?", "explanation": "Beim B-Baum werden die Nutzdaten gemeinsam mit dem Index gespeichert, beim B+-Baum getrennt von den Nutzdaten.", "type": "multiple-choice", "answers": [{"text": "B+ Baum", "solution": "true"}, {"text": "B-Baum", "solution": "false"}]}, {"id": 1159, "category": 9, "difficulty": 2, "text": "Welches Java-Paket realisiert unter SQLJ den Zugriff auf eine relationale Datenbank?", "type": "text", "answers": [{"text": "Das ist", "solution": "sqlj.runtime"}]}, {"id": 1160, "category": 9, "difficulty": 2, "text": "SQLJ-Code muss durch einen Translator vor\u00fcbersetzt werden", "explanation": "Der SQLJ-Translator \u00fcberpr\u00fcft schon zur Compilezeit, ob die SQL-Syntax korrekt ist,\ndie Datentypen \u00fcbereinstimmen und die Tabellendefinitionen der Schemadefinition\nentsprechen. Der Translator wird \u00fcber die Kommandozeilenprozedur \u00bfsqlj\u00bf aufgerufen\nund auf eine Datei mit der Endung *.sqlj , z.B. test.sqlj, angewandt. Ergebnis ist\neine *.java-Datei mit JDBC-Aufrufen. Diese Datei, z.B. test.java, wird wie jede andere\nJava-Datei mit dem Java-Compiler (z.B. javac test.java) in eine Class-Datei \u00fcbersetzt,\ndie mittels der Laufzeitumgebung \u00bfjava\u00bf gestartet werden kann.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1162, "category": 9, "difficulty": 1, "text": "Eine SQLJ-Klausel benutzt immer den voreingestellten Default-Kontext, um eine Verbindung zur Datenbank herzustellen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1163, "category": 9, "difficulty": 2, "text": "Bei welchem Kontext-Typ unter SQLJ k\u00f6nnen auch Verbindungen zu unterschiedlichen Datenbanken aufgebaut werden?", "type": "multiple-choice", "answers": [{"text": "Impliziter Kontext", "solution": "false"}, {"text": "Expliziter Kontext", "solution": "true"}, {"text": "Solch einen Kontext-Typ gibt es nicht", "solution": "false"}]}, {"id": 1165, "category": 9, "difficulty": 3, "text": "Wo werden unter ORACLE SQLJ die jar-Archive von Java-Klassen abgelegt?", "type": "multiple-choice", "answers": [{"text": "In einem Betriebssystemverzeichnis, das bei der Installation der Datenbank festgelegt wird", "solution": "false"}, {"text": "Als BFile-Datentyp in einer speziellen Tabelle", "solution": "false"}, {"text": "Als BLOB-Datentyp in einer speziellen Tabelle", "solution": "true"}]}, {"id": 1306, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber virtuelle SQL-Sichten sind richtig?", "explanation": "Mit dem SQL-Befehl \"CREATE VIEW  ...\" werden virtuelle Sichten erstellt. \nVirtuelle Sichten k\u00f6nnen sowohl auf der Basis von Tabellen als auch aufgrund von anderen Sichten definiert werden, so k\u00f6nnen Sicht-Hierarchien aufgebaut werden. \nAktualit\u00e4tsprobleme (veraltete Daten in der Sicht gegen\u00fcber neuen Daten in den Tabellen oder auch umgekehrt) gibt es nur bei den materialisierten Sichten, weil dort die Daten in Tabellen und Sichten redundant gespeichert sind. Bei virtuellen Sichten wird der Datenbestand bei jeder Anfrage auf den Tabellen ausgewertet und ist damit absolut aktuell, auch wenn es (etwas) l\u00e4nger dauert. \nDas Problem des \"View Updating\", was die automatische Weiterleitung/Transformation der \u00c4nderung von Sichtdaten auf die gespeicherten Tabellen-Daten meint, ist auch noch ein in der Wissenschaft ungel\u00f6stes Problem. F\u00fcr einige F\u00e4lle kann man die Daten automatisch transformieren (einige wenige davon sich auch bei Oracle implementiert), um viele andere F\u00e4lle wird semantisches Hintergrundwissen bei der Transformation ben\u00f6tigt, \u00fcber das nur der Entwickler verf\u00fcgt.", "type": "multiple-choice", "answers": [{"text": "Mit dem SQL-Befehl \"CREATE VIEW <viewname> ...\" werden virtuelle Sichten erstellt.", "solution": "true"}, {"text": "Virtuelle Sichten k\u00f6nnen nur auf der Basis von Tabellen und nicht aufgrund von anderen Sichten definiert werden.", "solution": "false"}, {"text": "Virtuelle Sichten k\u00f6nnen auch auf der Basis von anderen Sichten definiert werden.", "solution": "true"}, {"text": "Da die auf virtuellen Sichten ausgef\u00fchrten \u00c4nderungsoperationen (INSERT, UPDATE, DELETE) ja sowieso auf den zugrunde liegenden Tabellen ausgef\u00fchrt werden, k\u00f6nnen die \u00c4nderungsoperationen auf Sichten mit beliebig komplizierten Definitionen ohne jede Einschr\u00e4nkung ausgef\u00fchrt werden.", "solution": "false"}, {"text": "Bei virtuellen Sichten treten Aktualit\u00e4tsprobleme bei \u00c4nderungen der zugrunde liegenden Daten in den Tabellen auf.", "solution": "false"}]}, {"id": 1307, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber materialisierte SQL-Sichten sind richtig?", "explanation": "Mit dem SQL-Befehl \"CREATE MATERIALIZED VIEW  ...\" werden virtuelle Sichten erstellt. \nMaterialisierte Sichten k\u00f6nnen sowohl auf der Basis von Tabellen als auch aufgrund von anderen Sichten definiert werden, so k\u00f6nnen Sicht-Hierarchien aufgebaut werden. \nAktualit\u00e4tsprobleme (veraltete Daten in der Sicht gegen\u00fcber neuen Daten in den Tabellen oder auch umgekehrt) gibt es nur bei den materialisierten Sichten, weil dort die Daten aus den Tabellen und anderen Sichten beim Erstellen der matieralisierten Sicht einmal ermittelt und dann redundant gespeichert werden. Bei virtuellen Sichten wird der Datenbestand bei jeder Anfrage auf den Tabellen ausgewertet und ist damit absolut aktuell, auch wenn es (etwas) l\u00e4nger dauert.", "type": "multiple-choice", "answers": [{"text": "Mit dem SQL-Befehl \"CREATE MATERIALIZED VIEW <viewname>...\" werden materialisierte Sichten erstellt.", "solution": "true"}, {"text": "Materialisierte Sichten k\u00f6nnen nur auf der Basis von Tabellen und nicht aufgrund von anderen Sichten definiert werden.", "solution": "false"}, {"text": "Die Daten materialisierte Sichten werden bei jeder Anfrage an eine Sicht neu auf der Basis der zugrunde liegenden Tabellen abgeleitet.", "solution": "false"}, {"text": "Die Daten materialisierter Sichten werden nicht bei jeder Anfrage an eine Sicht vollst\u00e4ndig neu auf der Basis der Daten der zugrunde liegenden Tabellen abgeleitet, sondern einmal beim Erstellen der Sicht und liegen dann gespeichert in der Sicht selbst vor.", "solution": "true"}, {"text": "Bei materialisierten Sichten treten Aktualit\u00e4tsprobleme bei \u00c4nderungen der zugrunde liegenden Daten in den Tabellen auf.", "solution": "true"}]}, {"id": 1308, "category": 9, "difficulty": 1, "text": "Mit welcher Oracle-/SQL2003-Funktion k\u00f6nnen Sie eine Zeichenkette in ein Datum konvertieren?", "explanation": "Richtig ist der Befehl: TO_DATE ('15.06.2004', 'DD.MM.RRRR') \nDie Formatmaske gibt an, wie die Zeichenkette zu interpretieren ist. DD f\u00fcr den Tag, MM f\u00fcr den Monat, RRRR f\u00fcr ein 4-stelliges Jahr. Trennzeichen ist hier der Punkt \".\". Es k\u00f6nnen aber auch beliebige andere Trennzeichen verwendet werden. F\u00fcr andere Formatierungen gibt auch noch weitere Formatmasken.", "type": "multiple-choice", "answers": [{"text": "KONVERT_DATE ('15.06.2004', 'DD.MM.RRRR') ", "solution": "false"}, {"text": "TRANSFORM_DATE ('15.06.2004', 'DD.MM.RRRR') ", "solution": "false"}, {"text": "TO_DATE ('15.06.2004', 'DD.MM.RRRR') ", "solution": "true"}, {"text": "MAKE_DATE ('15.06.2004', 'DD.MM.RRRR') ", "solution": "false"}]}, {"id": 1309, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber CONSTRAINTS sind wahr?", "explanation": "Die drei richtigen Aussagen erkl\u00e4ren sich selbst. \nFALSCH ist: \nDie Sache mit dem \"MANDATORY-CONSTRAINT\". Ein Constraint dieses Namens gibt es nicht. Das Constraint mit der gew\u00fcnschten Funktion hei\u00dft: NOT NULL bei SQL.", "type": "multiple-choice", "answers": [{"text": "Die Standardreaktion auf einen Integrit\u00e4tsfehler beim \"integrity checking\" mittels Constraints ist das Zur\u00fcckrollen des fehlerhaften DML-Befehls (Pr\u00fcfungsmodus IMMEDIATE) bzw. der gesamten Transaktion beim Pr\u00fcfungsmodus DEFERRED. Nur das FOREIGN KEY-Constraint bietet mit der Action-Klausel eine M\u00f6glichkeit zur Fehlerkorrektur wie z.B. das kaskadierendes L\u00f6schen bei \"dangling tuples\".", "solution": "true"}, {"text": "Transitionale Integrit\u00e4tsbedingungen k\u00f6nnen in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Referenzvariablen (:OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.", "solution": "true"}, {"text": "Oracle-Trigger erweitern das Oracle-Integrit\u00e4tskonzept im Wesentlichen in 2 Punkten. \n- Die Bedingungen die mit Triggern abgepr\u00fcft werden k\u00f6nnen, sind wesentlich komplexer als mit CHECK-CONSTRAINTS (Zugriff auf andere Tabellen, transitionale Integrit\u00e4tsbedingungen).\n- Neben dem Zur\u00fcckrollen des fehlerausl\u00f6senden DML-Befehls, kann mittels der Triggeraktion der Fehler auch korrigiert werden.", "solution": "true"}, {"text": "F\u00fcr im ER-Modell als \"obligatorisch\" (Pflichteingabe) deklarierte Attribute werden im Datenmodell MANDATORY-CONSTRAINTS definiert.", "solution": "false"}]}, {"id": 1753, "category": 9, "difficulty": 1, "text": "Welche der beiden folgenden SELECT-Anweisungen ist korrekt, wenn Spalte_1 und Spalte_2 den gleichen Datentyp haben?", "explanation": "Eine ORDER-BY-Klausel kann in zwei SELECTs, die mit UNION verkn\u00fcpft werden, nicht verwendet werden.", "type": "multiple-choice", "answers": [{"text": "SELECT Spalte_1 FROM TEST1 ORDER BY Spalte_1\nUNION\nSELECT Spalte_2 FROM TEST2 ORDER BY Spalte_2", "solution": "false"}, {"text": "SELECT Spalte_1 FROM TEST1\nUNION\nSELECT Spalte_2 FROM TEST2", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 1754, "category": 9, "difficulty": 2, "text": "Welche CURSOR-Attribute sind korrekt?", "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR ge\u00f6ffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen", "type": "multiple-choice", "answers": [{"text": "%FOUND", "solution": "true"}, {"text": "%ROWTYPE", "solution": "false"}, {"text": "%ISSTARTED", "solution": "false"}, {"text": "%NOTFOUND", "solution": "true"}, {"text": "%ISROW", "solution": "false"}, {"text": "%ISOPEN", "solution": "true"}]}, {"id": 1755, "category": 9, "difficulty": 1, "text": "Packages bestehen aus verschiedenen Komponenten. Geben Sie an, welche Komponenten es gibt und ob sie f\u00fcr die private bzw. \u00f6ffentliche Deklaration von Package-Objekten zust\u00e4ndig sind!", "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder \u00f6ffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind \u00f6ffentlich und k\u00f6nnen damit von au\u00dferhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und k\u00f6nnen damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.", "type": "multiple-choice", "answers": [{"text": "Body", "solution": "true"}, {"text": "Header", "solution": "true"}, {"text": "Soul", "solution": "false"}, {"text": "Declare", "solution": "false"}, {"text": "Action", "solution": "false"}]}, {"id": 1756, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber PL/SQL-Programmierkonstrukte sind wahr?", "explanation": "Prozeduren k\u00f6nnen \u00fcber die Parametertypen IN OUT und OUT Werte an das aufrufende Programm zur\u00fcckgeben.", "type": "multiple-choice", "answers": [{"text": "Anonyme Bl\u00f6cke k\u00f6nnen beliebig geschachtelt werden.", "solution": "true"}, {"text": "F\u00fcr eine Funktion wird, anders als bei Prozeduren, der Datentyp eines R\u00fcckgabewertes definiert.", "solution": "true"}, {"text": "Eine Funktion muss immer mit einer RETURN-Anweisung beendet werden, die den R\u00fcckgabewert zur\u00fcck liefert", "solution": "true"}, {"text": "Bei Prozeduren gibt es keine M\u00f6glichkeit, Werte zur\u00fcckzugeben an die aufrufende Umgebung.", "solution": "false"}, {"text": "Selbstprogrammierte Funktionen k\u00f6nnen in einer SELECT-Anweisung aufgerufen werden.", "solution": "true"}, {"text": "In PL/SQL-Bl\u00f6cken ist immer die direkte Verwendung von SQL-DML- und -DDL-Anweisungen wie SELECT, INSERT, UPDATE, DELETE bzw. CREATE, DROP, ALTER erlaubt.", "solution": "false"}, {"text": "Transaktionen k\u00f6nnen innerhalb von PL/SQL-Bl\u00f6cken nicht mittels Befehlen wie COMMIT und ROLLBACK gesteuert werden.", "solution": "false"}]}, {"id": 1767, "category": 1, "difficulty": 1, "text": "In einer Datenbank sollen die Daten auch nach Beendigung aller Programme dauerhaft gespeichert werden. Diese Eigenschaft einer Datenbank nennt man:", "explanation": "Das ist die Definition der Datenbankpersistenz.", "type": "multiple-choice", "answers": [{"text": "Persistenz", "solution": "true"}, {"text": "Konsistenz", "solution": "false"}]}, {"id": 1758, "category": 10, "difficulty": 3, "text": "Welche Aussagen \u00fcber Trigger sind wahr?", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "multiple-choice", "answers": [{"text": "Das Mutating-Table-Problem tritt unter ORACLE-SQL auf, wenn ein ROW-Trigger bez\u00fcglich einer Tabelle X definiert ist und im Aktionsteil auf diese Tabelle X zugegriffen wird, sei es mit SELECT, INSERT, UPDATE, DELETE", "solution": "true"}, {"text": "In einem Trigger d\u00fcrfen neben SQL-DML-Befehlen (SELECT, INSERT, UPDATE, DELETE) auch die Anweisungen COMMIT und ROLLBACK zur Kontrolle der Transaktion verwendet werden.", "solution": "false"}, {"text": "Bricht ein Trigger fehlerhaft ab, so werden nur die Aktionen des Trigger-Aktionsteils r\u00fcckg\u00e4ngig gemacht. Das feuernde Ereignis wird ordentlich zu Ende ausgef\u00fchrt", "solution": "false"}, {"text": "Wird der Befehl DBMS_OUTPUT.PUT_LINE in einem Trigger ausgef\u00fchrt, so wird eine Fehlermeldung angezeigt und die Ausf\u00fchrung des Triggers unterbrochen.", "solution": "false"}, {"text": "Zul\u00e4ssige Ereignisse, die Trigger feuern k\u00f6nnen, sind bei Oracle u.a. alle SQL-DML-Befehle: SELECT, INSERT, UPDATE, DELETE.", "solution": "false"}, {"text": "Das Mutating-Table-Problem tritt bei den ROW-Triggern des SQL-Standards auf", "solution": "false"}]}, {"id": 1759, "category": 10, "difficulty": 2, "text": "Es wird eine UPDATE-Anweisung auf der Tabelle X ausgef\u00fchrt, von der 5 Datens\u00e4tze betroffen sind. F\u00fcr diese Tabelle X ist je ein BEFORE- und AFTER-UPDATE-STATEMENT-Trigger definiert. Wie oft werden diese Trigger jeweils ausgef\u00fchrt?", "explanation": "Die Statement-Trigger werden nach Definition nur einmal angesto\u00dfen.", "type": "text", "answers": [{"text": "BEFORE-UPDATE-STATEMENT-Trigger", "solution": "1"}, {"text": "AFTER-UPDATE-STATEMENT-Trigger", "solution": "1"}]}, {"id": 1760, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber LOBs bei Oracle sind wahr?", "explanation": "F\u00fcr strukturierte Datentypen verwendet man keine LOBS, sondern benutzerdefinierte Typen, die mit CREATE TYPE ... angelegt werden.\n\nEine SELECT-Anweisung an LOBS selektiert nur den LOB-Locator, nicht die eigentlichen LOB-Werte.\n\nLOBS k\u00f6nnen als BFILE auch im Dateisystem gespeichert werden.", "type": "multiple-choice", "answers": [{"text": "LOB-Datentypen werden zur Speicherung von umfangreichen, strukturierten Daten ben\u00f6tigt.", "solution": "false"}, {"text": "LOBs k\u00f6nnen nur in der Datenbank gespeichert werden. Eine Speicherung im Dateisystem ist nicht m\u00f6glich.", "solution": "false"}, {"text": "Die maximale Gr\u00f6\u00dfenbeschr\u00e4nkung f\u00fcr LOBs liegt bei 4 GB pro Datensatz.", "solution": "true"}, {"text": "Mittels der SELECT-Anweisung k\u00f6nnen die Inhalte von LOB-Daten ausgelesen und angezeigt werden.", "solution": "false"}, {"text": "LOBs, die in der Datenbank gespeichert werden, unterliegen dem Transaktionskonzept sowie dem Recovery.", "solution": "true"}]}, {"id": 1761, "category": 9, "difficulty": 2, "text": "Welche internen LOB-Arten gibt es bei Oracle?", "explanation": "BLOB: Mit diesem Datentyp k\u00f6nnen entsprechend dem SQL-Standard bin\u00e4re Objekte (Oracle bis zu 4 Gbyte) f\u00fcr Grafiken oder Tonaufzeichnungen in der Datenbank gespeichert werden. Au\u00dferdem stehen einige Methoden zur Verf\u00fcgung, mit denen diese Objekte auf dem Server manipuliert werden k\u00f6nnen.\n\nCLOB und NCLOB:  Oracle CLOB ist eine Modifikation des Typs BLOB, er wird f\u00fcr gro\u00dfe Textobjekte mit den entsprechenden Methoden zur Verf\u00fcgung gestellt. NCLOB entspricht dem CLOB mit nationalem Zeichensatz. \n\nBFILE:ist ein Oracle-Datentyp f\u00fcr Bin\u00e4robjekte, der nur einen Zeiger (LOB-Locator) auf ein Verzeichnis im Dateisystem enth\u00e4lt, das die Bin\u00e4rdateien beihaltet.", "type": "multiple-choice", "answers": [{"text": "ALOB", "solution": "false"}, {"text": "BLOB", "solution": "true"}, {"text": "CLOB", "solution": "true"}, {"text": "BFILE", "solution": "false"}, {"text": "NCLOB", "solution": "true"}, {"text": "VIDEOLOB", "solution": "false"}]}, {"id": 1772, "category": 9, "difficulty": 3, "text": "Welche der folgenden INSERT-Anweisungen in eine Tabelle test\n   \nCREATE TABLE test( Nr NUMBER(9), \nBezeichnung VARCHAR2(20), Wert NUMBER(9))  \n\nist korrekt? \n\nTabelle 2 soll die gleichen Spalten wie Tabelle test haben.", "explanation": "Bei einer INSERT-Anweisung m\u00fcssen die Werte in der Reihenfolge der Spaltenliste hinter dem Tabellennamen, oder wenn dieser fehlt, in der Reihenfolge der Spaltendefinition vorkommen.", "type": "multiple-choice", "answers": [{"text": "INSERT INTO TEST\nVALUES (1, 'Bier')", "solution": "false"}, {"text": "INSERT INTO TEST\nVALUES (1, 'Bier', 20)", "solution": "true"}, {"text": "INSERT INTO TEST (Nr, Bezeichnung, Wert)\nVALUES (1, 'Bier', 20)", "solution": "true"}, {"text": "INSERT INTO TEST (Nr, Wert, Bezeichnung)\nVALUES (1, 'Bier', '20')", "solution": "false"}, {"text": "INSERT INTO TEST SELECT Nr, Bezeichnung, Wert FROM Tabelle2", "solution": "true"}, {"text": "INSERT INTO TEST\n(1, 20, 'Bier')", "solution": "false"}]}, {"id": 1770, "category": 9, "difficulty": 2, "text": "Welche STRING-Funktionen gibt es unter ORACLE-SQL?", "explanation": "INSTR sucht eine gegebene Zeichenfolge in einem String und gibt dessen Position zur\u00fcck.\nSELECT INSTR(bemerkung, 'zahlungsfreudig') FROM kunden;\nGibt f\u00fcr jeden Kundendatensatz die Position der Wortes 'zahlungsfreudig' an.  \n\nSUBSTR schneidet aus einem Datenwert (1. Parameter) ab einer \u00fcbergebenen Position (2. Parameter) eine Zeichenkette bestimmter L\u00e4nge (3. Parameter) ab und gibt sie zur\u00fcck.\nSUBSTR(spalteA, 1, 7) liefert die ersten 7 Zeichen des Inhalts von spalteA zur\u00fcck.\nSUBSTR(spalteA, LENTGH(spalteA, 3) liefert die letzten 3 Zeichen des Inhalts von spalteA zur\u00fcck.", "type": "multiple-choice", "answers": [{"text": "SUBSTR", "solution": "true"}, {"text": "INSTR", "solution": "true"}, {"text": "keine von allen", "solution": "false"}, {"text": "LEFT", "solution": "false"}, {"text": "RIGHT", "solution": "false"}]}, {"id": 1170, "category": 42, "difficulty": 3, "text": "Welche Speicherstruktur beinhaltet einen d\u00fcnnen Index?", "explanation": "Bei der ISAM-Specherstruktur werden die Daten \u00fcber die Indexspalte(n) aufsteigend sortiert. Aus jedem Block wird der gr\u00f6\u00dfte Schl\u00fcsselwert als Repr\u00e4sentant vermerkt und in einer gesonderten Struktur, dem Index abgelegt. Der Index ordnet also jedem Block ein Intervall der m\u00f6glichen Schl\u00fcsselwerte zu. Der ISAM-Index ist daher ein d\u00fcnner Index mit logischen Adressen.", "type": "multiple-choice", "answers": [{"text": "gibt es nicht.", "solution": "false"}, {"text": "HEAP", "solution": "false"}, {"text": "ISAM", "solution": "true"}, {"text": "B+ -Baum", "solution": "true"}, {"text": "HASH", "solution": "false"}, {"text": "B-Baum", "solution": "false"}]}, {"id": 1171, "category": 42, "difficulty": 2, "text": "Bei welcher Speicherstruktur k\u00f6nnen \u00dcberlaufseiten entstehen?", "explanation": "Der B-Baum und der B+-Baum wurden entwickelt, um \u00dcberlaufseiten zu vermeiden.", "type": "multiple-choice", "answers": [{"text": "B+-Baum", "solution": "false"}, {"text": "HASH", "solution": "true"}, {"text": "HEAP", "solution": "false"}, {"text": "ISAM", "solution": "true"}, {"text": "B-Baum", "solution": "false"}]}, {"id": 1177, "category": 42, "difficulty": 2, "text": "Wie hei\u00dft ein Baum mit der Eigenschaft, dass der Weg von der Wurzel bis zu einem Blatt immer gleich lang ist?", "explanation": "Der B-Baum und der B+-Baum sind vollst\u00e4ndig balancierte B\u00e4ume, bei den der Weg von der Wurzel bis zu  Blatt immer gleich lang sind und der H\u00f6he H des Baums entsprechen.", "type": "text", "answers": [{"text": "Er hei\u00dft", "solution": "vollst\u00e4ndig balanciert"}]}, {"id": 1219, "category": 9, "difficulty": 3, "text": "Benutzerdefinierten Datentypen unter ORACLE verwenden Konstruktormethoden bei", "explanation": "Konstruktormethoden dienen zum Einf\u00fcgen und \u00c4ndern von Daten, nicht zum Selektieren bzw. Anlegen von Tabellen.", "type": "multiple-choice", "answers": [{"text": "DELETE", "solution": "false"}, {"text": "INSERT", "solution": "true"}, {"text": "UPDATE", "solution": "true"}, {"text": "SELECT", "solution": "false"}, {"text": "CREATE", "solution": "false"}]}, {"id": 1220, "category": 9, "difficulty": 3, "text": "Wie nennt man den folgenden Zugriff in einer Oracle-Objekttabelle?", "explanation": "Der Zugriff erfolgt im Multi-Column-Modus, falls die Objekttabelle als mehrspaltige Tabelle betrachtet wird, bei der jedes Attribut des benutzerdefinierten Datentyps die Anwendung relationaler Operationen erlaubt. \n\nDer Zugriff erfolgt im Single-Column-Modus, falls die Objekttabelle als einspaltige Tabelle betrachtet wird, in der jeder Datensatz ein Objekt darstellt, die die Anwendung von OO-Operationen erlaubt.", "type": "text", "answers": [{"text": "Die Objekttabelle wird als mehrspaltige Tabelle betrachtet, bei der jedes Attribut des benutzerdefinierten Datentyps die Anwendung relationaler Operationen erlaubt.\n\n(mit Bindestrich schreiben)", "solution": "Multi-Column"}]}, {"id": 1222, "category": 9, "difficulty": 1, "text": "In welchem Methoden-Typ ist unter ORACLE das Objekt selber mit SELF referenzierbar?", "explanation": "Eine MEMBER-Routine bezieht sich auf eine Instanz, das hei\u00dft eine Tabelle, die auf diesem Typ basiert. Eine STATIC-Routine bezieht\nsich auf den Typ selbst. Eine MEMBER-Methode wird aufgerufen \u00fcber Instanzname.method(), eine STATIC-Routine \u00fcber Typname.method(). In der MEMBER-Routine existiert immer ein implizites Argument SELF im Methoden-Body, das die Instanz repr\u00e4sentiert, f\u00fcr die die Methode aufgerufen wurde. SELF existiert bei STATIC-Routinen\nnat\u00fcrlich nicht.", "type": "multiple-choice", "answers": [{"text": "MEMBER-Typ", "solution": "true"}, {"text": "STATIC-Typ", "solution": "false"}]}, {"id": 1457, "category": 9, "difficulty": 1, "text": "Welche PL/SQL-Deklaration ist korrekt?", "explanation": "Das ist leider umgekehrt wir man das z.B. von JAVA gew\u00f6hnt ist :-(.", "type": "multiple-choice", "answers": [{"text": "zahl number;", "solution": "true"}, {"text": "number zahl;", "solution": "false"}]}, {"id": 1458, "category": 9, "difficulty": 3, "text": "Mit welcher Funktion gibt man unter ORACLE PL/SQL den Fehlermeldungstext aus?", "explanation": "SQLEERM gibt in einem EXCEPTION-Abschnitt den Oracle-Fehlermeldungstext, aus und SQLCODE die Oracle-Fehlernummer. Hier steht 0 f\u00fcr kein Fehler, 1 f\u00fcr einen benutzerdefinierten Fehler und 100 f\u00fcr NO_DATA_FOUND.", "type": "text", "answers": [{"text": "Das ist:", "solution": "SQLERRM"}]}, {"id": 1459, "category": 9, "difficulty": 3, "text": "Mit welcher Funktion gibt man unter PL/SQL die ORACLE -Fehlernummer aus?", "explanation": "SQLEERM gibt in einem EXCEPTION-Abschnitt den Oracle-Fehlermeldungstext, aus und SQLCODE die Oracle-Fehlernummer. Hier steht 0 f\u00fcr kein Fehler, 1 f\u00fcr einen benutzerdefinierten Fehler und 100 f\u00fcr NO_DATA_FOUND.", "type": "text", "answers": [{"text": "Das ist:", "solution": "SQLCODE"}]}, {"id": 1460, "category": 10, "difficulty": 1, "text": "Wenn ein Trigger existiert, kann der Anwender sicher sein, dass alle in der Datenbank gespeicherten Daten die Bedingung erf\u00fcllen, die durch den Trigger definiert ist.", "explanation": "Die Eigenschaft, dass r\u00fcckwirkend die Daten kontrolliert werden, haben nur Constraints. Das f\u00fchrt dazu, dass man keinen Constraint anlegen kann, wenn die bestehenden Daten nicht der in dem Constraint enthaltenen Bedingung gen\u00fcgen. F\u00fcr Trigger ist das nicht der Fall. Um die Kontrolle, die im Trigger enthalten ist, auszuf\u00fchren, muss der Trigger angesto\u00dfen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1462, "category": 9, "difficulty": 1, "text": "Wie \u00fcberl\u00e4dt man Prozeduren unter PL/SQL?", "explanation": "Ein expliziter OVELOADING-Befehl ist unter PL/SQL nicht notwendig. Gleichnamige Prozeduren werden durch eine unterschiedliche Anzahl von Parametern oder durch unterschiedliche Datentypen der Parameter unterschieden.", "type": "multiple-choice", "answers": [{"text": "Durch das zus\u00e4tzliche Schl\u00fcsselwort \"OVERLOADING\" hinter  \"CREATE PROZEDURE\" platziert.", "solution": "false"}, {"text": "Gleichnamige Prozeduren werden durch eine unterschiedliche Anzahl von Parametern oder durch unterschiedliche Datentypen der Parameter unterschieden.", "solution": "true"}, {"text": "\u00dcberladen von Prozeduren ist unter PL/SQL nicht m\u00f6glich.", "solution": "false"}]}, {"id": 1463, "category": 9, "difficulty": 2, "text": "Welcher Programmiersprache ist PL/SQL nachempfunden?", "explanation": "PL/SQL ist eine Oracle-spezifische prozedurale Erweiterung von SQL, die auf ADA basiert. Sie stellt somit eine M\u00f6glichkeit dar, die mengenorientierten SQL-DML-Anweisungen Datensatz f\u00fcr Datensatz zu verarbeiten. PL/SQL kann sowohl beim Server als auch beim Client ausgef\u00fchrt werden. Findet die Ausf\u00fchrung auf dem Server statt, dann handelt es sich um in der Datenbank gespeicherte Prozeduren und Funktionen, die durch externe Aufrufe (RPC Remote Procedure\nCall) angesto\u00dfen werden oder \u00fcber Datenbanktrigger. PL/SQL-Aufrufe k\u00f6nnen alternativ auch beim Client verarbeitet werden. In diesem Fall wird der PL/SQL-Programmcode auf der Client-Seite bearbeitet und das Ergebnis dem Oracle-Datenbank-Server \u00fcbergeben.", "type": "multiple-choice", "answers": [{"text": "BASIC", "solution": "false"}, {"text": "JAVA", "solution": "false"}, {"text": "C++", "solution": "false"}, {"text": "ADA", "solution": "true"}]}, {"id": 1466, "category": 9, "difficulty": 1, "text": "Mit welcher Funktion ersetzt man unter ORACLE-SQL einen Nullwert in der Ausgabe durch einen anderen, vordefinierten Wert?", "explanation": "Z.B: \nNVL(spalte1, 7)  \nliefert den Wert von spalte1 zur\u00fcck, wenn dieser ungleich NULL ist, also wenn spalte1 gef\u00fcllt ist. Ist spalte1 leer/NULL, dann liefert NVL den Wert 7 zur\u00fcck. Das funktioniert mit Spalten/Ausdr\u00fccken beliebigen Datentyps. \nDie Funktion IFNULL gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "IFNULL(...)", "solution": "false"}, {"text": "keine von beiden", "solution": "false"}, {"text": "NVL(...)", "solution": "true"}]}, {"id": 1468, "category": 10, "difficulty": 1, "text": "Welcher Trigger-Typ ist unter PL/SQL als DEFAULT eingestellt?", "explanation": "Ein Befehlstrigger  (STATEMENT TRIGGER, befehlsorientiert, default) wird genau einmal vor oder nach der Ausf\u00fchrung des feuernden Ereignisses ausgef\u00fchrt, auch dann, wenn kein Datensatz von der feuernden Anweisung manipuliert wird.  \nEin Zeilentrigger (ROW TRIGGER, zeilenorientiert) wird dagegen f\u00fcr jeden von der feuernden Datenmanipulation betroffenen Datensatz je einmal ausgef\u00fchrt. Wird kein Datensatz\nvon der Anweisung ge\u00e4ndert, dann wird auch kein Zeilentrigger ausgef\u00fchrt. Nur bei den Zeilentriggern sind die Transitionsvariablen zugreifbar, die Transitionstabellen hingegen sind es bei beiden Triggertypen.", "type": "multiple-choice", "answers": [{"text": "zeilenorientierte Trigger", "solution": "false"}, {"text": "befehlsorientierte Trigger", "solution": "true"}]}, {"id": 1469, "category": 10, "difficulty": 2, "text": "Bei einem Trigger unter PL/SQL muss eine WHEN-Bedingung immer in Klammern stehen.", "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugeh\u00f6rigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgef\u00fchrt (bei FALSE und NULL nicht). Sie muss immer in Klammern  stehen.  \n\nZu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung gepr\u00fcft, ob der Aktionsteil ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1471, "category": 10, "difficulty": 1, "text": "Das Mutating Table-Problem tritt auf:", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "multiple-choice", "answers": [{"text": "in zeilenorientierten ORACLE-Triggern", "solution": "true"}, {"text": "in befehlsorientierten orientierten ORACLE-Triggern", "solution": "false"}, {"text": "in keinem Triggertyp, der unter ORACLE PL/SQL definiert Trigger wurde", "solution": "false"}]}, {"id": 1472, "category": 10, "difficulty": 1, "text": "In PL/SQL kann man Trigger definieren", "explanation": "Der SQL-Standard und ORACLE-SQL sehen DML-Trigger vor, die nach INSERT, UPDATE oder DELETE gefeuert werden, SELECT-Anweisungen leider nicht. ORACLE kennt zus\u00e4tzlich noch DDL-Trigger, die sich jedoch nicht auf CREATE TABLE (einer einzelnen Tabelle) sondern auf CREATE ON SCHEMA beziehen, sowie INSTEAD-OF-Trigger auf views.", "type": "multiple-choice", "answers": [{"text": "nach INSERT-Anweisungen", "solution": "true"}, {"text": "nach SELECT-Anweisungen", "solution": "false"}, {"text": "nach CREATE-TABLE-Anweisungen", "solution": "false"}, {"text": "nach UPDATE-Anweisungen", "solution": "true"}, {"text": "nach DELETE-Anweisungen", "solution": "true"}]}, {"id": 1473, "category": 9, "difficulty": 1, "text": "Wie kann man unter PL/SQL dynamisches SQL erzeugen?", "explanation": "In PL/SQL kann nur SQL-Manipulationsanweisungen, aber keine DDL-Anweisungen wie CREATE, ALTER, DROP etc.,keine DCL wie GRANT, REVOKE etc. und keine SESSION CONTROL-Anweisungen wie ALTER SESSION\nverarbeiten. Einen Ausweg aus dieser Situation bietet dynamisches SQL unter PL/SQL mit NDS, dem Native Dynamic SQL. Die auszuf\u00fchrende SQL-Anweisung wird ohne abschlie\u00dfendes Semikolon als Zeichenkette oder in einer Textvariablen dem Befehl EXECUTE IMMEDIATE \u00fcbergeben, der diesen Text ungepr\u00fcft zur Ausf\u00fchrung an das Datenbankmanagementsystem sendet. Der Befehl EXECUTE IMMEDIATE selbst wird aber mit einem Semikolon abgeschlossen.Eine andere \u00e4ltere und etwas aufw\u00e4ndigere  M\u00f6glichkeit ist die Verwendung des Pakets DBMS_SQL.", "type": "multiple-choice", "answers": [{"text": "Mit dem Package DBMS_SQL", "solution": "false"}, {"text": "Mit EXECUTE IMMEDIATE", "solution": "true"}, {"text": "Solch eine M\u00f6glichkeit gibt es nicht.", "solution": "false"}]}, {"id": 1475, "category": 9, "difficulty": 3, "text": "In welchen Data-Dictionary-Views sind unter ORACLE Informationen \u00fcber PL/SQL-Prozeduren gespeichert?", "explanation": "USER_OBJECTS enth\u00e4lt Informationen \u00fcber alle in der DB gespeicherten Objekte, also auch \u00fcber Prozeduren. USER_FUNCTIONS existiert nicht und USER_SOURCE enth\u00e4lt den SOURCE-Code der Funktion. USER_PROCEDURES listet alle in der DB gespeicherten Prozeduren auf.", "type": "multiple-choice", "answers": [{"text": "USER_SOURCE", "solution": "true"}, {"text": "USER_OBJECTS", "solution": "true"}, {"text": "USER_SOURCE_TABLES", "solution": "true"}, {"text": "USER_PROCEDURES", "solution": "true"}, {"text": "USER_FUNCTIONS", "solution": "false"}]}, {"id": 1476, "category": 9, "difficulty": 3, "text": "PL/SQL-CURSOR k\u00f6nnen", "explanation": "Dynamisches SQL wird \u00fcber NDS mit EXECUTE IMMEDIATE ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "Parameter aufnehmen", "solution": "true"}, {"text": "als CURSOR-Variable deklariert werden", "solution": "true"}, {"text": "dynamisches SQL enthalten", "solution": "false"}]}, {"id": 1477, "category": 9, "difficulty": 2, "text": "Womit kann man in PL/SQL einen Record definieren, der den Datentypen einer kompletten Tabelle entspricht?", "explanation": "Mit Tabellenname%ROWTYPE wird die Attributstruktur einer Tabelle komplett an einen PL/SQL-Rekord \u00fcbertragen und dynamisch angepasst. wenn sich dien Tabellendefinition \u00e4ndert. Mit Tabellenname.Spaltenname%TYPE kann man eine Variable entsprechend der Spalte einer Tabelle definieren.", "type": "text", "answers": [{"text": "Das ist", "solution": "%ROWTYPE"}]}, {"id": 1478, "category": 10, "difficulty": 3, "text": "Auf die Transitionsvariablen :OLD... und :NEW... kann man unter PL/SQL zugreifen in", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": "befehlsorientierten Datenbanktriggern", "solution": "false"}, {"text": "zeilenorientierten Datenbanktriggern", "solution": "true"}, {"text": "einer WHEN-Klausel", "solution": "true"}]}, {"id": 1479, "category": 9, "difficulty": 2, "text": "Welche Typen von CURSORN gibt es in PL/SQL?", "explanation": "Implizite Cursor werden bei jedem DML oder DQL -Befehl im Hintergrund benutzt und k\u00f6nnten z.B. mit SQL%ROWCOUNT abgefragt werden. CURSOR-Variable werden mit \"TYPE name_cur_type IS REF CURSOR; definiert. Explizite Cursor werden im  DECLARE-Abschnitts eines PL/SQL-Blocks  festgelegt.", "type": "multiple-choice", "answers": [{"text": "Implizite Cursor", "solution": "true"}, {"text": "Ausnahmecursor", "solution": "false"}, {"text": "Explizite Cursor", "solution": "true"}, {"text": "Instanzcursor", "solution": "false"}, {"text": "CURSOR Variable", "solution": "true"}]}, {"id": 1480, "category": 9, "difficulty": 3, "text": "Mit welchen Schl\u00fcsselworten leitet man unter PL/SQL dynamisches SQL (NDS, Native Dynamic SQL) ein?", "explanation": "In PL/SQL kann nur SQL-Manipulationsanweisungen, aber keine DDL-Anweisungen wie CREATE, ALTER, DROP etc.,keine DCL wie GRANT, REVOKE etc. und keine SESSION CONTROL-Anweisungen wie ALTER SESSION\nverarbeiten. Einen Ausweg aus dieser Situation bietet dynamisches SQL unter PL/SQL mit NDS, dem Native Dynamic SQL. Die auszuf\u00fchrende SQL-Anweisung wird ohne abschlie\u00dfendes Semikolon als Zeichenkette oder in einer Textvariablen dem Befehl EXECUTE IMMEDIATE \u00fcbergeben, der diesen Text ungepr\u00fcft zur Ausf\u00fchrung an das Datenbankmanagementsystem sendet. Der Befehl EXECUTE IMMEDIATE selbst wird aber mit einem Semikolon abgeschlossen.", "type": "text", "answers": [{"text": "Das ist", "solution": "EXECUTE IMMEDIATE"}]}, {"id": 1620, "category": 9, "difficulty": 3, "text": "Ein B-Baum hat folgende Eigenschaften:", "explanation": "Der B-Baum und der B+-Baum sind vollst\u00e4ndig balancierte B\u00e4ume, bei denen der Weg von der Wurzel bis zu Blatt immer gleich lang sind und der H\u00f6he H des Baums entsprechen. Die Daten werden, anders als beim B+-Baum, gemeinsam mit dem Index gespeichert. Alle inneren Knoten mit n Eintr\u00e4gen haben n+1 Nachfolger. Und jeder Knoten, au\u00dfer der Wurzel, hat zwischen k und 2k Eintr\u00e4ge, wobei k der Typ des Baums ist.", "type": "multiple-choice", "answers": [{"text": "Der B-Baum speichert die Daten ausschlie\u00dflich in den Bl\u00e4ttern.", "solution": "false"}, {"text": "Innere Knoten enthalten nur Schl\u00fcsselinformationen und Verweise auf die nachfolgenden Knoten.", "solution": "false"}, {"text": "Der Baum ist vollst\u00e4ndig balanciert, d.h. jeder Weg von der Wurzel zum Blatt hat die gleiche L\u00e4nge, die H\u00f6he h.", "solution": "true"}, {"text": "Der Weg von der Wurzel zum Blatt hat die L\u00e4nge h, h+1 oder h+2, wobei h die H\u00f6he des Baumes ist.", "solution": "false"}, {"text": "Alle inneren Knoten haben zwei Nachfolger.", "solution": "false"}, {"text": "Alle inneren Knoten mit n Eintr\u00e4gen haben n+1 Nachfolger.", "solution": "true"}, {"text": "Jeder Knoten eines B- Baumes vom Typ k hat zwischen k und 2k Eintr\u00e4ge.", "solution": "false"}, {"text": "Jeder Knoten au\u00dfer der Wurzel eines B- Baumes vom Typ k hat zwischen k und 2k Eintr\u00e4ge.", "solution": "true"}, {"text": "Die Wurzel hat mindestens einen und h\u00f6chstens 2k Eintr\u00e4ge.", "solution": "true"}]}, {"id": 1621, "category": 42, "difficulty": 3, "text": "Bei welcher Speicherstruktur sind die Verwaltungsdaten von der Gr\u00f6\u00dfe her zu vernachl\u00e4ssigen?", "explanation": "Die Hash-Speicherstruktur und die Heap-Speicherstruktur beinhalten keinen gesonderten Index und daher sehr wenig Speicherplatz.", "type": "multiple-choice", "answers": [{"text": "HASH", "solution": "true"}, {"text": "ISAM", "solution": "false"}, {"text": "B-Baum", "solution": "false"}, {"text": "HEAP", "solution": "true"}]}, {"id": 1613, "category": 42, "difficulty": 3, "text": "Bei welcher Speicherstruktur kann beim Anlegen und L\u00f6schen von Daten ein relativ hoher Verwaltungsaufwand entstehen?", "explanation": "Beim Anlegen und L\u00f6schen von Daten in B-B\u00e4umen und B+-B\u00e4umen kann es vorkommen, dass eine Knoten \u00fcberbelegt oder unterbelegt ist. Ist der Knoten \u00fcberbelegt, wird er gesplittet und das mittlere Element wandert nach oben. Dieser Vorgang kann sich  im ung\u00fcnstigsten Fall bis zur Wurzel fortsetzen. Ist der Knoten unterbelegt, kann er mit den Nachbarknoten zusammengelegt oder ausgeglichen werden, um die B-Baum-Struktur zu erhalten. Beide Verfahren sind verh\u00e4ltnism\u00e4\u00dfig aufwendig, vor allem das L\u00f6schen.\n\nWenn man die \u00dcberlaufseiten bei der ISAM-Struktur ber\u00fccksichtigt, ist auch diese Antwort korrekt.", "type": "multiple-choice", "answers": [{"text": "HEAP", "solution": "false"}, {"text": "ISAM", "solution": "true"}, {"text": "B- Baum", "solution": "true"}, {"text": "HASH", "solution": "true"}]}, {"id": 1575, "category": 42, "difficulty": 1, "text": "Ein B-Baum w\u00e4chst", "explanation": "Ein B-Baum w\u00e4chst \u00fcber die Wurzel nach oben, da beim Einf\u00fcgen in einen vollen Knoten dieser gesplittet wird und das mittlere Element nach oben weitergegeben wird. Ist dieser Knoten auch voll, kann das bis zur Wurzel weitergereicht werden, so dass ein neues Wurzelelement entsteht.", "type": "multiple-choice", "answers": [{"text": "\u00fcber die Bl\u00e4tter nach unten", "solution": "false"}, {"text": "\u00fcber die Wurzel nach oben", "solution": "true"}]}, {"id": 2109, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat die Vereinigungsmenge der Tabelle Test mit sich selber?", "explanation": "Es wird nach den Spalten,  nicht nach die Zeilen der Tabelle gefragt :-).", "type": "text", "answers": [{"text": "", "solution": "3"}]}, {"id": 2111, "category": 9, "difficulty": 3, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat die Differenz der Tabelle Test mit sich selber?", "explanation": "Die Differenz einer Tabelle mit sich selber ist die leere Menge.", "type": "text", "answers": [{"text": "Bitte schreiben Sie die Zahl als numerischen Wert auf!", "solution": "3"}]}, {"id": 1487, "category": 8, "difficulty": 1, "text": "Wie viele Relationen gehen in eine Selektion ein?", "explanation": "Eine n-stellige Relation wird mittels der Selektion R \u2192 SelektionB(R) auf eine n-stellige Relation abgebildet: Rn \u2192 Rn. \nEs ist also neben der Projektion der zweite un\u00e4re Operator.", "type": "multiple-choice", "answers": [{"text": "1", "solution": "true"}, {"text": "2", "solution": "false"}, {"text": "3", "solution": "false"}, {"text": "0", "solution": "false"}]}, {"id": 1488, "category": 8, "difficulty": 1, "text": "Welche Aussagen \u00fcber die Join-Operation sind richtig?", "explanation": "In eine Join-Operation gehen nach Definition immer nur genau zwei Operatoren ein.", "type": "multiple-choice", "answers": [{"text": "Es ist eine un\u00e4re Operation.", "solution": "false"}, {"text": "Es ist eine bin\u00e4re Operation.", "solution": "true"}, {"text": "Es ist eine tern\u00e4re Operation.", "solution": "false"}, {"text": "Es k\u00f6nnen beliebig viele Relationen in einer Join-Operation miteinander verkn\u00fcpft werden.", "solution": "false"}]}, {"id": 1489, "category": 10, "difficulty": 3, "text": "Was kann in einer WHEN-Bedingung eines ORACLE-Datenbanktriggers verwendet werden?", "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugeh\u00f6rigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgef\u00fchrt (bei FALSE und NULL nicht). Sie muss immer in Klammern stehen.  \n\nZu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung gepr\u00fcft, ob der Aktionsteil ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "Eine SELECT-Anweisung", "solution": "false"}, {"text": "Vergleichsoperatoren", "solution": "true"}, {"text": "Systemvariablen", "solution": "true"}, {"text": "Transitionsvariablen", "solution": "true"}, {"text": "ORACLE BUILD-IN-Funktionen", "solution": "true"}]}, {"id": 1490, "category": 9, "difficulty": 2, "text": "In einer WHEN-Bedingung eines zeilenorientierten Triggers haben die Transitionsvariable einen Doppelpunkt.", "explanation": "Der Doppelpunkt steht zur St\u00e4rkung des Ged\u00e4chtnisses bei den Transitionsvariablen nur im PL/SQL-Ausf\u00fchrungsteil eines Triggers, nicht in der WHEN-Bedingung.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1491, "category": 9, "difficulty": 1, "text": "Wie viele Datens\u00e4tze darf unter PL/SQL ein expliziter CURSOR mit \"SELECT ...INTO ..\" liefern, ohne dass ein Fehler ausgel\u00f6st wird?", "explanation": "SELECT INTO \u00fcbergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datens\u00e4tze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datens\u00e4tze verarbeiten kann.", "type": "multiple-choice", "answers": [{"text": "keinen Datensatz", "solution": "false"}, {"text": "einen Datensatz", "solution": "true"}, {"text": "viele Datens\u00e4tze", "solution": "false"}]}, {"id": 1492, "category": 9, "difficulty": 2, "text": "Eine PL/SQL-Funktion a liefert einen booleschen Wert b zur\u00fcck. Wie k\u00f6nnen Sie diesen Wert b in SQL*PLUS bzw de, SQL-Developer ausgeben?", "explanation": "DBMS_OUPUT.PUTLINE(a); kann nicht in dieser Form verwendet werden, da SQL keinen BOOLESCHEN Datentyp kennt. Daher muss der Umweg \u00fcber eine IF-Abfrage benutzt werden.", "type": "multiple-choice", "answers": [{"text": "Direkt \u00fcber DBMS_OUPUT.PUTLINE(a);", "solution": "false"}, {"text": "Indirekt \u00fcber eine IF-Abfrage und Umwandlung in eine  Variable vom Typ VARCHAR", "solution": "true"}, {"text": "keine von beiden M\u00f6glichkeiten", "solution": "false"}]}, {"id": 1496, "category": 10, "difficulty": 1, "text": "Trigger mit einer WHEN-Bedingung k\u00f6nnen sein:", "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugeh\u00f6rigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgef\u00fchrt (bei FALSE und NULL nicht). Sie muss immer in Klammern  stehen.  \n\nZu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung gepr\u00fcft, ob der Aktionsteil ausgef\u00fchrt wird. \n\nDa Oracle keine Transitionstabellen kennt und Transitionsvariablen zu zeilenorienterten Triggern mit einer WHEN -Bedingung geh\u00f6ren, sind ORACLE-Trigger mit einer WHEN-Bedingung immer zeilenorientiert.", "type": "multiple-choice", "answers": [{"text": "zeilenorientiert", "solution": "true"}, {"text": "befehlsorientiert", "solution": "false"}]}, {"id": 1497, "category": 10, "difficulty": 2, "text": "Wof\u00fcr steht ECMA bei Datenbanktrigger?", "explanation": "F\u00fcr jede aktive Regel muss das Ereignis (E) spezifiziert werden, zu dem sie von der aktiven Regelkomponente gefeuert wird. Ereignisse k\u00f6\u00f6nen DML-Anweisungen z.B oder  Zeitereignisse sein.  \n\n(C) steht f\u00fcr die Formulierung einer optionalen Bedingung (condition), die vor der Aktivierung  oder Ausf\u00fchrung der aktiven Regel gepr\u00fcft wird.  Ist eine Bedingung definiert, so wird der Aktionsteil der gefeuerten Regel nur ausgef\u00fchrt, wenn die Bedingung erf\u00fcllt ist.  \n\n(M) steht f\u00fcr den optionalen Mode oder Ausf\u00fchrungszeitpunkt.  \n\n(A) steht f\u00fcr den Aktionsteil, der in jedem Trigger enthalten sein muss.", "type": "text", "answers": [{"text": "E steht f\u00fcr", "solution": "Event"}, {"text": "C steht f\u00fcr", "solution": "Condition"}, {"text": "M steht f\u00fcr", "solution": "Mode"}, {"text": "A steht f\u00fcr", "solution": "Action"}]}, {"id": 1498, "category": 10, "difficulty": 2, "text": "Welche Ausf\u00fchrungszeitpunkte sind bei Datenbanktriggern unter SQL:1999 zugelassen? \nBitte in alphabetischer Reihenfolge eintragen!", "explanation": "Der Ausf\u00fchrungszeitpunkt (AFTER oder BEFORE) legt fest, ob ein Trigger vor oder nach dem feuernden (aktivierenden) Ereignis ausgef\u00fchrt werden soll. Je nach Aufgabenstellung kann der BEFORE- oder der AFTER-Zeitpunkt sinnvoll oder gar notwendig sein. Sind Folgeverarbeitungen durchzuf\u00fchren, so bieten sich AFTER TRIGGER an, da bei deren Ausf\u00fchrung die Integrit\u00e4tsbedingungen bereits\ngepr\u00fcft wurden. Sollen die Werte des neuen Datensatzes ge\u00e4ndert oder erg\u00e4nzt werden, so bietet es sich hingegen an, in den BEFORE TRIGGER die NEW-Variablen mit entsprechenden Werten zu belegen.", "type": "text", "answers": [{"text": "Das sind", "solution": "AFTER"}, {"text": "und", "solution": "BEFORE"}]}, {"id": 1506, "category": 9, "difficulty": 3, "text": "BLOB, CLOB und BFILE Datentypen sind erlaubt", "explanation": "Die Datentypen k\u00f6nnen als Datentypen f\u00fcr gro\u00dfe Bin\u00e4robjekte nur als Datentyp einer Spalte und in einer PL-SQL-Variablen benutzt werden. Alle anderen Operationen machen keinen Sinn.", "type": "multiple-choice", "answers": [{"text": "als Datentyp einer Spalte", "solution": "true"}, {"text": "als Teil eines Schl\u00fcssels", "solution": "false"}, {"text": "als Datentyp einer PL/SQL-Variablen", "solution": "true"}, {"text": "in booleschen oder arithmetischen Ausdr\u00fccken", "solution": "false"}, {"text": "in der GROUP-BY-Klausel", "solution": "false"}, {"text": "in der ORDER-BY-Klausel", "solution": "false"}, {"text": "in einer SELECT DISTINCT - Anweisung", "solution": "false"}]}, {"id": 1331, "category": 8, "difficulty": 1, "text": "Wodurch wird in der relationalen Algebra der \"F\u00fcr-Alle-Quantor\" (Allaussage) umgesetzt?", "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.", "type": "multiple-choice", "answers": [{"text": "Division", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Durchschnitt", "solution": "false"}]}, {"id": 1333, "category": 9, "difficulty": 3, "text": "Womit beginnen SQLJ-Klauseln ?", "type": "multiple-choice", "answers": [{"text": "!", "solution": "false"}, {"text": "#", "solution": "true"}, {"text": "<!--", "solution": "false"}, {"text": "&", "solution": "false"}]}, {"id": 1361, "category": 9, "difficulty": 3, "text": "Mit welchem Befehl erteilen Sie dem Benutzer \"Hugo\" das Recht, die PL/SQL-Prozedur \"Test\" auszuf\u00fchren, die ihm nicht selber geh\u00f6rt?", "explanation": "Mit dem Befehl \nGRANT EXECUTE ON Prozedurname TO Benutzername; \nk\u00f6nnen Sie unter PL/SQL Ausf\u00fchrungsrechte an einzelne\nBenutzer vergeben, mit dem Befehl \nGRANT EXECUTE ON Prozedurname TO PUBLIC;  \nr\u00e4umen Sie diese Ausf\u00fchrungsrechte allen Benutzern ein.", "type": "text", "answers": [{"text": "Der SQL-Befehl lautet ( ohne Semikolon am Schluss)", "solution": "GRANT EXECUTE ON Test TO Hugo"}]}, {"id": 1362, "category": 9, "difficulty": 1, "text": "Eine \u00f6ffentliche Prozedur wird von einer privaten unterschieden:", "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur, Funktion, Variable, Konstante, Cursor etc., ist es entweder \u00f6ffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind \u00f6ffentlich und k\u00f6nnen damit von au\u00dferhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und k\u00f6nnen damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.", "type": "multiple-choice", "answers": [{"text": "durch den Zusatz public bzw. private", "solution": "false"}, {"text": "durch die Platzierung im Package", "solution": "true"}, {"text": "diese Unterscheidung gibt in PL/SQL nicht", "solution": "false"}]}, {"id": 1363, "category": 9, "difficulty": 1, "text": "In PL/SQL -Packages werden private Methoden definiert:", "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur, Funktion, Variable, Konstante, Cursor etc., ist es entweder \u00f6ffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind \u00f6ffentlich und k\u00f6nnen damit von au\u00dferhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und k\u00f6nnen damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.", "type": "multiple-choice", "answers": [{"text": "im Package-Header", "solution": "false"}, {"text": "im Package-Body", "solution": "true"}]}, {"id": 1365, "category": 9, "difficulty": 2, "text": "Overloading von Routinen bedeutet, dass Prozeduren und Funktionen gleich hei\u00dfen k\u00f6nnen und dieses Konzept gibt es nur f\u00fcr Package-Prozeduren und -Funktionen.", "explanation": "Beim Overloading in PL/SQL k\u00f6nnen Paketroutinen gleich hei\u00dfen:   Gleichnamige Prozeduren oder Funktionen werden durch eine unterschiedliche Anzahl, eine unterschiedliche Reihenfolge von Parametern oder durch unterschiedliche Datentypen der Parameter unterschieden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1366, "category": 9, "difficulty": 2, "text": "Mit welchem PL/SQL-Paket kann man unmittelbar HTML-Seiten aus der Datenbank generieren?", "explanation": "Eine vollst\u00e4ndige Referenz dieses Pakets finden Sie unter \n<a href= \"http://download.oracle.com/docs/cd/B14099_19/web.1012/b15896/toc.htm\"> http://download.oracle.com/docs/cd/B14099_19/web.1012/b15896/toc.htm", "type": "text", "answers": [{"text": "Das Paket hei\u00dft:", "solution": "HTP"}]}, {"id": 1372, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft die ORACLE-Funktion, die einen beliebigen, angegebenen Wert liefert, wenn ein Ausdruck (z.B. Spaltenwert) NULL ist?", "explanation": "Z.B: \nNVL(spalte1, 7)  \nliefert den Wert von spalte1 zur\u00fcck, wenn dieser ungleich NULL ist, also wenn spalte1 gef\u00fcllt ist. Ist spalte1 leer/NULL, dann liefert NVL den Wert 7 zur\u00fcck. Das funktioniert mit Spalten/Ausdr\u00fccken beliebigen Datentyps.", "type": "text", "answers": [{"text": "Das ist: (Nur der Funktionsname ohne Parameter)", "solution": "NVL"}]}, {"id": 1526, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft das JDBC Interface, das implementiert werden muss, um eine Datenbankverbindung aufzubauen?", "explanation": "Ein JAVA-Programm kann eine oder mehrere Verbindungen zu einer oder mehreren Datenbanken unterhalten. Jede Verbindung wird durch ein Objekt realisiert, das das Interface Connection implementiert.\nDieses Interface definiert unter anderem folgende Methoden:\nMit der Methode createStatement() kann ein Objekt, welches das Interface Statement implementiert, erzeugt werden.  Analog dazu wird mit der Methode prepareStatement(String sql) eine Anweisung vorbereitet.  Durch den Aufruf von setAutoCommit(boolean) wird der Autocommit-Modus der Verbindung an- oder ausgeschaltet.  \n- Mit getAutoCommit() wird gepr\u00fcft, welcher Modus vorliegt.\n- Mit close() wird die Verbindung explizit geschlossen,\n- mit isClosed() kann dies nachgepr\u00fcft werden.", "type": "text", "answers": [{"text": "Das Interface hei\u00dft:", "solution": "Connection"}]}, {"id": 1527, "category": 9, "difficulty": 3, "text": "Mit welchem Isolationsgrad (Konstante der Methode setTransactionIsolation() des Interfaces Connection) werden unter JDBC Transaktionen nacheinander ausgef\u00fchrt?", "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgef\u00fchrt.", "type": "text", "answers": [{"text": "Der Isolationsgrad hei\u00dft", "solution": "TRANSACTION_SERIALIZABLE"}]}, {"id": 1529, "category": 9, "difficulty": 2, "text": "Welche Klassen bzw.Interfaces besitzen unter JDBC eine Methode close()?", "explanation": "Wer n\u00e4heres Wissen will, sollte bei SUN selber nachschlagen: \n\n<a href= \"http://java.sun.com/j2se/1.4.2/docs/api/java/sql/package-summary.html\"> JDBC-Dokumentation bei Sun .", "type": "multiple-choice", "answers": [{"text": "Statement", "solution": "true"}, {"text": "ResultSet", "solution": "true"}, {"text": "DriverManager", "solution": "false"}, {"text": "Connection", "solution": "true"}]}, {"id": 1555, "category": 9, "difficulty": 3, "text": "Zu welchem Part von SQLJ geh\u00f6rt die Einbindung von statischen SQL-Statements in ein JAVA-Programm?", "type": "multiple-choice", "answers": [{"text": "Part 0", "solution": "true"}, {"text": "Part 1", "solution": "false"}, {"text": "Part 3", "solution": "false"}]}, {"id": 1548, "category": 9, "difficulty": 3, "text": "Welches Interface enth\u00e4lt die Metadaten eines ResultSets unter JDBC?", "explanation": "Wer n\u00e4heres Wissen will, sollte bei SUN selber nachschlagen: \n\n<a href= \"http://java.sun.com/j2se/1.4.2/docs/api/java/sql/package-summary.html\"> JDBC-Dokumentation bei Sun .", "type": "text", "answers": [{"text": "Das ist", "solution": "ResultSetMetaData"}]}, {"id": 1549, "category": 9, "difficulty": 3, "text": "Welche JAVA-SWING-Klassen k\u00f6nnen zur Ausgabe von Tabellen nach dem Model-View-Controler-Prinzip genutzt werden?", "explanation": "Wer n\u00e4heres Wissen will, sollte bei SUN selber nachschlagen:\n\n    <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/javax/swing/table/AbstractTableModel.html\">JDBC-Dokumentation bei Sun .", "type": "multiple-choice", "answers": [{"text": "AbstractTableModel", "solution": "true"}, {"text": "JTable", "solution": "true"}, {"text": "SQLTable", "solution": "false"}, {"text": "TableModel", "solution": "false"}]}, {"id": 1550, "category": 9, "difficulty": 1, "text": "Die Funktionalit\u00e4t zum Umgang mit LOBs ist im Standard-JDBC enthalten.", "explanation": "Seit JDBC 2.0 gibt es ein Interface CLOB, das dazu dienst den Datentyp CLOB aus SQL abzubilden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1551, "category": 9, "difficulty": 1, "text": "Welche Aussage \u00fcber SELECT-Abfragen unter ORACLE-JDBC ist wahr?", "explanation": "Wie in anderen SQL-Schnittstellen auch, wird unter JDBC/SQL nur der LOB-Locator selektiert.", "type": "multiple-choice", "answers": [{"text": "Durch SELECT-Statements werden nicht die eigentlichen LOB-Daten, sondern nur die LOB-Locator selektiert.", "solution": "true"}, {"text": "Durch SELECT-Statements werden die LOB-Daten selber selektiert.", "solution": "false"}]}, {"id": 1552, "category": 9, "difficulty": 1, "text": "Welche Aussage \u00fcber BFiles unter ORACLE-JDBC ist wahr?", "explanation": "BFILEs k\u00f6nnen nur gelesen werden. Es k\u00f6nnen weder Daten hinzugef\u00fcgt noch ein neues BFILE erzeugt werden.\nDer entsprechende JDBC-Datentyp ist BFILE Mit BFILE. getBFILE() kann ein BFILE-Locator aus einem OracleResultSet extrahiert werden.\nUm ein BFILE zu lesen, kann mit der Methode getBinaryStream() ein InputStream auf das BFILE ge\u00f6ffnet werden.\nGelesen werden die Daten mit den verschiedenen read()-Methoden.", "type": "multiple-choice", "answers": [{"text": "BFILEs k\u00f6nnen nur gelesen werden. Es k\u00f6nnen weder Daten hinzugef\u00fcgt noch ein neues BFILE erzeugt werden.", "solution": "true"}, {"text": "BFiles k\u00f6nnnen auch mit Methoden der Stream-KLasssen, wie getBinaryOutputStream(); ver\u00e4ndert werden.", "solution": "false"}]}, {"id": 1553, "category": 9, "difficulty": 3, "text": "Mit Java Stored Procedures kann man", "explanation": "null", "type": "multiple-choice", "answers": [{"text": "PL/SQL-Prozeduren aufrufen, die in der Datenbank gespeichert sind", "solution": "true"}, {"text": "Zugriffe auf das lokale Dateisystem realisieren", "solution": "false"}, {"text": "Prozeduren und Funktionen mit Klassenmethoden schreiben", "solution": "true"}, {"text": "JAVA-Objekte in der Datenbank anlegen", "solution": "false"}, {"text": "SQL DML-Statements (INSERT, UPDATE, DELETE und SELECT) absetzen", "solution": "true"}, {"text": "Grafische Benutzeroberfl\u00e4chen realisieren", "solution": "false"}]}, {"id": 1554, "category": 9, "difficulty": 2, "text": "Methoden und Variable in SQLJ-Prozeduren, die in der Datenbank gespeichert werden, m\u00fcssen public static (Klassenmethoden) sein.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1556, "category": 9, "difficulty": 2, "text": "Zu welchem Part von SQLJ geh\u00f6rt die Nutzung von statischen JAVA-Methoden als Stored Procedures?", "type": "multiple-choice", "answers": [{"text": "Part 0", "solution": "false"}, {"text": "Part 1", "solution": "true"}, {"text": "Part 2", "solution": "false"}]}, {"id": 1558, "category": 10, "difficulty": 2, "text": "Welche Aussagen \u00fcber Oracle/SQL-Trigger und sind wahr?", "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten. Daher wird das Ereignis selber zur\u00fcckgerollt, welches den Fehler ausgel\u00f6st hat.", "type": "multiple-choice", "answers": [{"text": "Bricht die Ausf\u00fchrung eines Oracle-Triggers fehlerhaft mit einem RAISE_APPLICATION_ERROR-Befehl ab, so terminiert nur der Trigger fehlerhaft und es passiert nichts weiter.", "solution": "false"}, {"text": "Bricht die Ausf\u00fchrung eines Oracle-Triggers fehlerhaft mit einem RAISE_APPLICATION_ERROR-Befehl ab, so wird die gesamte Transaktion zur\u00fcckgerollt.", "solution": "false"}, {"text": "Bricht die Ausf\u00fchrung eines Oracle-Triggers fehlerhaft mit einem RAISE_APPLICATION_ERROR-Befehl ab, so wird das Ereignis zur\u00fcckgerollt, welches den Fehler ausgel\u00f6st hat.", "solution": "true"}]}, {"id": 1559, "category": 8, "difficulty": 2, "text": "Welche Operation aus der relationalen Algebra hat die folgende Eigenschaft: Sie extrahiert bestimmte Attribute aus einer Relation und vertauscht eventuell die Reihenfolge der Attribute.", "explanation": "Die Projektion extrahiert bestimmte Attribute aus einer Relation und vertauscht eventuell die Reihenfolge:\n\n    Sei R(A1,...,An) eine Relation und L = (B1,...,Bj) mit 1 \u2264 j \u2264 n eine Attributkombination, d.h. eine geordnete Teilmenge von (A1,...,An).\n\n    B1 entspricht hier dem Attribut Ai1 und Bj entspricht dem Attribut Aij.\n\n    Die Projektion ist definiert durch: Projektion L (R) Projektion B1...Bj (R) := {(ai1,...,aij)|(a1,...,an)\u2208R}.", "type": "multiple-choice", "answers": [{"text": "Das ist die Selektion.", "solution": "false"}, {"text": "Das ist die Projektion.", "solution": "true"}, {"text": "Das ist die Division.", "solution": "false"}, {"text": "Das sind die Mengenoperatoren.", "solution": "false"}, {"text": "Das sind das kartesische Produkt und die Join-Operatoren.", "solution": "false"}]}, {"id": 1560, "category": 9, "difficulty": 1, "text": "Welche der folgenden SELECT-Abfragen ist korreliert?", "explanation": "Korreliert bedeutet, dass die Spalten der \u00e4u\u00dferen Anweisung mit der innneren SELECT-Anweisung durch eine WHERE-Klausel verkn\u00fcpft werden.", "type": "multiple-choice", "answers": [{"text": "SELECT AuftragsNr\nFROM  Auftraege\nWHERE EXISTS\n    (SELECT * FROM Kunden\n    WHERE  Kunden.Kun_Nr = Auftraege.Kun_Nr);", "solution": "true"}, {"text": "SELECT AuftragsNr\nFROM  Auftraege\nWHERE EXISTS\n    (SELECT * FROM Kunden);", "solution": "false"}]}, {"id": 1500, "category": 9, "difficulty": 2, "text": "Welche ORACLE-Build-in-Funktion ersetzt einen Nullwert durch einen selbstdefinierten Wert?", "explanation": "Z.B: \nNVL(spalte1, 7)  \nliefert den Wert von spalte1 zur\u00fcck, wenn dieser ungleich NULL ist, also wenn spalte1 gef\u00fcllt ist. Ist spalte1 leer/NULL, dann liefert NVL den Wert 7 zur\u00fcck. Das funktioniert mit Spalten/Ausdr\u00fccken beliebigen Datentyps.", "type": "text", "answers": [{"text": "Das ist", "solution": "NVL"}]}, {"id": 1740, "category": 9, "difficulty": 2, "text": "Betrachten Sie die folgende Package-Definition:\n\nCREATE PACKAGE xyz\nIS\n    PROCEDURE a (p1 NUMBER); --- Nr 1\n    PROCEDURE a (p1 NUMBER, p2 NUMBER); --- Nr 2\n    PROCEDURE a (p1 DATE); --- Nr 3\n    PROCEDURE a (p3 NUMBER); --- Nr 4\nEND;\n\nWelche Prozedur-Definition ist nicht zul\u00e4ssig?", "explanation": "Eine Prozedur kann den gleichen Name und unterschiedliche Parametertypen und -anzahlen, aber nicht den gleichen Namen und sowohl gleiche Parameteranzahlen wie auch Parametertypen haben.", "type": "multiple-choice", "answers": [{"text": "Nr. 3", "solution": "false"}, {"text": "Nr. 4", "solution": "true"}, {"text": "Nr 1", "solution": "false"}, {"text": "Nr. 2", "solution": "false"}]}, {"id": 1036, "category": 9, "difficulty": 2, "text": "Bei welchen ORACLE-Datentypen k\u00f6nnen bis zu 4 GB gespeichert werden?", "explanation": "BLOB: Mit diesem Datentyp k\u00f6nnen entsprechend dem SQL-Standard bin\u00e4re Objekte (Oracle bis zu 4 Gbyte) f\u00fcr Grafiken oder Tonaufzeichnungen in der Datenbank gespeichert werden. Au\u00dferdem stehen einige Methoden zur Verf\u00fcgung, mit denen diese Objekte auf dem Server manipuliert werden k\u00f6nnen.\n\nCLOB und NCLOB:  Oracle CLOB ist eine Modifikation des Typs BLOB, er wird f\u00fcr gro\u00dfe Textobjekte mit den entsprechenden Methoden zur Verf\u00fcgung gestellt. NCLOB entspricht dem CLOB mit nationalem Zeichensatz. \n\nBFILE:ist ein Oracle-Datentyp f\u00fcr Bin\u00e4robjekte, der nur einen Zeiger (LOB-Locator) auf ein Verzeichnis im Dateisystem enth\u00e4lt, das die Bin\u00e4rdateien beihaltet.", "type": "multiple-choice", "answers": [{"text": "LONG", "solution": "false"}, {"text": "LONG RAW", "solution": "false"}, {"text": "BLOB", "solution": "true"}, {"text": "CLOB", "solution": "true"}]}, {"id": 1034, "category": 9, "difficulty": 3, "text": "Welche Exception wird geworfen, wenn Spalte eine Tabelle und Variable nicht den gleichen Datentyp haben, obwohl sie aufeinander abgebildet sind?", "explanation": "ROWTYPE_MISMATCH wird in PL/SQL geworfen, wenn Spalte und Variable nicht den gleichen Datentyp haben.", "type": "text", "answers": [{"text": "Das ist", "solution": "ROWTYPE_MISMATCH"}]}, {"id": 1035, "category": 9, "difficulty": 3, "text": "Bei welchen Datentypen f\u00fcr gro\u00dfe Objekte ist nur eine Spalte dieses Types je Tabelle erlaubt?", "explanation": "LONG und RAW sind Oracle-Datentypen seit Version 8, die gro\u00dfe Bin\u00e4rdateien aufnehmen k\u00f6nnen. Sie bringen allerdings einige Probleme mit. So kann nur ein LONG-RAW-Spalte  und eine RAW-Spalte je Tabelle angelegt werden und die Daten k\u00f6nnen weder mit CREATE Table AS SELECT ... noch mit INSERT AS SELECT ... kopiert werden. Daher sollten diese Datentypen nicht mehr verwendet werden: BLOB und CLOB sind die empfohlenen Typen.", "type": "multiple-choice", "answers": [{"text": "LONG RAW", "solution": "true"}, {"text": "LONG", "solution": "true"}, {"text": "BLOB", "solution": "false"}, {"text": "CLOB", "solution": "false"}, {"text": "BFILE", "solution": "false"}]}, {"id": 1048, "category": 8, "difficulty": 3, "text": "Welcher Optimierungsvorgang ber\u00fccksichtigt die Gr\u00f6\u00dfe der beteiligten Relationen und das Vorhandensein von Schl\u00fcsseln etc.?", "explanation": "Bei der physischen Optimierung wird auf unterschiedliche Implementierungen der relationalen Algebra zur\u00fcckgegriffen. Dabei gehen Wissen \u00fcber das Datenbankschema, die Gr\u00f6\u00dfe der einzelnen Relationen und Statistiken \u00fcber die erfolgten Datenzugriffe etc. ein.", "type": "text", "answers": [{"text": "Das ist die ...", "solution": "physische Optimierung"}]}, {"id": 1038, "category": 9, "difficulty": 3, "text": "Welcher Datentyp f\u00fcr gro\u00dfe Objekte speichert alphanumerische Daten in der Datenbank im nationalen Zeichensatz ?", "explanation": "CLOB und NCLOB:  Oracle CLOB ist eine Modifikation des Typs BLOB, er wird f\u00fcr gro\u00dfe Textobjekte mit den entsprechenden Methoden zur Verf\u00fcgung gestellt. NCLOB entspricht dem CLOB mit nationalem Zeichensatz.", "type": "text", "answers": [{"text": "Das ist", "solution": "NCLOB"}]}, {"id": 1045, "category": 9, "difficulty": 2, "text": "LOB-Werte k\u00f6nnen direkt in SQL bearbeitet werden.", "explanation": "LOB-Werte k\u00f6nnen nicht in SQL direkt bearbeitet werde. Man braucht dazu Schnittstellen, wie JDBC oder Pakete, wie DBMS_LOB aus Oracle/PL-SQL.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1044, "category": 9, "difficulty": 3, "text": "Mit welcher SQL-Anweisung legt man ein Verzeichnis an, in dem BFILES abgelegt werden k\u00f6nnen?", "explanation": "CREATE DIRECTORY erzeugt einen Zeiger auf ein Verzeichnis auf dem Datenbankserver.", "type": "text", "answers": [{"text": "Das ist", "solution": "CREATE DIRECTORY"}]}, {"id": 1046, "category": 9, "difficulty": 3, "text": "Mit welchem PL/SQL-Paket k\u00f6nnen LOB-Werte bearbeitet werden?", "explanation": "DBMS_LOB bietet Funktionen zum Bearveiten von gro\u00dfen Bin\u00e4rdatentypen, die als BLOB, CLOB und NCLOB in der Oracle-Datenbank abgespeichert sind. Dazu geh\u00f6ren APPEND, CLOSE, COPY ERASE, GETLENGTH , FILEOPEN und andere. Eine ausf\u00fchrliche Beschreibung ist in <a href = \"http://www.dba-oracle.com/t_dbms_lob.htm\"> Oracle  Dokumentation  zu finden.", "type": "text", "answers": [{"text": "Das ist", "solution": "DBMS_LOB"}]}, {"id": 1047, "category": 9, "difficulty": 3, "text": "Welchen der folgenden Datentypen bezeichnet man als externen Datentypen f\u00fcr gro\u00dfe Objekte?", "explanation": "BFILE:ist ein Oracle-Datentyp f\u00fcr Bin\u00e4robjekte, der nur einen Zeiger (LOB-Locator) auf ein Verzeichnis im Dateisystem enth\u00e4lt, das die Bin\u00e4rdateien beihaltet.\nBFIles k\u00f6nnen mit der Funktion BFILENAME mit Dateien verbunden und gef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "LONG RAW", "solution": "false"}, {"text": "BFILE", "solution": "true"}, {"text": "BLOB", "solution": "false"}, {"text": "CLOB", "solution": "false"}]}, {"id": 1049, "category": 8, "difficulty": 3, "text": "Welche Operatoren der relationalen Algebra sind assoziativ?", "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind assoziativ, d. h., Klammern k\u00f6nnen beliebig gesetzt werden.", "type": "multiple-choice", "answers": [{"text": "Projektion", "solution": "false"}, {"text": "Natural Join", "solution": "true"}, {"text": "kartesisches Produkt", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Join-Operatoren (Theta, Natural, Equi)", "solution": "true"}]}, {"id": 1054, "category": 8, "difficulty": 1, "text": "Welcher Join-Operator ist der allgemeinste Operator, von dem sich die anderen Join-Operatoren ableiten lassen?", "explanation": "Den Super-Join gibt es nicht. \nDer Theta_Join ist der Join, dessen Selektionspr\u00e4dikat (Bedingung) keinen Restriktionen unterliegt. \nBeim Equi-Join sind nur Gleichheitsvergleiche (Vergleichsoperator \"=\") im Selektionspr\u00e4dikat zugelassen. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "multiple-choice", "answers": [{"text": "Equi-Join", "solution": "false"}, {"text": "Natural-Join", "solution": "false"}, {"text": "Theta-Join", "solution": "true"}, {"text": "Super-Join", "solution": "false"}]}, {"id": 1055, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren aus der relationalen Algebra l\u00e4sst sich der Differenz-Operator simulieren?", "explanation": "Die Differenz geh\u00f6rt zu den Grund-/Basisoperatoren und kann somit nicht simuliert werden mittels anderer RA-Operatoren. Mit ihrer Hilfe kann jedoch z.B. die Division abgeleitet werden.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Theta-Join", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Outer Join (Left, Right, Full)", "solution": "false"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Durchschnitt", "solution": "false"}, {"text": "Division", "solution": "false"}, {"text": "keine der aufgef\u00fchrten Antworten", "solution": "true"}]}, {"id": 1056, "category": 11, "difficulty": 3, "text": "Welche Aussagen \u00fcber \"Transaktionen in SQL\" sind richtig?", "explanation": "FALSCH sind:  \n\"Im SQL-Standard sind keine \"dirty reads\" m\u00f6glich.\" Dirty reads sind bei Oracle grunds\u00e4tzlich ausgeschlossen, so dass es dort, anders als beim SQL-Standard, den Isolationsgrad READ UNCOMMITTED nicht gibt.\n\n\"F\u00fchrt eine Transaktion eine Anfrage mehrfach aus, so k\u00f6nnen u.a. \"lost updates\", \"non repeatable reads\" und \"phantome\" auftreten.\" Diese Aussage ist hinsichtlich \"non repeatable reads\" und \"phantome\" richtig, nur f\u00fcr \"lost updates\" falsch. \"lost updates\" sind keine Probleme der Lesekonsistenz wie die anderen beiden, sie sind Probleme der Nebenl\u00e4ufigkeitskontrolle. \n\nRICHTIG sind: \n\"Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und \u00fcberschreibt somit die \u00c4nderungen von T2 ungesehen.\"\n\n\"Ein Ausf\u00fchrungsplan ist serialisierbar, wenn er zu einem seriellen Ausf\u00fchrungsplan \u00e4quivalent ist.\"", "type": "multiple-choice", "answers": [{"text": "Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und \u00fcberschreibt somit die \u00c4nderungen von T2 ungesehen.", "solution": "true"}, {"text": "Ein Ausf\u00fchrungsplan ist serialisierbar, wenn er zu einem seriellen Ausf\u00fchrungsplan \u00e4quivalent ist.", "solution": "true"}, {"text": "Im SQL-Standard sind keine \"dirty reads\" m\u00f6glich.", "solution": "false"}, {"text": "F\u00fchrt eine Transaktion eine Anfrage mehrfach aus, so k\u00f6nnen u.a. \"lost updates\", \"non repeatable reads\" und \"phantome\" auftreten.", "solution": "false"}]}, {"id": 1057, "category": 10, "difficulty": 3, "text": "Welche Aussagen sind \u00fcber CONSTRAINTS und Trigger in SQL sind wahr?", "explanation": "MANDATORY-CONSTRAINTS gibt es gar nicht. \n\nDie Fehlerkorrektur beschr\u00e4nkt sich bei Oracle auf die ON DELETE/UPDATE-Klausel bei den Fremdschl\u00fcsseln, wo man Masterdatens\u00e4tze l\u00f6schen bzw. \u00e4ndern kann. Weitergehende Fehlerkorrektur ist dann nur mittels Triggern m\u00f6glich. \n\nAlle IMMEDIATE-Constraints lassen sich mittels Trigger simulieren, aber nicht die DEFERRED-Constraints. Was fehlt ist ein Trigger zum COMMIT-Ereignis. \n\nRICHTIG sind: \n\"Transitionale Integrit\u00e4tsbedingungen k\u00f6nnen in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Referenzvariablen (:OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.\"", "type": "multiple-choice", "answers": [{"text": "F\u00fcr im ER-Modell als \"obligatorisch\" (Pflichteingabe) deklarierte Attribute werden im Datenmodell MANDATORY-CONSTRAINTS definiert.", "solution": "false"}, {"text": "Transitionale Integrit\u00e4tsbedingungen k\u00f6nnen in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Transitionsvariablen (Referenzvariablen, :OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.", "solution": "true"}, {"text": "MIT ORACLE-CONSTRAINTS k\u00f6nnen alle Fehler korrigiert werden, die beim Einf\u00fcgen von Daten entstehen.", "solution": "false"}, {"text": "MIT ORACLE-CONSTRAINTS k\u00f6nnen alle Fehler korrigiert werden, die beim L\u00f6schen von Daten entstehen.", "solution": "false"}, {"text": "Alles, was sich mit CONSTRAINTs pr\u00fcfen l\u00e4\u00dft, l\u00e4\u00dft sich auch mittels Oracle-Triggern programmieren.", "solution": "false"}]}, {"id": 1058, "category": 11, "difficulty": 2, "text": "Mit welchem Befehl kann man in SQL eine Transaktion beenden?", "explanation": "RICHTIG sind:\nCOMMIT f\u00fcr das persistente Abspeichern der Datenmanipulationen der Transaktion nach erfolgreicher DEFERRED-Integrit\u00e4tspr\u00fcfung. \n\nROLLBACK f\u00fcr das Zur\u00fcckrollen der Datenmanipulationen der Transaktion (R\u00fcckg\u00e4ngigmachen). \n\nFALSCH sind: \nEOT und END_OF_TRANSACTION: Es gibt zwar einen Begin of Transaktion-Befehl (START TRANSACTION) und es gibt ein implizites Begin of Transaktion-Ereignis, wenn dieser Befehl nicht abgesetzt wird: das letzte ausgef\u00fchrte COMMIT, aber ein EOT etc. gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "COMMIT", "solution": "true"}, {"text": "EOT", "solution": "false"}, {"text": "END_OF_TRANSACTION", "solution": "false"}, {"text": "ROLLBACK", "solution": "true"}]}, {"id": 1127, "category": 8, "difficulty": 3, "text": "Woraus k\u00f6nnen Selektionspr\u00e4dikate bestehen?", "explanation": "Bestandteile eines Selektionspr\u00e4dikats sind: \n1. Attribute einer Relation und Konstanten als Operanden, \n2. Vergleichsoperatoren = <, \u2264, >, \u2265 , <> und != (ungleich), \n3. die logischen Operatoren UND, ODER und NICHT und \n4. Berechnungen mit Konstanten und Spaltenwerten (z.B. Gehalt*1,.045)  \n5. eine beliebige Kombination aus den oben genannten M\u00f6glichkeiten, die durch Klammerung (..) erzeugt wird.", "type": "multiple-choice", "answers": [{"text": "Konstanten", "solution": "true"}, {"text": "Join-Operatoren", "solution": "false"}, {"text": "Attributen", "solution": "true"}, {"text": "Vergleichsoperatoren", "solution": "true"}, {"text": "Dom\u00e4nen", "solution": "false"}]}, {"id": 1066, "category": 9, "difficulty": 3, "text": "Mit welcher PL/SQL-Prozedur liest man einen BFILE-Datentyp ein?", "explanation": "BFILENAME(\"VERZEICHNIS\", \"DATEI\") liest eine Datei aus einem Verzeichnis auf dem Datenbankserver in eine Variable vom Typ BFILE ein.", "type": "text", "answers": [{"text": "Das ist (Name der Prozedur ohne Klammern)", "solution": "BFILENAME"}]}, {"id": 1074, "category": 1, "difficulty": 1, "text": "Wie nennt man ein Softwaresystem zur Verwaltung einer Datenbasis?", "explanation": "Ein DBS (Datenbanksystem) besteht aus zwei Teilen: dem Datenbankmanagementsystem (DBMS) und der Menge der zu verwaltenden Daten, der eigentlichen Datenbank. \nDas DBMS organisiert intern die strukturierte Speicherung der Daten und kontrolliert alle lesenden und schreibenden Zugriffe auf die Datenbank. \nZur Abfrage und Verwaltung der Daten bietet ein Datenbanksystem eine Datenbanksprache an.", "type": "text", "answers": [{"text": "Das ist ein (Abk\u00fcrzung)", "solution": "DBMS"}]}, {"id": 1068, "category": 9, "difficulty": 3, "text": "Welche Datentypen k\u00f6nnen mit ROLLBACK zur\u00fcckgerollt werden?", "explanation": "Alle Datentypen, die in der Datenbank selber gespeichert werden, d.h. alle au\u00dfer BFILE, der nur einen Zeiger auf ein Verzeichnis beinhaltet, haben diese Eigenschaft.", "type": "multiple-choice", "answers": [{"text": "BLOB", "solution": "true"}, {"text": "keine dieser Typen", "solution": "false"}, {"text": "LONG RAW", "solution": "true"}, {"text": "BFILE", "solution": "false"}]}, {"id": 1075, "category": 1, "difficulty": 1, "text": "Welche Typen von Datenbanken gibt es?", "explanation": "Eine m\u00f6gliche Einteilung der Datenbanken basiert auf der Art der Anwendung. Datenbanken werden in kommerzielle, betriebswirtschaftlich/administrativ ausgerichtete Standardsysteme und neuartige Systeme unterschieden. Kommerzielle Datenbanken sind durch gut formatierte Datenbest\u00e4nde und die Verwendung von Standardsystemen gekennzeichnet. Neben diesen Datenverwaltungssystemen geh\u00f6ren auch noch Recherchesysteme zur Suche in gro\u00dfen, unformatierten Datenbest\u00e4nden zu den kommerziellen Datenbanksystemen.\n\nNeuartige Anwendungen sind durch komplexe Datentypen, Multimediadatentypen und die Anforderungen, die sich aus einer objektorientierten Analyse ergeben (z.B. Vererbung, Kapselung von Methoden), gekennzeichnet. Typische Anwendungsfelder\nsind Geoinformationssysteme, Multimediadatenbanken oder die Unterst\u00fctzung technischer\nAnwendungen. \n\nEine andere Einteilung ist die Typisierung von Datenbanksystemen \u00fcber das Datenmodell. Ein Datenmodell ist eine festgelegte Struktur mit eigenen Begriffen, nach der Daten und ihre Beziehungen untereinander gespeichert werden. Man unterscheidet historisch gesehen zwischen hierarchischen Datenmodellen, Netzwerkdatenmodellen, relationalen Datenmodellen und objektorientierten Datenmodellen.", "type": "multiple-choice", "answers": [{"text": "Hierarchische Datenbanken", "solution": "true"}, {"text": "Grafische Datenbanken", "solution": "false"}, {"text": "Relationale Datenbanken", "solution": "true"}, {"text": "Objektorientierte Datenbanken", "solution": "true"}, {"text": "Parse-Datenbanken", "solution": "false"}, {"text": "Netzwerkdatenbanken", "solution": "true"}]}, {"id": 1078, "category": 8, "difficulty": 3, "text": "Mit welchem Operator der relationalen Algebra l\u00e4\u00dft sich der Theta-Join simulieren?", "explanation": "Alle Join-Operationen sind aus kartesischem Produkt, Selektion und ggf. Projektion ableitbar. \nWobei f\u00fcr den Theta-Join das kartesische Produkt mit einer anschlie\u00dfenden Selektion ausreichend ist. \nEine zus\u00e4tzliche Projektion wird nur noch beim Natural Join ben\u00f6tigt. \nDer Theta-Join ist der Join mit der allgemeinsten Bedingung, so dass er durch andere Joins (Equi, Natural, Left, Right, Full Outer) nicht simuliert werden kann.", "type": "multiple-choice", "answers": [{"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "mit keinem anderen Operator der relationalen Algebra", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Selektion", "solution": "true"}, {"text": "Natural Join", "solution": "false"}]}, {"id": 1084, "category": 9, "difficulty": 3, "text": "Welche CREATE-Anweisungen gibt es unter ORACLE-SQL und SQL2003?", "explanation": "TABLE (Tabelle), INDEX (Index), SEQUENCE (Nummerngenerator), VIEW (Sicht) und Benutzer (USER) sind eigenst\u00e4ndige DB-Objekte mit eigenen DDL-Befehlen wie CREATE, ALTER, DROP. \nEin ADMIN kann auch nicht explizit mit CREATE erzeugt werden. Man kann einem beliebigen USER Administrator-Rechte geben, dann hat dieses die Funktionalit\u00e4t eines Admins. \nCONSTRAINTs sind keine eigenst\u00e4ndigen DB-Objekte, es gibt keinen eigenen CREATE-Befehl f\u00fcr sie. Sie geh\u00f6ren zu genau einer Tabelle und k\u00f6nnen bei einem CREATE/ALTER/DROP TABLE angelegt oder gel\u00f6scht werden.", "type": "multiple-choice", "answers": [{"text": "INDEX", "solution": "true"}, {"text": "CONSTRAINTS", "solution": "false"}, {"text": "TABLE", "solution": "true"}, {"text": "VIEW", "solution": "true"}, {"text": "USER", "solution": "true"}, {"text": "ADMIN", "solution": "false"}, {"text": "SEQUENCE", "solution": "true"}]}, {"id": 1085, "category": 9, "difficulty": 3, "text": "Welcher PL/SQL-Blocktyp wird ausschlie\u00dflich auf dem Datenbankserver eingesetzt?", "explanation": "PL/SQL unterscheidet f\u00fcnf Typen von Bl\u00f6cken: Ein anonymer Block ist ein unbenannter PL/SQL-Block, der in einer Anwendung (Prozedur, Funktion ) eingebettet ist oder interaktiv eingegeben wird. Eine Stored Procedure ist ein benannter PL/SQL-Block, der Parameter haben kann und als Prozedur oder Funktion definiert ist. Er wird im Datenbanksystem gespeichert und auf dem Server von der PL/SQL-Engine ausgef\u00fchrt. Stored Functions geben \u00fcber RETURN einen Wert an das aufrufende Programm zur\u00fcckEin PACKAGE ist ein benannter PL/SQL-Block, der logisch verwandte Prozeduren und Funktionen, Deklarationen etc. zu einer Bibliothek zusammenfasst. Ein Datenbanktrigger ist ein PL/SQL-Block, der zu einem definierten Ereignis (INSERT, UPDATE oder DELETE) automatisch vom Datenbankmanagementsystem aktiviert und ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "ein Datenbanktrigger", "solution": "true"}, {"text": "eine \"stored Procedure\"", "solution": "true"}, {"text": "ein anonymer Block", "solution": "false"}, {"text": "ein Package", "solution": "true"}, {"text": "ein Funktion", "solution": "true"}]}, {"id": 1089, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft die Klausel unter ORACLE, die eine eingebettete Tabelle erzeugt?", "explanation": "Mit NESTED TABLE <Tabellenwertige Spalte> STORE AS Tabellenname k\u00f6nnen tabellenwertige Spalten beschrieben werden. F\u00fcr jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher innerenTabelle die tabellenwertigen Spalten abgelegt werden.", "type": "text", "answers": [{"text": "Das ist", "solution": "NESTED TABLE"}]}, {"id": 1126, "category": 8, "difficulty": 2, "text": "Wie hei\u00dft der Wertebereich eines Attributs?", "explanation": "Sei (A1,..., An) eine Menge von Attributen mit den Wertebereichen Mi. Die Elemente der Mi sind Basisdatentypen und beschreiben die Werte, die die Attribute annehmen k\u00f6nnen. \nDie Wertebereiche Mi hei\u00dfen Dom\u00e4nen. Dom\u00e4nen sind atomar, d.h. keine zusammengesetzten Datentypen. Bei der Definition von Dom\u00e4nen muss angegeben werden, ob NULL-Werte, also einzelne Attribute ohne Werteintrag, zugelassen sind. Eine Dom\u00e4ne kann auch eine festgelegte\nMenge von Werten aus den obigen Basisdatentypen sein.", "type": "text", "answers": [{"text": "Das ist eine", "solution": "Dom\u00e4ne"}]}, {"id": 1128, "category": 8, "difficulty": 1, "text": "Bei der Division R % S m\u00fcssen die Attribute von S in den Attributen von R enthalten sein.", "explanation": "Wir betrachten zwei Relationen R und S. Die Attribute von S sollen in den Attributen von R enthalten sein. Die Attribute der Ergebnismenge der Division entsprechen der Differenzmenge X der Attribute von R und S: \nDie Division R \u00f7 S besteht aus allen Tupeln x aus X, so dass die folgenden beiden Bedingungen f\u00fcr jedes x aus X gelten: \n1. Zu jedem s aus S gibt es eine Fortsetzung r aus R, so dass die Projektion von r auf S gleich s ist. \n2. Die Projektion von r auf X stimmt mit x \u00fcberein.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1130, "category": 7, "difficulty": 1, "text": "Eine Relation, die die Entity-Integrit\u00e4t besitzt, hat", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt.", "type": "multiple-choice", "answers": [{"text": "einen oder keinen Prim\u00e4rschl\u00fcssel.", "solution": "false"}, {"text": "genau einen Prim\u00e4rschl\u00fcssel.", "solution": "true"}, {"text": "einen oder mehrere Prim\u00e4rschl\u00fcssel.", "solution": "false"}]}, {"id": 1131, "category": 5, "difficulty": 1, "text": "Welche Vorteile haben k\u00fcnstliche Schl\u00fcssel?", "explanation": "K\u00fcnstliche Schl\u00fcssel werden zum schnelleren Suchen benutzt und sind kein Abbild eines realen Attributs.", "type": "multiple-choice", "answers": [{"text": "Einfacher Indexaufbau", "solution": "true"}, {"text": "Besseres Abbild der Realit\u00e4t", "solution": "false"}, {"text": "Schnelleres Suchen", "solution": "true"}]}, {"id": 1132, "category": 8, "difficulty": 1, "text": "Die Differenz ist kommutativ.", "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind kommutativ (vertauschbar), die Differenz aber nicht. \nEs macht sehr wohl einen semantischen Unterschied, ob man die \"Artikel ohne Rechnungen\" oder die \"Rechnungen ohne Atrikel\" anfragt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1133, "category": 8, "difficulty": 1, "text": "Die Division ist kommutativ.", "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind kommutativ (vertauschbar), die Division aber nicht. \nEs macht sehr wohl einen semantischen Unterschied, ob man die \"Kunden, die alle Artikel gekauft haben\" oder die \"Artikel, die von allen Kunden gekauft wurden\" anfragt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1134, "category": 8, "difficulty": 2, "text": "Bei welcher Join-Operation m\u00fcssen die Join-Attribute vom Namen her \u00fcbereinstimmen?", "explanation": "Die Join-Attribute der beiden betroffenen Relationen m\u00fcssen nicht den gleichen Namen haben, au\u00dfer beim Natural-Join: In diesem Fall m\u00fcssen die Join-Attribute den gleichen Namen haben.", "type": "multiple-choice", "answers": [{"text": "Theta-Join", "solution": "false"}, {"text": "Equi-Join", "solution": "false"}, {"text": "Natural Join", "solution": "true"}, {"text": "Outer Join", "solution": "false"}]}, {"id": 1136, "category": 9, "difficulty": 1, "text": "Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden r\u00fcckwirkend alle in der Datenbank vorhanden Daten gepr\u00fcft, ob sie dem CONSTRAINT gen\u00fcgen. Falls dies nicht der Fall ist, kann das CONSTRAINT nicht erzeugt werden.", "explanation": "Genau das ist der 100% Schutz, den Datenbanksysteme bei Constraints bieten. Wenn man in der USER_CONSTRAINTS des Dictionary sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabh\u00e4ngig vom Zeitpunkt der Speicherung korrekt sind. \nDas ist einer der Punkte, bei dem sich Integrit\u00e4tspr\u00fcfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden nur f\u00fcr alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1137, "category": 10, "difficulty": 3, "text": "Das Mutating-Table-Problem hat als Ursache", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "multiple-choice", "answers": [{"text": "Sicherstellung der Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung", "solution": "true"}, {"text": "keine dieser Ursachen", "solution": "false"}, {"text": "die mangelhafte Priorit\u00e4tensteuerung von Triggern", "solution": "false"}, {"text": "den fehlerhaften Einsatz eines Statement-Triggers", "solution": "false"}, {"text": "die kaskadierenden Triggern", "solution": "true"}]}, {"id": 1138, "category": 10, "difficulty": 2, "text": "In BEFORE-Triggern sind keine DML-Operationen zul\u00e4ssig", "explanation": "In ORACLE-SQL f\u00fchrt uner Umst\u00e4nden dies zum Mutating-Table-Problem, ist aber zul\u00e4ssig.", "type": "multiple-choice", "answers": [{"text": "in ORACLE-SQL", "solution": "false"}, {"text": "in DB2-SQL", "solution": "true"}]}, {"id": 1139, "category": 9, "difficulty": 1, "text": "Mit welcher Methode der Klasse DriverManager erzeugt man eine Connection-Schnittstelle?", "explanation": "Beim Aufruf von getConnection wird f\u00fcr alle registrierten Treiber (Class.ForName(\"DBDriver\")) der Reihe nach der gew\u00fcnschte Verbindungsaufbau getestet. Der erste Treiber, der erfolgreich getestet wurde, wird verwendet und das Connection-Objekt, welches die Verbindung realisiert, wird zur\u00fcckgegeben.", "type": "text", "answers": [{"text": "Die Methode hei\u00dft (ohne Klammern)", "solution": "getConnection"}]}, {"id": 1140, "category": 9, "difficulty": 3, "text": "Mit welcher Methode der Klasse Driver Manager werden alle registrierten Treiber nach dem gew\u00fcnschten Verbindungsaufbau getestet?", "explanation": "Beim Aufruf von getConnection wird f\u00fcr alle registrierten Treiber (Class.ForName(\"DBDriver\")) der Reihe nach der gew\u00fcnschte Verbindungsaufbau getestet. Der erste Treiber, der erfolgreich getestet wurde, wird verwendet und die Connection-Objekt, das die Verbindung realisiert, wird zur\u00fcckgegeben.", "type": "text", "answers": [{"text": "Das ist (ohne Klammern)", "solution": "getConnection"}]}, {"id": 1731, "category": 9, "difficulty": 2, "text": "Welche der folgenden SQL-Statements ist syntaktisch korrekt?", "explanation": "Bei \"revoke select from public on test;\" hat die falsche Reihenfolge der Schl\u00fcsselw\u00f6rter.", "type": "multiple-choice", "answers": [{"text": "revoke select on test from public;", "solution": "true"}, {"text": "revoke select from public on test;", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1142, "category": 9, "difficulty": 3, "text": "In welchen SQL-Statements k\u00f6nnen SEQUENCES angewendet werden ?", "explanation": "Eine Sequenz generiert eine fortlaufende Nummer. H\u00e4ufigste Einsatzgebiete sind Abfragen (SELECT) oder Zuweisungen (INSERT, UPDATE). Dort kann an der Stelle eines Spaltennamens oder einer Konstante der Aufruf des n\u00e4chsten Nummernwertes erfolgen mit .NEXTVAL. \nGrunds\u00e4tzlich lie\u00dfe sich eine Sequenz auch in einem DELETE in der WHERE-Klausel anwenden , wenn es den semantisch sinnvoll w\u00e4re.", "type": "multiple-choice", "answers": [{"text": "INSERT", "solution": "true"}, {"text": "SELECT", "solution": "true"}, {"text": "UPDATE", "solution": "true"}]}, {"id": 1732, "category": 9, "difficulty": 1, "text": "Mit welcher ORACLE-SQL-Funktion kann man aus einem String ein St\u00fcck ausschneiden?", "explanation": "SUBSTR(spalteA, 1, 7) liefert die ersten 7 Zeichen des Inhalts von spalteA zur\u00fcck.\nSUBSTR(spalteA, LENTGH(spalteA, 3) liefert die letzten 3 Zeichen des Inhalts von spalteA zur\u00fcck.\nINSTR sucht eine gegebene Zeichenfolge in einem String und gibt dessen Position zur\u00fcck.", "type": "multiple-choice", "answers": [{"text": "INSTR", "solution": "false"}, {"text": "SUBSTR", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 1733, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft unter ORACLE eine spezielle Tabellenart, in der jeder Datensatz als Objekt gespeichert wird?", "explanation": "Das ist die Definition einer Objekttabellen. Neben Objettabellen gibt es noch Tupeltabellen, bei denen jede Spalte einen eigenen Datentyp hat, der auch selbstdefiniert sein kann.", "type": "text", "answers": [{"text": "Das ist eine (in deutsch schreiben, ohne Bindestriche)", "solution": "Objekttabelle"}]}, {"id": 1734, "category": 9, "difficulty": 2, "text": "Mit welcher ORACLE-SQL-Funktion kann man innerhalb eines Strings nach einer Zeichenfolge suchen?", "explanation": "INSTR sucht eine gegebene Zeichenfolge in einem String und gibt dessen Position zur\u00fcck.\nSELECT INSTR(bemerkung, 'zahlungsfreudig') FROM kunden;\nGibt f\u00fcr jeden Kundendatensatz die Position der Wortes 'zahlungsfreudig' an.  \n\nSUBSTR schneidet aus einem Datenwert (1. Parameter) ab einer \u00fcbergebenen Position (2. Parameter) eine Zeichenkette bestimmter L\u00e4nge (3. Parameter) ab und gibt sie zur\u00fcck.\nSUBSTR(spalteA, 1, 7) liefert die ersten 7 Zeichen des Inhalts von spalteA zur\u00fcck.\nSUBSTR(spalteA, LENTGH(spalteA, 3) liefert die letzten 3 Zeichen des Inhalts von spalteA zur\u00fcck.", "type": "multiple-choice", "answers": [{"text": "SUBSTR", "solution": "false"}, {"text": "INSTR", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 1773, "category": 9, "difficulty": 1, "text": "Aus welchen verschiedenen Komponenten bestehen Packages?", "explanation": "Pakete (PACKAGES) sind Oracle-Datenbankobjekte, mit denen logisch in Verbindung stehende Programmkonstrukte, wie\n\nProzeduren,\nFunktionen,\nCURSOR,\nVariablen und Konstanten sowie\nEXCEPTIONS \n\n\nzu einer Einheit zusammengefasst werden.  \nIm BODY-Teil eines PACKAGES wird der Source-Code der zugeh\u00f6rigen Module abgelegt, im Header werden die Komponenten des Packages definiert.", "type": "multiple-choice", "answers": [{"text": "Body", "solution": "true"}, {"text": "Soul", "solution": "false"}, {"text": "Header", "solution": "true"}, {"text": "Feet", "solution": "false"}]}, {"id": 1737, "category": 9, "difficulty": 2, "text": "Welche Kollektionstypen gibt es unter ORACLE?", "explanation": "Objekt-Tabellen und Typen sind keine Kollektionen.", "type": "multiple-choice", "answers": [{"text": "VARRAYS", "solution": "true"}, {"text": "NESTED TABLES", "solution": "true"}, {"text": "OBJEKT -Tabellen", "solution": "false"}, {"text": "OBJEKT-Typen", "solution": "false"}]}, {"id": 1775, "category": 9, "difficulty": 2, "text": "Welche Isolationsgrade kennt JDBC im Zusammenhang mit der Transaktionsverwaltung?", "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "TRANSACTION_SERIALIZABLE", "solution": "true"}, {"text": "TRANSACTION_YES", "solution": "false"}, {"text": "TRANSACTION_NONE", "solution": "true"}, {"text": "TRANSACTION_WRITE_COMMITTED", "solution": "false"}, {"text": "TRANSACTION_NO_SERIALIZABLE", "solution": "false"}]}, {"id": 1776, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber SQLJ sind wahr?", "type": "multiple-choice", "answers": [{"text": "SQLJ-Quelltext-Dateien besitzen per Konvention die Endung sqlj.", "solution": "true"}, {"text": "SQLJ unterst\u00fctzt die Ausf\u00fchrung von SQL-DML-Anweisungen (SELECT, INSERT, UPDATE, DELETE), nicht aber von SQL-DDL-Anweisungen (CREATE, ALTER, DROP,).", "solution": "false"}, {"text": "Um aus SQLJ-Code ausf\u00fchrbaren Code zu erhalten, wird zuerst der Java-Compiler auf dem SQLJ-Code ausgef\u00fchrt und Java-Code mit JDBC-Aufrufen erzeugt, der dann noch vom SQLJ-Translator in ausf\u00fchrbare Class-Files \u00fcbersetzt wird.", "solution": "false"}, {"text": "In SQLJ-Programmen k\u00f6nnen Default-Verbindungen, sog. Default-Kontexte, aufgebaut werden.", "solution": "true"}, {"text": "Host-Variablen sind SQL-Variablen, die in der jeweiligen Host-Sprache, z.B. Java, verwendet werden k\u00f6nnen. Mit ihrer Hilfe k\u00f6nnen Daten zwischen SQL und der Host-Programmiersprache ausgetauscht werden.", "solution": "false"}, {"text": "Der Verbindungskontext spezifiziert die Datenbank mit den assoziierten Schemata und die Verbindungsinformationen.", "solution": "true"}, {"text": "Mehrere Verbindungskontexte k\u00f6nnen gleichzeitig instanziiert und genutzt werden.", "solution": "true"}]}, {"id": 1777, "category": 9, "difficulty": 3, "text": "Was passiert bei der Registrierung von Java Stored Procedures in der Datenbank?", "explanation": "\n    ist noch nicht da.", "type": "multiple-choice", "answers": [{"text": "Der zugeh\u00f6rige SQL-Name wird dem DBMS bekannt gemacht.", "solution": "true"}, {"text": "Es werden die SQL-Datentypen der Parameter bekannt gemacht.", "solution": "true"}, {"text": "Es wird ein jar.Archiv erstellt und in die Datenbank geladen.", "solution": "false"}]}, {"id": 1778, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Java Stored-Procedures sind wahr?", "explanation": "null", "type": "multiple-choice", "answers": [{"text": "Es kann auf das lokale Dateisystem zugegriffen werden.", "solution": "false"}, {"text": "Es k\u00f6nnen GUI-Funktionen ausgef\u00fchrt werden.", "solution": "false"}, {"text": "Es k\u00f6nnen SQL-Befehle wie SELECT, INSERT, UPDATE und DELETE ausgef\u00fchrt werden.", "solution": "true"}, {"text": "Es kann, \u00fcber die explizite Angabe des Kontextes, auf andere Datenbanksysteme zugegriffen werden.", "solution": "false"}, {"text": "Es sind statische Java-Methoden.", "solution": "true"}, {"text": "Sie k\u00f6nnen aus SQL-Statements heraus aufgerufen werden, ebenso wie aus Triggern, PL/SQL-Funktionen und -Prozeduren.", "solution": "true"}]}, {"id": 1788, "category": 7, "difficulty": 1, "text": "Eine Relation in der ersten Normalform mit nur einem Prim\u00e4rschl\u00fcsselattribut ist automatisch in der zweiten Normalform.", "explanation": "Das Gegebensein der 1. NF ist Grundvoraussetzung f\u00fcr die 2. NF. \nWenn ein Prim\u00e4rschl\u00fcssel nur aus Attribut besteht, dann sind alle abh\u00e4ngigen Attribute zwingend voll funktional abh\u00e4ngig. Partiell abh\u00e4ngig hie\u00dfe ja, dass Nichtschl\u00fcsselattribute nur von einer Teilmenge der Attribute abh\u00e4ngig w\u00e4ren, was bei nur einem Attribut des Prim\u00e4rschl\u00fcssels nicht geht.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1790, "category": 8, "difficulty": 1, "text": "Der Vereinigung als Mengenoperation der relationalen Algebra entspricht unter SQL", "explanation": "Die Mengenoperatoren der Relationalen Algebra lassen sich mit folgenden SQL-Operatoren implementieren: \n\nRA -SQL:\nVereinigung - UNION\nDifferenz - EXCEPT / MINUS\nDurchschnitt - INTERSECTION", "type": "multiple-choice", "answers": [{"text": "INTERSECT", "solution": "false"}, {"text": "UNION", "solution": "true"}, {"text": "MINUS", "solution": "false"}]}, {"id": 1800, "category": 8, "difficulty": 2, "text": "SQL ist eine Sprache der", "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.", "type": "multiple-choice", "answers": [{"text": "ersten Generation", "solution": "false"}, {"text": "zweiten Generation", "solution": "false"}, {"text": "dritten Generation", "solution": "false"}, {"text": "vierten Generation", "solution": "true"}]}, {"id": 1798, "category": 7, "difficulty": 1, "text": "Welche Aussagen \u00fcber Normalformen sind wahr?", "explanation": "Richtig ist: \"Jede 1NF-Relation mit einem Prim\u00e4rschl\u00fcssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 2NF.\" \nWenn ein Prim\u00e4rschl\u00fcssel nur aus einem Attribut besteht, wie soll es da eine partielle Abh\u00e4ngigkeit geben? Partielle hei\u00dft ja, dass einige Nichtschl\u00fcsselattribute nur von Teilen des Prim\u00e4rschl\u00fcssels abh\u00e4ngig sind, was bei einem Schl\u00fcssel mit nur einen Attribut ja ausgeschlossen ist. \nFalsch ist: \"Jede 1NF-Relation mit einem Prim\u00e4rschl\u00fcssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 3NF.\"\nGegenbeispiel: A->B,C und B->C und einer Relation R(A (PK),B,C).\n\nFalsch ist: \"Bei der \u00dcberf\u00fchrung in die dritte Normalform sind die vorher zu erstellende 2NF-Relationen immer von den endg\u00fcltigen 3NF-Relationen verschieden.\" \nWenn es keine transitiven Abh\u00e4ngigkeiten gibt, dann gilt: 2. NF = 3. NF und damit sind die Relationen gleich in beiden NFs.", "type": "multiple-choice", "answers": [{"text": "Jede 1NF-Relation mit einem Prim\u00e4rschl\u00fcssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 2NF.", "solution": "true"}, {"text": "Jede 1NF-Relation mit einem Prim\u00e4rschl\u00fcssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 3NF.", "solution": "false"}, {"text": "Bei der \u00dcberf\u00fchrung in die dritte Normalform sind die vorher zu erstellende 2NF-Relationen immer von den endg\u00fcltigen 3NF-Relationen verschieden.", "solution": "false"}]}, {"id": 1799, "category": 7, "difficulty": 2, "text": "Das Versicherungsb\u00fcro Schutzengel hat die Daten \u00fcber Versicherungspolicen in einer Relation \nVertraege(Vertrags_Nr, Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision) \ngespeichert, wobei die Vertrags_Nr der Prim\u00e4rschl\u00fcssel dieser Relation ist.\n\nBei der \u00dcberf\u00fchrung in eine Normalform entstehen die Relationen Kunden, Vertraege und Vertragsarten.", "explanation": "Aus der Relation lassen Vertraege(Vertrags_Nr, Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision) lassen sich folgende funktioanle Abh\u00e4ngigkeiten ableiten: \nVertrags_Nr -> Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision \nweil Vertrags_Nr einziges Prim\u00e4rschk\u00fcsselattribut ist \nKunden_NR -> Kundenname, Kundenadresse  \nVertragsart -> Abschlussprovision \nBei den beiden Abh\u00e4ngigkeiten von Kunden_NR und Vertragsart handelt es sich um transitive Abh\u00e4ngigkeiten, da diese wiederum von Kunden_NR abh\u00e4ngig sind. \nUnd daraus ergeben sich dann folgende drei Relationen: \nKunden (Kunden_NR (PK), Kundenname, Kundenadresse)  \nVertragsarten (Vertragsart (PK), Abschlussprovision) \nVertraege (Vertrags_Nr (PK), Vertragsart, Betrag, Kunden_NR)", "type": "multiple-choice", "answers": [{"text": "Es handelt sich um eine \u00dcberf\u00fchrung in die 1NF.", "solution": "false"}, {"text": "Es handelt sich um eine \u00dcberf\u00fchrung in die 3NF.", "solution": "true"}, {"text": "Es handelt sich um eine \u00dcberf\u00fchrung in die 2NF.", "solution": "false"}]}, {"id": 1801, "category": 8, "difficulty": 1, "text": "Java ist eine Sprache der", "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.", "type": "multiple-choice", "answers": [{"text": "zweiten Generation", "solution": "false"}, {"text": "ersten Generation", "solution": "false"}, {"text": "dritten Generation", "solution": "true"}, {"text": "vierten Generation", "solution": "false"}]}, {"id": 1805, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber (nicht-)identifizierende Beziehungen sind wahr?", "explanation": "Bei identifizierenden Beziehungen wird in der Detail-Entitymenge der Fremdschl\u00fcssel zum Prim\u00e4rschl\u00fcssel hinzugenommen, bei nicht identifizierenden Beziehungen wird der Fremdschl\u00fcssel nur als Attribut eingetragen, welches nicht zum Prim\u00e4rschl\u00fcssel der Relation geh\u00f6rt. Der Grund f\u00fcr den Ausschluss idendifizierender Beziehungen bei k\u00fcnstlichen Prim\u00e4rschl\u00fcsseln liegt darin, dass k\u00fcnstliche Prim\u00e4rschl\u00fcssel per Definition nur aus einem Attribut bestehen d\u00fcrfen.", "type": "multiple-choice", "answers": [{"text": "Es gibt fixe, anwendungsunabh\u00e4ngige Regeln, die f\u00fcr alle Anwendungsf\u00e4lle vorgeben, wann eine identifizierende und wann eine nicht identifizierende Beziehung zu verwenden ist.", "solution": "false"}, {"text": "Bei identifizierenden Beziehungen treten die Prim\u00e4rschl\u00fcsselattribute der Master-Entity-Menge als Fremdschl\u00fcssel-Attribute im Prim\u00e4rschl\u00fcssel bei der Detail-Entity-Menge auf.", "solution": "true"}, {"text": "Bei nicht-identifizierenden Beziehungen treten die Prim\u00e4rschl\u00fcsselattribute der Detail-Entity-Menge nur als \"einfache\" Fremdschl\u00fcssel-Attribute bei der Master-Entity-Menge auf.", "solution": "false"}, {"text": "Verf\u00fcgen die an einer 1:cn-Beziehung beteiligten Entity-Mengen allesamt \u00fcber k\u00fcnstliche Prim\u00e4rschl\u00fcssel, dann sind nur nicht-identifizierenden Beziehungen zugelassen.", "solution": "true"}, {"text": "Eine 1:c1-Beziehung kann als identifizierende verwendet werden, wenn die Master-Entity-Menge einen k\u00fcnstlichen Prim\u00e4rschl\u00fcssel hat und die Detail-Entity-Menge keinen eigenen Prim\u00e4rschl\u00fcssel, sondern nur den k\u00fcnstlichen, vererbten \u00fcber die identif. 1:c1-Beziehung.", "solution": "true"}]}, {"id": 1803, "category": 9, "difficulty": 3, "text": "Betrachten Sie die Tabelle Angestellte(Ang_Nr, Nachname, Jahresgehalt). \nEs werden die Angestellten gesucht, die das h\u00f6chste Jahresgehalt haben. Welche Abfrage liefert das gew\u00fcnschte Ergebnis?", "explanation": "Die Abfrage \nSELECT nachname, max(jahresgehalt)\nFROM angestellte\nGROUP by nachname;\nist syntaktisch korrekt, aber nicht semantisch, da die h\u00f6chsten Jahresgeh\u00e4lter je Nachname berechnet werden.\n\nAnsonsten kann das Ergebnis \u00fcber \"where jahresgehalt >= ALL(...)\"berechnet werden.", "type": "multiple-choice", "answers": [{"text": "SELECT ang_nr\nFROM angestellte\nWHERE jahresgehalt > all ;", "solution": "false"}, {"text": "SELECT max( all jahresgehalt)\nFROM angestellte;", "solution": "false"}, {"text": "SELECT nachname, max(jahresgehalt)\nFROM angestellte\nGROUP by nachname;", "solution": "false"}, {"text": "SELECT nachname, max(jahresgehalt) \nFROM angestellte;", "solution": "false"}, {"text": "SELECT a.nachname, a.jahresgehalt\nFROM angestellte a\nWHERE a.jahresgehalt = max(jahresgehalt);", "solution": "false"}, {"text": "SELECT ang_nr, jahresgehalt\nfrom angestellte\nwhere jahresgehalt = (SELECT max(jahresgehalt) from angestellte);", "solution": "true"}, {"text": "SELECT ang_nr\nFROM angestellte\nwhere jahresgehalt > ALL(\nSELECT jahresgehalt from angestellte)", "solution": "false"}, {"text": "select ang_nr, jahresgehalt\nFROM angestellte\nwhere jahresgehalt >= ALL(\nSELECT jahresgehalt from angestellte);", "solution": "true"}]}, {"id": 1804, "category": 9, "difficulty": 2, "text": "Betrachten Sie die Tabelle Angestellte(Ang_Nr, Nachname, Jahresgehalt) und die Tabelle Kurse(Kurs, Ang_NR, Anzahl). Es werden die Angestellten gesucht, die meisten Kurse abgehalten haben. Welche Abfrage liefert das gew\u00fcnschte Ergebnis?", "explanation": "Diese Anfrage kann nur \u00fcber eine Unterabfrage beantwortet werden; in den anderen Abfragen ist die Gruppenfunktion SUM falsch verwendet.", "type": "multiple-choice", "answers": [{"text": "SELECT nachname\nFROM angestellte\nWHERE ang_nr = (SELECT SUM(ang_nr)\nFROM kurse\nGROUP BY  k.ang_nr);", "solution": "false"}, {"text": "SELECT  a.ang_nr, a.Nachname, SUM(anzahl)\nFROM    angestellte a , kurse b\nWHERE a.ang_nr = b.ang_nr\nGROUP BY a.ang_nr, Nachname\nHAVING SUM(anzahl)  >= ALL\n       (SELECT SUM(anzahl)\n        FROM    angestellte a , kurse b\n        WHERE a.ang_nr = b.ang_nr\n        GROUP BY a.ang_nr);", "solution": "true"}, {"text": "SELECT SUM(anzahl), a.nachname\nFROM angestelltea, kurse b,\nWHERE a.ang_nr = b.ang_nr\nGROUP BY a.nachname\nORDER BY SUM(b.anzahl) DESC ;", "solution": "false"}]}, {"id": 1806, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber nicht identifizierende Beziehungen in ER-Diagrammen sind richtig?", "explanation": "Bei identifizierenden Beziehungen wird in der Detail-Entitymenge der Fremdschl\u00fcssel zum Prim\u00e4rschl\u00fcssel hinzugenommen, bei nicht identifizierenden Beziehungen wird der Fremdschl\u00fcssel nur als Attribut eingetragen, welches nicht zum Prim\u00e4rschl\u00fcssel der Relation geh\u00f6rt.", "type": "multiple-choice", "answers": [{"text": "Die Attribute des Prim\u00e4rschl\u00fcssels der Master-Tabelle treten als Prim\u00e4rschl\u00fcsselattribute in der Detail-Tabelle auf.", "solution": "false"}, {"text": "Die Attribute des Prim\u00e4rschl\u00fcssels der Master-Entitymenge treten als Nichtschl\u00fcsselattribute in der Detail-Tabelle auf.", "solution": "true"}, {"text": "Die Inhalte des Prim\u00e4rschl\u00fcssels der Master-Entitymenge stellen einen dynamischen Wertebereich f\u00fcr die zugeh\u00f6rigen Fremdschl\u00fcsselattribute der Detail-Entitymenge dar.", "solution": "true"}, {"text": "Die Attribute des Prim\u00e4rschl\u00fcssels der Detail-Entitymenge treten als Prim\u00e4rschl\u00fcsselattribute in der Master-Entitymenge auf.", "solution": "false"}]}, {"id": 1774, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber JDBC sind wahr?", "explanation": "Innerhalb eines ResultSets kann mann auch \u00fcber den Spaltennamen auf die \nErgebnismenge einer DB-Anfrage zugreifen.", "type": "multiple-choice", "answers": [{"text": "Die JDBC-API ist zu 100% in Java geschrieben und damit plattformunabh\u00e4ngig.", "solution": "true"}, {"text": "Ein \"native protocol pure Java\u0094 Treiber ist komplett in Java implementiert und kommuniziert direkt mit dem Datenbankmanagementsystem. Er ist Applet-f\u00e4hig.", "solution": "true"}, {"text": "Ein \"native API partly Java\" Treiber ist clientseitig komplett in Java implementiert und verwendet ein DBMS-unabh\u00e4giges Netzwerkprotokoll f\u00fcr die Kommunikation mit dem Applicationserver; der die Anweisungen dann in ein DB-Protokoll \u00fcbersetzt und an das DBMS weiterleitet.", "solution": "false"}, {"text": "Innerhalb der Datens\u00e4tze der Ergebnismenge einer DB-Anfrage kann mittels verschiedener Methodenaufrufe wie z.B. first(), previous(), hin und her navigiert werden.", "solution": "true"}, {"text": "Auf die einzelnen Spalten innerhalb der Ergebnismenge einer DB-Anfrage kann nur mittels Spaltennummern zugegriffen werden.", "solution": "false"}]}, {"id": 1730, "category": 9, "difficulty": 3, "text": "Welche der folgenden INSERT -Ausdr\u00fccke in die Teile-Tabelle  sind syntaktisch und semantisch korrekt, wenn die Teile-Tabelle durch das folgende CREATE-Table-Statement angelegt wird:\n\nCREATE TABLE TEILE\n( TNR NUMBER(38) NOT NULL,\n  BEZEICHNUNG VARCHAR2(50) NOT NULL,\n  TYP VARCHAR2(50),\n  MINDESTBESTAND NUMBER,\n  BESTAND NUMBER,\n  ZEITSTEMPEL DATE,\n  CONSTRAINT pruefe_bestand CHECK (Bestand >= Mindestbestand )\n);", "explanation": "Bei einem INSERT-Befehl m\u00fcssen alle Spalten, die mit NOT-NULL angelegt wurden, auch mit einem Wert versorgt werden,", "type": "multiple-choice", "answers": [{"text": "INSERT INTO Teile\n(TNR, BEZEICHNUNG, TYP, MINDESTBESTAND, BESTAND, ZEITSTEMPEL)\nVALUES  (33,  \"Dynamo\", \"Material\", 15, 20, \"01.01.2000\");", "solution": "true"}, {"text": "keiner von allen", "solution": "false"}, {"text": "INSERT INTO Teile\n       (TNR, BEZEICHNUNG, TYP, MINDESTBESTAND, BESTAND, ZEITSTEMPEL)\nVALUES  (3333,  \"Dynamo\", \"Material\", 20, 15, \"01.01.2000\");", "solution": "false"}, {"text": "INSERT INTO Teile (TNR, TYP, BEZEICHNUNG)\nVALUES  (\"33\", \"fremd\", Dynamo);", "solution": "true"}, {"text": "INSERT INTO Teile\nVALUES  (33, \"kg\", \"Dynamo\",  \"Material\", 20, 15;", "solution": "false"}, {"text": "INSERT INTO Teile (TNR, TYP, BEZEICHNUNG)\nVALUES  (33, \"Material\", \"Dynamo\");", "solution": "true"}, {"text": "INSERT INTO Teile (TYP, BEZEICHNUNG)\nVALUES  (\"Material\", \"Dynamo\");", "solution": "false"}, {"text": "INSERT INTO Teile (TNR, TYP)\nVALUES  (\"33\", \"Material\");", "solution": "false"}]}, {"id": 1482, "category": 9, "difficulty": 2, "text": "Was verbirgt sich hinter der Abk\u00fcrzung NDS in PL/SQL?", "explanation": "In PL/SQL kann nur SQL-Manipulationsanweisungen, aber keine DDL-Anweisungen wie CREATE, ALTER, DROP etc.,keine DCL wie GRANT, REVOKE etc. und keine SESSION CONTROL-Anweisungen wie ALTER SESSION\nverarbeiten. Einen Ausweg aus dieser Situation bietet dynamisches SQL unter PL/SQL mit NDS, dem Native Dynamic SQL. Die auszuf\u00fchrende SQL-Anweisung wird ohne abschlie\u00dfendes Semikolon als Zeichenkette oder in einer Textvariablen dem Befehl EXECUTE IMMEDIATE \u00fcbergeben, der diesen Text ungepr\u00fcft zur Ausf\u00fchrung an das Datenbankmanagementsystem sendet. Der Befehl EXECUTE IMMEDIATE selbst wird aber mit einem Semikolon abgeschlossen.", "type": "text", "answers": [{"text": "Das ist:", "solution": "Native Dynamic SQL"}]}, {"id": 801, "category": 8, "difficulty": 3, "text": "Welcher Optimierungsvorgang transformiert einen algebraischen Ausdruck der relationalen Algebra auf einen semantisch \u00e4quivalenten Ausdruck?", "explanation": "Bei der logischen Optimierung wird ein algebraischer Ausdruck der relationalen Algebra auf einen semantisch \u00e4quivalenten Ausdruck transformiert, der weniger Laufzeit ben\u00f6tigt. Je weniger Tupel die Zwischenergebnismengen haben, umso schneller ist die Anfrageauswertung.", "type": "text", "answers": [{"text": "Dies ist die ...", "solution": "logische Optimierung"}]}, {"id": 807, "category": 7, "difficulty": 3, "text": "Welche Vorteile hat eine Normalisierung von Relationen?", "explanation": "Es soll insgesamt ein \"gutes\" Datenbankschema entstehen, wobei sich die G\u00fcte misst in \nleichterer Handhabbarkeit, m\u00f6glichst wenig Redundanzen und  \u00dcbersichtlichkeit. \nDemgegen\u00fcber kennzeichnen sich schlechte Datenbankschemata durch: Redundanzen, die zu unn\u00f6tigem Speicherplatzverbrauch f\u00fchren.\u00c4nderungsanomalien: Bei \u00c4nderungen muss der gleiche Wert an mehreren Stellen aktualisiert werden.Einf\u00fcgeanomalien: Bereits vorhandene Daten werden an anderer Stelle wiederholt eingef\u00fcgt.L\u00f6schanomalien: Die Daten m\u00fcssen an mehreren Stellen gel\u00f6scht werden.Hohe Fehleranf\u00e4lligkeit: Die Fehlerh\u00e4ufigkeit ist erh\u00f6ht, da bei diesen \u00c4nderungen Daten anfallen k\u00f6nnen, die nicht alle auf den gleichen Stand gebracht wurden.", "type": "multiple-choice", "answers": [{"text": "Einf\u00fcgeanomalien werden vermieden", "solution": "true"}, {"text": "Inkonsistenzen treten nicht auf", "solution": "true"}, {"text": "\u00c4nderungsanomalien werden vermieden", "solution": "true"}, {"text": "Speicherplatzverbrauch wird reduziert.", "solution": "true"}, {"text": "Das Konzept der Objektorientierung wird umgesetzt.", "solution": "false"}]}, {"id": 1153, "category": 10, "difficulty": 1, "text": "Sobald ein Datenbanktrigger erzeugt und aktiviert wird, werden r\u00fcckwirkend alle in der Datenbank vorhanden Daten gepr\u00fcft, ob sie dem Trigger gen\u00fcgen. Falls dies nicht der Fall ist, kann der Trigger nicht erzeugt werden.", "explanation": "Die Eigenschaft, dass r\u00fcckwirkend die Daten kontrolliert werden, haben nur Constraints. Das f\u00fchrt dazu, dass man keinen Constraint anlegen kann, wenn die bestehenden Daten nicht der in dem Constraint enthaltenen Bedingung gen\u00fcgen. F\u00fcr Trigger ist das nicht der Fall. Um die Kontrolle, die im Trigger enthalten ist, auszuf\u00fchren, muss der Trigger angesto\u00dfen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1154, "category": 1, "difficulty": 1, "text": "Zu welcher Ebene einer Datenbankarchitektur geh\u00f6rt die Transaktionsverwaltung?", "explanation": "Eine Folge von Lese- und Schreibzugriffen, die als Einheit ausgef\u00fchrt werden m\u00fcssen, wird als Transaktion bezeichnet. Transaktionsverwaltung und Scheduler, wenn mehrere Personen gleichzeitig mit dem Datenbanksystem arbeiten, m\u00fcssen einen Multiuser-Betrieb und die Synchronisation paralleler Transaktionen erm\u00f6glichen. Diese Aufgabe \u00fcbernimmt der Scheduler.", "type": "multiple-choice", "answers": [{"text": "1. Ebene: Verarbeitung von Benutzereingaben", "solution": "false"}, {"text": "2. Ebene: Anfrageverarbeitung", "solution": "false"}, {"text": "3. Ebene: Zugriffsstrukturen und Codeerzeugung", "solution": "false"}, {"text": "4. Ebene: Synchronisation paralleler Zugriffe", "solution": "true"}, {"text": "5. Ebene: Speicherverwaltung", "solution": "false"}]}, {"id": 808, "category": 7, "difficulty": 1, "text": "Eine vollst\u00e4ndige Normalisierung hat den Nachteil, dass es Performanceverluste beim Lesen durch eine gro\u00dfe Anzahl von Relationen geben kann.", "explanation": "Durch die Normalisierung ergibt sich bei gr\u00f6\u00dferen Projekten eine Vielzahl von mit Fremdschl\u00fcsselbeziehungen verbundenen Relationen. Informationen, die inhaltlich im Sinne der Objektorientierung zusammengeh\u00f6ren, werden unter Umst\u00e4nden auf viele Relationen verteilt. Bei Abfragen kann es zu erheblichen Performanceverlusten kommen, da oft viele Relationen aufw\u00e4ndig miteinander verkn\u00fcpft werden m\u00fcssen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1155, "category": 8, "difficulty": 3, "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass jeder Wert eines Fremdschl\u00fcssels einer Relation Wert eines Prim\u00e4rschl\u00fcssel in einer anderen Relation ist.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrit\u00e4t, wenn jeder Wert eines Fremdschl\u00fcssels einer Relation Ri Wert eines Prim\u00e4rschl\u00fcssels in einer anderen Relation Rj ist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt.", "type": "text", "answers": [{"text": "Diese Eigenschaft hei\u00dft", "solution": "Referentielle Integrit\u00e4t"}]}, {"id": 814, "category": 9, "difficulty": 3, "text": "Mit welcher Aktion (Option des CONSTRAINTs REFERENCES/FOREIGN KEY) kann man in ORACLE-SQL wie auch im SQL-Standard kaskadierendes L\u00f6schen abbilden?", "explanation": "F\u00fcr das Fremdschl\u00fcssel-Constraint (REFERNCES/FOREIGN KEY) gibt es folgende Option: \n<Fehlerkorrektur Definition> ::= \nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n\nHintergrund der Problematik ist, dass wenn eine Fremdschl\u00fcsselbeziehung besteht, das L\u00f6schen von Datens\u00e4tzen, die referenziert werden, problematisch ist.\n\nON DELETE Die definierte Fehlerkorrekturoption wird ausgef\u00fchrt, wenn der referenzierte Master-Datensatz gel\u00f6scht wird.\nON UPDATE Die definierte Fehlerkorrekturoption wird ausgef\u00fchrt, wenn der Wert des referenzierten Schl\u00fcsselattributs in der Master-Tabelle ge\u00e4ndert wird.\nCASCADE Die Detaildatens\u00e4tze, deren Fremdschl\u00fcssel den manipulierten Master-Datensatz referenzieren, werden ebenfalls gel\u00f6scht (kaskadierendes L\u00f6schen) bzw. deren Schl\u00fcsselwert wird entsprechend ge\u00e4ndert (kaskadierendes \u00c4ndern). \nSET DEFAULT Die Fremdschl\u00fcsselspalten des Detaildatensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf den f\u00fcr diese Spalte definierten DEFAULT-Wert gesetzt.\nSET NULL Die Fremdschl\u00fcsselspalten des Detail-Datensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf NULL gesetzt.\nNO ACTION/RESTRICT Auf den Integrit\u00e4tsfehler wird je nach Pr\u00fcfungszeitpunkt mit dem Zur\u00fcckrollen der gesamten Transaktion bzw. der fehlerhaften DML-Anweisung reagiert (Reaktion wie bei den anderen CONSTRAINTS auch).", "type": "text", "answers": [{"text": "Der Ausdruck hei\u00dft", "solution": "ON DELETE CASCADE"}]}, {"id": 815, "category": 9, "difficulty": 3, "text": "Mit welcher Aktion (Option der CONSTRAINT REFERENCES-Klausel des CREATE/ALTER-TABLE-Befehls) kann man in ORACLE und beim SQL-Standard bei einer DELETE-Anweisung erreichen, dass NULL-Werte in abh\u00e4ngige Spalten eingetragen werden?", "explanation": "Hintergrund der Problematik ist, dass das L\u00f6schen von Datens\u00e4tzen, die referenziert werden, problematisch ist, wenn eine Fremdschl\u00fcsselbeziehung besteht. \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION \n\n\nON DELETE: Die definierte Fehlerkorrekturoption wird ausgef\u00fchrt, wenn der referenzierte Master-Datensatz gel\u00f6scht wird.\nON UPDATE: Die definierte Fehlerkorrekturoption wird ausgef\u00fchrt, wenn der Wert des referenzierten Schl\u00fcsselattributs in der Master-Tabelle ge\u00e4ndert wird.\nCASCADE: Die Detaildatens\u00e4tze, deren Fremdschl\u00fcssel den manipulierten Master-Datensatz referenzieren, werden ebenfalls gel\u00f6scht kaskadierendes L\u00f6schen) bzw. deren Schl\u00fcsselwert wird entsprechend ge\u00e4ndert (kaskadierendes \u00c4ndern).\nSET DEFAULT: Die Fremdschl\u00fcsselspalten des Detaildatensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf den f\u00fcr diese Spalte definierten DEFAULT-Wert gesetzt.\nSET NULL: Die Fremdschl\u00fcsselspalten des Detail-Datensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf NULL gesetzt.\nNO ACTION: Auf den Integrit\u00e4tsfehler wird je nach Pr\u00fcfungszeitpunkt mit dem Zur\u00fcckrollen der gesamten Transaktion bzw. der fehlerhaften DML-Anweisung reagiert (Reaktion wie bei den anderen CONSTRAINTS auch).\nRESTRICT: Diese Option ist analog zur NO ACTION-Funktionalit\u00e4t zu sehen.", "type": "text", "answers": [{"text": "Der Ausdruck hei\u00dft", "solution": "ON DELETE SET NULL"}]}, {"id": 816, "category": 9, "difficulty": 3, "text": "Wo findet man unter ORACLE den Source-Code einer View, auf den jeder Benutzer Zugriff hat und in der nur die Views eingetragen sind, die dem Benutzer selber geh\u00f6ren?", "explanation": "Das Dictionary von Oracle umfasst eine Vielzahl von Tabellen bzw. Sichten und u.a. auch die USER_VIEWS f\u00fcr den Code einer Sichtdefinition. \nDie Dictionary -Tabellen/Sichten sind in verschiedene Gruppen aufgeteilt, die im Namen deutlich werden:\nUSER_...: Sichten f\u00fcr alle DB-Objekte, die ein Benutzer selbst angelegt hat.\nALL_...: Sichten f\u00fcr alle DB-Objekte, die ein Benutzer selbst angelegt hat bzw. f\u00fcr die er von anderen Anwendern Zugriffsrechte vergeben bekommen hat.\nDBA_...: Sichten f\u00fcr alle DB-Objekte, die \u00fcberhaupt in der Datenbank existieren. Auf diese Sichten hat nur ein Benutzer mit Administrationsrechten Zugriff.\nV$-Views: Sichten mit statistischen Informationen.", "type": "text", "answers": [{"text": "Die Data-Dictionary-View hei\u00dft", "solution": "USER_VIEWS"}]}, {"id": 822, "category": 9, "difficulty": 1, "text": "Was versteht man unter transitionalen Integrit\u00e4tsbedingungen?", "explanation": "Transitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel aus der Fahrrad-Welt Byce & Co. w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber \nDatenbanktrigger realisieren.", "type": "multiple-choice", "answers": [{"text": "Diesen Begriff gibt es nicht.", "solution": "false"}, {"text": "Das sind Bedingungen, die Transaktionen abbilden.", "solution": "false"}, {"text": "Das sind Bedingungen bei denen der alte und der neue Zustand eines Datensatzes oder gar eine Folge von solchen Zustands\u00fcberg\u00e4ngen kontrolliert wird.", "solution": "true"}]}, {"id": 819, "category": 7, "difficulty": 3, "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass die Korrektheit der Eingaben der Benutzer gew\u00e4hrleistet ist.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die semantische Integrit\u00e4t, wenn die Korrektheit der Eingaben der Benutzer gew\u00e4hrleistet ist.", "type": "text", "answers": [{"text": "Das ist die ...", "solution": "semantische Integrit\u00e4t"}]}, {"id": 823, "category": 8, "difficulty": 2, "text": "Welche Schl\u00fcsselbegriffe gibt es nicht in der relationalen Algebra?", "explanation": "Eine Attributkombination L wird eindeutiger Schl\u00fcssel der Relation R1(A1,...An) genannt, wenn \n1. L \u2192 (A1,...,An) und \n2. (A1,...,An) von keiner echten Teilmenge von L funktional abh\u00e4ngig ist. \nIn jeder Relation wird genau ein eindeutiger Schl\u00fcssel zum Prim\u00e4rschl\u00fcssel (primary key, Hauptschl\u00fcssel) erkl\u00e4rt, \u00fcber den die Tupel der Relation eindeutig identifiziert werden k\u00f6nnen. Ein Prim\u00e4rschl\u00fcssel ist immer obligatorisch und darf keine NULL-Werte haben. \nZus\u00e4tzlich k\u00f6nnen in einer Relation zur Beschleunigung des Zugriffs bestimmte Attribute zu Zweitschl\u00fcsseln ernannt werden. Anders als beim Prim\u00e4rschl\u00fcssel m\u00fcssen die Zweitschl\u00fcssel weder eindeutig sein noch sind NULL-Werte verboten. Es werden Indizes in Hilfstabellen erstellt, \u00fcber die der schnellere Zugriff auf die Attribute des Zweitschl\u00fcssels m\u00f6glich ist.  \n\nDie \u00fcbrigen Schl\u00fcsselbegriffe gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "Indexschl\u00fcssel", "solution": "true"}, {"text": "Prim\u00e4rschl\u00fcssel", "solution": "false"}, {"text": "Eindeutiger Schl\u00fcssel", "solution": "false"}, {"text": "Zweitschl\u00fcssel", "solution": "false"}, {"text": "Fremdschl\u00fcssel", "solution": "false"}, {"text": "Drittschl\u00fcssel", "solution": "true"}]}, {"id": 1156, "category": 9, "difficulty": 2, "text": "Welche Komponente von SQLJ erstellt SQLJ-Profile ?", "type": "multiple-choice", "answers": [{"text": "Translator", "solution": "true"}, {"text": "Customizer", "solution": "false"}, {"text": "Laufzeitsystem", "solution": "false"}]}, {"id": 828, "category": 9, "difficulty": 1, "text": "Wozu geh\u00f6rt der Ausdruck \"START WITH\" in Standard-SQL?", "explanation": "Hier ein Beispiel f\u00fcr eine Sequenz:\n\n    Betrachten Sie die folgende Definition einer Sequenz:\n\n    CREATE SEQUENCE Kun_seq\n\n    INCREMENT BY 1\n\n    START WITH 1\n\n    NOMAXVALUE\n\n    NOCYCLE\n\n    CACHE 10;\n\n    \n\n    CONNECT BY geh\u00f6rt nicht zum Standard-SQL.", "type": "multiple-choice", "answers": [{"text": "CREATE SEQUENCE", "solution": "true"}, {"text": "CONNECT BY", "solution": "false"}, {"text": "Diesen Ausdruck gibt es nicht.", "solution": "false"}]}, {"id": 829, "category": 9, "difficulty": 1, "text": "Die Programmierung einer rekursiven Anfrage mittels CONNECT-BY-Klausel ist ORACLE-spezifisch.", "explanation": "Die Programmierung einer rekursiven Anfrage mittels CONNECT BY-Klausel ist ORACLE-spezifisch. In SQL gibt es daf\u00fcr eine WITH RECURSIVE-Klausel, mit der rekursive tempor\u00e4re Hilfssichten programmiert werden k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1157, "category": 9, "difficulty": 3, "text": "Welche drei grundlegenden Komponenten hat SQLJ ? Bitte in alphabetischer Reihenfolge eintragen!", "type": "text", "answers": [{"text": "Komponente 1", "solution": "Customizer"}, {"text": "Komponente 2", "solution": "Laufzeitsystem"}, {"text": "Komponente 3", "solution": "Translator"}]}, {"id": 832, "category": 9, "difficulty": 1, "text": "PL/SQL wird immer beim SERVER ausgef\u00fchrt.", "explanation": "PL/SQL ist eine Oracle-spezifische prozedurale Erweiterung von SQL, die auf ADA basiert. Sie stellt somit eine M\u00f6glichkeit dar, die mengenorientierten SQL-DML-Anweisungen Datensatz f\u00fcr Datensatz zu verarbeiten. PL/SQL kann sowohl beim Server als auch beim Client ausgef\u00fchrt werden. Findet die Ausf\u00fchrung auf dem Server statt, dann handelt es sich um in der Datenbank gespeicherte Prozeduren und Funktionen, die durch externe Aufrufe (RPC Remote Procedure\nCall) angesto\u00dfen werden oder \u00fcber Datenbanktrigger. PL/SQL-Aufrufe k\u00f6nnen alternativ auch beim Client verarbeitet werden. In diesem Fall wird der PL/SQL-Programmcode auf der Client-Seite bearbeitet und das Ergebnis dem Oracle-Datenbank-Server \u00fcbergeben.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 836, "category": 9, "difficulty": 1, "text": "Die kleinste Einheit eines PL/SQL-Programms", "explanation": "Die kleinste Einheit von PL/SQL ist ein sogenannter PL/SQL-Block, der aus bis zu drei PL/SQL-Abschnitten bestehen kann. \n\nDer Deklarationsabschnitt  enth\u00e4lt Deklarationen von benutzerdefinierten Datentypen, Variablen, Konstanten, CURSOR und\nbenutzerdefinierte EXCEPTIONS, Unterprozedurenund -funktionen und ist optional. \nDer Ausf\u00fchrungsabschnitt   enth\u00e4lt PL/SQL-Anweisungen und bestimmte SQL-Anweisungen\nwie INSERT, UPDATE, DELETE, SELECT,\nCOMMIT, ROLLBACK und ist obligatorisch. \n\nDer Fehlerbehandlungsabschnitt   gibt an, welche Aktionen ausgef\u00fchrt werden sollen, wenn im Ausf\u00fchrungsabschnitt  Fehler auftreten und ist optional.", "type": "text", "answers": [{"text": "hei\u00dft", "solution": "Block"}]}, {"id": 834, "category": 9, "difficulty": 1, "text": "Mit welchen Zeichen beginnen in PL/SQL einzeilige Kommentare?", "explanation": "Wie in anderen Programmiersprachen auch, k\u00f6nnen in PL/SQL an jeder beliebigen Stelle Kommentare untergebracht werden. Das doppelte Minuszeichen \"--\" wird verwendet, um einzeilige Kommentare einzuf\u00fcgen und die beiden Zeichen /* */ begrenzen einen mehrzeiligen Kommentar.", "type": "text", "answers": [{"text": "Das sind die Zeichen", "solution": "--"}]}, {"id": 835, "category": 9, "difficulty": 1, "text": "In PL/SQL k\u00f6nnen sich Kommentare wie in JAVA oder C auch \u00fcber mehrere Zeilen erstrecken.", "explanation": "Wie in anderen Programmiersprachen auch, k\u00f6nnen in PL/SQL an jeder beliebigen\nStelle Kommentare untergebracht werden. Das doppelte Minuszeichen \"--\" wird verwendet,\num einzeilige Kommentare einzuf\u00fcgen und die beiden Zeichen /* */\nbegrenzen einen mehrzeiligen Kommentar.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "false"}, {"text": "stimmt", "solution": "true"}]}, {"id": 838, "category": 9, "difficulty": 2, "text": "Welcher PL/SQL-Abschnitt ist optional?", "explanation": "Die kleinste Einheit von PL/SQL ist ein sogenannter PL/SQL-Block, der aus bis zu drei PL/SQL-Abschnitten bestehen kann. \n\nDer Deklarationsabschnitt  enth\u00e4lt Deklarationen von benutzerdefinierten Datentypen, Variablen, Konstanten, CURSOR und\nbenutzerdefinierte EXCEPTIONS, Unterprozedurenund -funktionen und ist optional. \nDer Ausf\u00fchrungsabschnitt   enth\u00e4lt PL/SQL-Anweisungen und bestimmte SQL-Anweisungen\nwie INSERT, UPDATE, DELETE, SELECT,\nCOMMIT, ROLLBACK und ist obligatorisch. \n\nDer Fehlerbehandlungsabschnitt   gibt an, welche Aktionen ausgef\u00fchrt werden sollen, wenn im Ausf\u00fchrungsabschnitt  Fehler auftreten und ist optional.", "type": "multiple-choice", "answers": [{"text": "Deklarationsteil", "solution": "true"}, {"text": "Ausf\u00fchrungsteil", "solution": "false"}, {"text": "Fehlerbehandlungsteil", "solution": "true"}]}, {"id": 1158, "category": 9, "difficulty": 3, "text": "Welche Komponente von SQLJ passt die SQLJ-Profile an die Datenbank an, damit herstellerspezifische Dialekte verwendet werden k\u00f6nnen?", "type": "text", "answers": [{"text": "Das ist der", "solution": "Customizer"}]}, {"id": 840, "category": 9, "difficulty": 2, "text": "Welche Kategorien von PL/SQL-Bl\u00f6cken gibt es?", "explanation": "PL/SQL unterscheidet vier Typen von Bl\u00f6cken: \n\nEin Anonymer Block ist ein unbenannter PL/SQL-Block, der in einer Anwendung (Prozedur, Funktion ) eingebettet ist oder interaktiv eingegeben wird. \nEine Stored Routine ist ein benannter PL/SQL-Block, der Parameter haben kann und als Prozedur oder Funktion definiert ist. Er wird im Datenbanksystem gespeichert und auf dem Server von der PL/SQL-Engine ausgef\u00fchrt. \nEin PACKAGE ist ein benannter PL/SQL-Block, der logisch verwandte Prozeduren und Funktionen, Deklarationen etc. zu einer Bibliothek zusammenfasst. \nEin Datenbanktrigger ist ein PL/SQL-Block, der zu einem definierten Ereignis (INSERT, UPDATE oder DELETE) automatisch vom Datenbankmanagementsystem aktiviert und ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "Anonyme Bl\u00f6cke", "solution": "true"}, {"text": "Pakete", "solution": "true"}, {"text": "Funktionen", "solution": "true"}, {"text": "Prozeduren", "solution": "true"}, {"text": "Datenbanktrigger", "solution": "true"}]}, {"id": 877, "category": 9, "difficulty": 1, "text": "Benannte PL/SQL-Bl\u00f6cke (anonyme ausgeschlossen)  werden kompiliert in der Datenbank gespeichert.", "explanation": "Der in die Oracle-DB integrierte Compiler pr\u00fcft die Syntax und sichert den \u00fcbersetzten Code in der Datenbank ab, damit er bei Aufrufen direkt zur Verf\u00fcgung steht.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 843, "category": 9, "difficulty": 1, "text": "Welcher Parametertyp entspricht unter PL/SQL der DEFAULT-Einstellung?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. Bei IN OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "OUT", "solution": "false"}, {"text": "IN OUT", "solution": "false"}]}, {"id": 1694, "category": 11, "difficulty": 2, "text": "Welche Aussagen \u00fcber \"Transaktionen und Integrit\u00e4tspr\u00fcfung in SQL\" sind richtig?", "explanation": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integrit\u00e4tspr\u00fcfung erkannt, so wird NICHT die gesamte Transaktion zur\u00fcckgerollt, sondern nur die fehlerhafte Datenmanipulation.\n\nWird vom DBMS ein Fehler bei der DEFERRED-Integrit\u00e4tspr\u00fcfung erkannt, so wird die gesamte Transaktion zur\u00fcckgerollt, denn die DEFERRED-Bedingungen werden ja erst zum Transaktionsende gepr\u00fcft.\n\nIMMEDIATE bezeichnet die Integrit\u00e4tspr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung des DML-Befehls und DEFERRED erst zum Transaktionsende. \n\nIn SQL gibt es f\u00fcnf CONSTRAINTs mittels denen die Datenintegrit\u00e4t gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.", "type": "multiple-choice", "answers": [{"text": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integrit\u00e4tspr\u00fcfung erkannt, so wird die gesamte Transaktion zur\u00fcckgerollt.", "solution": "false"}, {"text": "Wird vom DBMS ein Fehler bei der DEFERRED-Integrit\u00e4tspr\u00fcfung erkannt, so wird nur der fehlerhafte DML-Befehl zur\u00fcckgerollt.", "solution": "false"}, {"text": "IMMEDIATE bezeichnet die Integrit\u00e4tspr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung des DML-Befehls und DEFERRED erst zum Transaktionsende.", "solution": "true"}, {"text": "In SQL gibt es f\u00fcnf CONSTRAINTs mittels denen die Datenintegrit\u00e4t gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.", "solution": "true"}]}, {"id": 1695, "category": 9, "difficulty": 2, "text": "Ein COLUMN CONSTRAINT kann einen Fremdschl\u00fcssel definieren.", "explanation": "Klar geht das, alle Tabellen- und Spalten-Constraints haben die gleichen Typen (PRIMARY KEY, CHECK, UNIQUE, Fremdschl\u00fcssel) bis auf das [NOT] NULL-Constraint, das gibt es nur bei den Spalten-Constraints. Beim Fremdschl\u00fcssel besteht jedoch der syntaktische Unterschied, dass dieses Constraint als Tabellen-Constraint mit der Option FOREIGN KEY startet und als Spalten-Constraint direkt mit REFERENCES. \n\n ::= \n[ CONSTRAINT Constraintname ]  \n[ <CONSTRAINT Characteristika> ] \n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1713, "category": 9, "difficulty": 3, "text": "Wie hei\u00dfen SELECT-Anweisungen auf die man die Mengenoperationen UNION, INTERSECT und EXCEPT bzw. MINUS anwenden kann?", "explanation": "SELECT-Anweisungen hei\u00dfen <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform , wenn die beteiligten SELECT-Ausdr\u00fccke (UNION, INTERSECT und MINUS) die gleichen Spaltendefinitionen haben, also nicht zwingend gleich hei\u00dfen, sondern nur die Anzahl und die Datentypen und Inhalte kompatibel sind sowie die Reihenfolge \u00fcbereinstimmen.", "type": "text", "answers": [{"text": "Solche Anweisungen hei\u00dfen", "solution": "vereinigungskonform"}]}, {"id": 1697, "category": 9, "difficulty": 2, "text": "Welche CONSTRAINT-Typen gibt es in SQL?", "explanation": "Je nach der Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung) differenziert. \nDen Begriff USER_CONSTRAINTS gibt es nur als Name der Tabelle im Oracle-Data-Dictionary, in der alle angelegten Constraints eingetragen sind, nicht aber als Constraint-Typ. Den Begriff der SEQUENCE CONSTRAINTS gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "SEQUENCE CONSTRAINTS", "solution": "false"}, {"text": "COLUMNS CONSTRAINTS", "solution": "true"}, {"text": "TABLE CONSTRAINTS", "solution": "true"}, {"text": "USER_CONSTRAINTS", "solution": "false"}]}, {"id": 1794, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber Beziehungen in ER-Modellen sind wahr?", "explanation": "Beziehungen beschreiben Aktivit\u00e4ten zwischen Entity-Mengen, nicht zwischen deren Attributen. \nJede Beziehung hat zwei Enden, entsprechend werden sie auch in beiden Richtungen gelesen und f\u00fcr beide Enden die Kardinalit\u00e4ten festgelegt. Am Besten ist es, sie immer in beiden Richtungen zu beschriften, damit man die Kardinalit\u00e4t f\u00fcr jedes Ende gelesen und bestimmt hat. Ein h\u00e4ufig gemachter Fehler ist es, nur eine Richtung zu lesen und nur f\u00fcr eine Richtung die Kardinalit\u00e4t festzulegen. \nRekursive Beziehungen sind m\u00f6glich und werden durch eine Linie von einer Entity-Menge wieder auf sich selbst dargestellt.\nBei einer 1:n- bzw. c:cn-Beziehung wird die Entity-Menge beim 1-Ende als Master bezeichnet und die Entity-Menge beim n-Ende als Detail. \nUnd zwischen zwei Entity-Menen k\u00f6nnen beliebig viele Beziehungen modelliert werden. Die Anzahl h\u00e4ngt ab von der Semantik der Aufgabenstellung.", "type": "multiple-choice", "answers": [{"text": "Beziehungen beschreiben die Aktivit\u00e4ten zwischen Attributen", "solution": "false"}, {"text": "Beziehungen haben nur eine Richtung.", "solution": "false"}, {"text": "Rekursive Beziehungen sind m\u00f6glich.", "solution": "true"}, {"text": "Bei einer 1:n- bzw. c:cn-Beziehung wird die Entity-Menge beim 1-Ende als Master bezeichnet und die Entity-Menge beim n-Ende als Detail.", "solution": "true"}, {"text": "Beziehungen haben nur die Leserichtung von links nach rechts.", "solution": "false"}, {"text": "Zwischen zwei Entity-Mengen k\u00f6nnen mehrere Beziehungen modelliert werden.", "solution": "true"}]}, {"id": 1795, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber Fremdschl\u00fcssel sind wahr?", "explanation": "Nein, m:n bzw. cm:cn-Beziehungen werden nicht als Fremdschl\u00fcssel  bezeichnet. Es sind ie 1:n bzw. c:cn-Beziehungen, die als Fremdschl\u00fcssel bezeichnet werden. \nDie Master-Entitymenge stellt einen Wertebereich f\u00fcr das Fremdschl\u00fcsselattribut bei der Detail-Entitymenge dar. Werden Werte f\u00fcr das Fremdschl\u00fcsselattribut bei der Detail-Entitymenge eingetragen, so m\u00fcssen diese Werte mit Werten aus der Master-Entitymenge \u00fcbereinstimmen. Wenn nicht, kann der Wert der Detail-Entitymenge nicht akzeptiert werden. \nDieser Satz ist falsch: \"Werden Detail-Tupel gel\u00f6scht, so wird vom Datenbankmanagementsystem kontrolliert, ob noch abh\u00e4ngige Master-Tupel existieren.\" Es ist genau anders herum: Wenn Master-Tupel gel\u00f6scht werden, wird gepr\u00fcft, ob noch abh\u00e4ngige Detail-Tupel existieren. Wenn ja, kann der Master nicht gel\u00f6scht werden. \nAuch dieser Satz ist falsch: \"Werden Master-Tupel eingef\u00fcgt, so wird vom Datenbankmanagementsystem kontrolliert, ob bereits passende Detail-Tupel existieren.\" Eine Fremdschl\u00fcssel-Beziehung ist so definiert, dass dieser Sachverhalt v\u00f6llig irrelevant ist. Es kann Master-Tupel geben, ohne zugeh\u00f6rige Detail-Tupel. Aber nicht umgekehrt: Es kann keine Detail-Tupel ohne zugeh\u00f6rige Master-Tupel  geben, wenn das Fremdschl\u00fcsselattribt nicht leer sein darf. Das hat schon rein praktische Gr\u00fcnde, was sollte man den zuerst erfassen, den Master oder den Detail, wenn der eine den anderen vorraussetzt. Das ginge ja gar nicht.", "type": "multiple-choice", "answers": [{"text": "Als Fremdschl\u00fcssel werden m:n bzw. cm:cn-Beziehungen bezeichnet.", "solution": "false"}, {"text": "Die Master-Entitymenge stellt einen Wertebereich f\u00fcr das Fremdschl\u00fcsselattribut bei der Detail-Entitymenge dar.", "solution": "true"}, {"text": "Werden Detail-Tupel gel\u00f6scht, so wird vom Datenbankmanagementsystem kontrolliert, ob noch abh\u00e4ngige Master-Tupel existieren.", "solution": "false"}, {"text": "Werden Master-Tupel eingef\u00fcgt, so wird vom Datenbankmanagementsystem kontrolliert, ob bereits passende Detail-Tupel existieren.", "solution": "false"}]}, {"id": 1807, "category": 7, "difficulty": 2, "text": "Jede Relation, die die Entity-Integrit\u00e4t besitzt hat, hat neben einem Prim\u00e4rschl\u00fcssel auch immer mindestens einen Fremdschl\u00fcssel, wenn mehr als zwei Relationen in der Datenbank vorhanden sind.", "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrit\u00e4t, wenn jeder Wert eines Fremdschl\u00fcssels einer Relation Ri Wert eines Prim\u00e4rschl\u00fcssels in einer anderen Relation Rj ist.  \nEine Menge von Relationen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Relation einen Prim\u00e4rschl\u00fcssel besitzt. \nDas Konzept Prim\u00e4rschl\u00fcssels ist unabh\u00e4ngig von den Fremdschl\u00fcsseln. Es kann Relationen mit Prim\u00e4rschl\u00fcsseln geben (Entity-intregrit\u00e4t) ohne das es Fremdschl\u00fcssel (referentielle Integrit\u00e4t) gibt. Andersherum k\u00f6nnen Fremdschl\u00fcssel nur definiert werden, wenn es Prim\u00e4rschl\u00fcssel gibt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1631, "category": 9, "difficulty": 1, "text": "Auf einer Tabelle A soll ein Fremdschl\u00fcssel mit Bezug auf die Spalte \"Nr\" der Tabelle B definiert werden. Dazu muss auf der Spalte \"Nr\" in B vorher ein Prim\u00e4rschl\u00fcssel oder als UNIQUE KEY angelegt werden.", "explanation": "Spalte A geh\u00f6rt der Detailtabelle an und enth\u00e4lt Werte, die Spaltenwerte in B der Mastertabelle referenzieren. Das kann nur funktionieren, wenn die Werte in A eindeutig einen Datensatz der Mastertabelle referenzieren. Dies wird dadurch gew\u00e4hrleistet, dass die referenzierte Spalte B als PRIMARY oder UNIQUE KEY definiert werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1714, "category": 11, "difficulty": 1, "text": "Eine Transaktion unter SQL ist", "explanation": "Eine SQL-Transaktion ist eine Folge von \u00c4nderungsanweisungen, die aus einer oder mehreren SQL-DML- und DQL-Anweisungen (INSERT, UPDATE, DELETE, SELECT) besteht und \u00fcber die ACID-Eigenschaften verf\u00fcgt. Die Reihenfolge ergibt sich aus dem zeitlichen Ablauf der Ausf\u00fchrung der DML-Anweisungen. \n\nIn der Wissenschaft wird eine Transaktion oft auch als Menge von \u00c4nderungsanweisungen definiert, woraus sich zus\u00e4tziche interessante Aspekte erforschen lassen ;-)", "type": "multiple-choice", "answers": [{"text": "eine Folge von \u00c4nderungen", "solution": "true"}, {"text": "eine Menge von \u00c4nderungen", "solution": "false"}]}, {"id": 1716, "category": 11, "difficulty": 2, "text": "Wie viele Sperrzust\u00e4nde werden beim 2-Phasen-Sperrprotokoll verwendet?", "explanation": "Nur die beiden Zust\u00e4nde LOCK und UNLOCK sind sehr \"grob\" und lassen wenig parallen Zugriff zu, da nicht zwischen \"schreiben\" und \"lesen\" differenziert wird. \nDaher wird mit drei Sperrzust\u00e4nden gearbeitet: \nUNLOCK - entsperrt\nWRITELOCK - exklusiv sperren f\u00fcr einen Schreibzugriff\nREADLOCK - sperren f\u00fcr parallele Lesezugriffe", "type": "multiple-choice", "answers": [{"text": "1", "solution": "false"}, {"text": "2", "solution": "false"}, {"text": "3", "solution": "true"}, {"text": "4", "solution": "false"}]}, {"id": 1715, "category": 11, "difficulty": 3, "text": "Welche Sperren k\u00f6nnen beim 2-Phasen-Sperrprotokoll gesetzt werden?", "explanation": "LOCK ist eine sehr undifferenzierte Sperre, die wenig Parallelit\u00e4t zul\u00e4\u00dft, daher wird sie nicht verwendet. \nVerwendet werden: \nREAD_LOCK hingegen l\u00e4\u00dft paralleles Lesen zu und WRITE_LOCK sorgt f\u00fcr das exclusive Sperren bei Daten\u00e4nderungen/-einf\u00fcgungen. \nUNLOCK gibt die gesetzten Sperren wieder frei.", "type": "multiple-choice", "answers": [{"text": "read_lock", "solution": "true"}, {"text": "write_lock", "solution": "true"}, {"text": "lock", "solution": "false"}, {"text": "unlock", "solution": "true"}]}, {"id": 1718, "category": 11, "difficulty": 2, "text": "Welcher LOCKMODE wird unter ORACLE-SQL automatisch benutzt, wenn ein SELECT ausgef\u00fchrt wird?", "explanation": "Beim SELECT ohne FOR UPDATE-Klausel, wird gar nichts gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten nur angezeigt werden sollen oder wenn \"optimistisches Sperren\" praktiziert wird. \n\nBeim SELECT mit FOR UPDATE-Klausel, werden die selektierten Datens\u00e4tze exklusiv gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten selektiert werden, die anschlie\u00dfend manipuliert werden sollen oder wenn \"pessimistisches Sperren\" praktiziert wird. \n\n\u00dcbersicht \u00fcber automatische Sperren bei ORACLE:\n\nSELECT  -  Keine<\nSELECT FOR UPDATE  -  ROW EXCLUSIV-Sperre f\u00fcr die selektierten\nDatens\u00e4tze\nINSERT  -  ROW EXCLUSIV\nUPDATE  -  ROW EXCLUSIV\nDELETE  -  ROW EXCLUSIV\nALTER TABLE  -  EXCLUSIV", "type": "multiple-choice", "answers": [{"text": "SHARE", "solution": "false"}, {"text": "EXCLUSIV", "solution": "false"}, {"text": "ROW SHARE", "solution": "false"}, {"text": "ROW EXCLUSIV", "solution": "false"}, {"text": "SHARE ROW EXCLUSIV", "solution": "false"}, {"text": "Es wird \u00fcberhaupt kein LOCK gesetzt", "solution": "true"}]}, {"id": 1719, "category": 11, "difficulty": 2, "text": "Welcher LOCKMODE wird unter ORACLE-SQL automatisch benutzt, wenn ein INSERT, UPDATE oder DELETE ausgef\u00fchrt wird?", "explanation": "Beim SELECT ohne FOR UPDATE-Klausel, wird gar nichts gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten nur angezeigt werden sollen oder wenn \"optimistisches Sperren\" praktiziert wird.\n\nBeim SELECT mit FOR UPDATE-Klausel, werden die selektierten Datens\u00e4tze exklusiv gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten selektiert werden, die anschlie\u00dfend manipuliert werden sollen oder wenn \"pessimistisches Sperren\" praktiziert wird.\n\n\u00dcbersicht \u00fcber automatische Sperren bei ORACLE:\n\nSELECT  -  Keine\nSELECT FOR UPDATE  -  ROW EXCLUSIV-Sperre f\u00fcr die selektierten\nDatens\u00e4tze\nINSERT  -  ROW EXCLUSIV\nUPDATE  -  ROW EXCLUSIV\nDELETE  -  ROW EXCLUSIV\nALTER TABLE  -  EXCLUSIV", "type": "multiple-choice", "answers": [{"text": "SHARE", "solution": "false"}, {"text": "EXCLUSIV", "solution": "false"}, {"text": "ROW SHARE", "solution": "false"}, {"text": "ROW EXCLUSIV", "solution": "true"}, {"text": "SHARE ROW EXCLUSIV", "solution": "false"}, {"text": "Es wird \u00fcberhaupt kein LOCK gesetzt", "solution": "false"}]}, {"id": 1720, "category": 11, "difficulty": 3, "text": "Welcher LOCKMODE wird unter ORACLE-SQL automatisch benutzt, wenn ein ALTER TABLE ausgef\u00fchrt wird?", "explanation": "Beim SELECT ohne FOR UPDATE-Klausel, wird gar nichts gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten nur angezeigt werden sollen oder wenn \"optimistisches Sperren\" praktiziert wird.\n\nBeim SELECT mit FOR UPDATE-Klausel, werden die selektierten Datens\u00e4tze exklusiv gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten selektiert werden, die anschlie\u00dfend manipuliert werden sollen oder wenn \"pessimistisches Sperren\" praktiziert wird.\n\n\u00dcbersicht \u00fcber automatische Sperren bei ORACLE:\n\nSELECT  -  Keine<\nSELECT FOR UPDATE  -  ROW EXCLUSIV-Sperre f\u00fcr die selektierten\nDatens\u00e4tze\nINSERT  -  ROW EXCLUSIV\nUPDATE  -  ROW EXCLUSIV\nDELETE  -  ROW EXCLUSIV\nALTER TABLE  -  EXCLUSIV", "type": "multiple-choice", "answers": [{"text": "SHARE", "solution": "false"}, {"text": "EXCLUSIV", "solution": "true"}, {"text": "ROW SHARE", "solution": "false"}, {"text": "ROW EXCLUSIV", "solution": "false"}, {"text": "SHARE ROW EXCLUSIV", "solution": "false"}, {"text": "Es wird \u00fcberhaupt kein LOCK gesetzt.", "solution": "false"}]}, {"id": 1722, "category": 9, "difficulty": 1, "text": "Mit welchem SQL-Befehl \u00e4ndert man Daten?", "explanation": "Mit der UPDATE-Anweisung unter SQL k\u00f6nnen Mengen von Daten oder einzelne Datens\u00e4tze in Tabellen ver\u00e4ndert werden.", "type": "multiple-choice", "answers": [{"text": "SAVE", "solution": "false"}, {"text": "MODIFY", "solution": "false"}, {"text": "UPDATE", "solution": "true"}, {"text": "SAVE AS", "solution": "false"}]}, {"id": 1723, "category": 9, "difficulty": 1, "text": "Mit welcher SQL-Anweisung l\u00f6scht man Daten aus einer Tabelle, ohne die Tabellendefinition zu l\u00f6schen?", "explanation": "Die DROP-Anweisung l\u00f6scht auch die Tabellendefinitionen, die anderen Anweisungen gibt es unter SQL nicht.", "type": "multiple-choice", "answers": [{"text": "REMOVE", "solution": "false"}, {"text": "DELETE", "solution": "true"}, {"text": "DROP", "solution": "false"}, {"text": "COLLAPSE", "solution": "false"}]}, {"id": 1724, "category": 9, "difficulty": 1, "text": "Mit welcher SQL-Anweisung f\u00fcgt man Daten in eine Tabelle ein?", "explanation": "Eine INSERT-Anweisung hat unter SQL immer ein INTO, die anderen Anweisungen gibt es unter SQL nicht.", "type": "multiple-choice", "answers": [{"text": "INSERT INTO", "solution": "true"}, {"text": "INSERT NEW", "solution": "false"}, {"text": "ADD", "solution": "false"}, {"text": "ADD RECORD", "solution": "false"}]}, {"id": 1725, "category": 9, "difficulty": 1, "text": "Wie liest man alle Daten aus einer Tabelle \"Test\" unter Standard-SQL aus?", "explanation": "SELECT * FROM Test ist korrekt,  die anderen Anweisungen entsprechen nicht dem SQL-Standard.", "type": "multiple-choice", "answers": [{"text": "SELECT Test;", "solution": "false"}, {"text": "SELECT * FROM Test;", "solution": "true"}, {"text": "SELECT ALL FROM Test;", "solution": "false"}]}, {"id": 1726, "category": 8, "difficulty": 3, "text": "Wie hei\u00dfen Tupel, die bei einem Natural Join verloren gehen k\u00f6nnen?", "explanation": "Beim nat\u00fcrlichen Join werden diejenigen Tupel, die nur in einer Relation vorkommen, unterdr\u00fcckt. Diese Tupel bezeichnet man auch als \"Dangeling\"-Tupel (dangling tuples).", "type": "text", "answers": [{"text": "Diese Tupel hei\u00dfen (englischsprachiger Begriff, alles kleingeschrieben):", "solution": "dangling tupels"}]}, {"id": 1997, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat der Natural Join der Tabelle Test mit sich selber?", "explanation": "Der Natural Join einer Tabelle mit sich selber ergibt wieder die Ursprungstabelle.", "type": "multiple-choice", "answers": [{"text": "5", "solution": "true"}, {"text": "25", "solution": "false"}, {"text": "3", "solution": "false"}]}, {"id": 1998, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Tupel hat das kartesische Produkt der Tabelle Test mit sich selber?", "explanation": "Beim kartesischen Produkt wird jedes Tupel mit der beteiligten Tabellen miteinander verkn\u00fcpft, im Beispiel ergibt das 5 * 5 = 25 Tupel.", "type": "multiple-choice", "answers": [{"text": "5", "solution": "false"}, {"text": "10", "solution": "false"}, {"text": "25", "solution": "true"}]}, {"id": 1999, "category": 9, "difficulty": 2, "text": "JOIN-Verkn\u00fcpfungen k\u00f6nnen nicht \u00fcber Binary Large Object-Spalten (BLOBS) ausgef\u00fchrt werden.", "explanation": "Der Vergleich \u00fcber Bin\u00e4rwerte ist wohl etwas aufwendig :-).", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2008, "category": 5, "difficulty": 1, "text": "Tern\u00e4re Beziehungen lassen sich immer in bin\u00e4re Beziehungen aufl\u00f6sen, ohne eine Entity-Menge hinzuzuf\u00fcgen.", "explanation": "Um tern\u00e4re Beziehungen in bin\u00e4re Beziehungen aufzul\u00f6sen, braucht man eine zus\u00e4tzliche Entity-Menge.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1957, "category": 9, "difficulty": 2, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr}\n\nAbteilungen hat den Prim\u00e4rschl\u00fcssel Abt_nr und den Fremdschl\u00fcssel Leiter_Ang_Nr.\nAngestellte hat den Prim\u00e4rschl\u00fcssel Ang_nr und den Fremdschl\u00fcssel Abt_Nr.\n\nWelche der folgenden SELECT-Anweisungen liefern das gleiche Ergebnis?", "explanation": "RICHTIG sind: \nDie Anfragen \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ORT = Abteilungen.ORT AND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;\" \nund \n\"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\"\nhaben die gleiche Semantik: \"Welche Mitarbeiter arbeiten im gleichen Ort, in dem sie auch wohnen?\"\n\nOb Fremd-, E\u00edndeutigkeits- oder Prim\u00e4rschl\u00fcssel auf diesen Spalten definiert sind, ist unerheblich f\u00fcr die Ausf\u00fchrung des NATURAL JOINs, dessen Bedingung alle gleich lautenden Spalten auf Gleichheit pr\u00fcft und mit AND verkn\u00fcpft.\n\n\nFALSCH ist: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\".", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;", "solution": "false"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr;", "solution": "true"}, {"text": "SELECT *\nFROM Angestellte NATURAL JOIN Abteilungen;", "solution": "true"}]}, {"id": 2040, "category": 5, "difficulty": 1, "text": "Ein Fremdschl\u00fcssel kann auch rekursiv definiert werden, d.h. der Prim\u00e4rschl\u00fcssel einer Entity-Menge kann als Fremdschl\u00fcssel in der gleichen Entity-Menge verwendet werden.", "explanation": "Diese Rekursivit\u00e4t ist im ER-Modell vorgesehen, auch wenn hier die Frage nach Henne und Ei ungel\u00f6st bleibt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2018, "category": 5, "difficulty": 3, "text": "Ein EERM enth\u00e4lt zus\u00e4tzlich zu den klassischen Beziehungsarten und Dom\u00e4nen", "explanation": "Ein ER-Modell, das zus\u00e4tzlich zu den klassischen Beziehungsarten IS-A-Beziehungen und Aggregation sowie mehrwertige und zusammengesetzte Attribute vorsieht, bezeichnen wir als EERM.", "type": "multiple-choice", "answers": [{"text": "Assoziationen", "solution": "false"}, {"text": "Aggregationen", "solution": "true"}, {"text": "IS-A-Beziehungen", "solution": "true"}, {"text": "mehrwertige Attribute", "solution": "true"}, {"text": "zusammengesetzte Attribute", "solution": "true"}, {"text": "zeitabh\u00e4ngige Attribute", "solution": "false"}, {"text": "IST-Teil-von-Beziehungen", "solution": "true"}]}, {"id": 2044, "category": 8, "difficulty": 1, "text": "Ein Operatorbaum w\u00e4chst", "explanation": "Um Anfragen an einen Datenbestand zu formulieren, k\u00f6nnen Operationen der relationalen Algebra beliebig ineinander geschachtelt werden. Bei komplexen Anfragen ist daher die oben verwendete sogenannte \"Inline-Notation\" schwer lesbar. F\u00fcr diesen Zweck verwendet man Operatorb\u00e4ume statt der Inline-Notation. Bei dieser grafischen Darstellung erstellt und liest man die Abfrage von unten nach oben. Operationen, die miteinander verkn\u00fcpft sind, sind durch Kanten im Graphen miteinander verbunden. Gestartet wird mit den relvanten Relationen als unterster Teil des OP-Baumes.", "type": "multiple-choice", "answers": [{"text": "von unten nach oben", "solution": "true"}, {"text": "von oben nach unten", "solution": "false"}]}, {"id": 2046, "category": 7, "difficulty": 3, "text": "Welche Aussagen \u00fcber Zerlegungen von Relationen sind beim \u00dcbergang in die 2NF bzw. 3NF korrekt?", "explanation": "Wiederherstellbarkeit: Eine Zerlegung einer Relation ist verlustfrei, wenn sich alle Tupel der urspr\u00fcnglichen Relation durch einen Join aus den abgeleiteten Relationen wiederherstellen lassen. Eine verlustfreie Zerlegung stellt damit die Wiederherstellbarkeit der urspr\u00fcnglichen Relation sicher. \nAbh\u00e4ngigkeitswahrung: Die Zerlegung einer Relation ist abh\u00e4ngigkeitstreu, wenn jede funktionale Abh\u00e4ngigkeit der Ausgangsrelation in einer der resultierenden Relationen erhalten bleibt. Eine abh\u00e4ngigkeitstreue Zerlegung stellt damit die Wiederherstellbarkeit der urspr\u00fcnglichen funktionalen Abh\u00e4ngigkeiten sicher. \n  \nEine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "Eine verlustfreie Zerlegung sichert die Wiederherstellbarkeit der urspr\u00fcnglichen Relation.", "solution": "true"}, {"text": "Eine abh\u00e4ngigkeitstreue Zerlegung sichert die Wiederherstellbarkeit der urspr\u00fcnglichen Relation.", "solution": "false"}, {"text": "Eine abh\u00e4ngigkeitstreue Zerlegung sichert die Wiederherstellbarkeit der urspr\u00fcnglichen funktionalen Abh\u00e4ngigkeiten.", "solution": "true"}, {"text": "Eine verlustfreie Zerlegung sichert die Wiederherstellbarkeit der urspr\u00fcnglichen funktionalen Abh\u00e4ngigkeiten.", "solution": "false"}, {"text": "Die 2NF beseitigt alle transitiven Abh\u00e4ngigkeiten", "solution": "false"}, {"text": "Die 3NF beseitigt alle partiellen Abh\u00e4ngigkeiten", "solution": "false"}]}, {"id": 2051, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber Fremdschl\u00fcssel-Beziehungen sind richtig?", "explanation": "Klar geht das, alle Tabellen- und Spalten-Constraints haben die gleichen Typen (PRIMARY KEY, CHECK, UNIQUE, Fremdschl\u00fcssel) bis auf das [NOT] NULL-Constraint, das gibt es nur bei den Spalten-Constraints. Beim Fremdschl\u00fcssel besteht jedoch der syntaktische Unterschied, dass dieses Constraint als Tabellen-Constraint mit der Option FOREIGN KEY startet und als Spalten-Constraint direkt mit REFERENCES. Die Semantik bleibt jedoch in beiden F\u00e4llen gleich \n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ] \n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "Fremdschl\u00fcssel-Constraints k\u00f6nnen nur als Tabellen-Constraints definiert werden.", "solution": "false"}, {"text": "Fremdschl\u00fcssel-Constraints k\u00f6nnen nur als Spalten-Constraints definiert werden.", "solution": "false"}, {"text": "Fremdschl\u00fcssel-Constraints k\u00f6nnen sowohl als Tabellen- wie auch Spalten-Constraint definiert werden.", "solution": "true"}]}, {"id": 1907, "category": 10, "difficulty": 1, "text": "Im SQL-Standard und bei ORACLE gibt es auch Trigger, die mit COMMIT bzw. ROLLBACK ausgel\u00f6st werden.", "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1935, "category": 10, "difficulty": 1, "text": "Die NEW-Variablen sind in BEFORE TRIGGERN beschreibbar.", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. NEW-Variablen sind beschreibbar, wenn Sie existieren. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1970, "category": 9, "difficulty": 2, "text": "Ein benutzerdefinierter Datentyp unter ORACLE ist immer instanzierbar", "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint. \n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1913, "category": 11, "difficulty": 1, "text": "Welcher Modus ist bei ORACLE als DEFAULT voreingestellt?", "explanation": "Bei ORACLE ist die Standardarbeitsweise AUTOCOMMIT OFF, d.h. in diesem Modus k\u00f6nnen Transaktionen bei ORACLE aus mehr als nur einer DML-Anweisung bestehen. Soll eine Transaktion beendet werden, so muss der Anwender explizit COMMIT eingeben. \n  \nBei MYSQL ist das ganz anders, dort ist AUTOCOMMIT ON die \u00fcbliche Arbeitsweise. Somit wird bei MYSQL nach jeder SQL-Anweisung automatisch ein COMMIT durchgef\u00fchrt, eine Eingabe des Befehls ist hier nicht notwendig. Transaktionen bestehen also nur aus genau einer SQL-Anweisung.  \n  \nBei beiden DB-Systemen kann der Modus entsprechend umgesetzt werden. z.B.: \nSET AUTOCOMMIT Anweisung (Oracle)> ::=\n   SET AUTOCOMMIT { OFF | ON };", "type": "multiple-choice", "answers": [{"text": "AUTOCOMMIT ON", "solution": "false"}, {"text": "AUTOCOMMIT OFF", "solution": "true"}]}, {"id": 1914, "category": 11, "difficulty": 1, "text": "Bei ORACLE k\u00f6nnen Sperren (LOCKS) auch auf Sichten vergeben werden.", "explanation": "Bei Oracle werden Sichten weitgehend wie Tabellen behandelt. Es sind DML-Operationen (INSERT, UPDATE, DELETE) auf Sichten erlaubt und damit m\u00fcssen auch LOCKs auf Sichten gesetzt werden k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1917, "category": 42, "difficulty": 1, "text": "Betrachten Sie eine Relation mit vier Spalten. \nWie viele Indizes kann man  anlegen?", "explanation": "Bei vier Spalten berechnet sich die Anzahl der m\u00f6gliche Indizes x nach der Formel: x = Summe [k=1..n] (n!/(n-k)!), wobei n! die Fakult\u00e4t ist.F\u00fcr n= 4 erh\u00e4lt man:    x = 4x3x2x1 + 4x3x2 + 4x3 + 4 = 64F\u00fcr n= 3 bei drei Spalten entsprechend:    x = 3x2x1 + 3x2 + 3x1 = 15Das ist die Anzahl der m\u00f6glichen nicht leeren geordneten Teilmengen einer vierelementigen Menge. Diese Mengen hei\u00dfen in der Kombinatorik Variationen, siehe auch http://de.wikipedia.org/wiki/Abz\u00e4hlende_Kombinatorik.", "type": "multiple-choice", "answers": [{"text": "keine von allen", "solution": "false"}, {"text": "1", "solution": "false"}, {"text": "3", "solution": "false"}, {"text": "5", "solution": "false"}, {"text": "9", "solution": "false"}, {"text": "15", "solution": "false"}, {"text": "18", "solution": "false"}, {"text": "64", "solution": "true"}]}, {"id": 1918, "category": 42, "difficulty": 2, "text": "Betrachten Sie eine Relation mit zwei Spalten. \nWie viele Indizes kann man  anlegen?", "explanation": "Die Reihenfolge der Attribute spielt ja eine Rolle, daher 4 Kombinationsm\u00f6glichkeiten bei zwei Spalten a, b: \na, b, \nab, ba,", "type": "multiple-choice", "answers": [{"text": "1", "solution": "false"}, {"text": "2", "solution": "false"}, {"text": "3", "solution": "false"}, {"text": "4", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1933, "category": 9, "difficulty": 3, "text": "Mit welchem SQL - Statement r\u00e4umt man allen Benutzern Ausf\u00fchrungsrechte auf einer gespeicherten Prozedure Test ein (mit Semikolon schreiben)?", "explanation": "GRANT EXECUTE on Test TO PUBLIC; r\u00e4umt diese Rechte allen Benutzern ein, GRANT EXECUTE on Test TO Hugo; nur dem  DB-Benutzer Hugo.", "type": "text", "answers": [{"text": "Das ist:", "solution": "GRANT EXECUTE on Test TO PUBLIC;"}]}, {"id": 1936, "category": 10, "difficulty": 1, "text": "In BEFORE-Triggern sind unter ORACLE auch DML-Operationen zugelassen.", "explanation": "Dies ist der Grund f\u00fcr das Mutating-Table-Problem, dass nur unter Oracle auftritt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1937, "category": 10, "difficulty": 2, "text": "In Before-Triggern sind im Standard SQL2003 auch DML-Operationen zugelassen.", "explanation": "Dies ist der Grund f\u00fcr das Mutating-Table-Problem, dass nur unter Oracle auftritt, also nicht im SQL-Standard.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1971, "category": 9, "difficulty": 2, "text": "Zur Definition einer Object-View ist ein selbstdefinierter Type (CREATE TYPE...) notwendig", "explanation": "Die Definition einer Objekt-Sicht (View) ist hier analog einer Objekttabelle m\u00f6glich.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2011, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber das EERM sind wahr?", "explanation": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen erg\u00e4nzt werden k\u00f6nnen. \nEin weiterer wichtiger Beziehungstyp ist die Aggregation, die die \"Ist Teil von\" Beziehung beschreibt. Mithilfe dieses Beziehungstyps lassen sich komplexe Objekte modellieren. Beispielsweise ist es m\u00f6glich, in der ER-Modellierung von Byce & Co. auf die Struktur-Entity-Menge zu verzichten und stattdessen die Bestandteile eines Fahrrads explizit aufzulisten. \nUnter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp, und unter einer Generalisierung den genau umgekehrten Prozess, die Gewinnung eines Supertypen aus gegebenen Subtypen. \nEin System von Subtypen und Supertypen nennt man vollst\u00e4ndig, wenn der Supertyp keine eigenen Elemente enth\u00e4lt, also jedes Element in einem der Subtypen enthalten ist.", "type": "multiple-choice", "answers": [{"text": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen erg\u00e4nzt werden k\u00f6nnen.", "solution": "true"}, {"text": "Eine Aggregation ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen erg\u00e4nzt werden k\u00f6nnen.", "solution": "false"}, {"text": "Unter einer Generalisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.", "solution": "false"}, {"text": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.", "solution": "true"}, {"text": "Ein System von Subtypen und Supertypen hei\u00dft vollst\u00e4ndig, wenn die einzelnen Subtypen keine gemeinsamen Elemente haben.", "solution": "false"}, {"text": "Ein System von Subtypen und Supertypen nennt man vollst\u00e4ndig, wenn der Supertyp keine eigenen Elemente enth\u00e4lt, also jedes Element in einem der Subtypen enthalten ist.", "solution": "true"}]}, {"id": 2023, "category": 8, "difficulty": 2, "text": "Welcher Typkonstruktor hat homogene Elemente und erlaubt keine Duplikate?", "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschr\u00e4nkter Kardinalit\u00e4t), \nLIST (ohne Beschr\u00e4nkung der Kardinalit\u00e4t).  \nInhomogene (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogene (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)", "type": "multiple-choice", "answers": [{"text": "SET", "solution": "true"}, {"text": "ROW", "solution": "false"}, {"text": "UNION", "solution": "false"}, {"text": "ARRAY", "solution": "false"}, {"text": "LIST", "solution": "false"}, {"text": "MULTISET", "solution": "false"}]}, {"id": 2024, "category": 8, "difficulty": 3, "text": "Welche Typkonstruktoren hat die relationale Algebra?", "explanation": "Wir n\u00e4hern uns dem grundlegenden relationalen Modell auf zwei Wegen: zum einen als Teilmenge eines kartesischen Produkts im mathematischen Sinn und zum anderen als Datenmodell, welches als Typkonstruktoren nur SET und ROW benutzt.", "type": "multiple-choice", "answers": [{"text": "ROW", "solution": "true"}, {"text": "UNION", "solution": "false"}, {"text": "SET", "solution": "true"}, {"text": "ARRAY", "solution": "false"}, {"text": "LIST", "solution": "false"}, {"text": "MULTISET", "solution": "false"}]}, {"id": 2060, "category": 9, "difficulty": 1, "text": "Welche Typen von Integrit\u00e4tsbedingungen gibt es?", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \n\nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen  beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingungen", "solution": "true"}, {"text": "dynamische, transitionale Bedingungen", "solution": "true"}, {"text": "statische, transitionale Bedingungen", "solution": "false"}, {"text": "dynamische, temporale Bedingungen", "solution": "true"}, {"text": "statische, temporale Bedingungen", "solution": "false"}]}, {"id": 1980, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche Abfragen liefern das gleiche Ergebnis, wenn die Tabellen mit Daten gef\u00fcllt sind?", "explanation": "RICHTIG ist: \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr\nAND  Angestellte.Ang_Nr = Abteilungen.Ang_Nr;\" \nweil ein Natural Join, \u00fcber alle Spalten dieser Tabellen, die gleich hei\u00dfen, Abt_Nr, Ang_Nr, auf Gleichheit verglichen werden und die Teilbedingungen mit AND verkn\u00fcpft werden. \noder diese Anfrage: \nSELECT * FROM Angestellte NATURAL JOIN Abteilungen;\n\n\nDie Semantik dieses nat\u00fcrlichen Joins hei\u00dft: \"Welche Mitarbeiter arbeiten in Abteilungen, deren Leiter sie sind?\"\n\n\nFALSCH sind:\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verkn\u00fcpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ort = Abteilungen.Standort AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN, weil \u00fcber zwei Spalten verglichen wird, die nicht gleich hei\u00dfen: \"Angestellte.Ort = Abteilungen.Standort\". \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN, weil nur \u00fcber eine gleich hei\u00dfende Spalte verkn\u00fcpft wird und nicht \u00fcber alle beide.", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.ORT = Abteilungen.STANDORT\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM     Angestellte, Abteilungen\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr\nAND   Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "true"}, {"text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1958, "category": 9, "difficulty": 3, "text": "Worauf muss man bei Gruppierungen in SQL achten?", "explanation": "Die WHERE-Klausel bezieht sich auf einzelne Tupel, daher sind Aggregationsfunktionen nicht zul\u00e4ssig.", "type": "multiple-choice", "answers": [{"text": "Nach allen nicht aggregierten Projektionsattributen der SELECT-Klausel muss gruppiert werden.", "solution": "true"}, {"text": "In der SELECT-Klausel darf nur auf aggregierte Attribute projiziert werden.", "solution": "false"}, {"text": "Die WHERE-Klausel darf keine Aggregationsfunktionen (SUM, AVG, MIN, MAX, COUNT) benutzen.", "solution": "true"}, {"text": "Die Having-Klausel darf keine Aggregationsfunktionen (SUM, AVG, MIN, MAX, COUNT) benutzen.", "solution": "false"}, {"text": "In der WHERE-Klausel d\u00fcrfen nur Gruppierungsattribute auftreten.", "solution": "false"}]}, {"id": 1934, "category": 9, "difficulty": 2, "text": "In der DECLARE-Komponente eines CURSORS kann auch eine SELECT-INTO-Anweisung stehe.", "explanation": "SELECT INTO ist nur bei impliziten Cursorn vorgesehen, die genau einen Wert liefern und ohne explizite Cursordefinition benutzt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1959, "category": 9, "difficulty": 1, "text": "Wenn in durch AVG aggregierten Attributen NULL-Werte auftreten, dann", "explanation": "Null-Werte werden in Gruppenfunktionen (AVG, SUM, COUNT, MIN und MAX) einfach ignoriert.", "type": "multiple-choice", "answers": [{"text": "wird das ganze Ergebnis zu NULL", "solution": "false"}, {"text": "geht das Tupel mit 0 in die Berechnung ein", "solution": "false"}, {"text": "wird das Tupel in der Berechnung ignoriert", "solution": "true"}, {"text": "wird ein Fehler ausgegeben", "solution": "false"}]}, {"id": 1977, "category": 8, "difficulty": 1, "text": "Ein nat\u00fcrlicher Join (Natural Join) unterdr\u00fcckt", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "multiple-choice", "answers": [{"text": "doppelte Attribute (gleicher Attributname)", "solution": "true"}, {"text": "doppelte Tupel", "solution": "false"}, {"text": "keins von beiden", "solution": "false"}]}, {"id": 1978, "category": 9, "difficulty": 3, "text": "Wie gibt man unter PL/SQL \u00dcbersetzungsfehler aus?", "explanation": "RAISE und RAISE_APPLICATION_ERROR werfen einen Fehler, dem man eine eigene Fehlermeldung zuordnen kann.", "type": "multiple-choice", "answers": [{"text": "RAISE_APPLICATION_ERROR (.....)", "solution": "false"}, {"text": "RAISE (.....)", "solution": "false"}, {"text": "SHOW ERRORS", "solution": "true"}, {"text": "SELECT * FROM USER_ERRORS", "solution": "true"}, {"text": "keine  von allen", "solution": "false"}]}, {"id": 2022, "category": 8, "difficulty": 3, "text": "Welcher Typkonstruktor hat homogene Elemente und erlaubt Duplikate?", "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschr\u00e4nkter Kardinalit\u00e4t), \nLIST (ohne Beschr\u00e4nkung der Kardinalit\u00e4t).  \nInhomogene (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogene (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)", "type": "multiple-choice", "answers": [{"text": "SET", "solution": "false"}, {"text": "ROW", "solution": "false"}, {"text": "UNION", "solution": "false"}, {"text": "ARRAY", "solution": "true"}, {"text": "LIST", "solution": "true"}, {"text": "MULTISET", "solution": "true"}]}, {"id": 2030, "category": 8, "difficulty": 1, "text": "Welche Outer-Join-Operatoren gibt es in der relationalen Algebra?", "explanation": "Der linke Outer-Join (linker \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit\naufgef\u00fchrt und in den Attributen, die zu R2 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden. \nDer rechte Outer-Join (rechter \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R1 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.  \nDer Full Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgef\u00fcllt\nwerden, die beim nat\u00fcrlichen Join herausfallen w\u00fcrden.", "type": "multiple-choice", "answers": [{"text": "Vollst\u00e4ndiger Outer-Join", "solution": "true"}, {"text": "Rechter Outer-Join", "solution": "true"}, {"text": "Halber Outer-Join", "solution": "false"}, {"text": "Linker Outer Join", "solution": "true"}, {"text": "Super Outer-Join", "solution": "false"}]}, {"id": 2064, "category": 9, "difficulty": 3, "text": "Der SQL-Ausdruck UNIQUE kann verwendet werden:", "explanation": "Ein INDEX verbessert den Datenzugriff durch den Aufbau von gut zu durchsuchenden separaten Verzeichnissen der Gestalt (Wert, Adresse). Die Spaltenwerte eines solchen Index k\u00f6nnen nun optional eindeutig (UNIQUE) sein oder nicht.\n \n\n<CREATE INDEX Anweisung> ::= \nCREATE [UNIQUE] INDEX Indexname ON Tabellenname  \n       (Spaltenname [, Spaltenname]... );\n \n\nUNIQUE ist einer der 5 SQL-Constraints und zwar der f\u00fcr die Eindeutikeitsschl\u00fcssel (Zweitschl\u00fcssel aus dem relationalen Modell) und bestimmt eine oder mehrere Spalten als eindeutigen Schl\u00fcssel. Die Werte dieser Schl\u00fcsselspalten erlauben keine Duplikate, d\u00fcrfen jedoch NULL-Werte enthalten. Mehrere UNIQUE KEYS sind je Tabelle definierbar. F\u00fcr die Schl\u00fcsselspalten wird automatisch ein INDEX angelegt.\n \nHier das Syntaxbeispiel f\u00fcr die Tabellen-Constraints, gleiches gilt aber auch f\u00fcr die Spalten-Constraints:\n \n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )", "type": "multiple-choice", "answers": [{"text": "bei CONSTRAINTS", "solution": "true"}, {"text": "in einer CREATE-INDEX-Anweisung", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 1947, "category": 9, "difficulty": 3, "text": "Mit welchem Operator werden auch auch mehrfach vorkommenden Datens\u00e4tze des gleichen Satzaufbaus vereinigt?", "explanation": "UNION unterdr\u00fcckt mehrfach vorkommende Datens\u00e4tze, bei UNION ALL bleiben sie erhalten.", "type": "text", "answers": [{"text": "Dieser  Operator hei\u00dft:", "solution": "UNION ALL"}]}, {"id": 1981, "category": 9, "difficulty": 3, "text": "Wie viele Tupel liefert der folgende SELECT ausgef\u00fchrt auf einer Angestellten-Tabelle mit 10 Datens\u00e4tzen, die sich auf 4 Abteilungen verteilen: \n\nSELECT AVG(AVG(Gehalt)) FROM Angestellte GROUP BY ABT_NR;", "explanation": "Die innere Aggregation AVG((Gehalt) ermittelt die Durchschnittsgeh\u00e4lter je Gruppe, also je Abteilung und damit f\u00fcr 4 Datens\u00e4tze. \nDie \u00e4u\u00dfere Aggregation AVG(AVG((Gehalt)) ermittelt das Durchschnittsgehalt aller Durchschnittsgeh\u00e4lter der Abteilungen und damit bleibt letztlich 1 Datensatz \u00fcbrig.", "type": "text", "answers": [{"text": "Die Zahl ist", "solution": "1"}]}, {"id": 2007, "category": 8, "difficulty": 3, "text": "Welche Regeln geh\u00f6ren zu den zw\u00f6lf Basisregeln, die E.F. Codd f\u00fcr relationale Datenbanksysteme aufstellte?", "explanation": "E. F. Codd, einer der Begr\u00fcnder der relationalen Datenbanken, beschreibt\nzw\u00f6lf Basisregeln, die eine relationale Datenbank auszeichnen,\nsich aber auch auf andere Datenbanktypen verallgemeinern lassen\n\nRegel 1: Informationsregel\nJede Information einer relationalen Datenbank wird in genau einer Weise durch Werte in\nRelationen dargestellt und damit redundanzfrei und einheitlich verwaltet. \n\nRegel 2: Garantierter Zugriff\nJedes einzelne Feld der Datenbank ist durch eine Kombination von Relationsname,\nPrim\u00e4rschl\u00fcssel und Spaltenname erreichbar.\n\nRegel 3: Systematische Behandlung fehlender Information\nIn einer relationalen Datenbank m\u00fcssen Spalten mit fehlender Information (Nullwerte)\neinheitlich darstellbar sein. Diese Nullwerte werden systematisch als fehlende\nInformation von den Standardwerten (z.B. Strings mit Leerzeichen) unterschieden.\nSpalten k\u00f6nnen auch so eingerichtet werden, dass Nullwerte nicht erlaubt sind.\n\nRegel 4: Dynamischer Online-Katalog (Data Dictionary)\nEin Datenbankschema wird in derselben Weise wie die gespeicherten Daten selbst\nbeschrieben \u00bf n\u00e4mlich in Tabellen, dem sogenannten Data Dictionary. Autorisierte\nBenutzer k\u00f6nnen das Data Dictionary in gleicher Weise abfragen wie die eigentliche\nDatenbasis.\n\nRegel 5: Allumfassende Sprache\nEin Datenbanksystem muss eine Sprache unterst\u00fctzen, die allumfassend sein, d.h. sie \nerf\u00fcllt die folgenden Aufgaben:\nDefinition der Benutzerdaten,\nDefinition von Sichten als virtuelle Tabellen,\nManipulation von Benutzerdaten,\n\u00dcberpr\u00fcfung von Integrit\u00e4tsregeln,\nVergabe von Benutzerrechten und Autorisierung,\nTransaktionskontrolle und Transaktionshandling \n\nRegel 6: Benutzersichten und Daten\u00e4nderungen\nF\u00fcr unterschiedliche Benutzergruppen und Anwendungen sind unterschiedliche\nSichten (Views) auf die Datenbank notwendig. In einfachen Views, z.B. Teilansichten\neiner Tabelle, sollen auch Daten\u00e4nderungen m\u00f6glich sein.\n\nRegel 7: HIGH-LEVEL INSERT, UPDATE und DELETE\nIn der Datenbank muss das Einf\u00fcgen, \u00c4ndern und L\u00f6schen von Daten m\u00f6glich sein.\nDabei soll das System sich den optimalen Zugriffspfad zur schnellen Durchf\u00fchrung\nder Transaktion selbst suchen.\n\nRegel 8: Physische Datenunabh\u00e4ngigkeit\nAnwendungsprogramme und Anwenderoberfl\u00e4chen bleiben unver\u00e4ndert, wenn Ver\u00e4nderungen\nan der Speicherstruktur oder der Zugriffsmethode in der Datenbank vorgenommen werden.\n\nRegel 9: Logische Datenunabh\u00e4ngigkeit\nAnwendungsprogramme und Anwenderoberfl\u00e4chen bleiben unver\u00e4ndert, wenn sich\nBasisrelationen ver\u00e4ndern, die nicht direkt die Anwendungsprogramme betreffen. \n\nRegel 10: Integrit\u00e4tsunabh\u00e4ngigkeit\nIntegrit\u00e4tsbedingungen, die von der Datenbank erf\u00fcllt werden m\u00fcssen, werden mithilfe\nder relationalen Datenbanksprache definiert, im Data Dictionary abgelegt und\nvom DBMS ausgef\u00fchrt. Diese Integrit\u00e4tsbedingungen geh\u00f6ren nicht ins Anwenderprogramm.\n\nRegel 11: Verteilungsunabh\u00e4ngigkeit\nEine relationale Datenbank besitzt die Verteilungsunabh\u00e4ngigkeit. Das hei\u00dft, die Anwendungsprogramme\nbleiben unver\u00e4ndert, wenn die verteilte Datenhaltung auf mehreren\nRechnern eingef\u00fchrt oder wieder zur\u00fcckgenommen wird und mehrere Datenbanken zu\neiner Datenbank zusammengelegt werden.\n\nRegel 12: Unterwanderungsverbot\nFalls das DBMS eine andere 3GL-Sprache wie C oder Java zul\u00e4sst, darf diese Sprache\nnicht die aufgestellten Regeln 1 bis 11 ver", "type": "multiple-choice", "answers": [{"text": "Informationsregel", "solution": "true"}, {"text": "Physische Datenunabh\u00e4ngigkeit", "solution": "true"}, {"text": "Unterwanderungsverbot", "solution": "true"}, {"text": "Persistencesicherung", "solution": "false"}, {"text": "Ver\u00e4nderungsgebot", "solution": "false"}, {"text": "Garantierter Zugriff", "solution": "true"}, {"text": "Sicherheitsregel", "solution": "false"}]}, {"id": 2009, "category": 5, "difficulty": 3, "text": "Welche Aussagen \u00fcber schwache Entity-Mengen sind wahr?", "explanation": "Schwache Entity-Mengen h\u00e4ngen in ihrer Existenz von einer \u00fcbergeordneten Entity-Menge ab und haben einen (zusammengesetzten) Schl\u00fcssel, der den Prim\u00e4rschl\u00fcssel der \u00fcbergeordneten Entity-Menge als Teilschl\u00fcssel hat. Grafisch werden sie durch ein doppelt gezeichnetes Rechteck dargestellt. Da der Schl\u00fcssel der schwachen Entity-Mengen den \u00fcbergeordneten Prim\u00e4rschl\u00fcssel als Teilschl\u00fcssel enth\u00e4lt, ist die Beziehung zu Master-Entity-Menge immer identifizierend.", "type": "multiple-choice", "answers": [{"text": "Bei schwachen Entity-Mengen ist die Beziehung zur Master-Entity-Menge immer identifizierend.", "solution": "true"}, {"text": "Bei schwachen Entity-Mengen ist die Beziehung zur Master-Entity-Menge nie identifizierend.", "solution": "false"}, {"text": "Jede identifizierende Beziehung erzeugt eine schwache Entity-Menge.", "solution": "false"}, {"text": "Jede nicht identifizierende Beziehung erzeugt eine schwache Entity-Menge.", "solution": "false"}, {"text": "Jede schwache Entity-Menge hat einen zusammengesetzten Prim\u00e4rschl\u00fcssel.", "solution": "true"}]}, {"id": 2020, "category": 8, "difficulty": 2, "text": "Welche Typkonstruktoren sind homogen?", "explanation": "Homogene Elemente lassen nur Elemente gleichen Typs zu, dazu geh\u00f6ren: ARRAY, LIST, MULTISET und SET. \nInhomogene Elemente lassen nur Elemente unterschiedlichen Typs zu, dazu geh\u00f6ren: ROW und UNION", "type": "multiple-choice", "answers": [{"text": "SET", "solution": "true"}, {"text": "ROW", "solution": "false"}, {"text": "UNION", "solution": "false"}, {"text": "ARRAY", "solution": "true"}, {"text": "LIST", "solution": "true"}, {"text": "MULTISET", "solution": "true"}]}, {"id": 2021, "category": 8, "difficulty": 3, "text": "Welche Typkonstruktoren sind homogen und geordnet?", "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschr\u00e4nkter Kardinalit\u00e4t), \nLIST (ohne Beschr\u00e4nkung der Kardinalit\u00e4t).  \nInhomogene (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogene (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)", "type": "multiple-choice", "answers": [{"text": "SET", "solution": "false"}, {"text": "ROW", "solution": "false"}, {"text": "UNION", "solution": "false"}, {"text": "ARRAY", "solution": "true"}, {"text": "LIST", "solution": "true"}, {"text": "MULTISET", "solution": "false"}]}, {"id": 637, "category": 4, "difficulty": 3, "text": "Welche Komponenten geh\u00f6ren zu einem Datenbankschema?", "explanation": "In der Entwurfsphase wird das konzeptionelle Schema auf ein relationales Datenbankschema abgebildet und eine Normalisierung durchgef\u00fchrt. Das Datenbankschema ist ein auf den Datenbanktyp abgestimmtes Datenmodell, im relationalen Fall also ein relationales Schema, bestehend aus miteinander verkn\u00fcpften Relationen.\n\n    \n\n    Ferner wird das Schema erg\u00e4nzt um einzelne Benutzersichten, Indexangaben zur Zugriffsoptimierung und Speicherstrukturen, wie B-Baum, oder HASH- Verfahren sowie die Zugriffsrechte der Benutzer im Multiuser-System.", "type": "multiple-choice", "answers": [{"text": "Normalisierte Relationen", "solution": "true"}, {"text": "Prim\u00e4rschl\u00fcssel", "solution": "true"}, {"text": "Fremdschl\u00fcssel", "solution": "true"}, {"text": "Beziehungen", "solution": "false"}, {"text": "Wertebereiche der Attribute", "solution": "true"}, {"text": "Indizes", "solution": "true"}, {"text": "\u00dcberblick \u00fcber Zugriffsrechte", "solution": "true"}, {"text": "Spezielle Benutzersichten (Views)", "solution": "true"}, {"text": "SQL-Skripte", "solution": "false"}]}, {"id": 2031, "category": 8, "difficulty": 1, "text": "Ein Outer-Join ist eine Spezialform des Natural-Joins", "explanation": "Ein Natural Join liefert nur eine Teilmenge der Tupel, die ein Outer-Join liefern w\u00fcrde, namlich die Tupel, die in beiden Relationen enthalten sind.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2032, "category": 8, "difficulty": 1, "text": "Ein vollst\u00e4ndiger Outer-Join ist immer verlustfrei.", "explanation": "Eine Join-Operation  zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.", "type": "multiple-choice", "answers": [{"text": "Stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2041, "category": 8, "difficulty": 2, "text": "Welcher Typkonstruktor ist homogen, hat geordnete Elemente und beschr\u00e4nkte Kardinalit\u00e4t?", "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschr\u00e4nkter Kardinalit\u00e4t), \nLIST (ohne Beschr\u00e4nkung der Kardinalit\u00e4t).  \nInhomogene (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogen (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)", "type": "multiple-choice", "answers": [{"text": "ARRAY", "solution": "true"}, {"text": "MULTISET", "solution": "false"}, {"text": "SET", "solution": "false"}, {"text": "UNION", "solution": "false"}]}, {"id": 2042, "category": 8, "difficulty": 2, "text": "Welcher Typkonstruktor ist homogen, hat ungeordnete Elemente und erlaubt Duplikate?", "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschr\u00e4nkter Kardinalit\u00e4t), \nLIST (ohne Beschr\u00e4nkung der Kardinalit\u00e4t).  \nInhomogen (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogen (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)", "type": "multiple-choice", "answers": [{"text": "ARRAY", "solution": "false"}, {"text": "MULTISET", "solution": "true"}, {"text": "LIST", "solution": "false"}, {"text": "ROW", "solution": "false"}]}, {"id": 2043, "category": 8, "difficulty": 2, "text": "Welcher Typkonstruktor ist homogen, hat ungeordnete Elemente und erlaubt keine Duplikate?", "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschr\u00e4nkter Kardinalit\u00e4t), \nLIST (ohne Beschr\u00e4nkung der Kardinalit\u00e4t).  \nInhomogen (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogen (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)", "type": "multiple-choice", "answers": [{"text": "ROW", "solution": "false"}, {"text": "SET", "solution": "true"}, {"text": "LIST", "solution": "false"}, {"text": "MULTISET", "solution": "false"}]}, {"id": 2045, "category": 7, "difficulty": 1, "text": "Beim \u00dcbergang zur ersten Normalform werden", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "alle mehrwertigen Attribute aufgel\u00f6st", "solution": "true"}, {"text": "alle zusammengesetzten Attribute aufgel\u00f6st", "solution": "false"}, {"text": "alle partiellen funktionalen Abh\u00e4ngigkeiten beseitigt", "solution": "false"}, {"text": "alle transitiven funktionalen Abh\u00e4ngigkeiten beseitigt", "solution": "false"}]}, {"id": 1967, "category": 9, "difficulty": 2, "text": "Wenn man unter ORACLE eine BLOB-Spalte mit UPDATE \u00e4ndern will, muss man diese mit EMPTY_BLOB() initialisieren.", "explanation": "Bevor man einen BLOB-Datentyp benutzen kann, muss er mit EMPTY_BLOB() initialisiert werden. Bei einen CLOB ist es die Funktion EMPTY_CBLOB().", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1969, "category": 9, "difficulty": 2, "text": "Benutzerdefinierte Typen unter ORACLE stimmen einschlie\u00dflich der Methoden mit dem SQL-Standard 2003 \u00fcberein.", "explanation": "Leider gibt es zahlreiche Abweichungen, wie z.B. die Definition der Methoden eines benutzerdefinierten Typs, die Anlage einer Objekttabelle oder einer eingebetteten Tabelle.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2301, "category": 9, "difficulty": 3, "text": "In welcher Methode gibt es bei Oracle einen impliziten SELF-Parameter?", "explanation": "Eine MEMBER-Methode bezieht sich auf eine Instanz, das hei\u00dft eine Tabelle, die auf diesem Typ basiert. Eine STATIC-Methode bezieht\nsich auf den Typ selbst. Eine MEMBER-Methode wird aufgerufen \u00fcber Instanzname.method(), eine STATIC-Routine \u00fcber Typname.method(). In der MEMBER-Routine existiert immer ein implizites Argument SELF im Methoden-Body, das die Instanz repr\u00e4sentiert, f\u00fcr die die Methode aufgerufen wurde. SELF existiert bei STATIC-Routinen\nnat\u00fcrlich nicht.", "type": "text", "answers": [{"text": ".", "solution": "Member"}]}, {"id": 2302, "category": 9, "difficulty": 3, "text": "Strukturierte Datentypen k\u00f6nnen bei Oracle wie auch bei OR-SQL in welcher/n Tabellenform/en verwendet werden.", "explanation": "Manchmal ist alles korrekt :-).", "type": "multiple-choice", "answers": [{"text": "in relationale Tabellen", "solution": "true"}, {"text": "in Objekttabellen", "solution": "true"}]}, {"id": 2303, "category": 9, "difficulty": 1, "text": "Objektrelationale DBS sind streng typisiert.", "explanation": "Ja, ORDBS sind streng typisiert, mit der Konsequenz, dass f\u00fcr die Typtransformation von benuzterdefinierten Typen entsprechende Konvertierungsfunktionen (CAST-Funktionen) definiert werden m\u00fcssen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht.", "solution": "false"}]}, {"id": 2332, "category": 9, "difficulty": 2, "text": "Die vom Oracle-DBS systemgenerierte OID ist", "explanation": "Die OID-Generierung bietet zwei M\u00f6glichkeiten: SYSTEM GENERATED bedeutet,dass eine weltweit eindeutige OID erzeugt wird, PRIMARY KEY entspricht dem Konzept eines Prim\u00e4rschl\u00fcssels. \n\nObjekttabellenhierarchien gibt es unter Oracle nicht.", "type": "multiple-choice", "answers": [{"text": "innerhalb einer Objekttabelle eindeutig.", "solution": "false"}, {"text": "innerhalb einer Objekttabellenhierarchie eindeutig.", "solution": "false"}, {"text": "innerhalb einer Typhierarchie eindeutig.", "solution": "false"}, {"text": "innerhalb eines DB-Schemas eindeutig.", "solution": "false"}, {"text": "innerhalb einer Datenbank eindeutig.", "solution": "false"}, {"text": "weltweit eindeutig.", "solution": "true"}]}, {"id": 2351, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Referenzen sind wahr?", "explanation": "Referenzen sind nicht identisch zu Fremdschl\u00fcsseln, da auch NULL-Pointer vorkommen k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "Referenzen verweisen von einer Instanz direkt auf verbundene Objektinstanzen.", "solution": "true"}, {"text": "Referenzen im OR-Modell sind funktional identisch zu den Fremdschl\u00fcsseln im relationalen Modell.", "solution": "false"}, {"text": "Referenzen machen Join-Operationen wie in relationalen DBS \u00fcberfl\u00fcssig.", "solution": "true"}, {"text": "Um Referenzen mit den M\u00f6glichkeiten des relationalen Modells zu simulieren, w\u00fcrde man Fremdschl\u00fcssel verwenden.", "solution": "true"}]}, {"id": 2358, "category": 9, "difficulty": 1, "text": "Welcher Befehl ist syntaktisch richtig, um in JDBC einen Befehl dynamisch erst zur Laufzeit zusammenzusetzen? Con ist dabei das Verbindungsobjekt.", "explanation": "Der Platzhalter f\u00fcr Parameter unter JDBC ist \" ? .", "type": "multiple-choice", "answers": [{"text": "PreparedStatement updOrt =\n     con.PrepareStatement(\"UPDATE Kunden SET Ort = !\");", "solution": "false"}, {"text": "PreparedStatement updOrt =\n     con.PrepareStatement(\"UPDATE Kunden SET Ort = *\");", "solution": "false"}, {"text": "PreparedStatement updOrt =\n     con.PrepareStatement(\"UPDATE Kunden SET Ort = ?\");", "solution": "true"}, {"text": "So etwas geht bei JDBC gar nicht.", "solution": "false"}]}, {"id": 2360, "category": 9, "difficulty": 2, "text": "Geben Sie die Reihenfolge (1 - 5) an, in der die folgenden Befehle programmiert werden m\u00fcssen. Falsche/\u00fcberfl\u00fcssige Befehle k\u00f6nnen mit 0 gekennzeichnet werden.Damit die L\u00f6sung eindeutig wird: Die String-Spezifikation soll als erstes erfolgen.", "explanation": "Zuerst wird der String (1) definiert, dann muss das PreparedStatement-Objekt (2) erstellt werden, dann updateOrt (3) deklariert werden, dann wird der Parameter mit einem Wert best\u00fcckt (4) und zum Schluss mit updateOrt.executeUpdate(); ausgef\u00fchrt (5).  \n\nL\u00f6sung: 3, 4, 2, 5, 1", "type": "text", "answers": [{"text": "updateOrt = v_connection.prepareStatement(updateString);", "solution": "3"}, {"text": "updateOrt.setString(1, \"K\u00f6ln\");", "solution": "4"}, {"text": "PreparedStatement updateOrt;", "solution": "2"}, {"text": "updateOrt.executeUpdate();", "solution": "5"}, {"text": "String updateString = \"update kunden set ort = ?\";", "solution": "1"}]}, {"id": 2361, "category": 9, "difficulty": 1, "text": "Mit der Methode prepareCall der Schnittstelle Connection wird ein CallableStatement-Objekt erzeugt, um folgendes aufzurufen:", "explanation": "prepareCall erzeugt ein Callable-Statement -Objekt, mit dem man in der Datenbank gespeicherte Prozeduren aufrufen kann.", "type": "multiple-choice", "answers": [{"text": "DB-Trigger", "solution": "false"}, {"text": "In der DB gespeicherte Prozeduren", "solution": "true"}, {"text": "In der DB gespeicherte Funktionen", "solution": "true"}]}, {"id": 2362, "category": 9, "difficulty": 1, "text": "Welcher Befehl ist syntaktisch richtig, um in JDBC eine gespeicherte Routine auszuf\u00fchren? Con ist dabei das Verbindungsobjekt.", "explanation": "prepareCall erzeugt ein Callable-Statement-Objekt, mit dem man in der Datenbank gespeicherte Prozeduren aufrufen kann.\n\nDie exakte Syntax ist: \n\nCallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(?)}\");", "type": "multiple-choice", "answers": [{"text": "CallableStatement callst = \n         con.prepareCall(\"{exec setze_zeitstempel(?)}\");", "solution": "false"}, {"text": "CallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(?)}\");", "solution": "true"}, {"text": "CallableStatement callst = \n         con.prepareCall(\"{run setze_zeitstempel(?)}\");", "solution": "false"}, {"text": "So etwas geht bei JDBC gar nicht.", "solution": "false"}]}, {"id": 2363, "category": 9, "difficulty": 1, "text": "Welcher Befehl ist syntaktisch richtig, um in JDBC eine gespeicherte Routine auszuf\u00fchren? Con ist dabei das Verbindungsobjekt.", "explanation": "prepareCall erzeugt ein Callable-Statement-Objekt, mit dem man in der Datenbank gespeicherte Prozeduren aufrufen kann.\n\nDie exakte Syntax ist: \n\nCallableStatement callst = \n                con.prepareCall(\"{call setze_zeitstempel(?)}\");", "type": "multiple-choice", "answers": [{"text": "CallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(?)}\");", "solution": "true"}, {"text": "CallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(*)}\");", "solution": "false"}, {"text": "CallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(!)}\");", "solution": "false"}, {"text": "So etwas geht bei JDBC gar nicht.", "solution": "false"}]}, {"id": 2048, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema mittels Universalrelation. Die Universalrelation wird nicht weiter zerlegt und die Subtypen werden durch ein diskriminierendes Attribut beschrieben.\n\nUm welchen Fragmentierungstyp handelt es sich hier?", "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp geh\u00f6ren, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch. \nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enth\u00e4lt alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschl\u00fcssel mit dem Supertyp verbunden und haben den gleichen Prim\u00e4rschl\u00fcssel wie der Supertyp. Au\u00dferdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.", "type": "multiple-choice", "answers": [{"text": "virtuelle Fragmentierung", "solution": "true"}, {"text": "vertikale Fragmentierung", "solution": "false"}, {"text": "horizontale Fragmentierung", "solution": "false"}]}, {"id": 2049, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema. Welche Fragmentierungstypen gibt es?", "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp geh\u00f6ren, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch. \nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enth\u00e4lt alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschl\u00fcssel mit dem Supertyp verbunden und haben den gleichen Prim\u00e4rschl\u00fcssel wie der Supertyp. Au\u00dferdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.", "type": "multiple-choice", "answers": [{"text": "virtuelle Fragmentierung", "solution": "true"}, {"text": "vertikale Fragmentierung", "solution": "true"}, {"text": "horizontale Fragmentierung", "solution": "true"}, {"text": "faktische Fragmentierung", "solution": "false"}, {"text": "abgeleitete Fragmentierung", "solution": "false"}, {"text": "diagonale Fragmentierung", "solution": "false"}]}, {"id": 2052, "category": 8, "difficulty": 2, "text": "Welche Integrit\u00e4tsbedingung werden wie folgt charakterisiert:\n\"Sie beschreiben, welche Bedingungen beim \u00dcbergang von einem Zustand in einen anderen Zustand erf\u00fcllt sein m\u00fcssen.\"", "explanation": "Bei der Integrit\u00e4t lassen sich die folgenden Arten unterscheiden:\n- statische Bedingungen und\n- dynamische Bedingungen:\n    - transitionale Bedingungen und\n    - temporale Bedingungen.\nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel aus der Fahrrad-Welt Byce & Co. w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf.", "type": "multiple-choice", "answers": [{"text": "Statische Integrit\u00e4tsbedingungen", "solution": "false"}, {"text": "Dynamisch, transitionale Integrit\u00e4tsbedingungen", "solution": "true"}, {"text": "Dynamisch, temporale Integrit\u00e4tsbedingungen", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2053, "category": 8, "difficulty": 1, "text": "Welche Integrit\u00e4tsbedingung werden wie folgt charakterisiert:\n\"Sie beschreiben einen Zustand, der von einer Datenbasis erf\u00fcllt sein muss.\"", "explanation": "Bei der Integrit\u00e4t lassen sich die folgenden Arten unterscheiden:\n- statische Bedingungen und\n- dynamische Bedingungen:\n    - transitionale Bedingungen und\n    - temporale Bedingungen.\nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel aus der Fahrrad-Welt Byce & Co. w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf.", "type": "multiple-choice", "answers": [{"text": "Statische Integrit\u00e4tsbedingungen", "solution": "true"}, {"text": "Dynamische, transitionale Integrit\u00e4tsbedingungen", "solution": "false"}, {"text": "Dynamische, temporale Integrit\u00e4tsbedingungen", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2054, "category": 8, "difficulty": 3, "text": "Welche Integrit\u00e4tsbedingung werden wie folgt charakterisiert:\n\"Sie beschreiben, welche Bedingungen an ein Folge von Zustands\u00e4nderungen zu stellen sind.\"", "explanation": "Bei der Integrit\u00e4t lassen sich die folgenden Arten unterscheiden:\n- statische Bedingungen und\n- dynamische Bedingungen:\n    - transitionale Bedingungen und\n    - temporale Bedingungen.\nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel aus der Fahrrad-Welt Byce & Co. w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf.", "type": "multiple-choice", "answers": [{"text": "Statische Integrit\u00e4tsbedingungen", "solution": "false"}, {"text": "Dynamische, transitionale Integrit\u00e4tsbedingungen", "solution": "false"}, {"text": "Dynamische, temporale Integrit\u00e4tsbedingungen", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2160, "category": 9, "difficulty": 2, "text": "Welche Endung besitzen JDBC-Quelltexte?", "explanation": "JDBC-Quelltexte besitzen als reine Java-Quelltexte die Endung .java", "type": "text", "answers": [{"text": "Die Endung ist", "solution": ".java"}]}, {"id": 2162, "category": 9, "difficulty": 3, "text": "In welchen Punkten unterscheidet sich ein PRIMARY KEY-Constraint von einem UNIQUE-Constraint?", "explanation": "Die Constraints UNIQUE und PRIMARY KEY unterscheiden sich in den beiden Punkten: \nEs gibt pro Tabelle nur einen PRIMARY KEY aber beliebig viele UNIQUE-Schl\u00fcssel.\nDie Spalten eines PRIMARY KEY sind implizit auch Pflichteingabespalten, w\u00e4hrend die Spalten des UNIQUE-Schl\u00fcssels auch leer sein d\u00fcrfen.", "type": "multiple-choice", "answers": [{"text": "Prim\u00e4rschl\u00fcssel muss immer NOT NULL sein", "solution": "true"}, {"text": "Ein UNIQUE-Schl\u00fcssel muss immer NOT NULL sein", "solution": "false"}, {"text": "Prim\u00e4rschl\u00fcssel sind automatisch indiziert, UNIQUE-Schl\u00fcssel nicht.", "solution": "false"}, {"text": "Es ist nur ein Prim\u00e4rschl\u00fcssel pro Tabelle zul\u00e4ssig, aber viele UNIQUE-Schl\u00fcssel.", "solution": "true"}, {"text": "Ein Prim\u00e4rschl\u00fcssel darf nicht zusammengesetzt sein aus mehreren Spalten.", "solution": "false"}, {"text": "Ein UNIQUE-Schl\u00fcssel darf nicht zusammengesetzt sein aus mehreren Spalten.", "solution": "false"}]}, {"id": 2187, "category": 8, "difficulty": 1, "text": "Der Durchschnittsoperator ist aus den Grundoperatoren der relationalen Algebra (Selektion, Projektion, Kartesisches Produkt, Differenz, Union)  ableitbar.", "explanation": "Die Simulation sieht wie folgt aus: \n(A Durchschnitt B)  =  ( A ohne (A ohne B) ) \n\n(A Durchschnitt B)  =  ( A Differenz (A Differenz B) ) \n\nPS: Zeichnen Sie sich ruhig die Venn-Diagramme auf - es hilft ;-) \nPS: War mal Klausuraufgabe :-)", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2387, "category": 9, "difficulty": 1, "text": "Objektrelationale Sichten sind typisierte Sichten.", "explanation": "Welche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht \u00fcber beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht.", "solution": "false"}]}, {"id": 2389, "category": 9, "difficulty": 2, "text": "Objektrelationale Sichten sind ein Hilfsmittel f\u00fcr die physische Datenunabh\u00e4ngigkeit", "explanation": "Nein, f\u00fcr die logische Datenunabh\u00e4ngigkeit. \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht \u00fcber beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht.", "solution": "true"}]}, {"id": 2394, "category": 9, "difficulty": 3, "text": "Welche Semantik hat die folgende Anfrage?\n\nSELECT m.pers_nr, m.name, m.vorname, a.bez, \n       l.name||l.vorname, v.name||v.vorname \nFROM mitarbeiter_r m, abteilungen_r a, \n       mitarbeiter_r l, mitarbeiter_r v\nWHERE  m.abt_nr       = a.abt_nr \n   AND a.leiter       = l.pers_nr \n   AND m.vorgesetzter = v.pers_nr;", "explanation": "Richtig ist: \nAnzeige der Mitarbeiter (Personalnummer, Name, Vorname), die in Abteilungen arbeiten, mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung; \n\nAufgrund der Join-Verkn\u00fcpfung zwischen den Tabellen, werden hier nur die Angestellten angezeigt, die auch in Abteilungen arbeiten. Wenn es Mitarbeiter gibt, die in keinen Abteilungen arbeiten, so werden sie bei dieser Anfrage nicht angezeigt.", "type": "multiple-choice", "answers": [{"text": "Anzeige der Mitarbeiter (Personalnummer, Name, Vorname), die in Abteilungen arbeiten, mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung;", "solution": "true"}, {"text": "Anzeige aller Mitarbeiter (Personalnummer, Name, Vorname) mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung;", "solution": "false"}, {"text": "Keine dieser Antworten ist richtig.", "solution": "false"}]}, {"id": 2398, "category": 9, "difficulty": 3, "text": "Mit welchem/n Befehl/en kann man bei Oracle Methoden programmieren?", "explanation": "Einen CREATE METHOD-Befehl gibt es bei Oracle nicht. Die Methoden-Deklaration und -Definition wird im CREATE TYPE-Befehl vorgenommen analog zum Package-Konzept und zwar die Deklaration des Methoden-Kopfs im CREATE TYPE und die Definition mit Programmcode im CREATE TYPE BODY. \n\nCREATE [OR REPLACE] TYPE  AS OBJECT\u000b\n(  )\u000b\n[[NOT] FINAL] \u000b[[NOT] INSTANTIABLE] \n\u000b[]\n\nCREATE [OR REPLACE] TYPE BODY  AS \n[]", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPLACE PROCEDURE <methodenname> ;", "solution": "false"}, {"text": "CREATE OR REPLACE FUNCTION <methodenname> ;", "solution": "false"}, {"text": "CREATE OR REPLACE METHOD <methodenname> ;", "solution": "false"}, {"text": "CREATE OR REPLACE TYPE <typname> ;", "solution": "true"}, {"text": "CREATE OR REPLACE TYPE BODY <typname> ;", "solution": "true"}]}, {"id": 2474, "category": 9, "difficulty": 2, "text": "Wie hei\u00dfen die SQL-Befehle, mit den man eine Transaktion abschlie\u00dfen kann? \nBitte in alphabetischer Reihenfolge aufschreiben und durch ein Komma trennen!", "explanation": "Mit COMMIT werden die Daten\u00e4nderungen einer Transaktion persistent in der Datenbasis gespeichert. Die Anweisung l\u00f6st eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus, die im Fehlerfall die gesamte Transaktion zur\u00fcckrollt. \nMit ROLLBACK werden die Daten\u00e4nderungen einer Transaktion zur\u00fcckgerollt, d.h. r\u00fcckg\u00e4ngig gemacht.", "type": "text", "answers": [{"text": "Das sind:", "solution": "commit, rollback"}]}, {"id": 2477, "category": 7, "difficulty": 3, "text": "Welche Aussagen hinsichtlich Normalisierung und Normalformen sind wahr?", "explanation": "1. Die Normalisierung geht von einem Datenvolumen aus, bei dem die in den Relationen enthaltenen Daten schon vorhanden sind und sich nicht ver\u00e4ndern. Auf diesen Relationen werden aufgrund funktionaler Abh\u00e4ngigkeiten Ma\u00dfnahmen zur besseren Strukturierung durchgef\u00fchrt. In der Praxis sind nat\u00fcrlich die Relationen beim Datenbankentwurf noch nicht in allen F\u00e4llen mit Daten gef\u00fcllt; Bewegungsdaten ver\u00e4ndern sich immer im laufenden Betrieb. Der Entwickler muss also einen\ngewissen Sp\u00fcrsinn haben, wo in Zukunft unerw\u00fcnschte funktionale Abh\u00e4ngigkeiten und Redundanzen auftreten k\u00f6nnten. Au\u00dferdem wird beim konzeptionellen Modell als ER-Modell oft schon intuitiv die dritte Normalform gew\u00e4hlt. \n2. Anders sieht das Ganze bei der Reorganisation alter Datenbest\u00e4nde aus. In diesen F\u00e4llen ist die Normalformenlehre ein n\u00fctzliches Instrument, um Redundanzen zu beseitigen und eine gute Datenstruktur zu erreichen. \n3. Durch die Normalisierung ergibt sich bei gr\u00f6\u00dferen Projekten eine Vielzahl von mit Fremdschl\u00fcsselbeziehungen verbundenen Tabellen. Informationen, die inhaltlich im Sinne der Objektorientierung zusammengeh\u00f6ren, werden unter Umst\u00e4nden auf viele Tabellen verteilt. Bei Abfragen kann es zu erheblichen Performanceverlusten kommen, da oft viele Relationen aufw\u00e4ndig miteinander verkn\u00fcpft werden m\u00fcssen. \n4. Aus den angef\u00fchrten Gr\u00fcnden ist eine Verletzung der dritten Normalform (Denormalisierung) in der Praxis manchmal gewollt. Die Normalisierung ist nicht als Dogma zu verstehen, aber nach wie vor ein analytisches Instrument, um Relationenstrukturen auf ihre Qualit\u00e4t hin zu \u00fcberpr\u00fcfen. Mit Datenbanktriggern wird das Problem der Redundanzen handhabbar.", "type": "multiple-choice", "answers": [{"text": "Problematisch ist, dass der Normalisierungsprozess von den vorhandenen Daten ausgeht.", "solution": "true"}, {"text": "Die Aufteilung auf viele Relationen kann zu l\u00e4ngeren Antwortzeiten bei Anfragen f\u00fchren.", "solution": "true"}, {"text": "Die Idee der Normalisierung widerspricht der Objektorientierung.", "solution": "true"}]}, {"id": 2061, "category": 9, "difficulty": 2, "text": "Um welchen Typ einer Integrit\u00e4tsbedingung handelt es sich hier?\n\nDer durchschnittliche Rabatt aller Kunden darf 30 Prozent nicht \u00fcberschreiten.", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingung", "solution": "true"}, {"text": "dynamische, transitionale Bedingung", "solution": "false"}, {"text": "statische, transitionale Bedingung", "solution": "false"}, {"text": "dynamische, temporale Bedingung", "solution": "false"}, {"text": "statische, temporale Bedingung", "solution": "false"}]}, {"id": 2062, "category": 9, "difficulty": 1, "text": "Um welchen Typ einer Integrit\u00e4tsbedingung handelt es sich hier?\n\nEine Rechnung muss einen positiven Gesamtbetrag aufweisen, eine Gutschrift einen negativen.", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingung", "solution": "true"}, {"text": "dynamische, transitionale Bedingung", "solution": "false"}, {"text": "statische, transitionale Bedingung", "solution": "false"}, {"text": "dynamische, temporale Bedingung", "solution": "false"}, {"text": "statische, temporale Bedingung", "solution": "false"}]}, {"id": 2223, "category": 9, "difficulty": 1, "text": "Wie lautet das Ergebnis der Berechnung im folgenden PL/SQL-Block?\n\n    DECLARE\n\n       v1 NUMBER := 5;\n\n       v2 NUMBER := NULL;\n\n    BEGIN\n\n       v1 := v1 + v2;\n\n    END;", "explanation": "\n    Die Summe aus einer Zahl und einem NULL-Wert ist NULL.", "type": "text", "answers": [{"text": "v1:", "solution": "NULL"}, {"text": "v2:", "solution": "NULL"}]}, {"id": 2224, "category": 9, "difficulty": 2, "text": "Wie lautet das Ergebnis der folgenden ORACLE-SQL-Anfrage?\n\nSELECT  (5 * 6) + NULL AS ergebnis  FROM dual;", "explanation": "Das Ergebnis einer numerischen Operation (+, - , * /) und eines NULL-Werts ist immer selber Null.", "type": "text", "answers": [{"text": "ergebnis:", "solution": "NULL"}]}, {"id": 2225, "category": 9, "difficulty": 3, "text": "Welche/r Parametertyp/en k\u00f6nnen beim Aufruf der Routine (Prozedur oder Funktion) sowohl mit einer Konstanten als auch mit einer initialisierten Variablen belegt werden?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "INOUT", "solution": "false"}, {"text": "OUT", "solution": "false"}]}, {"id": 2226, "category": 9, "difficulty": 3, "text": "Welche/r Parametertyp/en k\u00f6nnen beim Aufruf der Routine (Prozedur oder Funktion) mit einer initialisierten Variablen belegt werden?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "INOUT", "solution": "true"}, {"text": "OUT", "solution": "false"}]}, {"id": 2227, "category": 9, "difficulty": 1, "text": "Welche/r Parametertyp/en k\u00f6nnen beim Aufruf der Routine (Prozedur oder Funktion) mit einer Konstanten belegt werden?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "true"}, {"text": "INOUT", "solution": "false"}, {"text": "OUT", "solution": "false"}]}, {"id": 2228, "category": 9, "difficulty": 2, "text": "Mit welchem Befehl kann man eine Meldung in PL/SQL anzeigen lassen und gleichzeitig das Programm fehlerhaft abbrechen lassen?", "explanation": "RAISE_APPLICATION_ERROR(negative_nr, Text, { TRUE | FALSE } ):  \nDieser Befehl zeigt auch eine Fehlermeldung an, die als Text vorgegeben wird. Zudem erzeugt er aber auch einen neuen Fehler und bricht das Programm fehlerhaft ab. Mit diesem Befehl erreicht man also, dass in den EXCEPTIONS ein Fehler behandelt wird und das Programm trotzdem fehlerhaft abbricht. Die negative Zahl muss im Bereich von -20000 bis -20999 liegen. Sie spielt eine Rolle, wenn mehrere solcher Nachrichten zu unterscheiden sind und wenn Fehler\nbei geschachtelten Programmen zur sp\u00e4teren Bearbeitung nach oben weitergereicht werden. Mit TRUE wird spezifiziert, dass die Fehlermeldung auf einem System-Fehler- Stack oben aufgelegt werden soll, und mit dem Default-Wert FALSE, dass die Meldung alle bisherigen Meldungen des Stack \u00fcberschreibt.", "type": "text", "answers": [{"text": "Das ist: (Befehlsname ohne Parameter)", "solution": "RAISE_APPLICATION_ERROR"}]}, {"id": 2229, "category": 9, "difficulty": 2, "text": "Welche SQL-Anweisungen k\u00f6nnen in PL/SQL direkt und ohne syntaktische \u00c4nderungen ausgef\u00fchrt werden?", "explanation": "SELECT braucht eine INTO-Klausel oder einen Cursor, DDL-Anweisungen sind in PL/SQL nicht vorgesehen. Sie k\u00f6nnen nur \u00fcber dynamischens SQL  (NDS, EXECUTE IMMEDIATE) ausgef\u00fchrt werden.", "type": "multiple-choice", "answers": [{"text": "INSERT, UPDATE, DELETE", "solution": "true"}, {"text": "COMMIT, ROLLBACK", "solution": "true"}, {"text": "CREATE, ALTER, DROP", "solution": "false"}, {"text": "SELECT", "solution": "false"}]}, {"id": 2232, "category": 10, "difficulty": 3, "text": "Welcher Ausf\u00fchrungsmodus spezifiziert, dass die Triggeraktion unter Oracle PL/SQL anstelle des feuernden Ereignisses ausgef\u00fchrt werden soll? Wenn es keines gibt schreiben Sie einfach \"keiner\u0094 als L\u00f6sung.", "explanation": "INSTEAD-OF-Trigger werden f\u00fcr Manipulationsereignisse auf Sichten, materialisierte wie auch virtuelle, definiert und statt dieses Ereignisses ausgef\u00fchrt. Im Aktionsteil sind die Manipulationsanweisungen f\u00fcr die relevanten Basistabellen programmiert, die anstelle der \u00c4nderungen der View-Daten durchzuf\u00fchren sind.", "type": "text", "answers": [{"text": "Das ist", "solution": "INSTEAD OF"}]}, {"id": 2237, "category": 9, "difficulty": 2, "text": "Die Tabelle Kunden hat 1000 Datens\u00e4tze. Prim\u00e4rschl\u00fcssel ist die Spalte Kund_id.\nEs wird die folgende Anfrage ausgef\u00fchrt:\n  SELECT funktionsname(spalte1, spalte2) FROM Kunden; \n\nwobei funktionsname eine PL-SQL-Funktion ist.", "explanation": "Die Funktion wird 1000 mal aufgerufen, da Kun_id der Prim\u00e4rschl\u00fcssel der Tabelle Kunden ist, die Kun_id aber nicht in der Abfrage festgelegt ist.", "type": "text", "answers": [{"text": "Wie oft wird die Funktion ausgef\u00fchrt?", "solution": "1000"}]}, {"id": 2239, "category": 9, "difficulty": 1, "text": "Die Tabelle Kunden hat 1000 Datens\u00e4tze. Prim\u00e4rschl\u00fcssel ist die Spalte Kund_id.\nEs wird die folgende Anfrage ausgef\u00fchrt:\n  SELECT funktionsname(spalte1, spalte2) \n    FROM Kunden WHERE Kund_id = 4711;", "explanation": "Die Funktion wird nur einmal aufgerufen, da Kun_id der Prim\u00e4rschl\u00fcssel der Tabelle Kunden ist.", "type": "text", "answers": [{"text": "Wie oft wird die Funktion ausgef\u00fchrt?", "solution": "1"}]}, {"id": 2252, "category": 10, "difficulty": 1, "text": "Das Mutating Table-Problem tritt bei Oracle", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "multiple-choice", "answers": [{"text": "in zeilenorientierten Triggern auf.", "solution": "true"}, {"text": "in befehlsorientierten Triggern auf.", "solution": "false"}, {"text": "gar nicht auf.", "solution": "false"}, {"text": "in beiden Triggerarten auf.", "solution": "false"}]}, {"id": 2253, "category": 10, "difficulty": 3, "text": "Wie k\u00f6nnen Informationen an einen Oracle-Trigger \u00fcbergeben werden?", "explanation": "Das feuernde Ereignis liefert die Werte f\u00fcr die Transitionsvariablen :NEW und :OLD (Oracle leider keine Transitionstabellen), die in den ROW-Triggern verf\u00fcgbar sind. \n\nAndere M\u00f6glichkeiten, Daten an einen Trigger zu \u00fcbergeben, sind eine SELECT-Anweisung oder eine \u00f6ffentliche Package-Variable.\n\nEin Trigger verf\u00fcgt \u00fcber keine Parameter. Dieses Konzept ist nur bei Funktionen und Prozeduren bekannt.", "type": "multiple-choice", "answers": [{"text": "durch das feuernde Ereignis", "solution": "true"}, {"text": "durch Anfragen an Tabellen", "solution": "true"}, {"text": "mittels Parameter\u00fcbergabe: IN, OUT, INOUT", "solution": "false"}, {"text": "durch \u00f6ffentliche (public) Variablen in einem Package", "solution": "true"}]}, {"id": 2254, "category": 10, "difficulty": 1, "text": "Einen Oracle-Trigger, der f\u00fcr mehrere Ereignisse definiert ist,", "explanation": "Verschiedene Ereignisse (INSERT, UPDATE oder DELETE) k\u00f6nnen unter Oracle_SQL den gleichen Programmcode im Action-Teil eines Triggers ausf\u00fchren und dort mit IF INSERTING....., IF DELETING..., IF UPDATETING ...... abgefragt werden. Dies gilt nicht f\u00fcr Standard-SQL.", "type": "multiple-choice", "answers": [{"text": "gibt es bei Oracle nicht.", "solution": "false"}, {"text": "kann f\u00fcr alle Ereignisse nur den gleichen Programmcode ausf\u00fchren.", "solution": "false"}, {"text": "kann f\u00fcr die verschiedenen Ereignisse auch unterschiedlichen Programmcode ausf\u00fchren.", "solution": "true"}]}, {"id": 2255, "category": 10, "difficulty": 1, "text": "Welcher ORACLE-Ausf\u00fchrungsmodus spezifiziert, dass die Triggeraktion anstelle des feuernden Ereignisses ausgef\u00fchrt werden soll?", "explanation": "INSTEAD_OF-Trigger werden f\u00fcr Manipulationsereignisse auf Sichten, materialisierte wie auch virtuelle, definiert und statt dieses Ereignisses ausgef\u00fchrt. Im Aktionsteil sind die Manipulationsanweisungen f\u00fcr die relevanten Basistabellen programmiert, die anstelle der \u00c4nderungen der View-Daten durchzuf\u00fchren sind.", "type": "multiple-choice", "answers": [{"text": "INSTEAD OF", "solution": "true"}, {"text": "REPLACE", "solution": "false"}, {"text": "solch einen Modus gibt es nicht.", "solution": "false"}]}, {"id": 2256, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgende Package-Definition:\n\n    Welche Prozedur-Spezifikation/en ist/sind nicht zul\u00e4ssig?\n\n    CREATE PACKAGE xyz IS PROCEDURE a (p1 NUMBER); -- Nr 1\n\n    PROCEDURE a (p1 NUMBER, p2 NUMBER); -- Nr 2\n\n    PROCEDURE a (p3 NUMBER); -- Nr 3\n\n    PROCEDURE a (p1 DATE); -- Nr 4\n\n    PROCEDURE a (p1 NUMBER); -- Nr 5\n\n    END;\n\n    Welche Prozedur-Spezifikation/en ist/sind nicht zul\u00e4ssig?", "explanation": "Eine Prozedur kann den gleichen Namen und unterschiedliche Parametertypen und -anzahlen, aber nicht den gleichen Namen und sowohl gleiche Parameteranzahlen wie auch Parametertypen haben.", "type": "multiple-choice", "answers": [{"text": "Nr 1", "solution": "false"}, {"text": "Nr 2", "solution": "false"}, {"text": "Nr 3", "solution": "false"}, {"text": "Nr 4", "solution": "false"}, {"text": "Nr 5", "solution": "true"}]}, {"id": 2270, "category": 9, "difficulty": 3, "text": "Welche Methoden hat das Interface connection?", "explanation": "Ein JAVA-Programm kann eine oder mehrere Verbindungen zu einer oder mehreren Datenbanken unterhalten.\nJede Verbindung wird durch ein Objekt realisiert, das das Interface Connection implementiert.\nDieses Interface definiert unter anderem folgende Methoden:\nMit der Methode createStatement() kann ein Objekt, welches das Interface Statement implementiert, erzeugt werden.  Analog dazu wird mit der Methode prepareStatement(String sql) eine Anweisung vorbereitet.  Durch den Aufruf von setAutoCommit(boolean) wird der Autocommit-Modus der Verbindung an- oder ausgeschaltet.  \n- Mit getAutoCommit() wird gepr\u00fcft, welcher Modus vorliegt.\n- Mit close() wird die Verbindung explizit geschlossen,\n- mit isClosed() kann dies nachgepr\u00fcft werden.", "type": "multiple-choice", "answers": [{"text": "createStatement", "solution": "true"}, {"text": "prepareStatement", "solution": "true"}, {"text": "prepareCallableStatement", "solution": "true"}, {"text": "prepareCall", "solution": "true"}, {"text": "createCall", "solution": "false"}]}, {"id": 2280, "category": 9, "difficulty": 3, "text": "Welche/r Datentyp/en / Typkonstruktoren f\u00fchren zu einer Verletzung der 1. Normalform bei objektrelationalen DBSen von Oracle/ bei SQL2003?", "explanation": "TABLE, VARRAY und NESTED TABLE beinhalten per Definition eine Verletzung der ersten Normalform, da sie sogenannte Kollektionsdatentypen sind und es erm\u00f6glichen, mengenwertige Attribute zu spezifizieren. Die 1. Normalform hingegen schlie\u00dft genau diese mengenwertigen Attribute aus.", "type": "multiple-choice", "answers": [{"text": "NUMBER", "solution": "false"}, {"text": "VARRAY / ARRAY", "solution": "true"}, {"text": "DATE", "solution": "false"}, {"text": "BLOB", "solution": "false"}, {"text": "NESTED TABLE / MULTISET", "solution": "true"}, {"text": "Benutzerdefinierte Datentypen ohne Kollektionsdatentypen", "solution": "false"}, {"text": "CLOB, NCLOB", "solution": "false"}, {"text": "BFILE", "solution": "false"}, {"text": "TABLE", "solution": "true"}]}, {"id": 2281, "category": 9, "difficulty": 1, "text": "F\u00fcr welche/s Einsatzgebiet/e sind objektrelationale DBS am besten geeignet?", "explanation": "Komplexe Datenstrukturen k\u00f6nnen mit den objektrelationalen Features wie CREATE TYPE .. gut abgebildet werden. F\u00fcr Abfragen ist in einem ORDBMS SQL ausgebaut worden.", "type": "multiple-choice", "answers": [{"text": "Keine Anfragen und einfache Daten", "solution": "false"}, {"text": "Viele Anfragen und einfache Daten", "solution": "false"}, {"text": "Viele Anfragen und komplexe Daten", "solution": "true"}, {"text": "Keine Anfragen und komplexe Daten", "solution": "false"}, {"text": "Dies sind keine geeigneten Kriterien f\u00fcr eine Einsatzentscheidung.", "solution": "false"}]}, {"id": 2282, "category": 9, "difficulty": 1, "text": "Objektrelationale DBS sind bestens geeignet, wenn komplexe Daten zu verwalten sind und keine Anfragen gestellt werden.\n\nDiese Aussage", "explanation": "Komplexe Datenstrukturen k\u00f6nnen mit den objektrelationalen Features wie CREATE TYPE .. gut abgebildet werden. F\u00fcr Abfragen ist in einem ORDBMS SQL ausgebaut worden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2283, "category": 9, "difficulty": 1, "text": "Objektrelationale DBS sind bestens geeignet, wenn einfache Daten zu verwalten sind und viele Anfragen gestellt werden.\n\nDiese Aussage", "explanation": "Falls einfach strukturierte Daten vorliegen, reicht ein relationales Datenbanksystem vollst\u00e4ndig aus.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2284, "category": 9, "difficulty": 1, "text": "Objektrelationale DBS sind bestens geeignet, wenn komplexe Daten zu verwalten sind und viele Anfragen gestellt werden.\n\nDiese Aussage", "explanation": "Falls kein objektrelationales Datenbanksystem zur Verf\u00fcgung steht, k\u00f6nnen zu einem objektrelationalen Datenmodell Standardabbildungen definiert werden, die den Entwurf auf ein relationales Datenbankschema definieren. Diese Abbildungen hei\u00dfen objektrelationale Abbildungen. Das Vorgehen ist in der Praxis weit verbreitet, da sich objektrelationale Modelle gut zur Beschreibung komplexer Probleme eignen und man den Umstieg auf ein objektrelationales System noch scheut.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2286, "category": 9, "difficulty": 2, "text": "Nach einer objektorientierten Analyse z.B. mit UML wird mittels einem relationalem DBS implementiert.", "explanation": "Problem ist hier das die m\u00e4chtigen OO-Konzepte (Klassen, Methoden, Objektidentit\u00e4t, Aggregation, ...) auf einfache relationale Strukturen (Relationen, Prozeduren, Funktionen, Prim\u00e4rschl\u00fcssel, Fremdschl\u00fcssel) abgebildet werden m\u00fcssen - das macht OR-Mapping notwendig.", "type": "multiple-choice", "answers": [{"text": "Dieser Weg ist in der Praxis kaum zu finden", "solution": "false"}, {"text": "Dieser Weg ist relativ unproblematisch.", "solution": "false"}, {"text": "Dieser Weg beinhaltet das Impadance Missmatch-Problem und erfordert OR-Mapping.", "solution": "true"}]}, {"id": 2287, "category": 9, "difficulty": 2, "text": "Was geh\u00f6rt zu einem objektrelationalen DBS?", "explanation": "Dieser User ist noch nicht erfunden worden :-).", "type": "multiple-choice", "answers": [{"text": "objektrelationales Typsystem", "solution": "true"}, {"text": "objektrelationale Tabellen", "solution": "true"}, {"text": "objektrelationale Sichten", "solution": "true"}, {"text": "objektrelationale User", "solution": "false"}]}, {"id": 2291, "category": 9, "difficulty": 3, "text": "Es gibt beim Oracle-ORDBS", "explanation": "Tabellenhierarchien existieren nur im Standard-SQL, Benutzerhierarchien \u00fcberhaupt nicht.", "type": "multiple-choice", "answers": [{"text": "Typhierarchien", "solution": "true"}, {"text": "Tabellenhierarchien", "solution": "false"}, {"text": "Sichthierarchien", "solution": "true"}, {"text": "Benutzerhierarchien", "solution": "false"}]}, {"id": 2292, "category": 9, "difficulty": 2, "text": "Es gibt beim objektrelationalen SQL", "explanation": "Beim objektrelationalem SQL gibt es f\u00fcr Typen, Tabellen und Sichten entsprechende Hierarchiekonzepte mit Vererbung. \nBenutzerhierarchien sind hingegen unbekannt.", "type": "multiple-choice", "answers": [{"text": "Typhierarchien", "solution": "true"}, {"text": "Tabellenhierarchien", "solution": "true"}, {"text": "Sichthierarchien", "solution": "true"}, {"text": "Benutzerhierarchien", "solution": "false"}]}, {"id": 2293, "category": 9, "difficulty": 2, "text": "Welche Klausel sorgt daf\u00fcr, dass ein definierter Typ ein Supertyp werden kann?", "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt \u00fcber die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "text", "answers": [{"text": "Das ist die Klausel:", "solution": "NOT FINAL"}]}, {"id": 2294, "category": 9, "difficulty": 3, "text": "Welche Klausel sorgt bei Oracle daf\u00fcr, dass ein definierter Typ ein Subtyp wird? Geben Sie nur die Klausel ohne Zus\u00e4tze an!", "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt \u00fcber die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "text", "answers": [{"text": "Das ist die Klausel:", "solution": "UNDER"}]}, {"id": 2295, "category": 9, "difficulty": 1, "text": "Welcher Befehl definiert bei Oracle einen Subtypen?", "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt \u00fcber die der UNDER-Klausel: CREATE TYPE  UNDER  AS  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "multiple-choice", "answers": [{"text": "CREATE TYPE <Typname> AS OBJECT ...", "solution": "false"}, {"text": "CREATE TYPE <Subtypname> UNDER <Supertypname> AS", "solution": "true"}, {"text": "CREATE SUBTYPE <Subtypname> OF <Supertypname> AS", "solution": "false"}]}, {"id": 2296, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Typkonstruktoren sind wahr?", "explanation": "Hier ist der Typkonstruktor gemeint, im Gegensatz zum Wert-oder Instanzkonstruktor, der eine Instanz eines Datentyps erzeugt.", "type": "multiple-choice", "answers": [{"text": "Sie erzeugen einen Datentyp.", "solution": "true"}, {"text": "Benannte Datentypen werden in SQL und bei Oracle mittels CREATE TYPE erzeugt.", "solution": "true"}, {"text": "Er wird auch als Instanz- oder Wertkonstruktor bezeichnet.", "solution": "false"}, {"text": "Das DBMS erzeugt automatisch f\u00fcr jeden angelegten (instanzierbaren) Datentyp einen Konstruktor, mit dem Werte dieses Datentyps erzeugt werden k\u00f6nnen.", "solution": "true"}]}, {"id": 2297, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Konstruktoren sind wahr?", "explanation": "Hier ist der Wert- / Instanzkonstruktor gemeint, im Gegensatz zum Typkonstruktor, der einen Datentyp erzeugt.", "type": "multiple-choice", "answers": [{"text": "Sie erzeugen einen Datentyp.", "solution": "false"}, {"text": "Benannte Datentypen werden in SQL und bei Oracle mittels des Konstruktors CREATE TYPE erzeugt.", "solution": "false"}, {"text": "Ein Konstruktor wird auch als Instanz- oder Wertkonstruktor bezeichnet.", "solution": "true"}, {"text": "Das DBMS erzeugt automatisch f\u00fcr jeden angelegten (instanziierbaren)\nDatentyp einen Konstruktor, mit dem Werte dieses Datentyps erzeugt\nwerden k\u00f6nnen.", "solution": "true"}]}, {"id": 2298, "category": 9, "difficulty": 3, "text": "Welche Arten von benutzerdefinierten Methoden gibt es beim objektrelationalen SQL?", "explanation": "Es kann auch alles richtig sein :-).", "type": "multiple-choice", "answers": [{"text": "statische Methoden", "solution": "true"}, {"text": "Instanzmethode", "solution": "true"}, {"text": "benutzerdefinierte Konstuktormethoden", "solution": "true"}]}, {"id": 2304, "category": 9, "difficulty": 3, "text": "Der Begriff der strengen Typisierung bedeutet, dass", "explanation": "Typumwandlungen k\u00f6nnen mit expliziten und impliziten Typumwandlungen durchgef\u00fchrt werden.", "type": "multiple-choice", "answers": [{"text": "f\u00fcr die Attribute von Objekttabellen nur strukturierte Datentypen verwendet werden k\u00f6nnen.", "solution": "false"}, {"text": "keine Vergleichbarkeit von verschiedenen Typen mit gleicher Struktur m\u00f6glich ist.", "solution": "true"}, {"text": "die Typkonvertierung ausschlie\u00dflich mittels expliziter Typumwandlungen durchgef\u00fchrt werden.", "solution": "false"}, {"text": "die Typkonvertierung ausschlie\u00dflich mittels impliziter Typumwandlungen durchgef\u00fchrt werden.", "solution": "false"}]}, {"id": 2078, "category": 9, "difficulty": 3, "text": "Welche Aussage \u00fcber einen Join in SQL2003 ist richtig?", "explanation": "richtig sind: \nEin Theta-Join kann eine USING-Komponente haben.\n\nfalsch sind: \nEin Theta-Join kann eine USING-Komponente sowie eine ON-Komponente in der gleiche FROM -Klausel haben. \nEin Natural-Join kann eine USING-Komponente haben.\nEin Natural-Join kann eine ON-Komponente haben.", "type": "multiple-choice", "answers": [{"text": "Ein Theta-Join kann eine USING-Komponente haben.", "solution": "true"}, {"text": "Ein Theta-Join kann eine USING-Komponente sowie eine ON-Komponente in der gleiche FROM -Klausel haben.", "solution": "false"}, {"text": "Ein Natural-Join kann eine USING-Komponente haben.", "solution": "false"}, {"text": "Ein Natural-Join kann eine ON-Komponente haben.", "solution": "false"}]}, {"id": 2081, "category": 9, "difficulty": 3, "text": "Welche Typkonstruktoren hat SQL?", "explanation": "Das relationale Modell basiert auf den beiden Typkonstruktoren ROW(Basisdatentyp) und SET(ROW(Basisdatentyp)). \nSQL hingegen basiert auf den beiden Typkonstruktoren ROW(Basisdatentyp) und MULTISET(ROW(Basisdatentyp)). \nDie beiden Modelle unterscheiden sich also dahingehend, dass bei SQL doppelte Datens\u00e4tze zugelassen sind, w\u00e4hrend bei der RA doppelte Tupel automatisch von den Operatoren eliminiert werden.", "type": "multiple-choice", "answers": [{"text": "ROW", "solution": "true"}, {"text": "UNION", "solution": "false"}, {"text": "SET", "solution": "false"}, {"text": "ARRAY", "solution": "false"}, {"text": "LIST", "solution": "false"}, {"text": "MULTISET", "solution": "true"}]}, {"id": 2083, "category": 9, "difficulty": 3, "text": "Welche SQL-Ausdr\u00fccke liefern unter ORACLE das gleiche Ergebnis, unabh\u00e4ngig vom Inhalt der Tabellen Auftraege und Kunden?", "explanation": "Der (+) Operator in der WHERE-Klausel ist die urspr\u00fcngliche, Oracle-Syntax des Outer-Joins.", "type": "multiple-choice", "answers": [{"text": "SELECT   Kun_Nr, Nachname, Auftragsnr\nFROM     Auftraege  RIGHT OUTER JOIN Kunden \nUSING   (Kun_Nr);", "solution": "true"}, {"text": "SELECT k.Kun_Nr, Nachname, Auftragsnr\nFROM   Auftraege b, Kunden k\nWHERE  k.Kun_Nr = b.Kun_Nr (+);", "solution": "true"}, {"text": "SELECT k.Kun_Nr, Nachname, Auftragsnr\nFROM Auftraege b, Kunden k\nWHERE k.Kun_Nr(+)= b.Kun_Nr;", "solution": "false"}, {"text": "SELECT k.Kun_Nr, Nachname, Auftragsnr\nFROM Auftraege b, Kunden k\nWHERE k.Kun_Nr = b.Kun_Nr;", "solution": "false"}]}, {"id": 2101, "category": 1, "difficulty": 3, "text": "Welche Aussagen \u00fcber ein Datenmodell sind wahr?", "explanation": "Ein Datenmodell stellt einen allgemeinen Begriffsapparat zur Verf\u00fcgung, der es gestattet, Realit\u00e4tsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren. Mit dem Datenmodell werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, \u00e4hnlich wie bei einer Programmiersprache, in der auch Ausdr\u00fccke und Regeln festgelegt sind, die in der Programmiersprache\nbenutzt werden d\u00fcrfen.  \n\nEin Datenmodell hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.", "type": "multiple-choice", "answers": [{"text": "Ein Datenmodell stellt einen allgemeinen Begriffsapparat zur Verf\u00fcgung, der es gestattet, Realit\u00e4tsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren.", "solution": "true"}, {"text": "Mit dem Datenmodell werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, \u00e4hnlich wie bei einer Programmiersprache, in der auch Ausdr\u00fccke und Regeln festgelegt sind, die in der Programmiersprache benutzt werden d\u00fcrfen.", "solution": "true"}, {"text": "Ein Datenmodell ist die konkrete Auspr\u00e4gung eines bestimmten Datenbankschemas mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.", "solution": "false"}, {"text": "Ein Datenmodell hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.", "solution": "true"}, {"text": "Bei einem Datenmodell werden die Daten in Dateien gespeichert, die nur von einem Programm genutzt werden.", "solution": "false"}]}, {"id": 2103, "category": 8, "difficulty": 2, "text": "Welche der genannten Operatoren sind Operatoren der Relationalen Algebra?", "explanation": "Die Konkatenation bezeichnet das Zusammenf\u00fcgen z.B. von zwei Zeichenketten und ist als separate Funktion bei SQL verf\u00fcgbar, es ist aber kein Operator der RA.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "true"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}, {"text": "Division", "solution": "true"}, {"text": "Differenz", "solution": "true"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Theta-Join", "solution": "true"}, {"text": "Natural Join", "solution": "true"}, {"text": "Equi-Join", "solution": "true"}, {"text": "Outer Join (Left, Full, Right)", "solution": "true"}, {"text": "Konkatenation", "solution": "false"}]}, {"id": 2104, "category": 8, "difficulty": 3, "text": "Welche der genannten Operatoren sind abgeleitete Operatoren der Relationalen Algebra, die mittels der Basisoperatoren simuliert werden k\u00f6nnen?", "explanation": "Basisoperatoren sind: Selektion, Projektion, Differenz, kartesisches Produkt, Vereinigung. \nTheta-, Equi- und die Outer Joins lassen sich mittels kartesischem Produkt und Selektion simulieren. \nNatural Join l\u00e4sst sich mittels kartesischem Produkt Selektion und Pojektion simulieren. \nDie Division l\u00e4sst sich mittels Selektion, Projektion, kartesischem Produkt und Differenz ableiten.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Division", "solution": "true"}, {"text": "Differenz", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Theta-Join", "solution": "true"}, {"text": "Natural Join", "solution": "true"}, {"text": "Equi-Join", "solution": "true"}, {"text": "Outer Join (Left, Full, Right)", "solution": "true"}]}, {"id": 2106, "category": 9, "difficulty": 2, "text": "Was versteht man unter \"Dangling-Datens\u00e4tzen\" in SQL?", "explanation": "Werden Fremdschl\u00fcssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datens\u00e4tze, die noch von Detail-Datens\u00e4tze referenziert werden, gel\u00f6scht oder deren Schl\u00fcsselwert ge\u00e4ndert wird und das anschlie\u00dfend Detail-Datens\u00e4tze existieren, f\u00fcr deren Fremdschl\u00fcsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt. \nDas Einf\u00fcgen von Master-Datens\u00e4tzen ist immer unproblematisch, da eine Fremdschl\u00fcsselbedingung es zul\u00e4\u00dft, dass es Master-Datens\u00e4tze gibt, f\u00fcr die es keine Detail-Datens\u00e4tze gibt. \n\nAnaloge Probleme k\u00f6nnen bei Join-Operationen (Theta, Equi, Natural) auftreten. In die Ergebnismenge werden nur die Datens\u00e4tze aufgenommen, die die Verkn\u00fcpfungsbedingung erf\u00fcllen. Alle anderen fallen heraus, das sind die sog. \"dangling tuples\". Will man diese auch anzeigen lassen, muss man mit LEFT/RIGHT/FULL OUTER JOINs arbeiten.", "type": "multiple-choice", "answers": [{"text": "Datens\u00e4tze, die nicht gesichert werden.", "solution": "false"}, {"text": "Datens\u00e4tze, denen bei Join-Operationen bzw. bei Fremdschl\u00fcsselbeziehungen die entsprechenden Datens\u00e4tze in der anderen Tabelle fehlen, mit denen sie verkn\u00fcpft werden k\u00f6nnen.", "solution": "true"}, {"text": "Datens\u00e4tze, denen Attributwerte fehlen.", "solution": "false"}, {"text": "Ge\u00e4nderte Datens\u00e4tze, deren Transaktion noch nicht abgeschlossen ist.", "solution": "false"}]}, {"id": 2073, "category": 9, "difficulty": 1, "text": "Welcher Join-Tabellen-Typ hat eine ON-Klausel?", "explanation": "Beim CROSS JOIN, dem kartesischen Produkt, gibt es gar keine Verkn\u00fcpfungsbedingung. Jeder Datensatz der einen Relation wird \"grundlos\" mit jedem anderen aus der anderen Relation verkn\u00fcpft.\nBeim NATURAL JOIN gibt es zwar eine Bedingung, aber die ist vordefiniert, so dass sie nicht mittels USING spezifiziert werden muss. Die vordefinierte Bedingung hei\u00dft: Alle Spalten mit gleichen Namen werden auf Gleichheit verglichen und die Teilbedingungen ggf. mit AND verkn\u00fcpft.\nLediglich beim THETA JOIN wird eine Bedingung angegeben.", "type": "multiple-choice", "answers": [{"text": "CROSS-Join", "solution": "false"}, {"text": "THETA-Join", "solution": "true"}, {"text": "NATURAL-Join", "solution": "false"}]}, {"id": 2074, "category": 9, "difficulty": 3, "text": "Welche Aussage \u00fcber einen Theta-Join in SQL2003 ist richtig?", "explanation": "Jede Using-Komponente l\u00e4sst sich auch \u00fcber eine ON-Komponente formulieren. \nDie bei der USING-Klausel angegebenen Spalten werden implizit auf Gleichheit verglichen. Bei der ON-Klausel k\u00f6nnen beliebige Verk\u00fcpfungsbedingungen definiert werden.", "type": "multiple-choice", "answers": [{"text": "Jede Using-Komponente l\u00e4sst sich auch \u00fcber eine ON-Komponente formulieren.", "solution": "true"}, {"text": "Jede ON-Komponente l\u00e4sst sich auch \u00fcber eine USING-Komponente formulieren.", "solution": "false"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 2092, "category": 9, "difficulty": 3, "text": "Die Tabellen \"ausleihen\" und \"fahrzeuge\" sollen unter anderem folgende Spalten  haben: \nausleihen (kfz_nr, Kunden_Nr, von, bis,....)\nFahrzeuge (kfz_nr, nummernschild,...)\n\nWelche SELECT-Anweisung beantwortet die Anfrage: Gibt es Fahrzeuge, die noch nie ausgeliehen wurden?", "explanation": "RICHTIG sind: \nDer LEFT OUTER JOIN nimmt alle Datens\u00e4tze der linken Tabelle, also der Fahrzeuge und verkn\u00fcpft sie falls m\u00f6glich mit Ausleihvorg\u00e4ngen. Bei den Fahrzeugen, f\u00fcr die es keine Ausleihvorg\u00e4nge gibt, ist die Spalte von NULL. \nDer FULL OUTER JOIN nimmt sowohl von den Ausleihen wie auch von den Fahrzeugen alle Datens\u00e4tze und verf\u00e4hrt dann weiter wie beim LEFT OUTER JOIN. Der FULL ist etwas \"oversized\", der LEFT reicht v\u00f6llig aus f\u00fcr den gew\u00fcnschten Effekt.\nBeim NOT IN werden alle Fahrzeug-Datens\u00e4tze gepr\u00fcft, ob es f\u00fcr ihre kfz_nr einen Datensatz in der Ausleihe-Tabelle gibt, wenn nicht, dann kommt dieser Fahrzeug-Datensatz in die Ergebnismenge. \n\nFALSCH sind: \nRIGHT OUTER Join hei\u00dft ja, das die rechte Tabelle vollst\u00e4ndig \u00fcbernommen wird, hier also die Ausleihen und falls m\u00f6glich mit KFZs verbunden wird und die sonst fehlenden Spalten mit NULL aufgef\u00fcllt werden. Damit ist die Semantik mit der IS NULL-Bedingung: \"F\u00fcr welche Ausleihen haben keine Fahrzeuge?\" \n\nDer NATURAL JOIN ist falsch, weil er implizit die Bedingung \"WHERE ausleihen.kfz_nr = fahrzeuge.kfz_nr\" ausf\u00fchrt. Seine Semantik w\u00e4re bis dahin: \"Welche Fahrzeuge wurden ausgeliehen?\" Die zus\u00e4tzliche Bedingung \"von IS NULL\" f\u00fchrt f\u00fcr den Fall, dass \"von\" f\u00fcr Ausleihen Pflichteinfabefeld ist, zu einer unerf\u00fcllbaren Bedingung, so dass die Ergebnismenge immer leer ist. Ist die Spalte \"von\" kein Pflichteingabefeld, so ist die Semantik der Anfrage: \"Welche Fahrzeuge wurden ausgeliehen und deren von-Datum ist vergessen worden einzutragen.\"\n\nDie NOT EXISTS-Anfrage w\u00e4re richtig, wenn sie korreliert w\u00e4re, also die Bedingung \"WHERE ausleihen.kfz_nr = fahrzeuge.kfz_nr\" h\u00e4tte. So liefert die Unteranfrage immer dann wenigstens einen Datensatz, wenn die Tabelle Ausleihen gef\u00fcllt ist - und damit ist NOT EXISTS immer FALSE, wenn die Ausleihen-Tabelle Datens\u00e4tze enth\u00e4lt, unabh\u00e4ngig davon, welche KfFZ_NR dort vertreten sind.", "type": "multiple-choice", "answers": [{"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge LEFT OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge RIGHT OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;", "solution": "false"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge FULL OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;", "solution": "false"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT EXISTS (SELECT DISTINCT kfz_nr from ausleihen)", "solution": "false"}]}, {"id": 2125, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank \nSpieler (Spieler_id, Name, Adresse, Geburtsdatum)\nVereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr)\nSpiele  (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\nSpieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\nWelche der angegeben SQL-Abfragen beantwortet/en die Frage: \nWelche Vereine (K\u00fcrzel, Name) haben wenigstens ein Ausw\u00e4rtsspiel, also wenigstens ein Spiel als Gastmannschaft in der R\u00fcckrunde (Spieltag 18-34) absolviert?", "explanation": "RICHTIG sind: alle Anfragen\nDie Teilaussage \"...welche Vereine haben gespielt...\" kann durch einen (Natural) Join, einen IN- oder auch einen EXISTS-Operator formuliert werden. \nDa der BETWEEN-Operator die Grenzen mit einschlie\u00dft, muss die Simulation <= und >= verwenden. \n\nFALSCH ist: keine der Anfragen", "type": "multiple-choice", "answers": [{"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND  spieltag BETWEEN 18 AND 34;", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND spieltag >= 18 AND spieltag <= 34;", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34);", "solution": "true"}, {"text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE EXISTS \n(SELECT * FROM spiele \n WHERE spieltag BETWEEN 18 AND 34\n AND gast_v_kuerzel = v_kuerzel);", "solution": "true"}]}, {"id": 2098, "category": 1, "difficulty": 2, "text": "ANSI-3-Ebenen-Modell: Was geh\u00f6rt zur externen Ebene?", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "physische Datenstruktur", "solution": "false"}, {"text": "konzeptionelles Schema", "solution": "false"}, {"text": "Anwendungen", "solution": "true"}, {"text": "Datenbankschema", "solution": "false"}]}, {"id": 2099, "category": 1, "difficulty": 1, "text": "ANSI-3-Ebenen-Modell: Was geh\u00f6rt zur internen Ebene?", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "externe Datenstruktur", "solution": "false"}, {"text": "physische Datenstruktur", "solution": "true"}, {"text": "konzeptionelles Schema", "solution": "false"}, {"text": "Anwendungen", "solution": "false"}, {"text": "Datenbankschema", "solution": "false"}]}, {"id": 2100, "category": 1, "difficulty": 1, "text": "ANSI-3-Ebenen-Modell: Was geh\u00f6rt zur konzeptionellen Ebene?", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "externe Datenstruktur", "solution": "false"}, {"text": "physische Datenstruktur", "solution": "false"}, {"text": "konzeptionelles Schema", "solution": "true"}, {"text": "Anwendungen", "solution": "false"}, {"text": "Datenbankschema", "solution": "true"}]}, {"id": 2107, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die f\u00fcnf Tupel eingetragen sind.\n\nWie viele Spalten hat der Natural Join der Tabelle Test mit sich selber?", "explanation": "Der Natural Join einer Tabelle mit sich selber ergibt wieder die Ursprungstabelle, und die hat hier 3 Spalten.", "type": "multiple-choice", "answers": [{"text": "5", "solution": "false"}, {"text": "10", "solution": "false"}, {"text": "25", "solution": "false"}, {"text": "3", "solution": "true"}]}, {"id": 2137, "category": 9, "difficulty": 2, "text": "Die Tabellen \"ausleihen\" und \"fahrzeuge\" sollen unter anderem folgende Spalten  haben: \nausleihen (kfz_nr, Kunden_Nr, von, bis,....)\nFahrzeuge (kfz_nr, nummernschild,...)\n\nWelche SELECT-Anweisung beantwortet die Anfrage: \n\"Gibt es Fahrzeuge, die noch nie ausgeliehen wurden?\"", "explanation": "RICHTIG sind: \nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT EXISTS \n(SELECT * from ausleihen WHERE fahrzeuge.kfz_nr = ausleihen.kfz_nr)\n\nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)\n \n\nFALSCH sind: \nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;\nmit der Semantik: \"Welche Fahrzeuge wurden ausgeliehen?\" \n\nSELECT kfz_nr, nummernschild, ausleihen.von \nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr;\nmit einer unerf\u00fcllbaren Bedingung. Die implizite Bedingung des Natural Joins \"fahrzeuge.kfz_nr = ausleihen.kfz_nr\" wiederspricht der formulierten WHERE-Klausel \"WHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr\".", "type": "multiple-choice", "answers": [{"text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;", "solution": "false"}, {"text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge \nWHERE NOT EXISTS \n(SELECT * from ausleihen WHERE fahrzeuge.kfz_nr = ausleihen.kfz_nr)", "solution": "true"}, {"text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr;", "solution": "false"}]}, {"id": 2138, "category": 9, "difficulty": 2, "text": "Damit die folgende UPDATE-Anweisung ausgef\u00fchrt werden kann:\nUPDATE TABELLE 1 SET SPALTE1 = (SELECT SPALTE2 FROM TABELLE2);", "explanation": "Die Abfrage darf nur einen Ergebnisdatensatz liefern, da ein Tupel in einem Feld (hier Spalte1) auch nur einen Wert aufnehmen kann.", "type": "multiple-choice", "answers": [{"text": "darf die Abfrage nur einen Ergebnisdatensatz liefern.", "solution": "true"}, {"text": "muss die Abfrage so viele Ergebnisdatens\u00e4tze liefern, wie Datens\u00e4tze mit der UPDATE-Anweisung ge\u00e4ndert werden.", "solution": "false"}, {"text": "gelten keine Einschr\u00e4nkungen hinsichtlich der Ergebnismenge der Abfrage.", "solution": "false"}]}, {"id": 2063, "category": 9, "difficulty": 2, "text": "Um welchen Typ einer Integrit\u00e4tsbedingung handelt es sich hier?\n\nDer Einkaufspreis eines Produkts darf innerhalb eines Jahres nicht um mehr als 10 % steigen.", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingung", "solution": "false"}, {"text": "dynamische, transitionale Bedingung", "solution": "false"}, {"text": "statische, transitionale Bedingung", "solution": "false"}, {"text": "dynamische, temporale Bedingung", "solution": "true"}, {"text": "statische, temporale Bedingung", "solution": "false"}]}, {"id": 2084, "category": 9, "difficulty": 3, "text": "Welche SELECT-Abfragen sind syntaktisch korrekt?", "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \n* Die beteiligten Tabellen (Eingangsdatenmengen) m\u00fcssen die gleichen Spaltendefinitionen aufweisen: \n* Die Anzahl der Spalten muss \u00fcbereinstimmen. \n* Die Datentypen der der Spalten m\u00fcssen gleich sein.  \n* Die Reihenfolge der Spalten muss \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "SELECT Nachname, Vorname\nFROM Angestellte\n    UNION\nSELECT Nachname\nFROM Kunden;", "solution": "false"}, {"text": "SELECT Nachname\nFROM Angestellte\n    UNION\nSELECT Nachname\nFROM Kunden;", "solution": "true"}, {"text": "SELECT Nachname\nFROM Angestellte\n    MINUS\nSELECT Vorname\nFROM Kunden;", "solution": "true"}]}, {"id": 2379, "category": 9, "difficulty": 3, "text": "Welche Eigenschaften hat eine objektrelationale Sicht bei Oracle?", "explanation": "Welche Tabellen-/Sichtformen kann es in einem ORDBMS geben?\n\nDefinitionsart: untypisiert vs. typisiert \n- Untypisiert: die Struktur ergibt sich direkt aus den Attributstrukturen (RM)\n- Typisiert: Sicht-/Tabellendefinition basiert auf benutzerdefinierten Typ (OR)\n\nZeilentyp: tupelwertig vs. objektwertig \n- Tupelwertig: keine Methodenaufrufe f\u00fcr ein konkretes Tupel (RM)\n- Objektwertig: Methodenaufrufe des zugeh\u00f6rigen Objekttyps direkt \u00fcber die Zeilenvariable (OR)\n\nReferenzierbarkeit: nicht referenzierbar vs. referenzierbar  \n- Nicht referenzierbar: Zeilen sind nicht referenzierbar (RM)\n- Referenzierbar: Zeilen sind mittels Referenzspalten (OIDs) referenzierbar; setzt OIDs voraus (OR)\n\n\nRelationale Tabellen sind: \n- tupelwertig, \n- untypisiert, \n- nicht referenzierbar\n\nObjektorientierte/objektrelationale Klassen/Tabellen sind: \n- objektwertig, \n- typisiert, \n- referenzierbar", "type": "multiple-choice", "answers": [{"text": "Typisiert", "solution": "true"}, {"text": "Untypisiert", "solution": "false"}, {"text": "Tupelwertig", "solution": "false"}, {"text": "Objektwertig", "solution": "true"}, {"text": "Referenzierbar", "solution": "true"}, {"text": "Nicht referenzierbar", "solution": "false"}]}, {"id": 2409, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle: \n\n    CREATE TABLE Zeitschrift ( Zeitschrift_id INTEGER NOT NULL, Namen VARCHAR2(20) NULL, PRIMARY KEY (Zeitschrift_id));\n\n    CREATE TABLE Aufsatz ( Aufsatz_id INTEGER NOT NULL, Titel VARCHAR2(20) NULL, Zeitschrift_id INTEGER NOT NULL, PRIMARY KEY (Aufsatz_id), FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\n    Welche der beiden Tabellen kann zuerst gel\u00f6scht werden?", "explanation": "Eine Tabelle mit einem Primary-Key (hier Zeitschrift mit Zeitschrift_id) , der als Foreign-Key in einer anderen Tabelle vorkommt, kann nicht gel\u00f6scht werden, solange die Verweistabelle noch existiert.", "type": "multiple-choice", "answers": [{"text": "Zeitschrift", "solution": "false"}, {"text": "Aufsatz", "solution": "true"}]}, {"id": 2410, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle: \n\nCREATE TABLE Zeitschrift ( Zeitschrift_id INTEGER NOT NULL, Namen VARCHAR2(20) NULL, PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz ( Aufsatz_id INTEGER NOT NULL, Titel VARCHAR2(20) NULL, Zeitschrift_id INTEGER NOT NULL, PRIMARY KEY (Aufsatz_id), FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\nAuf welcher der beiden Tabellen ist ein ON DELETE CASCADE m\u00f6glich, mit dem Zweck, dass zu einer Zeitschrift auch die zuh\u00f6rigen Aufs\u00e4tze gel\u00f6scht werden?", "explanation": "ON DELETE CASCADE ist eine Option des Fremdschl\u00fcssel-Constraints und da bei der Zeitschriften-Tabelle gar kein Fremdschl\u00fcssel definiert ist, kann auch kein ON DELETE CASCADE spezifiziert werden.", "type": "multiple-choice", "answers": [{"text": "Zeitschrift", "solution": "false"}, {"text": "Aufsatz", "solution": "true"}]}, {"id": 2412, "category": 9, "difficulty": 3, "text": "Welche Datenbankobjekte k\u00f6nnen unter Oracle mit CREATE OR REPLACE angelegt werden?", "explanation": "Datens\u00e4tze werden mittels INSERT eingef\u00fcgt und mittels UPDATE ge\u00e4ndert. \nF\u00fcr Benutzer gibt es nur eine CREATE-Anweisung, ebenso wie f\u00fcr Tabellen. \nCREATE OR REPLACE-Anweisungen gibt es f\u00fcr gespeicherte Routinen, Views, Trigger.", "type": "multiple-choice", "answers": [{"text": "Tabellen", "solution": "false"}, {"text": "Views", "solution": "true"}, {"text": "Benutzer", "solution": "false"}, {"text": "Trigger", "solution": "true"}, {"text": "gespeicherte Prozeduren", "solution": "true"}, {"text": "Datens\u00e4tze", "solution": "false"}]}, {"id": 2439, "category": 9, "difficulty": 2, "text": "In einer Oracle-When-Bedingung eines Zeilentriggers kann eine SELECT-Anweisung stehen.", "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugeh\u00f6rigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgef\u00fchrt (bei FALSE und NULL nicht). Sie muss immer in Klammern  stehen.\n\n    \n\n    Zu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung gepr\u00fcft, ob der Aktionsteil ausgef\u00fchrt wird. SELECT-Anweisungen sind hier nicht zugelassen\n\n    \n\n    Da Oracle keine Transitionstabellen kennt und Transitionsvariablen zu zeilenorienterten Triggern mit einer WHEN -Bedingung geh\u00f6ren, sind ORACLE-Trigger mit einer WHEN-Bedingung immer zeilenorientiert.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2440, "category": 9, "difficulty": 2, "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Prim\u00e4rschl\u00fcssel A, S den Prim\u00e4rschl\u00fcssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz?", "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS ausgedr\u00fcckt werden.", "type": "multiple-choice", "answers": [{"text": "SELECT *\nFROM R\nWHERE A NOT IN (SELECT B FROM S);", "solution": "true"}, {"text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;", "solution": "true"}, {"text": "SELECT * FROM S\n MINUS\nSELECT * FROM R;", "solution": "false"}]}, {"id": 1501, "category": 9, "difficulty": 3, "text": "Mit dem ALTER TABLE-Befehl kann man unter Oracle-SQL", "explanation": "Der Befehl RENAME benennt eine Tabelle um.\nMit einem ALTER TABLE hingegen kann eine Spalte umbenannt werden, eine Spalte vergr\u00f6\u00dfert werden oder auch gel\u00f6scht werden und vieles vieles mehr.", "type": "multiple-choice", "answers": [{"text": "eine Spalte hinzuf\u00fcgen", "solution": "true"}, {"text": "eine Tabelle umbenennen", "solution": "false"}, {"text": "eine Spalte umbenennen", "solution": "true"}, {"text": "eine Spalte vergr\u00f6\u00dfern", "solution": "true"}, {"text": "eine Spalte l\u00f6schen", "solution": "true"}]}, {"id": 1510, "category": 9, "difficulty": 3, "text": "Zu SQL2003 geh\u00f6ren folgende Datentypen:", "explanation": "Zum SQL2003-Standard geh\u00f6ren folgende Datentypen: \nCHARACTER, CHARACTER VARYING, CHARACTER LARGE OBJECT, BINARY LARGE OBJECT, NUMERIC, DECIMAL, SMALLINT, INTEGER, BIGINT, FLOAT, REAL, DOUBLE PRECISION, BOOLEAN, DATE, TIME, TIMESTAMP, INTERVAL. \n\nDie \u00fcbrigen Datentypen geh\u00f6ren zu Oracle: \nLONG RAW, BFILE, LOB, CLOB, BLOB, NCLOB", "type": "multiple-choice", "answers": [{"text": "LONG RAW", "solution": "false"}, {"text": "NCLOB", "solution": "false"}, {"text": "BOOLEAN", "solution": "true"}, {"text": "BLOB", "solution": "false"}, {"text": "CLOB", "solution": "false"}, {"text": "LOB", "solution": "false"}, {"text": "BFILE", "solution": "false"}]}, {"id": 1511, "category": 9, "difficulty": 3, "text": "Aus welchen Komponenten besteht ein LOB-Datentyp? (in alphabetischer Reihenfolge und englisch)", "explanation": "Der LOB-Locator ist der Zeiger auf die Adresse des LOBS in der Datenbank, der LOB-Value der eigentliche Wert, der die Bin\u00e4rdaten enth\u00e4lt.", "type": "text", "answers": [{"text": "Das ist der LOB", "solution": "Locator"}, {"text": "und der LOB", "solution": "Value"}]}, {"id": 1512, "category": 9, "difficulty": 2, "text": "\u00dcber eine SELECT-Anweisung an eine CLOB-Spalte werden selektiert", "explanation": "Eine SELECT-Anweisung auf einer BLOB-, CLOB- oder NCLOB-Spalte selektiert immer nur den LOB-Locator, also nicht den LOB-Value.", "type": "multiple-choice", "answers": [{"text": "der Inhalt des Textes, der in der CLOB-Spalte abgelegt ist", "solution": "false"}, {"text": "nur der LOB-Locator", "solution": "true"}, {"text": "keins von beiden", "solution": "false"}]}, {"id": 1513, "category": 9, "difficulty": 3, "text": "Mit welchem Befehl legt man unter ORACLE ab Version 8 ein Verzeichnis an, in das LOBS (Large Objects) vom Datentyp BFILE abgelegt werden k\u00f6nnen?", "explanation": "Der Oracle-Befehl 'CREATE DIRECTORY DIR-Name as 'VERZEICHNIS';' legt ein Verzeichnis im Dateisystem des Datenbankservers an, auf den dann z.B.mit BFILENAME(...) oder dem DBMS_LOB-Paket zugegriffen werden kann. Ein GRANT-Befehl der Form 'grant read, write on VERZEICHNIS to micky_mouse;' ist notwendig, wenn ein anderer Benutzer dieses Verzeichnis nutzen m\u00f6chte.", "type": "text", "answers": [{"text": "Das ist", "solution": "CREATE DIRECTORY"}]}, {"id": 1515, "category": 9, "difficulty": 2, "text": "Welcher der folgenden UPDATE-Befehle ist syntaktisch korrekt, vorausgesetzt, die Tabellen haben die angegebenen Spalten?", "explanation": "In einem UPDATE-Befehl kann man nur \u00fcber eine SELECT-Anweisung auf eine andere Tabelle zugreifen.", "type": "multiple-choice", "answers": [{"text": "UPDATE tab1\nSET spalte1 = tab2.spalte2\nWHERE tab1.spalte3 = tab2.spalte3;", "solution": "false"}, {"text": "UPDATE tab1\nSET spalte1 = \n   (SELECT tab2.spalte2 FROM tab2\n    WHERE  tab1.spalte3 = tab2.spalte3);", "solution": "true"}]}, {"id": 1516, "category": 9, "difficulty": 3, "text": "Welche ORACLE-Datumsformate sind korrekt?", "explanation": "Alle sind richtig. DD steht f\u00fcr den Tag, MM f\u00fcr den Monat, RRRR/YYYY f\u00fcr das Jahr. Ein Jahr kann zwei- oder vierstellig sein. Das Trennzeichen ist beliebig, hier z.B. . und / oder -, ...", "type": "multiple-choice", "answers": [{"text": "DD-MON-RR", "solution": "true"}, {"text": "DD.MM.RR", "solution": "true"}, {"text": "DD.MM.RRRR", "solution": "true"}]}, {"id": 2130, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN\"", "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.", "type": "multiple-choice", "answers": [{"text": "bewirkt keine Sortierung", "solution": "true"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}]}, {"id": 2131, "category": 9, "difficulty": 3, "text": "Der Ausdruck \"SELECT Nachname, SUM(Umsaetze) FROM KUNDEN GROUP BY Nachname\"", "explanation": "GROUP By bewirkt hier keine Sortierung \u00fcber den Nachnamen.", "type": "multiple-choice", "answers": [{"text": "bewirkt eine Gruppierung", "solution": "true"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}]}, {"id": 1744, "category": 1, "difficulty": 3, "text": "ANSI-3-Ebenen-Modell: Ein Anwendungsprogramm wird entwickelt, das neue, zus\u00e4tzliche Datenstrukturen ben\u00f6tigt.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft keine Ebene.", "solution": "false"}]}, {"id": 1749, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den linken Outer-Join der folgenden beiden Relationen \u00fcber R1.S1 = R2.S3!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z", "explanation": "Der linke Outer-Join (linker \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R2 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y", "solution": "true"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}]}, {"id": 1751, "category": 9, "difficulty": 1, "text": "Wie erzeugt man mit einem ALTER TABLE-Befehl einen TABLE-CONSTRAINT?", "explanation": "Mit der Option ADD beim ALTER TABLE k\u00f6nnen Constraint einer bereits bestehenden Tabelle hinzugef\u00fcgt werden. Die Option MODIFY gibt es nicht f\u00fcr CONSTRAINTS selber, sondern nur f\u00fcr Spaltendefinitionen, die aber einen COMSTRAINT haben k\u00f6nnen. \nConstraints sind keine eigenst\u00e4ndigen DB-Objekte, so dass es f\u00fcr sie keine eigenen CREATE, ALTER, DROP-Befehle gibt. Sie k\u00f6nnen nur durch entsprechende CREATE TABLE, ALTER TABLE, DROP TABLE-Befehle erzeugt, manipuliert oder gel\u00f6scht werden.", "type": "multiple-choice", "answers": [{"text": "Mit dem Zusatz MODIFY", "solution": "false"}, {"text": "Mit dem Zusatz ADD", "solution": "true"}]}, {"id": 1750, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Relation R(A, B, C, D, E) mit den funktionalen Abh\u00e4ngigkeiten AB -> C, BC ->D, CD -> E. Welche Attributkombination ist ein (minimaler) eindeutiger Schl\u00fcssel?", "explanation": "Die beiden einzigen Attribute, die von keinem anderen Attribut abh\u00e4ngig sind, sind A und B, also ist die L\u00f6sung AB.\n\nAndererseits bestimmt eine Kombination aus AB und einem anderen Atrribut aus (C, D) alle anderen Attribute.", "type": "text", "answers": [{"text": "Das ist", "solution": "AB"}]}, {"id": 1752, "category": 9, "difficulty": 1, "text": "Wie viele Spalten kann man innerhalb eines ALTER-Table-Befehls (ALTER TABLE XXX ADD (...)) ver\u00e4ndern bzw. neu hinzuf\u00fcgen?", "explanation": "Man kann mit einem ALTER TABLE xxx ADD | MODIFY mehrere Spalten \u00e4ndern bzw. hinzuf\u00fcgen.", "type": "multiple-choice", "answers": [{"text": "eine Spalte", "solution": "false"}, {"text": "mehrere Spalten", "solution": "true"}]}, {"id": 1762, "category": 9, "difficulty": 1, "text": "In PL/SQL kann man mit dynamischem SQL eine Stored Procedure schreiben, die sich selber in der Datenbank l\u00f6scht.", "explanation": "PL/SQL nimmt einfach den String entgegen, der in einer Textvariablen gespeichert ist und f\u00fchrt in als SQL-Anweisung aus. Das kann auch zum Selbstmord der PL/SQL-Prozedur f\u00fchren.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 1622, "category": 42, "difficulty": 2, "text": "Bei welcher Speicherstruktur gibt es einen Algorithmus, mit dem man die Adresse auf der Basis des Schl\u00fcsselwertes berechnen kann?", "explanation": "Das ist die Definition der Hash-Speicherstruktur.", "type": "multiple-choice", "answers": [{"text": "HEAP", "solution": "false"}, {"text": "ISAM", "solution": "false"}, {"text": "B+ Baum", "solution": "false"}, {"text": "HASH", "solution": "true"}]}, {"id": 1623, "category": 42, "difficulty": 3, "text": "Bei welcher Speicherstruktur werden die Daten sequentiell in der Reihenfolge der Eingabe abgelegt?", "explanation": "Das ist die Definition der Heap-Speicherstruktur. Hash ist auch richtig, wenn man nur die Daten selber ohne den Hash-Algorithmus betrachtet", "type": "multiple-choice", "answers": [{"text": "HEAP", "solution": "true"}, {"text": "ISAM", "solution": "false"}, {"text": "B-Baum", "solution": "false"}, {"text": "HASH", "solution": "true"}, {"text": "B-Baum", "solution": "false"}]}, {"id": 1665, "category": 4, "difficulty": 3, "text": "Aus welchen Phasen besteht das Vorgehensmodell zur Systementwicklung nach Balzert, das auch in der Datenbankentwicklung benutzt wird? Tragen Sie die Phasen in der korrekten Reihenfolge ein!", "explanation": "Aus dem konzeptionellen Schema wird das konkrete Datenbankschema abgeleitet. Das Datenbankschema ist ein auf den Datenbanktyp abgestimmtes Datenmodell, im relationalen Fall also ein relationales Schema, bestehend aus miteinander verkn\u00fcpften Relationen. Dieser Transformationsvorgang kann weitgehend automatisiert werden, Entity-Mengen und Beziehungen werden nach einem Verfahren, das in Kapitel 4 behandelt wird, auf Relationen abgebildet. Das entstandene Schema wird normalisiert und zum Datenbankschema vervollst\u00e4ndigt . Ferner wird das Modell erg\u00e4nzt um einzelne Benutzersichten, Indexangaben zur Zugriffsoptimierung und Speicherstrukturen, wie B-Baum, oder HASH- Verfahren sowie die Zugriffsrechte der Benutzer im Multiuser-System. Da diese Punkte abh\u00e4ngig sind vom verwendeten Datenbanksystem, werden sie erst jetzt in der Entwurfsphase durchgef\u00fchrt. Wurden die Wertebereiche der Attribute und Integrit\u00e4tsbeziehungen nicht bereits w\u00e4hrend der Analysephase festgelegt, so sind auch diese jetzt zu definieren.", "type": "text", "answers": [{"text": "Die vierte Phase ist die", "solution": "Abnahme- und Einf\u00fchrungsphase"}, {"text": "Die f\u00fcnfte Phase ist die", "solution": "Wartungs- und Pflegephase"}, {"text": "Die zweite Phase ist die", "solution": "Entwurfsphase"}, {"text": "Die erste Phase ist die", "solution": "Analysephase"}, {"text": "Die dritte Phase ist die", "solution": "Implementierungsphase"}]}, {"id": 1676, "category": 5, "difficulty": 3, "text": "Auf welche Weise sollte man so genannte Stammdaten modellieren, deren Wertebereich sich nur selten \u00e4ndert, wie z.B. die Kontaktarten (Telefon, Brief, pers\u00f6nliches Gespr\u00e4ch, Email,... ) zur n\u00e4heren Spezifikation eines Kundenkontakts eines Beraters mit seinen Kunden?", "explanation": "Die M\u00f6glichkeiten, dies \u00fcber eine Dom\u00e4ne oder \u00fcber eine Entitymenge, die als Wertebereich dient und mit nichtidentifizierender Beziehung mit der Haupt-Entitymenge verbunden sind, sind hier \u00e4quivalent. \nIn der Praxis sollte man sich nach den M\u00f6glichkeiten des konkreten Datenbanksystems richten. Ein identifizierende Beziehung macht hier keinen Sinn, da das Attribut nicht zum Prim\u00e4rschl\u00fcssel geh\u00f6ren soll.", "type": "multiple-choice", "answers": [{"text": "Als eigene Entitymenge \"Kontaktart\" mit identifizierender 1:n-Beziehung zur Entitymenge \"Kundenkontakt\".", "solution": "false"}, {"text": "Als eigene Entitymenge \"Kontaktart\" mit nicht identifizierender 1:n-Beziehung zur Entitymenge \"Kundenkontakt\".", "solution": "true"}, {"text": "Als Wertebereichsdefinition einer selbst definierten Dom\u00e4ne, die dem Textfeld \"Kontaktart\" in der Entitymenge \"Kundenkontakt\" anstelle eines Datentyps zugeordnet wird.", "solution": "true"}, {"text": "Als vom Anwender frei eingebbares Textfeld \"Kontaktart\" in der Entitymenge \"Kundenkontakt\".", "solution": "false"}]}, {"id": 2132, "category": 9, "difficulty": 3, "text": "In welcher Reihenfolge werden in einem SELECT-Befehl die folgenden Komponenten vom DBMS ausgef\u00fchrt? (Geben Zahlen von 1 bis 6 an)", "explanation": "F\u00fcr die SELECT-Anweisungen gelten folgende Ausf\u00fchrungsreihenfolgen der einzelnen Klauseln: \n6. SELECT\n1. FROM\n2. WHERE\n3. GROUP BY \n4. HAVING\n5. ORDER BY", "type": "text", "answers": [{"text": "WHERE", "solution": "2"}, {"text": "FROM", "solution": "1"}, {"text": "ORDER BY", "solution": "5"}, {"text": "HAVING", "solution": "4"}, {"text": "GROUP BY", "solution": "3"}, {"text": "SELECT", "solution": "6"}]}, {"id": 1624, "category": 5, "difficulty": 1, "text": "Welche Aussagen \u00fcber Prim\u00e4rschl\u00fcssel sind wahr?", "explanation": "Prim\u00e4rschl\u00fcssel k\u00f6nnen aus einem oder mehreren Attributen bestehen und sind minimal in dem Sinne, dass sie aus einer minimalen Menge von Attributen bestehen, die eine Entit\u00e4t eindeutig identifizieren.", "type": "multiple-choice", "answers": [{"text": "Prim\u00e4rschl\u00fcssel bestehen immer aus einem einzelnen Attribut, z.B. einer fortlaufenden Nummer.", "solution": "false"}, {"text": "Prim\u00e4rschl\u00fcssel k\u00f6nnen auch aus mehreren Attributen zusammengesetzt sein.", "solution": "true"}, {"text": "Prim\u00e4rschl\u00fcssel sind eine minimale Menge von Attributen, die die zugeordnete Entit\u00e4t eindeutig identifizieren.", "solution": "true"}, {"text": "Prim\u00e4rschl\u00fcssel sind eine maximale Menge von Attributen, die die zugeordnete Entit\u00e4t eindeutig identifizieren.", "solution": "false"}, {"text": "Schl\u00fcsselattribute sind nicht obligatorisch, d.h. k\u00f6nnen auch einen NULL-Wert enthalten.", "solution": "false"}]}, {"id": 1626, "category": 9, "difficulty": 2, "text": "Betrachten Sie die folgende Abfrage an eine Angestellten-Tabelle:\nWelche Angestellten wohnen in K\u00f6ln oder Gummersbach?\nWelche der folgenden Abfragen liefert das gew\u00fcnschte Ergebnis:", "explanation": "Der logische Operator \"=\" kann nur mit einem einzelnen Wert vergleichen.\nEine Ort kann nicht gleichzeitig K\u00f6ln und Gummersbach hei\u00dfen.", "type": "multiple-choice", "answers": [{"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = 'K\u00f6ln'\nOR ORT = 'Gummersbach'", "solution": "true"}, {"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT in ( 'K\u00f6ln',  'Gummersbach')", "solution": "true"}, {"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = ( 'K\u00f6ln',  'Gummersbach')", "solution": "false"}, {"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = ALL ( 'K\u00f6ln',  'Gummersbach')", "solution": "false"}, {"text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = 'K\u00f6ln'\nAND ORT = 'Gummersbach'", "solution": "false"}]}, {"id": 1627, "category": 42, "difficulty": 2, "text": "Betrachten Sie einen B-Baum vom Typ 1 mit 15 Eintr\u00e4gen. Welche H\u00f6he h hat der Baum maximal?", "explanation": "Wenn jeder Knoten nur einen Eintrag hat, ergibt sich die H\u00f6he 3.", "type": "text", "answers": [{"text": "Die H\u00f6he h ist", "solution": "3"}]}, {"id": 1628, "category": 42, "difficulty": 1, "text": "Betrachten Sie einen B-Baum vom Typ 1 mit 14 Eintr\u00e4gen. Welche H\u00f6he h hat der Baum minimal?", "explanation": "Wenn jeder Knoten zwei Eintr\u00e4ge hat, ergibt sich als H\u00f6he  der Wert 2.", "type": "text", "answers": [{"text": "Die H\u00f6he ist", "solution": "2"}]}, {"id": 1629, "category": 42, "difficulty": 3, "text": "Wie viele Eintr\u00e4ge hat ein B-Baum vom Typ 2 der H\u00f6he 2 maximal?", "explanation": "Ein B-Baum vom Typ 2 hat maximal eine Wurzel, 5 Knoten auf der ersten Ebene (h = 1) und nochmal 5*5 = 25 Knoten auf der zweiten Ebene (h=2).Insgesamt sind das 31 Knoten mit maximal 124 = 31 * 4 Eintr\u00e4gen.", "type": "text", "answers": [{"text": "Die Anzahl ist:", "solution": "124"}]}, {"id": 1630, "category": 42, "difficulty": 3, "text": "Wie viele Eintr\u00e4ge hat ein B-Baum vom Typ 1 der H\u00f6he 2 maximal?", "explanation": "Die Wurzel: hat 2 Eintr\u00e4ge\n\n    1. Ebene: 2+2+2=6 Eintr\u00e4ge\n\n    2. Ebene: 3*(2+2+2)=18 Eintr\u00e4ge\n\n    \n\n    Summe: 26", "type": "text", "answers": [{"text": "Die Anzahl ist", "solution": "26"}]}, {"id": 1743, "category": 5, "difficulty": 2, "text": "Welches/welche der folgenden Attribute einer Entitymenge \"Spiele (Heimmannschaft_id, Gastmannschaft_id, Spieltag, Ergebnis, Anzahl_Zuschauer,  Starttermin) sind notwendig f\u00fcr die Definition des Prim\u00e4rschl\u00fcssels, wenn die Daten der Fu\u00dfball-Bundesliga f\u00fcr mehrere Saisons gespeichert werden sollen? Gehen Sie dabei davon aus, dass eine Heimmannschaft nur einmal an einem Tag spielen kann. Kreuzen Sie aus den angegebene Attributen die Prim\u00e4rschl\u00fcsselattribute an!", "explanation": "Da eine Heimmannschaft nur einmal an einem Tag spielen kann, sind die Heimmannschaft und der Starttermin  ausreichend f\u00fcr den Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Spieltag (Wert: 1-34)", "solution": "false"}, {"text": "Heimmannschaft_ID", "solution": "true"}, {"text": "Ergebnis", "solution": "false"}, {"text": "Gastmannschaft_ID", "solution": "false"}, {"text": "Anzahl_Zuschauer", "solution": "false"}, {"text": "Starttermin (Datum und Uhrzeit des Anpfiffs)", "solution": "true"}]}, {"id": 1644, "category": 42, "difficulty": 2, "text": "Wie viele Eintr\u00e4ge sind in einem B-Baum vom Typ 3 in der Wurzel mindestens enthalten?", "explanation": "In der Wurzel kann nach Definition des B-Baumes auch nur ein Element, unabh\u00e4ngig von Typ des Baumes, enthalten sein.", "type": "text", "answers": [{"text": "Die Anzahl ist (als Zahl eintragen):", "solution": "1"}]}, {"id": 1645, "category": 9, "difficulty": 3, "text": "Welche SQL-Anweisungen mit CONSTRAINTS sind syntaktisch korrekt?", "explanation": "RICHTIG sind: \nknz      VARCHAR2(1)    CHECK (knz IN ('J','N'))\nknz      VARCHAR2(1)    CHECK (knz = ALL ('J','N'))\nBeide CHECK-Bedingungen sind syntaktisch richtig, verf\u00fcgen aber eine unterschiedliche Semantik. Beim IN wird gepr\u00fcft, ob der Wert der Spalte knz 'J' oder 'N' ist. Beim =ALL wird gepr\u00fcft, ob der Wert der Spalte knz die beiden Werte 'J' und 'N' hat. Diese Bedingung ist nicht erf\u00fcllbar, denn wie kann eine Spalte gleichzeitig zwei verschiedene Werte enthalten. Semantisch \u00e4quivalent w\u00e4re die Formulierung mit =ANY. \nFALSCH ist: \nWenn ein Vergleichsoperand eine Menge kosntanter Werte ist, da hilft ein einfaches \"=\" nicht weiter, nur ein IN oder ein \"=\" mit ANY- oder ALL-Option.\nDies \"IN ('J','N')\" reicht syntaktisch auch nicht aus. Ein CHECK-Constraint startet mit \"CHECK ( spaltenname ...\".", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz IN ('J','N')));", "solution": "true"}, {"text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz = ('J','N')));", "solution": "false"}, {"text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz = ALL ('J','N')));", "solution": "true"}, {"text": "keine dieser SQL-Anweisungen", "solution": "false"}, {"text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    IN ('J','N'));", "solution": "false"}]}, {"id": 1654, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgenden Mini-Datenbank eines Weinh\u00e4ndlers:\nRebsorte (Sorte, Name, Farbe)\nWein (WeinID, Name, Rebsorte)\nJahrgang (WeinID, Jahr, Preis, Qualitaet)\n\nWelche SELECT-Abfrage beantwortet die folgende Anfrage:\n\nWelche Riesling Weine haben in keinem Jahrgang die Qualit\u00e4tsstufe 3 besessen?", "explanation": "Die Antworten mit NOT EXISTS  entsprechen den Antworten mit NOT IN. Allerdings muss man darauf achten, dass man korrelierte Subselects verwendet, damit man auch die Weine enth\u00e4lt, die der Semantik (Welche Riesling Weine haben in keinem Jahrgang die Qualit\u00e4tsstufe 3 besessen?) gen\u00fcgen. Die \u00e4u\u00dferen SELECT-Anweisungen m\u00fcssen mit den inneren \u00fcber Join-Bedingungen verkn\u00fcpft werden. Wenn eine Join-Verkn\u00fcpfung fehlt, liefert der NOT EXISTS immer ein Ergebnis.", "type": "multiple-choice", "answers": [{"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte  = r.sorte\nAND    r.name      = 'Riesling'\nAND    NOT EXISTS (SELECT j.wein_id\n                   FROM   jahrgang j\n                   WHERE  j.qualitaet = 3);\n", "solution": "false"}, {"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name       = 'Riesling'\nAND    w.wein_id NOT IN (SELECT j.wein_id\n                         FROM   jahrgang j\n                         WHERE  j.qualitaet > 3);\n", "solution": "false"}, {"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte  = r.sorte\nAND    r.name      = 'Riesling'\nAND    NOT EXISTS (SELECT j.wein_id\n                   FROM   jahrgang j\n                   WHERE  j.qualitaet = 3\n           AND    j.wein_id   = w.wein_id);", "solution": "true"}, {"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name       = 'Riesling'\nAND    w.wein_id NOT EXISTS(SELECT j.wein_id\n                          FROM   jahrgang j\n                          WHERE  j.qualitaet = 3);\n", "solution": "false"}, {"text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name    = 'Riesling'\nAND    w.wein_id NOT IN (SELECT j.wein_id\n                         FROM   jahrgang j\n                         WHERE  j.qualitaet = 3);\n", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1656, "category": 1, "difficulty": 1, "text": "Wann entstand das hierarchische Datenmodell?", "explanation": "Das hierarchisches Datenbankmodell ist das \u00e4lteste Datenbankmodell, es bildet die reale Welt durch eine hierarchische Baumstruktur ab und wurde sp\u00e4ter Grundlage des Netzwerkdatenmodells. Es entstand schon in den 60er Jahren und wurde Grundlage des Systems IMS/DB der Firma IBM. \nHeutzutage erlebt die hierarchische Datenspeicherung  eine Renaissance in Verbindung mit XML.", "type": "multiple-choice", "answers": [{"text": "50er Jahre", "solution": "false"}, {"text": "60er Jahre", "solution": "true"}, {"text": "70er Jahre", "solution": "false"}]}, {"id": 1655, "category": 1, "difficulty": 1, "text": "Wann entstand das Netzwerkdatenmodell?", "explanation": "Das Netzwerkdatenmodell wurde schon 1971 von der Codasyl-DBTG-Gruppe gemeinsam mit dem Cobol-Standard vorgeschlagen und wurde die theoretische Grundlage der Netzwerkdatenbanken.", "type": "multiple-choice", "answers": [{"text": "50er Jahre", "solution": "false"}, {"text": "60er Jahre", "solution": "true"}, {"text": "70er Jahre", "solution": "false"}]}, {"id": 1658, "category": 1, "difficulty": 1, "text": "Die Anwenderprogramme sind nicht von den Daten abh\u00e4ngig. Programme sollen anwendungsstabil gegen\u00fcber der \u00c4nderung der Datenstrukturen sein.", "explanation": "Das ist die Definition der vertikalen, logischen Datenunabh\u00e4ngigkeit.", "type": "multiple-choice", "answers": [{"text": "Diese Eigenschaft nennt man vertikale, logische Datenunabh\u00e4ngigkeit.", "solution": "true"}, {"text": "Diese Eigenschaft nennt man physische Datenunabh\u00e4ngigkeit.", "solution": "false"}, {"text": "Diese Eigenschaft nennt man horizontale, logische Datenunabh\u00e4ngigkeit.", "solution": "false"}]}, {"id": 1687, "category": 9, "difficulty": 2, "text": "Welche der folgenden SELECT-Abfragen ist syntaktisch korrekt?", "explanation": "Die WHERE-Klausel steht immer vor der Group-By-Klausel. \nIn der SELECT-Klausel d\u00fcrfen nur zwei Arten von Spalten vorkommen:\n\ndie, die mit einer Gruppenfunktion versehen sind (hier Gehalt) \ndie anderen Spalten m\u00fcssen in der GROUP-BY-Klausel enthalten sein.", "type": "multiple-choice", "answers": [{"text": "SELECT COUNT(*), Gruppe\nFROM Praktikum\nWHERE Fachkuerzel = 'DBS'\nGROUP BY Gruppe;", "solution": "true"}, {"text": "SELECT COUNT(*), Gruppe\nFROM Praktikum\nGROUP BY Gruppe\nWHERE Fachkuerzel = 'DBS';", "solution": "false"}, {"text": "SELECT COUNT(*), Gruppe\nFROM Praktikum;", "solution": "false"}, {"text": "keine", "solution": "false"}]}, {"id": 1659, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Relation R(A, B, C, D, E) mit den funktionalen Abh\u00e4ngigkeiten \nAB -> C, CD-> E und D -> B. Welche Attributkombination ist ein (minimaler) eindeutiger Schl\u00fcssel?", "explanation": "Es kann nur AD sein, weil dies die beiden einzigen Attribute sind, die von keinen anderen Attributen funktional abh\u00e4ngig sind.", "type": "multiple-choice", "answers": [{"text": "AB", "solution": "false"}, {"text": "AD", "solution": "true"}, {"text": "ABC", "solution": "false"}, {"text": "ABCD", "solution": "false"}, {"text": "ABE", "solution": "false"}]}, {"id": 1663, "category": 9, "difficulty": 2, "text": "Zu IF in PL/SQL geh\u00f6rt noch", "explanation": "Das Syntaxdiagramm der IF-Anweisung in PL/SQL ist:\n<IF Anweisung> ::=  \nIF  THEN   \n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]...\n[ ELSIF  THEN\n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]... ]...\n[ ELSE\n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]... ]\nEND IF;", "type": "multiple-choice", "answers": [{"text": "THEN", "solution": "true"}, {"text": "ENDIF", "solution": "false"}, {"text": "END IF", "solution": "true"}, {"text": "ELSE", "solution": "true"}, {"text": "ELSEIF", "solution": "false"}, {"text": "ELSIF", "solution": "true"}, {"text": "ELSE IF", "solution": "false"}]}, {"id": 1661, "category": 9, "difficulty": 2, "text": "Zu einer IF-Anweisung in PL/SQL kann es", "explanation": "Das Syntaxdiagramm der IF-Anweisung in PL/SQL ist:\n<IF Anweisung> ::=  \nIF  THEN   \n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]...\n[ ELSIF  THEN\n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]... ]...\n[ ELSE\n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]... ]\nEND IF;", "type": "multiple-choice", "answers": [{"text": "nur eine ELSE-Anweisung geben", "solution": "true"}, {"text": "mehrere ELSE-Anwe\u00edsungen geben", "solution": "false"}]}, {"id": 1679, "category": 7, "difficulty": 2, "text": "A und B  seien zwei Attribute einer Relation R.\nWoran erkennt man eine (volle) funktionale Abh\u00e4ngigkeit A -> B?", "explanation": "X und Y seien zwei Teilmengen von Attributen einer Relation R. \nY hei\u00dft funktional abh\u00e4ngig von X, wenn Folgendes gilt: \nF\u00fcr alle Tupel r, s aus R gilt: \nAus ProjX(s) = ProjX(r) folgt stets: ProjY(s) = ProjY(r). \nAus dieser Definition folgt f\u00fcr einen Attributwert in A (=X) dass es in B (=Y) genau einen Attributwert gibt. \nAndere Aussagen l\u00e4sst diese Definition nicht zu.", "type": "multiple-choice", "answers": [{"text": "Zu einem Spaltenwert B gibt es mehrere Spaltenwerte in A.", "solution": "false"}, {"text": "Zu einem Spaltenwert B gibt es genau einen  Spaltenwert in A.", "solution": "false"}, {"text": "Es gibt einen Spaltenwert B, zu dem es keinen Spaltenwert in A gibt.", "solution": "false"}, {"text": "Zu einem Spaltenwert A gibt es mehrere Spaltenwerte in B.", "solution": "false"}, {"text": "Zu einem Spaltenwert A gibt es genau einen  Spaltenwert in B.", "solution": "true"}, {"text": "Es gibt einen Spaltenwert A, zu dem es keinen Spaltenwert in B gibt.", "solution": "false"}]}, {"id": 1666, "category": 5, "difficulty": 1, "text": "Wie viele Beziehungsarten gibt es in ER-Diagrammen, wenn man die Kardinalit\u00e4t und die Optionalit\u00e4t, aber nicht die Symmetrie (1:n und n:1 bezeichnen den gleichen Typ) mit einbezieht? Dabei soll auch nicht  ber\u00fccksichtigt werden, ob die Beziehung identifizierend  ist oder nicht.", "explanation": "(1:1) (1:C) (1:M) (1:CM)+\n\n    (C:C) (C:M) (C:CM)+\n\n    (N:M) (N:CM)+\n\n    (CN :CM)+\n\n    ================================\n\n    10 Beziehungstypen", "type": "multiple-choice", "answers": [{"text": "4", "solution": "false"}, {"text": "8", "solution": "false"}, {"text": "10", "solution": "true"}, {"text": "12", "solution": "false"}, {"text": "16", "solution": "false"}]}, {"id": 1671, "category": 5, "difficulty": 3, "text": "Welche Aussagen \u00fcber identifizierende 1:cn-Beziehungen in ER-Diagrammen sind richtig?", "explanation": "Bei identifizierenden Beziehungen werden in der Detail-Entitymenge die Fremdschl\u00fcsselattribute zum Prim\u00e4rschl\u00fcssel hinzugenommen, bei nicht identifizierenden Beziehungen werden die Fremdschl\u00fcsselattribute nur als \"normales\" Nichtschl\u00fcsselattribut eingetragen, welches nicht zum Prim\u00e4rschl\u00fcssel der Relation geh\u00f6rt. Dass die Aussage \u00fcber die Nichtverwendung von identifizierenden Beziehungen bei k\u00fcnstlichen Prim\u00e4rschl\u00fcsseln korrekt ist, liegt an der Definition der k\u00fcnstlichen Prim\u00e4rschl\u00fcssel, die ja nur aus einem Attribut bestehen d\u00fcrfen.", "type": "multiple-choice", "answers": [{"text": "Die Inhalte der Prim\u00e4rschl\u00fcsselspalten der Master-Entitymenge stellen einen dynamischen Wertebereich f\u00fcr die zugeh\u00f6rigen Fremdschl\u00fcsselspalten der Detail-Entitymenge dar.", "solution": "true"}, {"text": "Die Attribute des Prim\u00e4rschl\u00fcssels der Master-Entitymenge treten als Nichtschl\u00fcsselattribute in der Detail-Entitymenge auf.", "solution": "false"}, {"text": "Die Attribute des Prim\u00e4rschl\u00fcssels der Master-Entitymenge treten als Prim\u00e4rschl\u00fcsselattribute in der Detail-Entitymenge auf.", "solution": "true"}, {"text": "Die Attribute des Prim\u00e4rschl\u00fcssels der Detail-Entitymenge treten als Prim\u00e4rschl\u00fcsselattribute in der Master-Entitymenge auf.", "solution": "false"}, {"text": "F\u00fcr den Fall, dass die an einer 1:cn-Beziehung beteiligten Entity-Menngen allesamt k\u00fcnstliche Prim\u00e4rschl\u00fcssel verwenden, gilt, dass keine identifizierenden Beziehungen verwendet werden d\u00fcrfen.", "solution": "true"}, {"text": "Eine 1:c1-Beziehung kann als identifizierende verwendet werden, wenn die Master-Entity-Menge einen k\u00fcnstlichen Prim\u00e4rschl\u00fcssel hat und die Detail-Entity-Menge keinen eigenen Prim\u00e4rschl\u00fcssel, sondern nur den k\u00fcnstlichen, vererbten \u00fcber die identif. 1:c1-Beziehung.", "solution": "true"}]}, {"id": 1674, "category": 5, "difficulty": 2, "text": "K\u00fcnstliche Schl\u00fcssel haben folgende Vorteile:", "explanation": "Schl\u00fcssel sind definiert als Menge von Attributen einer Entity-Menge, die eine Entit\u00e4t eindeutig identifizieren. Eine Entity-Menge kann auch mehrere Schl\u00fcssel haben. Ein Angestellter z.B. l\u00e4sst sich \u00fcber seine Personalnummer wie auch \u00fcber die Attributkombination Name, Vorname, Adresse, Geburtsdatum identifizieren. Der letztgenannte Schl\u00fcssel ist ein Beispiel f\u00fcr einen zusammengesetzten Schl\u00fcssel. Bei der Modellierung wird ein Schl\u00fcssel als Prim\u00e4rschl\u00fcssel ausgezeichnet.\n\nZusammengesetzte Prim\u00e4rschl\u00fcssel sind in der Praxis schwer zu handhaben. Sobald sie als Fremdschl\u00fcssel in anderen Entity-Mengen auftreten, m\u00fcssen bei lesendem Zugriff \u00fcber diese Entitymenge und die Master-Entitymenge  immer alle Schl\u00fcsselattribute aufgef\u00fchrt werden. Werden Teile des Schl\u00fcssels bei der Programmierung vergessen, kann das schwerwiegende Folgen f\u00fcr die Korrektheit der L\u00f6sung haben. Ein Index \u00fcber mehrere Attribute hat au\u00dferdem den Nachteil, dass der Zugriff bei alternativen Attributreihenfolgen, die nicht dem Index entsprechen, langsamer ist. \nDaher werden in der Praxis h\u00e4ufig sogenannte k\u00fcnstliche Schl\u00fcssel (surrogate keys) verwendet. Ein k\u00fcnstlicher Schl\u00fcssel ist ein zus\u00e4tzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Z\u00e4hler vom\nDatentyp Integer, der systemintern verwaltet wird, nach au\u00dfen nicht sichtbar ist und ausschlie\u00dflich f\u00fcr die Prim\u00e4r- und Fremdschl\u00fcsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und \u00c4hnlichem zu unterscheiden, die nach au\u00dfen sichtbar sind und im Schriftverkehr verwendet oder zur\nIdentifikation beim Kunden erfragt werden. Wenn man sich f\u00fcr die Verwendung von k\u00fcnstlichen Prim\u00e4rschl\u00fcsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen f\u00fcr das gesamte Modell, unabh\u00e4ngig von den sonstigen Schl\u00fcsseln der Entity-Mengen.", "type": "multiple-choice", "answers": [{"text": "Sie reduzieren die Gr\u00f6\u00dfe von Fremdschl\u00fcsseln", "solution": "true"}, {"text": "Sie erm\u00f6glichen eine schnelle Suche", "solution": "true"}, {"text": "Sie sind Abbild eines Attributs der realen Welt.", "solution": "false"}, {"text": "Sie dienen der Objektorientierung der Datenbank.", "solution": "false"}]}, {"id": 1791, "category": 1, "difficulty": 2, "text": "Welche Aussagen \u00fcber eine Datenbank sind richtig?", "explanation": "Ein DBS (Datenbanksystem) besteht aus zwei Teilen: dem Datenbankmanagementsystem (DBMS) und der Menge der zu verwaltenden Daten, der eigentlichen Datenbank. \nDas DBMS organisiert intern die strukturierte Speicherung der Daten und kontrolliert alle lesenden und schreibenden Zugriffe auf die Datenbank. \nZur Abfrage und Verwaltung der Daten bietet ein Datenbanksystem eine Datenbanksprache an. Daher ist DBS = Datenbasi + DBMS richtig.", "type": "multiple-choice", "answers": [{"text": "DBS = Datenbasis + DBMS", "solution": "true"}, {"text": "DBS ist die Abk\u00fcrzung f\u00fcr Datenbasis", "solution": "false"}, {"text": "Als Datenbasis werden die nach einheitlichen Regeln in einem DBS persistent gespeicherten Daten bezeichnet", "solution": "true"}, {"text": "DBMS = DBS + Datenbasis", "solution": "false"}, {"text": "Das DBMS liegt in der Funktionalit\u00e4t zwischen Anwendungsprogrammen und Betriebssystem", "solution": "true"}]}, {"id": 1683, "category": 10, "difficulty": 1, "text": "Welche der beiden Datenbanktrigger l\u00f6st das Mutating-Table-Problem aus?", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.   \n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "multiple-choice", "answers": [{"text": "CREATE or REPLACE TRIGGER pruefen\nAFTER INSERT ON test\nFOR EACH ROW\nDECLARE\nMY_VAR number;\nBEGIN\n      SELECT count(*) INTO MY_VAR\n    FROM Test;    \n    \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-2001, 'Zu viele Daten!');\n    END IF;\nEND;\n", "solution": "true"}, {"text": "CREATE or REPLACE TRIGGER pruefen\nAFTER INSERT ON test\nDECLARE\nMY_VAR number;\nBEGIN\n      SELECT count(*) INTO MY_VAR\n    FROM Test;    \n    \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-2001, 'Zu viele Daten!');\n    END IF;\nEND;\n", "solution": "false"}]}, {"id": 1792, "category": 1, "difficulty": 2, "text": "Welche Aussagen \u00fcber das Data Dictionary sind richtig?", "explanation": "Das Data Dictionary enth\u00e4lt Daten (sogenannte Metadaten), die die Datenbasis, z.B. Tabellenstrukturen, definieren. Es umfasst au\u00dferdem Daten \u00fcber die Verwendung und Bedeutung des Datenmodells, die Beziehungen der Daten untereinander und Integrit\u00e4tsbedingungen. \nDaher beruht es auf den gleichen Konzepten wie das Datenbanksystem selber und ist nicht optional,  also immer vorhanden.", "type": "multiple-choice", "answers": [{"text": "Das Data Dictionary kann optional f\u00fcr ein Datenbanksystem eingerichtet werden", "solution": "false"}, {"text": "Das Data Dictionary basiert auf den gleichen Konzepten wie das Datenbanksystem selbst, n\u00e4mlich Tabellen, Attribute und Beziehungen", "solution": "true"}, {"text": "Das Data Dictionary enth\u00e4lt Daten, die den Datenbestand beschreiben, also die Metadaten f\u00fcr die vom Benutzer angelegten Tabellen, Attribute, und Datentypen.", "solution": "true"}]}, {"id": 1682, "category": 9, "difficulty": 2, "text": "Wie gibt man unter SQLJ einen expliziten Kontext an?", "type": "multiple-choice", "answers": [{"text": "#sql [context] { sql-Anweisung}", "solution": "true"}, {"text": "#sql (context) { sql-Anweisung}", "solution": "false"}, {"text": "#sql context = { sql-Anweisung}", "solution": "false"}, {"text": "#sql context { sql-Anweisung}", "solution": "false"}]}, {"id": 1684, "category": 1, "difficulty": 1, "text": "Welche Aufgabe hat ein SQL-Parser?", "explanation": "Ein SQL-Parser verarbeitet die Eingaben des Benutzers, indem er die Syntax, z.B. Verwendung von Schl\u00fcsselw\u00f6rtern anlysiert.\nSo w\u00fcrde z.B. \"SLECT\" anstelle von \"SELECT\" zur\u00fcckgewiesen.", "type": "multiple-choice", "answers": [{"text": "Ein SQL-Parser \u00fcbersetzt SQL-Anteile in eine Programmiersprache, wie z.B. C.", "solution": "false"}, {"text": "Der SQL-Parser analysiert die Syntax, z.B. die korrekte Verwendung von Schl\u00fcsselw\u00f6rtern.", "solution": "true"}]}, {"id": 1685, "category": 5, "difficulty": 3, "text": "Modelliert man ein Attribut mit vorgegebenem Wertebereich, bei dem sich die Werte nur selten \u00e4ndern (sogenannte Stammdaten) als ein vom Anwender frei eingebbares Textfeld, so k\u00f6nnen Probleme auftreten. Als Beispiel sei hier auf die Kontaktarten (Telefon, Brief, pers\u00f6nliches Gespr\u00e4ch, Email,... ) zur n\u00e4heren Spezifikation eines Kundenkontakts eines Beraters mit seinen Kunden hingewiesen, die als Attribut \"Kontaktart\" in der Entitymenge \"Kundenkontakt\" modelliert werden kann.", "explanation": "F\u00fcr diese Zwecke sind eine selbstdefinierte Dom\u00e4ne oder eine Werte-Entitymenge mit nicht identifizirender Beziehung am besten geeignet.", "type": "multiple-choice", "answers": [{"text": "Dieses Problem kann mit einer eigenen Entitymenge f\u00fcr die Kontaktarten l\u00f6sen, wobei eine 1:n-Beziehung zur Entitymenge \"Kundenkontakt\" modelliert wird.", "solution": "true"}, {"text": "Dieses Problem kann mit einer eigenen Entitymenge f\u00fcr die Kontaktarten l\u00f6sen, wobei eine 1:1-Beziehung zur Entitymenge \"Kundenkontakt\" modelliert wird.", "solution": "false"}, {"text": "Dieses Problem kann man mit der Definition einer Dom\u00e4ne l\u00f6sen.", "solution": "true"}, {"text": "Nein, es k\u00f6nnen keine Probleme auftreten.", "solution": "false"}, {"text": "Da f\u00fcr jeden Datensatz der Wert der Kontaktart eingetippt werden muss, k\u00f6nnen Rechtschreibfehler bei den verschiedenen Eintr\u00e4gen gemacht werden. Aufgrund dieser Rechtschreibfehler wird es schwierig, alle Eintr\u00e4ge eines Werts mit seinen unterschiedlichen Schreibweisen wieder zu finden.", "solution": "true"}]}, {"id": 1688, "category": 9, "difficulty": 2, "text": "Mit welcher Anweisung werden in SQL*PLUS bzw. dem SQL-Developer Ausgaben aus PL/SQL mit DBMS_OUTPUT.PUT_LINE (...) erst sichtbar?", "explanation": "Mit SET SERVEROUTPUT ON kann man das Ergebnis von DBMS_OUTPUT.PUT_LINE ()sichtbar machen und die Bildschirmbuffergr\u00f6\u00dfe \u00fcber SIZE XXX \u00e4ndern. Ohne SET SERVEROUTPUT ON ist das Ergebnis einer PL/SQL-Prozedur zun\u00e4chst unsichtbar.", "type": "text", "answers": [{"text": "Die Anweisung (ohne Semikolon) hei\u00dft:", "solution": "SET SERVEROUTPUT ON"}]}, {"id": 1689, "category": 8, "difficulty": 1, "text": "Welche Operation aus der relationalen Algebra setzt den \"F\u00fcr-Alle-Quantor\" (Allaussage) um?", "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.", "type": "multiple-choice", "answers": [{"text": "Addition", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Division", "solution": "true"}, {"text": "Produkt", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 1793, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber Attribute einer Entity-Menge sind wahr?", "explanation": "In ER-Modellen sind Entity-Mengen mit Attributen, die NULL-Werte zulassen, vorgesehen, aber keine mengenwertigen Attribute.", "type": "multiple-choice", "answers": [{"text": "Ein Attribut ist eine Eigenschaft, die allen Entit\u00e4ten einer Entity-Menge gemeinsam ist.", "solution": "true"}, {"text": "Attribute sind die Spalten der Entity-Mengen.", "solution": "true"}, {"text": "Attribute sind immer optional.", "solution": "false"}, {"text": "Ein Schl\u00fcssel kann aus einem oder mehreren Attributen bestehen.", "solution": "true"}, {"text": "Attribute k\u00f6nnen Mengen von Werten enthalten (nicht atomar).", "solution": "false"}]}, {"id": 1691, "category": 8, "difficulty": 1, "text": "Der Full Outer Join ist kommutativ.", "explanation": "Der Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgef\u00fcllt werden, die beim nat\u00fcrlichen Join herausfallen w\u00fcrden. \nDie rechten und linken Outer-Joins sind hingegen nicht kommutativ, da entweder nur die rechte oder nur die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 1692, "category": 9, "difficulty": 3, "text": "Mit welchem CONSTRAINT_CHARACTERISTICA  kann man den Pr\u00fcfungszeitpunkt unmittelbar direkt nach einer DML-Anweisung ausf\u00fchren?", "explanation": "<CONSTRAINT Characteristika> ::= \n{ INITIALLY DEFERRED | INITIALLY IMMEDIATE } [ [ NOT ] DEFERRABLE ]\n\nMit DEFERRED (verz\u00f6gert) wird die Pr\u00fcfung der Integrit\u00e4tsbedingung zum Ende der Transaktion (COMMIT) bezeichnet. IMMEDIATE (unmittelbar) beschreibt die Pr\u00fcfung unmittelbar im Anschluss an die Ausf\u00fchrung einer einzelnen \u00c4nderungsanweisung. \nIMMEDIATE hat den Vorteil, dass Integrit\u00e4tsfehler so fr\u00fch wie m\u00f6glich erkannt werden und DEFERRED, dass w\u00e4hrend der laufenden Transaktion durch nachfolgende Anweisungen ein zwischenzeitlich inkonsistenter Zustand wieder korrigiert werden kann.", "type": "text", "answers": [{"text": "CONSTRAINT_CHARACTERISTICA  =", "solution": "INITIALLY IMMEDIATE"}]}, {"id": 1693, "category": 9, "difficulty": 2, "text": "Ein CHECK-CONSTRAINT kann sich als COLUMN-Constraint auch auf mehrere Spalten beziehen.", "explanation": "Das ist ja gerade der entscheidende Unterschied zwischen Spalten- (COLUMN-) und Tabellen-Constraints (TABLE-Constraint). Spalten-Constraints k\u00f6nnen sich nur auf eine Spalte beziehen, w\u00e4hrend Tabellen-Constraints sich sowohl auf nur eine oder auf mehrere Spalten beziehen kann.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2441, "category": 9, "difficulty": 2, "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Prim\u00e4rschl\u00fcssel A, S den Prim\u00e4rschl\u00fcssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz)?", "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS ausgedr\u00fcckt werden. Der Natural Join \u00e4hnelt dem Durchschnitt, nur das doppelte Spalten unterdr\u00fcckt werden.", "type": "multiple-choice", "answers": [{"text": "SELECT *\nFROM R\nWHERE NOT EXISTS (SELECT B FROM S where a = b);", "solution": "true"}, {"text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;", "solution": "true"}, {"text": "SELECT * FROM R natural Join S;", "solution": "false"}]}, {"id": 2442, "category": 9, "difficulty": 3, "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Prim\u00e4rschl\u00fcssel A, S den Prim\u00e4rschl\u00fcssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz)?", "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS oder einem LEFT Outer Join ausgedr\u00fcckt werden.", "type": "multiple-choice", "answers": [{"text": "SELECT A \nFROM R LEFT OUTER JOIN S ON S.B = R.A\nWHERE B is NULL;", "solution": "true"}, {"text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;", "solution": "true"}, {"text": "SELECT * FROM R,S WHERE R.ID <> S.ID;", "solution": "false"}, {"text": "SELECT * FROM R\nJOIN S USING (R.id !0 S.ID);", "solution": "false"}]}, {"id": 2947, "category": 1, "difficulty": 1, "text": "In einer Datenbank sollen alle Daten widerspruchsfrei gespeichert werden. Diese Eigenschaft nennt man:", "explanation": "Das ist die Definition von konsistenten Daten.", "type": "multiple-choice", "answers": [{"text": "Konsistenz", "solution": "true"}, {"text": "Persistenz", "solution": "false"}, {"text": "Renitenz", "solution": "false"}]}, {"id": 2164, "category": 42, "difficulty": 1, "text": "Welche Aussagen \u00fcber B-B\u00e4ume sind wahr?", "explanation": "Da beim Einf\u00fcgen eines Elements das mittlere Element nach oben gereicht wird, kann dies rekursiv zum Erzeugen von mehreren neuen Knoten (bis zur Wurzel) im B-Baum f\u00fchren.", "type": "multiple-choice", "answers": [{"text": "Nach einer Einf\u00fcgung eines neuen Elements in einen B-Baum m\u00fcssen h\u00f6chstens zwei Knoten wegen \u00dcberlaufs aufgeteilt werden.", "solution": "false"}, {"text": "Nach einer Einf\u00fcgung eines neuen Elements in einen B-Baum k\u00f6nnen auch mehr als zwei Knoten wegen \u00dcberlaufs aufgeteilt werden.", "solution": "true"}]}, {"id": 2197, "category": 9, "difficulty": 2, "text": "Womit kann man in PL/SQL einen Record definieren, dessen Datentyp sich auf eine Tabellendefinition bezieht und der bei \u00c4nderungen der Tabellendefinition entsprechend aktualisiert wird?", "explanation": "Mit Tabellenname%ROWTYPeE wird die Attributstruktur einer Tabelle komplett \u00fcbertragen, mit Tabellenname.Spaltenname%TYPE nur die Spaltendefinition einer einzigen Spalte der Tabelle.", "type": "text", "answers": [{"text": "Das ist", "solution": "%ROWTYPE"}]}, {"id": 2198, "category": 9, "difficulty": 2, "text": "Womit kann man in PL/SQL eine Variable definieren, deren Datentyp sich auf eine einzelne Spaltendefinition bezieht und die bei \u00c4nderungen der Tabellendefinition entsprechend aktualisiert wird?", "explanation": "Mit Tabellenname%ROWTYPeE wird die Attributstruktur einer Tabelle komplett \u00fcbertragen, mit Tabellenname.Spaltenname%TYPE nur die Spaltendefinition einer einzigen Spalte der Tabelle.", "type": "text", "answers": [{"text": "Das ist", "solution": "%TYPE"}]}, {"id": 2216, "category": 10, "difficulty": 2, "text": "Transitionsvariablen sind bei SQL und Oracle in STATEMENT-Triggern verf\u00fcgbar.", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2309, "category": 9, "difficulty": 3, "text": "Welche/r Befehl/e sind bei Oracle syntaktisch richtig und erzeugen einen VARRAY?", "explanation": "Bei einem VARRAY kann nach der OF-Klausel nur ein Standarddatentyp (hier varchar2(25)) oder ein selbstdefinierter Typ (hier kinder_typ) stehen.", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF Name VARCHAR2(25);", "solution": "false"}, {"text": "CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF VARCHAR2(25);", "solution": "true"}, {"text": "CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF \n                Name        VARCHAR2(25), \n                Geb_Datum   DATE;", "solution": "false"}, {"text": "CREATE OR REPLACE TYPE kinder_typ AS OBJECT (Name VARCHAR2(25, Geb_Datum DATE);\n\n    CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF kinder_typ;", "solution": "true"}, {"text": "CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF Name VARCHAR2;", "solution": "false"}, {"text": "keiner von allen", "solution": "false"}]}, {"id": 2329, "category": 9, "difficulty": 3, "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind Subklassen der Gesch\u00e4ftspartner. \nWelche (Objekt-)Tabellen werden ben\u00f6tigt, wenn man diesen Sachverhalt gem\u00e4\u00df der horizontalen Fragmentierung implementieren m\u00f6chte?", "explanation": "Es gibt drei Fragmentierungstypen:  \n\nhorizontalen Fragmentierung  \nBei der horizontalen Form werden f\u00fcr jeden Subtyp eine Tabelle angelegt, aber nicht f\u00fcr den Supertypen, geht also nur, wenn die Subtypen vollst\u00e4ndig sind. Die Subtypen-Tabellen verf\u00fcgen neben den eigenen Attributen zudem \u00fcber die Attribute des Supertypen.  \n\nvertikale Fragmentierung: \nBei der vertikalen Form werden f\u00fcr jeden Subtyp eine Tabelle angelegt und auch f\u00fcr den Supertypen, geht also, wenn die Subtypen unvollst\u00e4ndig sind. Subtypen- und Supertyp-Tabellen verf\u00fcgen jeweils \u00fcber ihre eigenen Attribute. \n \nvirtuelle Fragmentierung:  \nBei der virtuellen Form wird nur eine Tabelle mit den Attributen aller Super- und Subtyen angelegt. Um unterscheiden zu k\u00f6nnen, welcher Datensatz nun zu welchem Subtypen geh\u00f6rt, werden entweder subtypenspezifische Attribute abgefragt oder eine zus\u00e4tzliche sog. Diskriminatorspalte angelegt, die f\u00fcr jeden Subtpyen einen spezifischen Wert annimmt.", "type": "multiple-choice", "answers": [{"text": "Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und einem Kennzeichenattribut, welches die Partnerart spezifiziert", "solution": "false"}, {"text": "Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen sowie alle kunden- und lieferantenspezifischen Attribute und einem Kennzeichenattribut, welches die Partnerart spezifiziert", "solution": "false"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den kundenspezifischen", "solution": "true"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den lieferantenspezifischen", "solution": "true"}, {"text": "Kunden, nur mit den kundenspezifischen Attributen", "solution": "false"}, {"text": "Lieferanten, nur mit den lieferantenspezifischen Attributen", "solution": "false"}]}, {"id": 2411, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber WHERE und GROUP BY sind korrekt?", "explanation": "Die Reihenfolge der Klauseln der SELECT-Anweisung ist folgende: \nSELECT ...\nFROM ...\nWHERE ....\nGROUP BY ...\nHAVING ...\nORDER BY ....", "type": "multiple-choice", "answers": [{"text": "Die GROUP-BY-Klausel steht immer vor der WHERE-Klausel", "solution": "false"}, {"text": "Die GROUP-BY-Klausel steht immer nach der WHERE-Klausel", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 2305, "category": 9, "difficulty": 2, "text": "Welche objektrelationalen Datentypen/Typkonstruktoren  sind bei Oracle neu gegen\u00fcber dem relationalen DBS?", "explanation": "Atomare Werte gab es schon im relationalen Modell und der boolesche Datentyp fehlt nach wie vor.", "type": "multiple-choice", "answers": [{"text": "OID (object identifier)", "solution": "true"}, {"text": "Atomare Werte", "solution": "false"}, {"text": "LOB (large objects)", "solution": "true"}, {"text": "VARRAY", "solution": "true"}, {"text": "NESTED TABLE", "solution": "true"}, {"text": "OBJECT (Objekttyp)", "solution": "true"}, {"text": "REF (Referenz)", "solution": "true"}, {"text": "BOOLEAN", "solution": "false"}]}, {"id": 2209, "category": 10, "difficulty": 3, "text": "Was bewirkt der folgende Oracle-Trigger?  \n\nCREATE OR REPLACE TRIGGER test_trg\nAFTER UPDATE ON test_tabelle \nFOR EACH ROW \nBEGIN \n  :NEW.benutzer := USER; \nEND;", "explanation": "Da der Trigger erst nach dem Ereignis AFTER-UPDATE gef\u00fcllt wird, \u00e4ndert sich nichts mehr in der Tabelle test_tabelle.", "type": "multiple-choice", "answers": [{"text": "Er sorgt daf\u00fcr, dass der Wert der Spalte Benutzer mit der Kennung des angemeldeten Anwenders gef\u00fcllt wird.", "solution": "false"}, {"text": "Er sorgt daf\u00fcr, dass der Wert der Spalte Benutzer mit dem Wort 'User' gef\u00fcllt wird. \n", "solution": "false"}, {"text": "nichts", "solution": "true"}]}, {"id": 2082, "category": 9, "difficulty": 1, "text": "SELECT-Abfragen, die SELECT-Anweisungen der Grundform \u00fcber einen UNION, einen INTERSECT oder MINUS verkn\u00fcpfen, m\u00fcssen", "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) m\u00fcssen die gleichen Spaltendefinitionen aufweisen: \nDie Anzahl der Spalten muss \u00fcbereinstimmen. \nDie Datentypen der der Spalten m\u00fcssen gleich sein.  \nDie Reihenfolge der Spalten muss \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "disjunkt sein", "solution": "false"}, {"text": "vollst\u00e4ndig sein", "solution": "false"}, {"text": "vereinigungskonform sein", "solution": "true"}, {"text": "linear \u00e4quivalent sein", "solution": "false"}]}, {"id": 2093, "category": 9, "difficulty": 1, "text": "Mit welchem Befehl l\u00f6scht man alle Rechte auf einer Tabelle XYZ f\u00fcr einen Benutzer Hugo?\nBitte Befehl mit Semikolon beenden!", "explanation": "RICHTIG ist: \nREVOKE ALL ON XYZ FROM Hugo;  \nweil die Syntaxvorgabe folgende ist:  \n<REVOKE Anweisung> ::=  \nREVOKE  ON [ Tabellenname | Sichtname ] FROM ;  \nFALSCH ist: \nREVOKE ALL FROM XYZ OF Hugo; weil falsche Schl\u00fcsselw\u00f6rter FROM und OF.\nGRANT ALL FROM XYZ OF HUGO; weil mit GRANT Rechtevergeben werden und die Schl\u00fcsselw\u00f6rter FROM und OF total falsch sind. \nDROP ALL ON XYZ; weil DROP ein Befehl zum L\u00f6schen von DB-Objekten wie Tabellen, Sichten, Sequenzen, Indexen etc. ist, aber nicht zum L\u00f6schen von Rechtezuordnungen zwischen Benutzern und DB-Objekten.\nDELETE ALL FROM XYZ; weil DELETE ein DML-Befehl zum L\u00f6schen von Datens\u00e4tzen ist.", "type": "multiple-choice", "answers": [{"text": "REVOKE ALL FROM XYZ OF Hugo;", "solution": "false"}, {"text": "REVOKE ALL ON XYZ FROM Hugo;", "solution": "true"}, {"text": "GRANT ALL ON XYZ TO HUGO;", "solution": "false"}, {"text": "DROP ALL ON XYZ FROM Hugo;", "solution": "false"}, {"text": "DELETE ALL FROM XYZ OF Hugo;", "solution": "false"}]}, {"id": 2094, "category": 1, "difficulty": 1, "text": "Was versteht man unter der Abk\u00fcrzung DDL?", "explanation": "DDL (Data Definition Language):\n\nDie DDL stellt Sprachelemente zur Verf\u00fcgung, mit denen die Datenbankobjekte definiert, modifiziert und gel\u00f6scht werden. Einsatzgebiet ist die konzeptionelle Ebene im ANSI-3-Ebenen-Modell.", "type": "text", "answers": [{"text": "Man versteht darunter:", "solution": "Data Definition Language"}]}, {"id": 2095, "category": 1, "difficulty": 1, "text": "Was versteht man unter der Abk\u00fcrzung DML?", "explanation": "DML (Data Manipulation Language):\nDie DML stellt Sprachelemente zum Anlegen, \u00c4ndern und L\u00f6schen von Daten zur Verf\u00fcgung. Einsatzgebiet ist die externe Ebene im ANSI-3-Ebenen-Modell.", "type": "text", "answers": [{"text": "Man versteht darunter:", "solution": "Data Manipulation Language"}]}, {"id": 2096, "category": 1, "difficulty": 1, "text": "Was versteht man unter der Abk\u00fcrzung DCL?", "explanation": "DCL (Data Control Language)\nDie DCL stellt Sprachelemente zur Definition der Speicherstrukturen und Zugriffsmechanismenzur Verf\u00fcgung. Dazu geh\u00f6ren:\n\nFestlegung von Speicherstrukturen,\nFestlegung von Zugriffs- und Integrit\u00e4tskontrollen,\nFestlegung der Sicherungsstrategie,\n\u00dcberwachung der Systemauslastung und des Laufzeitverhaltens (Performance) und \nTuning des Systems zur optimalen Anpassung an laufende oder neue Aufgabenstellungen", "type": "text", "answers": [{"text": "Man versteht darunter:", "solution": "Data Control Language"}]}, {"id": 2097, "category": 9, "difficulty": 1, "text": "Was versteht man unter der Abk\u00fcrzung DQL?", "explanation": "Die DQL (Data Query Language) besteht nur eine einzigen SQL-Anweisung, der SELECT-Anweisung.", "type": "text", "answers": [{"text": "Man versteht darunter:", "solution": "Data Query Language"}]}, {"id": 2102, "category": 1, "difficulty": 2, "text": "Welche Aussagen \u00fcber ein Datenbankschema sind wahr?", "explanation": "Ein Datenbankschema ist die konkrete Auspr\u00e4gung eines bestimmten Datenmodells mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.", "type": "multiple-choice", "answers": [{"text": "Ein Datenbankschema stellt einen allgemeinen Begriffsapparat zur Verf\u00fcgung, der es gestattet, Realit\u00e4tsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren.", "solution": "false"}, {"text": "Mit dem Datenbankschema werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, \u00e4hnlich wie bei einer Programmiersprache, in der auch Ausdr\u00fccke und Regeln festgelegt sind, die in der Programmiersprache benutzt werden d\u00fcrfen.", "solution": "false"}, {"text": "Ein Datenbankschema ist die konkrete Auspr\u00e4gung eines bestimmten Datenmodells mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.", "solution": "true"}, {"text": "Ein Datenbankschema hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.", "solution": "false"}, {"text": "Bei einem Datenbankschema werden die Daten in Dateien gespeichert, die nur von einem Programm genutzt werden.", "solution": "false"}]}, {"id": 2207, "category": 10, "difficulty": 3, "text": "Wie k\u00f6nnen Informationen an einen Oracle-Trigger \u00fcbergeben werden?", "explanation": "ORACLE-Trigger verwenden Transitionsvariablen :NEW und :OLD, aber leider keine Transitionstabellen, wie im SQL-Standard vorsehen. \n\nEine andere M\u00f6glichkeit, Daten an einen Trigger zu \u00fcbergeben, ist eine SELECT-Anweisung oder eine \u00f6ffentliche Package-Variablen.\n\nEin Trigger verf\u00fcgt \u00fcber keine Parameter. Dieses Konzept ist nur bei Funktionen und Prozeduren bekannt.", "type": "multiple-choice", "answers": [{"text": "Transitionsvariablen", "solution": "true"}, {"text": "Transitionstabellen", "solution": "false"}, {"text": "Aufrufparameter", "solution": "false"}, {"text": "Public Package-Variable", "solution": "true"}, {"text": "Anfrage an eine Tabelle", "solution": "true"}]}, {"id": 2208, "category": 10, "difficulty": 3, "text": "Welche/r Trigger verhindert, dass die oid-Spalte ge\u00e4ndert wird?", "explanation": "Ein Trigger mit \"BEFORE UPDATE ON Test\" ohne Spaltenangabe verhindert, dass irgendein Wert in der Tabelle Test ver\u00e4ndert wird, nicht nur die OID. \n\nEin Trigger kann kein ROLLBACK enthalten, da er Bestandteil einer Transaktion ist. \n\nDBMS_OUTPUT.PUT_LINE (...) l\u00f6st kein Rollback aus, dass hei\u00dft, die Spalte OID kann ver\u00e4ndert werden.", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPLACE TRIGGER update_verhindern\nAFTER UPDATE ON test_tabelle OF oid \nFOR EACH ROW \nBEGIN \n  RAISE_APPLICATION_ERROR(-20002,\"OID nicht ge\u00e4ndert!\"); \nEND;", "solution": "true"}, {"text": "CREATE OR  REPLACE TRIGGER update_verhindern\nBEFORE UPDATE ON test_tabelle OF oid \nFOR EACH ROW \nBEGIN  \n  RAISE_APPLICATION_ERROR(-20002,\"OID nicht ge\u00e4ndert!\"); \nEND;", "solution": "true"}, {"text": "CREATE OR  REPLACE TRIGGER update_verhindern\nBEFORE UPDATE ON test_tabelle OF oid \nFOR EACH ROW \nBEGIN  \n  DBMS_OUTPUT.PUT_LINE(\"OID nicht ge\u00e4ndert!\"); \nEND;", "solution": "false"}, {"text": "keiner von allen", "solution": "false"}]}, {"id": 2210, "category": 10, "difficulty": 1, "text": "Was bewirkt der folgende Oracle-Trigger?  \n\nCREATE OR REPLACE TRIGGER test_trg\nBEFORE UPDATE ON test_tabelle \nFOR EACH ROW \nBEGIN \n  :NEW.benutzer := USER; \nEND;", "explanation": "Da der Trigger vor nach dem Ereignis BEFORE-UPDATE gef\u00fcllt wird, \u00e4ndert sich in der Tabelle test_tabelle der Eintrag in der Spalte Benutzer. Es wird die Systemvariable USER, also die Kennung des angemeldeten Anwenders eingetragen.", "type": "multiple-choice", "answers": [{"text": "Er sorgt daf\u00fcr, dass der Wert der Spalte Benutzer mit der Kennung des angemeldeten Anwenders gef\u00fcllt wird.", "solution": "true"}, {"text": "Er sorgt daf\u00fcr, dass der Wert der Spalte Benutzer mit dem Wort 'User' gef\u00fcllt wird. \n", "solution": "false"}, {"text": "nichts", "solution": "false"}]}, {"id": 2211, "category": 10, "difficulty": 2, "text": "Eine Preiserh\u00f6hung darf nicht mehr als 10% betragen. Wie kann diese Integrit\u00e4tsbedingung ganz einfach gepr\u00fcft werden?", "explanation": "Diese Integrit\u00e4tsbedingung l\u00e4sst sich nur mit ROW-Triggern realisieren, da CHECK-Constraints nur eine sehr eingeschr\u00e4nkte Syntax haben und STATEMENT-Trigger keinen Zugriff auf eine einzelne Zeile erlauben.", "type": "multiple-choice", "answers": [{"text": "Tabellen-CHECK-Constraint", "solution": "false"}, {"text": "Spalten-CHECK-Constraint", "solution": "false"}, {"text": "ROW-Trigger", "solution": "true"}, {"text": "STATEMENT-Trigger", "solution": "false"}]}, {"id": 2220, "category": 10, "difficulty": 3, "text": "Welche Anweisungen sind in ORACLE-Triggern zugelassen?", "explanation": "Alle DML-Anweisungen und SELECT sind m\u00f6glich, genauso wie nat\u00fcrlich PL/SQL-Statements. DDL-Anweisungen k\u00f6nnen aus Sicherheitsgr\u00fcnden und da Trigger Bestandteile eine Transaktion sind nur \u00fcber dynamisches SQL ausgef\u00fchrt werden.", "type": "multiple-choice", "answers": [{"text": "INSERT, UPDATE, DELETE", "solution": "true"}, {"text": "COMMIT, ROLLBACK", "solution": "false"}, {"text": "CREATE, ALTER, DROP", "solution": "false"}, {"text": "alle PL/SQL-Anweisungen", "solution": "true"}]}, {"id": 2221, "category": 10, "difficulty": 2, "text": "Es wird eine UPDATE-Anweisung auf der Tabelle X ausgef\u00fchrt, von der aber keine Datens\u00e4tze betroffen sind. F\u00fcr diese Tabelle X ist je ein BEFORE-STATEMENT- und ein BEFORE-ROW-Trigger definiert. Wie oft werden diese Trigger jeweils ausgef\u00fchrt?", "explanation": "Da keine Spalte ver\u00e4ndert wird, wird der BEFORE-ROW-Trigger nicht angesto\u00dfen, w\u00e4hrend der BEFORE-UPDATE-STATEMENT-Trigger genau einmal ausgef\u00fchrt wird.", "type": "text", "answers": [{"text": "BEFORE-UPDATE-STATEMENT-Trigger", "solution": "1"}, {"text": "BEFORE-UPDATE-ROW-Trigger", "solution": "0"}]}, {"id": 2222, "category": 10, "difficulty": 1, "text": "Es wird eine UPDATE-Anweisung auf der Tabelle X ausgef\u00fchrt, von der 6 Datens\u00e4tze betroffen sind. F\u00fcr diese Tabelle X ist je ein BEFORE-STATEMENT- und ein BEFORE-ROW-Trigger definiert. Wie oft werden diese Trigger jeweils ausgef\u00fchrt?", "explanation": "Da 6 Spaltenwerte ver\u00e4ndert werden, wird der BEFORE-ROW-Trigger 6-mal angesto\u00dfen, w\u00e4hrend der BEFORE-UPDATE-STATEMENT-Trigger genau einmal ausgef\u00fchrt wird.", "type": "text", "answers": [{"text": "BEFORE-UPDATE-STATEMENT-Trigger", "solution": "1"}, {"text": "BEFORE-UPDATE-ROW-Trigger", "solution": "6"}]}, {"id": 2233, "category": 9, "difficulty": 2, "text": "Transitionsvariablen werden bei Oracle", "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verf\u00fcgbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten w\u00e4hrend der Triggerausf\u00fchrung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu k\u00f6nnen, wird dem Attributnamen das Schl\u00fcsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).\n\n    \n\n    Liegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugeh\u00f6rigen alten/neuen Werten gef\u00fcllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. F\u00fcr BEFORE TRIGGER gilt die zus\u00e4tzliche Restriktion, dass keine Transitionstabellen verf\u00fcgbar sind. Der Geltungsbereich der Transitionsvariablen und -tabellen sind die Trigger, die f\u00fcr das zugeh\u00f6rige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die M\u00f6glichkeit die Schl\u00fcsselw\u00f6rter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gew\u00e4hlte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.\n\n    \n\n    Der SQL-Standard definiert Transitionstabellen und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.", "type": "multiple-choice", "answers": [{"text": "in allen Triggerkomponenten mit Doppelpunkt geschrieben.", "solution": "false"}, {"text": "in der WHEN-Bedingung mit Doppelpunkt geschrieben.", "solution": "false"}, {"text": "in der WHEN-Bedingung ohne Doppelpunkt geschrieben.", "solution": "true"}, {"text": "im Aktionsteil mit Doppelpunkt geschrieben.", "solution": "true"}, {"text": "im Aktionsteil ohne Doppelpunkt geschrieben.", "solution": "false"}, {"text": "in allen Triggerkomponenten ohne Doppelpunkt geschrieben.", "solution": "false"}]}, {"id": 2234, "category": 10, "difficulty": 2, "text": "Wie wird ein Trigger mit dem Bezeichner triggername aufgerufen und ausgef\u00fchrt?", "explanation": "Trigger werden nur durch das ausl\u00f6sende Ereignis (INSERT / UPDATE / DELETE) angesto\u00dfen, eine andere M\u00f6glichkeit gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "Unter SQL-Plus/ISQL-Plus mit     EXECUTE triggername", "solution": "false"}, {"text": "Im PL/SQL-Programm einfach nur mit dem   triggername", "solution": "false"}, {"text": "Durch ein eingetretenes Ereignis", "solution": "true"}, {"text": "Durch einen eingetretenen Ausf\u00fchrungszeitpunkt", "solution": "false"}, {"text": "In SELECT- und DML-Anweisungen durch Verwendung von   triggername", "solution": "false"}]}, {"id": 2257, "category": 9, "difficulty": 1, "text": "Mit  welchem PL/SQL-Blocktyp ermittelt man immer einen Wert und gibt ihn zur\u00fcck?", "explanation": "PL/SQL unterscheidet vier Typen von Bl\u00f6cken: \n\nEin Anonymer Block ist ein unbenannter PL/SQL-Block, der in einer Anwendung (Prozedur, Funktion ) eingebettet ist oder interaktiv eingegeben wird. \nEine Stored ist ein benannter PL/SQL-Block, der Parameter haben kann und als Prozedur oder Funktion definiert ist. Er wird im Datenbanksystem gespeichert und auf dem Server von der PL/SQL-Engine ausgef\u00fchrt. Stored Functions geben \u00fcber RETURN einen Wert an das aufrufende Programm zur\u00fcck\nEin PACKAGE ist ein benannter PL/SQL-Block, der logisch verwandte Prozeduren und Funktionen, Deklarationen etc. zu einer Bibliothek zusammenfasst. \nEin Datenbanktrigger ist ein PL/SQL-Block, der zu einem definierten Ereignis (INSERT, UPDATE oder DELETE) automatisch vom Datenbankmanagementsystem aktiviert und ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "Prozedur", "solution": "false"}, {"text": "Trigger", "solution": "false"}, {"text": "Funktion", "solution": "true"}, {"text": "Paket", "solution": "false"}, {"text": "Anonymer Block", "solution": "false"}]}, {"id": 2258, "category": 9, "difficulty": 2, "text": "Womit kann man in PL/SQL einen Record definieren, dessen Datentyp sich auf eine Tabellendefinition bezieht und der bei  \u00c4nderungen der Tabellendefinition entsprechend aktualisiert wird?", "explanation": "Mit Tabellenname%ROWTYPE wird die Attributstruktur einer Tabelle komplett an einen PL/SQL-Rekord \u00fcbertragen und dynamisch angepasst. wenn sich dien Tabellendefinition \u00e4ndert. Mit Tabellenname.Spaltenname%TYPE kann man eine Variable entsprechend der Spalte einer Tabelle definieren.", "type": "text", "answers": [{"text": "Das ist:", "solution": "%ROWTYPE"}]}, {"id": 2259, "category": 9, "difficulty": 3, "text": "Womit kann man in PL/SQL eine Variable definieren, deren Datentyp sich auf eine Tabellendefinition bezieht und die bei \u00c4nderungen der Tabellendefinition entsprechend aktualisiert wird?", "explanation": "Mit Tabellenname%ROWTYPE wird die Attributstruktur einer Tabelle komplett an einen PL/SQL-Rekord \u00fcbertragen und dynamisch angepasst. wenn sich die Tabellendefinition \u00e4ndert. Mit Tabellenname.Spaltenname%TYPE kann man eine Variable entsprechend einer einzelnen Spalte einer Tabelle definieren.", "type": "text", "answers": [{"text": "Das ist:", "solution": "\r\n    %ROWTYPE\r"}]}, {"id": 2260, "category": 9, "difficulty": 2, "text": "Mit welchem Befehl kann man unter PL/SQL eine Meldung anzeigen lassen und gleichzeitig das Programm fehlerhaft abbrechen lassen?", "explanation": "RAISE und RAISE_APPLICATION_ERROR werfen einen Fehler, dem man eine eigene Fehlermeldung zuordnen kann. Damit wird das PL/SQL-Programm unterbrochen.", "type": "text", "answers": [{"text": "Das ist:", "solution": "RAISE_APPLICATION_ERROR"}]}, {"id": 2261, "category": 9, "difficulty": 1, "text": "Welche Klausel kommt bei SELECT-Anweisungen unter PL/SQL neu hinzu?", "explanation": "SELECT INTO var \n\u00fcbergibt genau einen Datensatz oder Wert an die INTO-Variable var, die nur genau einen Wert oder Datensatz aufnehmen kann.", "type": "text", "answers": [{"text": "Das ist:", "solution": "INTO"}]}, {"id": 2288, "category": 9, "difficulty": 1, "text": "Aufgrund der strengen Typisierung bei ORBS sind implizite und explizite Typumwandlungen notwendig.", "explanation": "Das ist die Definition der strengen Typisierung.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2289, "category": 9, "difficulty": 3, "text": "Welche Datentypen sind g\u00e4ngige Basisdatentypen in einem ORDBS?", "explanation": "VARRAY und NESTED-Table sind ORACLE-Konstrukte, die nicht zum Standard-SQL geh\u00f6ren.", "type": "multiple-choice", "answers": [{"text": "NUMBER", "solution": "true"}, {"text": "VARRAY", "solution": "false"}, {"text": "DATE", "solution": "true"}, {"text": "BLOB", "solution": "true"}, {"text": "NESTED TABLE", "solution": "false"}]}, {"id": 2290, "category": 9, "difficulty": 3, "text": "Typkonstuktoren in ORDBS", "explanation": "Typkonstruktoren k\u00f6nnen auch in Tupeltabellen benutzt werden.", "type": "multiple-choice", "answers": [{"text": "sind beliebig schachtelbar", "solution": "true"}, {"text": "k\u00f6nnen nicht geschachtelt aufgerufen werden", "solution": "false"}, {"text": "sollen eine intuitivere Abbildung der Realit\u00e4t erm\u00f6glichen.", "solution": "true"}, {"text": "k\u00f6nnen nur in Objekttabellen verwendet werden.", "solution": "false"}]}, {"id": 2306, "category": 9, "difficulty": 3, "text": "Welche objektrelationalen Datentypen sind in der Theorie objektrelationaler DBS vorgesehen, die es beim relationalen Modell nicht gibt?", "explanation": "Atomare Werte und boolesche Datentypen geh\u00f6ren zum relationalen Modell.", "type": "multiple-choice", "answers": [{"text": "OID (object identifier)", "solution": "true"}, {"text": "Atomare Werte", "solution": "false"}, {"text": "LOB (large objects)", "solution": "true"}, {"text": "ARRAY", "solution": "true"}, {"text": "MULTISET", "solution": "true"}, {"text": "SET", "solution": "true"}, {"text": "LIST", "solution": "true"}, {"text": "OBJECT (Objekttyp)", "solution": "true"}, {"text": "ROW", "solution": "true"}, {"text": "REF (Referenz)", "solution": "true"}, {"text": "BOOLEAN", "solution": "false"}]}, {"id": 2307, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber VARRAY-Datentypen sind bei Oracle wahr?", "explanation": "Bis auf die Einschr\u00e4nkung, dass einzelne Eintr\u00e4ge nicht ver\u00e4ndert werden k\u00f6nnen, sind alle Aussagen der Frage zu den VARRAY richtig.", "type": "multiple-choice", "answers": [{"text": "Sie sind eine geordnete Menge Elementen von Datenelementen.", "solution": "true"}, {"text": "Alle Datenelemente haben den gleichen Datentyp.", "solution": "true"}, {"text": "Es wird eine maximale Anzahl an Eintr\u00e4gen vorgegeben.", "solution": "true"}, {"text": "Innerhalb dieser Eintragsgrenze ist die Anzahl an Eintr\u00e4gen variabel.", "solution": "true"}, {"text": "Es wird automatisch eine Konstruktormethode erzeugt, die genauso hei\u00dft wie der VARRAY-Typ.", "solution": "true"}, {"text": "Daten werden unter Verwendung der Konstruktormethode eingef\u00fcgt.", "solution": "true"}, {"text": "Daten werden unter Verwendung der Konstruktormethode ge\u00e4ndert.", "solution": "true"}, {"text": "Einzelne Eintr\u00e4ge in einem VARRAY k\u00f6nnen direkt ge\u00e4ndert werden.", "solution": "false"}, {"text": "VARRAYs sind Kollektionsdatentypen und stellen daher eine Verletzung der 1. NF im relationalen Modell dar.", "solution": "true"}]}, {"id": 2312, "category": 9, "difficulty": 2, "text": "Beim Erzeugen eines NESTED TABLE-Datentyps kann man bei Oracle nur ein Datentyp spezifiziert werden, so dass es nur einspaltige NESTED TABLEs gibt.", "explanation": "NESTED TABLE \nMit der STORE-Klausel k\u00f6nnen tabellenwertige Spalten beschrieben werden. F\u00fcr jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher inneren Tabelle die tabellenwertigen Spalten abgelegt werden. Der Kollektionstyp kann dabei wieder auf einem benutzerdefinierten Datentyp aufsetzen.", "type": "multiple-choice", "answers": [{"text": "Dieses Problem gibt es nicht bei Oracle.", "solution": "false"}, {"text": "Will man dieses Problem umgehen, so kann man bei Oracle einen strukturierten Datentyp verwenden, der aus mehreren Attributen besteht.", "solution": "true"}, {"text": "Will man dieses Problem umgehen, so kann man bei Oracle f\u00fcr die Datentypdefinition einen ROW-Kontruktor verwenden", "solution": "false"}]}, {"id": 2313, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft die Klausel bei Oracle, mit der man den Namen einer NESTED-TABLE spezifiziert? Wenn es eine solche Klausel nicht gibt, schreiben Sie \"gibt es nicht\"", "explanation": "NESTED TABLE \nMit der STORE AS Klausel k\u00f6nnen tabellenwertige Spalten beschrieben werden. F\u00fcr jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher inneren Tabelle die tabellenwertigen Spalten abgelegt werden. Der Kollektionstyp kann dabei wieder auf einem benutzerdefinierten Datentyp aufsetzen.", "type": "text", "answers": [{"text": "Sie hei\u00dft:", "solution": "STORE AS"}]}, {"id": 2314, "category": 9, "difficulty": 2, "text": "In welchem Befehl wird beim Oracle-DBS der Tabellenname f\u00fcr ein NESTED-TABLE-Attribut spezifiziert?", "explanation": "Die STORE AS-Klausel wird bei der Tabellendefinition, nicht bei der Typdefinition angegeben.", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPLACE TYPE <typname>   STORE AS <tabellenname>;", "solution": "false"}, {"text": "CREATE TABLE <tabellenname> AS OBJECT   STORE AS <tabellenname>;", "solution": "true"}, {"text": "Solch eine Klausel gibt es nicht.", "solution": "false"}]}, {"id": 2178, "category": 11, "difficulty": 2, "text": "Es ist folgende Tabelle mit zwei persistent gespeicherten Datens\u00e4tzen gegeben:\nCREATE TABLE trans_tab (s1  NUMBER(3) PRIMARY KEY INITIALLY IMMEDIATE, \n                        s2  VARCHAR2(20) UNIQUE INITIALLY DEFERRED);\nINSERT INTO trans_tab VALUES (1, 'Mustermann');\nINSERT INTO trans_tab VALUES (2, 'Musterfrau');\nCOMMIT;\n\nSchauen Sie sich nachfolgende Anweisungen an und geben Sie an, welche Datens\u00e4tze zum Zeitpunkt b) mit der SELECT-Anfrage angezeigt werden. \n\nSELECT * FROM trans_tab;                -- Zeitpunkt a)\nINSERT INTO trans_tab VALUES (3, 'Schmitt');\nINSERT INTO trans_tab VALUES (4, 'Schmidt');\nINSERT INTO trans_tab VALUES (4, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                -- Zeitpunkt b)\nINSERT INTO trans_tab VALUES (5, 'Schmitzchen');\nINSERT INTO trans_tab VALUES (6, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                 -- Zeitpunkt c)\nCOMMIT;\n\nSELECT * FROM trans_tab;                -- Zeitpunkt d)", "explanation": "Nach dem CREATE-TABLE werden zwei Datens\u00e4tze eingef\u00fcgt, die keines der Constraints verletzt, und anschlie\u00dfend mit COMMIT persistent gespeichert, so dass folgender Inhalt beim a)-SELECT gegen ist. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n\nVon den drei bis zum b)-SELECT eingef\u00fcgten Datens\u00e4tzen verletzt der letzte mit dem Prim\u00e4rschl\u00fcssel 4 das PRIMARY KEY-Constraint und da dies als IMMEDIATE definiert ist, wird nur dieser fehlerhafte, letzte Datensatz zur\u00fcckgewiesen. Die beiden vorherigen richtigen Datens\u00e4tze bleiben in der aktuellen Transaktion. Aber Achtung, da hier nicht \"committed\" wird, werden diese beiden Datens\u00e4tze nicht persistent gespeichert. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt", "type": "multiple-choice", "answers": [{"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen", "solution": "false"}, {"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt", "solution": "true"}, {"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2179, "category": 11, "difficulty": 2, "text": "Es ist folgende Tabelle mit zwei persistent gespeicherten Datens\u00e4tzen gegeben:\nCREATE TABLE trans_tab (s1  NUMBER(3) PRIMARY KEY INITIALLY IMMEDIATE, \n                        s2  VARCHAR2(20) UNIQUE   INITIALLY DEFERRED);\nINSERT INTO trans_tab VALUES (1, 'Mustermann');\nINSERT INTO trans_tab VALUES (2, 'Musterfrau');\nCOMMIT;\n\nSchauen Sie sich nachfolgende Anweisungen an und geben Sie an, welche Datens\u00e4tze zum Zeitpunkt c) mit der SELECT-Anfrage angezeigt werden. \n\nSELECT * FROM trans_tab;                -- Zeitpunkt a)\nINSERT INTO trans_tab VALUES (3, 'Schmitt');\nINSERT INTO trans_tab VALUES (4, 'Schmidt');\nINSERT INTO trans_tab VALUES (4, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                -- Zeitpunkt b)\nINSERT INTO trans_tab VALUES (5, 'Schmitzchen');\nINSERT INTO trans_tab VALUES (6, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                 -- Zeitpunkt c)\nCOMMIT;\n\nSELECT * FROM trans_tab;                -- Zeitpunkt d)", "explanation": "Nach dem CREATE-TABLE werden zwei Datens\u00e4tze eingef\u00fcgt, die keines der Constraints verletzt, und anschlie\u00dfend mit COMMIT persistent gespeichert, so dass folgender Inhalt beim a)-SELECT gegen ist. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n\nVon den drei bis zum b)-SELECT eingef\u00fcgten Datens\u00e4tzen verletzt der letzte mit dem Prim\u00e4rschl\u00fcssel 4 das PRIMARY KEY-Constraint und da dies als IMMEDIATE definiert ist, wird nur dieser fehlerhafte, letzte Datensatz zur\u00fcckgewiesen. Die beiden vorherigen richtigen Datens\u00e4tze bleiben in der aktuellen Transaktion. Aber Achtung, da hier nicht \"committed\" wird, werden diese beiden Datens\u00e4tze nicht persistent gespeichert. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n\nDie laufende Transaktion wird mit zwei weiteren INSERTs (5, 6) fortgesetzt. Der zweite davon verletzt mit einer erneuten Einf\u00fcgung des Namens \"Schmitzschen\" zwar das UNIQUE-Constraint, aber da dies als DEFERRED definiert ist, wird dieser Fehler noch nicht vom DBS erkannt, die beiden neuen Datens\u00e4tze geh\u00f6ren zum Zeitpunkt des c)-SELECTs nun auch der aktuellen Transaktion an.  \n\n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen", "type": "multiple-choice", "answers": [{"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen", "solution": "true"}, {"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt", "solution": "false"}, {"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2180, "category": 11, "difficulty": 2, "text": "Es ist folgende Tabelle mit zwei persistent gespeicherten Datens\u00e4tzen gegeben:\nCREATE TABLE trans_tab (s1  NUMBER(3) PRIMARY KEY INITIALLY IMMEDIATE, \n                        s2  VARCHAR2(20) UNIQUE   INITIALLY DEFERRED);\nINSERT INTO trans_tab VALUES (1, 'Mustermann');\nINSERT INTO trans_tab VALUES (2, 'Musterfrau');\nCOMMIT;\n\nSchauen Sie sich nachfolgende Anweisungen an und geben Sie an, welche Datens\u00e4tze zum Zeitpunkt d) mit der SELECT-Anfrage angezeigt werden. \n\nSELECT * FROM trans_tab;                -- Zeitpunkt a)\nINSERT INTO trans_tab VALUES (3, 'Schmitt');\nINSERT INTO trans_tab VALUES (4, 'Schmidt');\nINSERT INTO trans_tab VALUES (4, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                -- Zeitpunkt b)\nINSERT INTO trans_tab VALUES (5, 'Schmitzchen');\nINSERT INTO trans_tab VALUES (6, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                 -- Zeitpunkt c)\nCOMMIT;\n\nSELECT * FROM trans_tab;                -- Zeitpunkt d)", "explanation": "Nach dem CREATE-TABLE werden zwei Datens\u00e4tze eingef\u00fcgt, die keines der Constraints verletzt, und anschlie\u00dfend mit COMMIT persistent gespeichert, so dass folgender Inhalt beim a)-SELECT gegen ist. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n\nVon den drei bis zum b)-SELECT eingef\u00fcgten Datens\u00e4tzen verletzt der letzte mit dem Prim\u00e4rschl\u00fcssel 4 das PRIMARY KEY-Constraint und da dies als IMMEDIATE definiert ist, wird nur dieser fehlerhafte, letzte Datensatz zur\u00fcckgewiesen. Die beiden vorherigen richtigen Datens\u00e4tze bleiben in der aktuellen Transaktion. Aber Achtung, da hier nicht \"committed\" wird, werden diese beiden Datens\u00e4tze nicht persistent gespeichert. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n\nDie laufende Transaktion wird mit zwei weiteren INSERTs (5, 6) fortgesetzt. Der zweite davon verletzt mit einer erneuten Einf\u00fcgung des Namens \"Schmitzschen\" zwar das UNIQUE-Constraint, aber da dies als DEFERRED definiert ist, wird dieser Fehler noch nicht vom DBS erkannt, die beiden neuen Datens\u00e4tze geh\u00f6ren zum Zeitpunkt des c)-SELECTs nun auch der aktuellen Transaktion an.  \n\n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen\n\nDie aktuelle Transaktion bestehend aus den Datens\u00e4tzen 3, 4, 5, 6 wird vor dem d)-SELECT mittels COMMIT abgeschlossen. Damit werden alle DEFERRED-Constraints gepr\u00fcft und in diesem Fall der UNIQUE-Fehler mit \"Schmitzchen\" erkannt. Da bei DEFERRED-Fehlern die gesamte Transaktion zur\u00fcckgerollt wird, bleiben nur noch die beiden urspr\u00fcnglichen Datens\u00e4tze \u00fcbrig, die mit der ersten Transaktion \"committed\" wurden. \n\n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau", "type": "multiple-choice", "answers": [{"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen", "solution": "false"}, {"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt", "solution": "false"}, {"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2181, "category": 10, "difficulty": 3, "text": "Betrachten Sie die Tabelle Test:\n\nCREATE TABLE TEST\n(OID NUMBER(38),\n bezeichnung VARCHAR2(100));\n\nWelche/r Trigger ist syntaktisch korrekt und verhindert nur f\u00fcr die OID-Spalte, dass sie ver\u00e4ndert wird?", "explanation": "Ein Trigger mit \"BEFORE UPDATE ON Test\" ohne Spaltenangabe verhindert, dass irgendein Wert in der Tabelle Test ver\u00e4ndert wird, nicht nur die OID. \n\nEin Trigger kann kein ROLLBACK enthalten, da er Bestandteil einer Transaktion ist. \n\nDBMS_OUTPUT.PUT_LINE (...) l\u00f6st kein Rollback aus, dass hei\u00dft, die Spalte OID kann ver\u00e4ndert werden.", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPLACE trigger update_verhindern\nAFTER UPDATE OF OID ON Test\nFOR EACH ROW\nBEGIN\n   RAISE_APPLICATION_ERROR \n           (-20003, 'Sie k\u00f6nnen die Spalte oid nicht ver\u00e4ndern!');\nEND; /\n", "solution": "true"}, {"text": "CREATE OR REPLACE trigger update_verhindern\nBEFORE UPDATE OF OID ON Test FOR EACH ROW\nBEGIN\n   RAISE_APPLICATION_ERROR \n           (-20003, 'Sie k\u00f6nnen die Spalte oid nicht ver\u00e4ndern!'); END;\n/\n", "solution": "true"}, {"text": "CREATE OR REPLACE trigger update_verhindern BEFORE UPDATE ON Test\nFOR EACH ROW\nBEGIN\n  RAISE_APPLICATION_ERROR \n           (-20003, 'Sie k\u00f6nnen die Spalte oid nicht ver\u00e4ndern!');END;\n/\n", "solution": "false"}, {"text": "CREATE OR REPLACE trigger update_verhindern\nAFTER UPDATE OF oid ON Test FOR EACH ROW\nBEGIN\n  IF :NEW.OID <> :OLD.OID THEN\n    ROLLBACK;\n  END IF;\nEND;\n/", "solution": "false"}, {"text": "CREATE OR REPLACE trigger update_verhindern AFTER UPDATE OF OID ON Test FOR EACH ROW\nBEGIN\n DBMS_OUTPUT.PUT_LINE \n         ('Sie k\u00f6nnen die Spalte oid nicht ver\u00e4ndern!'); END; /\n", "solution": "false"}, {"text": "CREATE OR REPLACE trigger update_verhindern\nAFTER UPDATE ON Test\nFOR EACH ROW\nWHEN (NEW.OID <> OLD.OID)\nBEGIN\n RAISE_APPLICATION_ERROR \n           (20000, 'Sie k\u00f6nnen die Spalte oid nicht ver\u00e4ndern!');\n  \nEND; /\n", "solution": "true"}]}, {"id": 2251, "category": 10, "difficulty": 1, "text": "Betrachten Sie einen ROW-Trigger auf der Tabelle Test_Tab (nr1 NUMBER, nr2 NUMBER) der Gestalt:  \n\nCREATE OR REPLACE TRIGGER test_tab_trg\n            AFTER UPDATE ON test_tab FOR EACH ROW BEGIN  END; \n\nWelche Aussagen sind f\u00fcr diesen ORACLE-Trigger wahr, wenn sich nur die Spalte nr1 mittels UPDATE \u00e4ndert?", "explanation": "Da das Ereignis nach einem UPDATE angesto\u00dfen wird und es sich um eine Zeilentrigger handelt, der nicht von einer Spalte abh\u00e4ngt, ist auch die Transitionsvariable NEW.n2 gef\u00fcllt.", "type": "multiple-choice", "answers": [{"text": "Die Transitionsvariable NEW f\u00fcr nr2 ist gef\u00fcllt.", "solution": "true"}, {"text": "Die Transitionsvariable NEW f\u00fcr nr2 ist nicht gef\u00fcllt.", "solution": "false"}]}, {"id": 2218, "category": 10, "difficulty": 3, "text": "Die Theorie sieht bei ECMA-Regeln unter anderem folgende Ereignisse vor:", "explanation": "Alle diese Ereignisse sind in der Theorie vorgesehen, im SQL-Standard sind leider nur die DML-Ereignisse zul\u00e4ssig.", "type": "multiple-choice", "answers": [{"text": "\u00c4nderungsoperationen auf Daten", "solution": "true"}, {"text": "Zeitereignisse", "solution": "true"}, {"text": "Prozedur- und Funktionsaufrufe", "solution": "true"}, {"text": "Datendefinitionsanweisungen", "solution": "true"}, {"text": "Mittels einer Algebra kombinierte Ereignisse", "solution": "true"}]}, {"id": 2230, "category": 9, "difficulty": 3, "text": "Das Oracle-Package NDS (Native Dynamic SQL) wird gebraucht, um folgende Befehle auszuf\u00fchren:", "explanation": "In PL/SQL kann nur SQL-Manipulationsanweisungen, aber keine DDL-Anweisungen wie CREATE, ALTER, DROP etc.,keine DCL wie GRANT, REVOKE etc. und keine SESSION CONTROL-Anweisungen wie ALTER SESSION\nverarbeiten. Einen Ausweg aus dieser Situation bietet dynamisches SQL unter PL/SQL mit NDS, dem Native Dynamic SQL. Die auszuf\u00fchrende SQL-Anweisung wird ohne abschlie\u00dfendes Semikolon als Zeichenkette oder in einer Textvariablen dem Befehl EXECUTE IMMEDIATE \u00fcbergeben, der diesen Text ungepr\u00fcft zur Ausf\u00fchrung an das Datenbankmanagementsystem sendet. Der Befehl EXECUTE IMMEDIATE selbst wird aber mit einem Semikolon abgeschlossen.Eine andere \u00e4ltere und etwas aufw\u00e4ndigere  M\u00f6glichkeit ist die Verwendung des Pakets DBMS_SQL.", "type": "multiple-choice", "answers": [{"text": "SELECT-Anweisungen, die erst zur Laufzeit zusammengesetzt werden", "solution": "true"}, {"text": "SELECT-Anweisungen, deren Formulierung bei der Programmierung fix ist", "solution": "false"}, {"text": "INSERT-, UPDATE-, DELETE-Anweisungen, die erst zur Laufzeit zusammengesetzt werden", "solution": "true"}, {"text": "INSERT-, UPDATE-, DELETE-Anweisungen, deren Formulierung bei der Programmierung fix ist", "solution": "false"}, {"text": "CREATE-Anweisungen", "solution": "true"}, {"text": "ALTER-Anweisungen", "solution": "true"}, {"text": "DROP-Anweisungen", "solution": "true"}]}, {"id": 2236, "category": 9, "difficulty": 3, "text": "Wie wird eine Prozedur mit dem Bezeichner prozedurname aufgerufen?", "explanation": "Beispiele f\u00fcr Prozeduraufrufe sind:\n\n    SQL-Developer\n\n    EXECUTE prozedurname(var_y, var_x)\n\n    \n\n    Im PL/SQL-Programm:\n\n    prozedurname(var_y, var_x)\n\n    \n\n    SELECT/DML-Anweisung, IF-Bedingung und Zuweisungen sind Aufrufformen f\u00fcr Funktionen. Und Trigger werden \"durch ein eingetretenes Ereignis\" gefeuert und zu einem \"einen eingetretenen Ausf\u00fchrungszeitpunkt\" ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "Im SQL-Editor von TOAD oder des SQL Developers mit EXECUTE prozedurname", "solution": "true"}, {"text": "Im PL/SQL-Programm einfach nur mit   prozedurname", "solution": "true"}, {"text": "Durch ein eingetretenes Ereignis", "solution": "false"}, {"text": "Durch einen eingetretenen Ausf\u00fchrungszeitpunkt", "solution": "false"}, {"text": "In SELECT- und DML-Anweisungen durch Verwendung von   prozedurname", "solution": "false"}, {"text": "In IF-Bedingungen", "solution": "false"}, {"text": "In Zuweisungen", "solution": "false"}]}, {"id": 2250, "category": 10, "difficulty": 1, "text": "Zu welchem Problem f\u00fchrt das Ausf\u00fchrungsmodell von Oracle, wenn in einem Row-Trigger mittels DML-Anweisung auf die Tabelle zugegriffen wird, f\u00fcr die der Trigger definiert ist?", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "multiple-choice", "answers": [{"text": "Impedance Missmatch", "solution": "false"}, {"text": "Mutating Table", "solution": "true"}, {"text": "keins von allen", "solution": "false"}, {"text": "Kakadierende Trigger", "solution": "false"}]}, {"id": 2263, "category": 9, "difficulty": 2, "text": "Welche EXCEPTION wird geworfen, wenn eine SELECT-Anweisung unter PL/SQL mehrere Datens\u00e4tze liefert?", "explanation": "SELECT INTO \u00fcbergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datens\u00e4tze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datens\u00e4tze verarbeiten kann.", "type": "text", "answers": [{"text": "Das ist:", "solution": "TOO_MANY_ROWS"}]}, {"id": 2326, "category": 9, "difficulty": 2, "text": "Will man ein Objektklasse aus einem objektorientierten Modell auf ein relationales Modell abbilden,", "explanation": "RICHTIG ist: \n\"so wird eine Klasse auf eine oder mehrere relationale Tabellen abgebildet.\"\n\nWenn die Attribute einer Klasse z.B. nur mit einfachen Datentypen (INT, CHAR, NUMBER, ...) definiert sind, so kann man eine Klasse auf genau eine Relation abbilden. \n\nHat man jedoch z.B. eine Klasse mit mengenwertigen Attributen (ARRAY, LIST, ...), so k\u00f6nnte eine Form der relationalen Implementierung aussehen, dass man das mengenwertige Attribut in einer eigenen Relation \"auslagert\" und beide Relationen mit einer 1:n-Beziehung verbindet.", "type": "multiple-choice", "answers": [{"text": "so wird eine Klasse immer auf genau eine relationale Tabelle abgebildet.", "solution": "false"}, {"text": "so wird eine Klasse immer auf mehrere relationale Tabellen abgebildet.", "solution": "false"}, {"text": "so wird eine Klasse auf eine oder mehrere relationale Tabellen abgebildet.", "solution": "true"}, {"text": "Keine dieser Abbildungen ist richtig.", "solution": "false"}]}, {"id": 2330, "category": 9, "difficulty": 3, "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind Subklassen der Gesch\u00e4ftspartner. \nWelche (Objekt-)Tabellen werden ben\u00f6tigt, wenn man diesen Sachverhalt gem\u00e4\u00df der vertikalen Fragmentierung implementieren m\u00f6chte?", "explanation": "Es gibt drei Fragmentierungstypen:  \n\nhorizontalen Fragmentierung \nBei der horizontalen Form werden f\u00fcr jeden Subtyp eine Tabelle angelegt, aber nicht f\u00fcr den Supertypen, geht also nur, wenn die Subtypen vollst\u00e4ndig sind. Die Subtypen-Tabellen verf\u00fcgen neben den eigenen Attributen zudem \u00fcber die Attribute des Supertypen. \n\nvertikale Fragmentierung: \nBei der vertikalen Form werden f\u00fcr jeden Subtyp eine Tabelle angelegt und auch f\u00fcr den Supertypen, geht also, wenn die Subtypen unvollst\u00e4ndig sind. Subtypen- und Supertyp-Tabellen verf\u00fcgen jeweils \u00fcber ihre eigenen Attribute.\n\nvirtuelle Fragmentierung:  \nBei der virtuellen Form wird nur eine Tabelle mit den Attributen aller Super- und Subtyen angelegt. Um unterscheiden zu k\u00f6nnen, welcher Datensatz nun zu welchem Subtypen geh\u00f6rt, werden entweder subtypenspezifische Attribute abgefragt oder eine zus\u00e4tzliche sog. Diskriminatorspalte angelegt, die f\u00fcr jeden Subtpyen einen spezifischen Wert annimmt.", "type": "multiple-choice", "answers": [{"text": "Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "true"}, {"text": "Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen sowie alle kunden- und lieferantenspezifischen Attribute und einem Kennzeichenattribut, welches die Partnerart spezifiziert", "solution": "false"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den kundenspezifischen", "solution": "false"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den lieferantenspezifischen", "solution": "false"}, {"text": "Kunden, nur mit den kundenspezifischen Attributen", "solution": "true"}, {"text": "Lieferanten, nur mit den lieferantenspezifischen Attributen", "solution": "true"}]}, {"id": 2470, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft der CONSTRAINT, wenn eine Spalte Prim\u00e4rschl\u00fcssel ist?", "explanation": "Das Prim\u00e4rschl\u00fcssel-Constraint hei\u00dft PRIMARY KEY.\n\n    \n\n    Die \u00fcbrigen vier  Constraints sind: UNIQUE, CHECK, FOREIGN KEY und NOT NULL.", "type": "text", "answers": [{"text": "Das ist:", "solution": "PRIMARY KEY"}]}, {"id": 2468, "category": 5, "difficulty": 1, "text": "Eine m:n-Beziehung im ERD (ohne beteiligte Entity-Mengen) wird beim \u00dcbergang zum DB-Schema in wie viele der folgenden Objekte \u00fcberf\u00fchrt?", "explanation": "Eine n-m-Beziehung wird bei diesem \u00dcbergang in einer Relation und zwei 1:n-Beziehungen aufgel\u00f6st, die durch Fremdschl\u00fcssel dargestellt  werden.", "type": "multiple-choice", "answers": [{"text": "Eine 1:1-Beziehung und zwei Relationen", "solution": "false"}, {"text": "Zwei 1:1-Beziehungen und eine Relation", "solution": "false"}, {"text": "Zwei 1:n-Beziehungen und eine Relation", "solution": "true"}, {"text": "Zwei 1:n-Beziehungen", "solution": "false"}]}, {"id": 2498, "category": 9, "difficulty": 1, "text": "\u00dcber die Verwendung von Prim\u00e4rschl\u00fcsseln f\u00fcr Anfragen sind folgende Aussagen wahr:", "explanation": "Die einzig richtige Aussage ist: \"Prim\u00e4rschl\u00fcsselspalten k\u00f6nnen eine Rolle spielen, wenn die Laufzeit von Anfragen verbessert werden muss.\". \nDie \u00fcbrigen Aussagen sind falsch: Prim\u00e4rschl\u00fcsselspalten werden weder f\u00fcr die Projektion noch f\u00fcr die Selektion von Daten gebraucht.", "type": "multiple-choice", "answers": [{"text": "Man kann in der SELECT-Klausel nur Prim\u00e4rschl\u00fcsselspalten projizieren.", "solution": "false"}, {"text": "Man kann in der WHERE-Klausel nur \u00fcber Prim\u00e4rschl\u00fcsselspalten suchen.", "solution": "false"}, {"text": "Prim\u00e4rschl\u00fcsselspalten k\u00f6nnen eine Rolle spielen, wenn die Laufzeit von Anfragen verbessert werden muss.", "solution": "true"}, {"text": "Keine von diesen Aussagen.", "solution": "false"}]}, {"id": 2159, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl: \n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Angestellter) REFERENCES Hierarchie (Vorgesetzter) ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?", "explanation": "Der Prim\u00e4rschl\u00fcssel ist als Tabellen-Constraint definiert. Gut zu erkennen an dem trennenden Komma zu der vorangehenden Spaltendefinition der Spalte Vorgesetzter.\n\n    \n\n    Die Eingabe der Datens\u00e4tze \"(\"Hugo\",\"Emil\"), (\"Erna\",\"Emil\"), (\"Anna\",\"Emil\")\" wird bereits beim 1. Datensatz fehl schlagen, da die Fremdschl\u00fcsselbeziehung f\u00fcr \"Emil\" fehl schl\u00e4gt, weil es keinen Mitarbeitersatz f\u00fcr Emil mit seinem Vorgesetzten gibt z.B. mit (\"Emil\",\"Annna\").\n\n    \n\n    Die Einf\u00fcgung von Anton schl\u00e4gt ebenfalls fehl, weil f\u00fcr Anton der Name seines Vorgesetzten fehlt, den er ja nicht hat. Die Spalte Vorgesetzter ist jedoch Pflichteingabe (NOT NULL).\n\n    \n\n    Wenn f\u00fcr eine Einf\u00fcgung eines neuen Datensatzes die Prim\u00e4rschl\u00fcsselbedingung fehl schl\u00e4gt, dann wird die Einf\u00fcgung r\u00fcckg\u00e4ngig gemacht und eine entsprechende Fehlermeldung angezeigt.", "type": "multiple-choice", "answers": [{"text": "Der Prim\u00e4rschl\u00fcssel ist als Spalten-Constraint definiert.", "solution": "false"}, {"text": "Es sollen die folgenden 3 Datens\u00e4tze in die noch leere Tabelle Hierarchie eingef\u00fcgt werden:\n \n('Hugo','Emil'), ('Erna','Emil'), ('Anna','Emil')\n\nStimmt die Aussage: \n\"Das ist ein semantisch korrekter Inhalt der Tabelle Hierarchie.\"?", "solution": "false"}, {"text": "Als erster Datensatz wird erfolgreich der 'oberste Chef' Anton eingef\u00fcgt: \n\nINSERT INTO hierarchie VALUES ('Anton',NULL);", "solution": "false"}, {"text": "Wenn f\u00fcr eine Einf\u00fcgung eines neuen Datensatzes die Prim\u00e4rschl\u00fcsselbedingung fehl schl\u00e4gt, dann wird die Einf\u00fcgung r\u00fcckg\u00e4ngig gemacht und eine entsprechende Fehlermeldung angezeigt.", "solution": "true"}]}, {"id": 2161, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren aus der relationalen Algebra l\u00e4sst sich der Durchschnittsoperator simulieren?", "explanation": "Die Simulation sieht wie folgt aus: \n(A Durchschnitt B)  =  ( A ohne (A ohne B) ) \n\n(A Durchschnitt B)  =  ( A Differenz (A Differenz B) ) \n\nPS: Zeichnen Sie sich ruhig die Venn-Diagramme auf - es hilft ;-) \nPS: War mal Klausuraufgabe :-)", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Division", "solution": "false"}, {"text": "Mit keinem Operator aus der relationalen Algebra", "solution": "false"}, {"text": "Differenz", "solution": "true"}]}, {"id": 2163, "category": 9, "difficulty": 3, "text": "Betrachten Sie zwei Relationen R und S mit jeweils einer Spalte A mit dem Datentyp Integer. \n\nWelche SQL-Anweisung beantwortet die Anfrage R - S (Differenz) aus der relationalen Algebra?", "explanation": "SELECT *\nFROM S\nWHERE A NOT IN (SELECT B FROM R); \nist falsch, da S-R berechnet wird \n\nMit UNION kann keine Differenz, sondern nur die Vereinigungsmenge berechnet werden. \n\nMinus kann ansonsten mit NOT IN oder \u00fcber den LEFT JOIN ausgedr\u00fcckt werden.", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM R\nWHERE A NOT IN (SELECT A FROM S);", "solution": "true"}, {"text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;", "solution": "true"}, {"text": "SELECT *\nFROM S\nWHERE A NOT IN (SELECT A FROM R);", "solution": "false"}, {"text": "SELECT * FROM R\n UINON\nSELECT * FROM S;", "solution": "false"}, {"text": "SELECT A FROM R LEFT OUTER JOIN S  ON S.A = R.A\nWHERE S.A IS NULL;", "solution": "true"}]}, {"id": 2213, "category": 10, "difficulty": 1, "text": "In ROW- und in STATEMENT-Triggern sind im Aktionsteil die gleichen Anweisungen m\u00f6glich.", "explanation": "IN ROW-Triggern l\u00f6sen DML-Anweisungen auf den ausl\u00f6senden Tabellen unter Oracle das Mutating-Table-Problem aus, im SQL-Standard sind sie gar nicht zugelassen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2214, "category": 10, "difficulty": 2, "text": "Mit Triggern lassen sich DEFERRED-Integrit\u00e4tspr\u00fcfungen durchf\u00fchren", "explanation": "Aufgrund ihres Ausf\u00fchrungsmodus BEFORE oder AFTER des feuernden Ereignisses k\u00f6nnen nur IMMEDIATE zu pr\u00fcfende Integrit\u00e4tsbedingungen simuliert werden. Es gibt leider keine Trigger mit dem feuernden Ereignis der COMMIT-Anweisung, so dass keine Bedingungen zum DEFERRED-Zeitpunkt gepr\u00fcft werden k\u00f6nnen. Nur in dem \u00e4u\u00dferst seltenen Fall, dass die Transaktion nur eine Manipulationsanweisung enth\u00e4lt, kann man den Zeitpunkt f\u00fcr die AFTER TRIGGER mit dem COMMIT-Zeitpunkt gleichsetzen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2215, "category": 10, "difficulty": 1, "text": "Mit Triggern lassen sich IMMEDIATE-Integrit\u00e4tspr\u00fcfungen durchf\u00fchren.", "explanation": "Aufgrund ihres Ausf\u00fchrungsmodus BEFORE oder AFTER des feuernden Ereignisses k\u00f6nnen nur IMMEDIATE zu pr\u00fcfende Integrit\u00e4tsbedingungen simuliert werden. Es gibt leider keine Trigger mit dem feuernden Ereignis der COMMIT-Anweisung, so dass keine Bedingungen zum DEFERRED-Zeitpunkt gepr\u00fcft werden k\u00f6nnen. Nur in dem \u00e4u\u00dferst seltenen Fall, dass die Transaktion nur eine Manipulationsanweisung enth\u00e4lt, kann man den Zeitpunkt f\u00fcr die AFTER TRIGGER mit dem COMMIT-Zeitpunkt gleichsetzen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2219, "category": 10, "difficulty": 3, "text": "Welche Aussagen \u00fcber ORACLE-Trigger und Integrit\u00e4tspr\u00fcfung sind wahr? Mit ihnen k\u00f6nnen", "explanation": "Mit Triggern kann nur der Pr\u00fcfungszeitpunkt DEFERRED simuliert werden.  \n\nTrigger sind Bestandteile eine Transaktion und k\u00f6nnen daher nicht eine komplette Transaktion zur\u00fcckrollen.", "type": "multiple-choice", "answers": [{"text": "alle CONSTRAINTS sowie die beiden Pr\u00fcfungszeitpunkte simuliert werden.", "solution": "false"}, {"text": "transitionale Bedingungen gepr\u00fcft werden.", "solution": "true"}, {"text": "Fehler korrigiert werden, die beim Einf\u00fcgen und \u00c4ndern von Daten entstehen", "solution": "true"}, {"text": "Fehler erkannt und die Transaktion zur\u00fcckgerollt werden.", "solution": "false"}]}, {"id": 2231, "category": 10, "difficulty": 3, "text": "Welchen Befehl muss man programmieren, damit sich die Triggerausf\u00fchrung analog zu einem aufgetretenen IMMEDIATE-Integrit\u00e4tsfehler verh\u00e4lt? Wenn es keinen solchen Befehle gibt schreiben Sie bitte \"gibt es nicht\", wenn doch reicht der Befehlsname ohne Parameter.", "explanation": "RAISE_APPLICATION_ERROR(-..) bewirkt genau das Zur\u00fcckrollen des aktuellen DML-Befehls und entspricht damit der IMMEDIATE-Integrit\u00e4tspr\u00fcfung,", "type": "text", "answers": [{"text": "Das ist", "solution": "RAISE_APPLICATION_ERROR"}]}, {"id": 2238, "category": 9, "difficulty": 1, "text": "Die Tabelle Kunden hat 1000 Datens\u00e4tze. Prim\u00e4rschl\u00fcssel ist die Spalte Kund_id.\nEs wird die folgende Anfrage ausgef\u00fchrt:\n  SELECT funktionsname(spalte1, spalte2) FROM Dual;", "explanation": "Die Funktion wird nur einmal aufgerufen, da die Pseudotabelle dual nur einen Datensatz hat.", "type": "text", "answers": [{"text": "Wie oft wird die Funktion ausgef\u00fchrt?", "solution": "1"}]}, {"id": 2240, "category": 9, "difficulty": 3, "text": "Welche Aufgabe hat eine \u00f6ffentliche Package-Variable?", "explanation": "Hier sind alle Antworten richtig bis auf \"Sie dient ausschlie\u00dflich dem Informationsaustausch zwischen Routinen des gleichen Packages.\", da dies nur eine von mehreren M\u00f6glichkeiten ist.", "type": "multiple-choice", "answers": [{"text": "Sie dient ausschlie\u00dflich dem Informationsaustausch zwischen Routinen des gleichen Packages.", "solution": "false"}, {"text": "Sie dient dem Informationsaustausch zwischen Routinen (auch ohne Package-Zugeh\u00f6rigkeit).", "solution": "true"}, {"text": "Sie dient dem Informationsaustausch zwischen Triggern.", "solution": "true"}, {"text": "Sie kann in DML und DQL-Anweisungen bei Oracle verwendet werden.", "solution": "true"}]}, {"id": 2308, "category": 9, "difficulty": 1, "text": "VARRAY-Datentypen sind bei Oracle als eine geordnete Menge von Elementen, die alle den gleichen Datentyp und eine maximale Anzahl haben, implementiert.", "explanation": "F\u00fcr eine geordnete Menge von Elementen, die nicht  alle den gleichen Datentyp  haben, ben\u00f6tigt man einen benutzerdefinierten Typ und und einen TABLE-Konstruktor.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2310, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber NESTED TABLE-Datentypen sind bei Oracle wahr?", "explanation": "Da Nested-Table \u00fcber den TABLE-Konstruktor angelegt werden, ist eine maximale Anzahl der Eintr\u00e4ge nicht vorgesehen. Alle anderen Aussagen sind richtig..", "type": "multiple-choice", "answers": [{"text": "Sie sind eine ungeordnete Menge Elementen von Datenelementen.", "solution": "true"}, {"text": "Alle Datenelemente haben den gleichen Datentyp.", "solution": "true"}, {"text": "Es wird eine maximale Anzahl an Eintr\u00e4gen vorgegeben.", "solution": "false"}, {"text": "Innerhalb dieser Eintragsgrenze ist die Anzahl an Eintr\u00e4gen variabel.", "solution": "false"}, {"text": "Es wird automatisch eine Konstruktormethode erzeugt, die genauso hei\u00dft wie der NESTED TABLE-Typ.", "solution": "true"}, {"text": "Jedes Element hat nur eine Spalte, die entweder einen atomaren oder einen strukturierten Datentyp hat.", "solution": "true"}, {"text": "Einzelne Eintr\u00e4ge in einer NESTED TABLE k\u00f6nnen direkt ge\u00e4ndert werden.", "solution": "true"}, {"text": "Die Daten der NESTED TABLE-Spalte werden in einer separaten Tabelle gespeichert.", "solution": "true"}, {"text": "NESTED TABLEs sind Kollektionsdatentypen und stellen daher eine Verletzung der 1. NF im relationalen Modell dar.", "solution": "true"}]}, {"id": 2311, "category": 9, "difficulty": 2, "text": "NESTED TABLE-Datentypen sind bei Oracle als eine einspaltige, ungeordnete Menge Elementen von Datenelementen, die alle den gleichen Datentyp haben, implementiert.", "explanation": "NESTED TABLE \nMit der STORE-AS-Klausel k\u00f6nnen tabellenwertige Spalten beschrieben werden. F\u00fcr jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher inneren Tabelle die tabellenwertigen Spalten abgelegt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2331, "category": 9, "difficulty": 3, "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind Subklassen der Gesch\u00e4ftspartner. \nWelche (Objekt-)Tabellen werden ben\u00f6tigt, wenn man diesen Sachverhalt gem\u00e4\u00df der virtuellen Fragmentierung implementieren m\u00f6chte?", "explanation": "Es gibt drei Fragmentierungstypen:  \n\nhorizontalen Fragmentierung \nBei der horizontalen Form werden f\u00fcr jeden Subtyp eine Tabelle angelegt, aber nicht f\u00fcr den Supertypen, geht also nur, wenn die Subtypen vollst\u00e4ndig sind. Die Subtypen-Tabellen verf\u00fcgen neben den eigenen Attributen zudem \u00fcber die Attribute des Supertypen. \n\nvertikale Fragmentierung: \nBei der vertikalen Form werden f\u00fcr jeden Subtyp eine Tabelle angelegt und auch f\u00fcr den Supertypen, geht also, wenn die Subtypen unvollst\u00e4ndig sind. Subtypen- und Supertyp-Tabellen verf\u00fcgen jeweils \u00fcber ihre eigenen Attribute.\n\nvirtuelle Fragmentierung:  \nBei der virtuellen Form wird nur eine Tabelle mit den Attributen aller Super- und Subtyen angelegt. Um unterscheiden zu k\u00f6nnen, welcher Datensatz nun zu welchem Subtypen geh\u00f6rt, werden entweder subtypenspezifische Attribute abgefragt oder eine zus\u00e4tzliche sog. Diskriminatorspalte angelegt, die f\u00fcr jeden Subtpyen einen spezifischen Wert annimmt.", "type": "multiple-choice", "answers": [{"text": "Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen sowie alle kunden- und lieferantenspezifischen Attribute und einem Kennzeichenattribut, welches die Partnerart spezifiziert", "solution": "true"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den kundenspezifischen", "solution": "false"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den lieferantenspezifischen", "solution": "false"}, {"text": "Kunden, nur mit den kundenspezifischen Attributen", "solution": "false"}, {"text": "Lieferanten, nur mit den lieferantenspezifischen Attributen", "solution": "false"}]}, {"id": 2544, "category": 9, "difficulty": 3, "text": "Welche Operatoren gibt es im objektrelationalen SQL/ORACLE-Dialekt?", "explanation": "Eine geschachtelte Tabelle wird mit dem Operator TABLE flachgeklopft und auf eine relationale Tabelle abgebildet.Au\u00dferdem gibt es den Typkonstruktor TABLE, der einem nicht beschr\u00e4nkten Vektor entspricht. \n\nVALUE wird wie im relationalen SQL einmal in einem INSERT-Befehlt verwendet und zum anderen gibt der VALUE-Operator das Objekt als solches in einer REF-Beziehung zur\u00fcck.\n\nARRAY und REF sind objektrelationale Datentypen, aber keine Operatoren. \n\nCURSOR ist zum einen ein PL/SQL-Konzept zum Ausf\u00fchren von SELECT-Anweisungen, das es erlaubt, eine Ergebnismenge Datensatz f\u00fcr Datensatz abzuarbeiten.  \nAls objektrelationaler Operator erzeugt der CURSOR-Operator eine Unterabfrage an die geschachtelte Tabelle.", "type": "multiple-choice", "answers": [{"text": "VALUE", "solution": "true"}, {"text": "REF", "solution": "true"}, {"text": "ARRAY", "solution": "false"}, {"text": "TABLE", "solution": "true"}, {"text": "CURSOR", "solution": "true"}]}, {"id": 2558, "category": 8, "difficulty": 2, "text": "Wie viele Tupel hat die Ergebnismenge des Natural Joins von zwei Relationen, die 18 bzw. 20 Tupel beinhalten, wobei es f\u00fcr 14 Tupel der einen Relation Tupel der anderen Relation gibt, die in einem gleichhei\u00dfenden Attribut die gleichen Werte aufweisen?", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. Diese Bedingung trifft f\u00fcr 14 Tupel zu.", "type": "text", "answers": [{"text": "Der Natural Join hat ... Tupel.", "solution": "14"}]}, {"id": 2156, "category": 9, "difficulty": 3, "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nWelche der folgenden Anfragen liefern das gleiche Ergebnis?", "explanation": "Das gleiche Ergebnis liefern: \n\nSELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);\n\nSELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN  (SELECT b.TNr FROM Auftragspositionen b \n         WHERE a.TNr = b.TNr);\n\nDie Semantik dieser Anfragen ist: \"Welche Artikel wurden verkauft?\"\n\nEine ganz andere Semantik hat:  \nSELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;\nSemantik: \"F\u00fcr welche Auftraege gibt es auch verkaufte Artikel?\"\n\n\nSELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT b.TNR FROM Auftragspositionen b);\nDiese Anfrage h\u00e4tte eine richtige Semantik, wenn die Anfrage korreliert w\u00e4re, d.h. es g\u00e4be eine Bedingung bei der unteren Anfrage, die die obere und die untere Anfrage in Beziehung setzt: \"WHERE b.tnr=a.trn\". Ohne diese Korrelation liefert diese Anfrage immer alle Artikel, sobald in der Auftragspositionen-Tabelle wenigstens ein Datensatz gespeichert ist - unabh\u00e4ngig davon, ob die TNR \u00fcbereinstimmen.", "type": "multiple-choice", "answers": [{"text": "SELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;", "solution": "true"}, {"text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);", "solution": "true"}, {"text": "SELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT b.TNR FROM Auftragspositionen b);", "solution": "false"}, {"text": "SELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;", "solution": "true"}, {"text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN  (SELECT b.TNr FROM Auftragspositionen b \n         WHERE a.TNr = b.TNr);", "solution": "true"}, {"text": "SELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;", "solution": "false"}]}, {"id": 2557, "category": 8, "difficulty": 2, "text": "Wie viele Attribute hat die Ergebnismenge des Natural Joins von zwei Relationen, die \u00fcber 15 bzw. 25 Attribute verf\u00fcgen, wobei es in der einen Relation drei Attribute gibt, die gleich hei\u00dfen wie in der anderen?", "explanation": "Die Struktur der Ergebnismenge des Natural Joins verf\u00fcgt \u00fcber alle Attribute aus beiden beteiligten Relationen, wobei die doppelten Attribute nur einmal vertreten sind: 15+25-3= 37 Attribute.", "type": "text", "answers": [{"text": "Der Natural Join hat ... Attribute.", "solution": "37"}]}, {"id": 2559, "category": 8, "difficulty": 1, "text": "Welche Operatoren der Relationalen Algebra sind un\u00e4r?", "explanation": "Un\u00e4r:  F1 : Rn --> Rm      mit n , m \u2208 Nbin\u00e4r: F2 : Rn \u00d7 Rm --> Rk mit n , m , k \u2208 N un\u00e4re Operatoren: Selektion, Projektion\nBin\u00e4re Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "true"}, {"text": "Division", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "false"}, {"text": "Join-Operatoren (Theta, Equi, Natural, Left Outer, Right Outer, Outer)", "solution": "false"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Differenz", "solution": "false"}, {"text": "Durchschnitt", "solution": "false"}]}, {"id": 2570, "category": 8, "difficulty": 1, "text": "Der Left Outer Join ist kommutativ.", "explanation": "Der linke Outer-Join (linker \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit\naufgef\u00fchrt und in den Attributen, die zu R2 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden. \nDie rechten und linken Outer-Joins sind nicht kommutativ, da entweder nur die rechte oder nur die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden. \nDer Full-Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ist jedoch kommutativ, da bei ihn sowohl die rechte als aich die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2572, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den rechten Outer-Join der folgenden beiden Relationen \u00fcber R1.S1 = R2.S3!\n\nR1: </br\nS1  S2    \nA    W \nC    Y </br\n\nR2: </br\nS3  S4 \nC    Y \nD    Z", "explanation": "Der rechte Outer-Join (rechter \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R1 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z", "solution": "true"}]}, {"id": 2580, "category": 8, "difficulty": 2, "text": "Es sind die folgenden beiden Relationen R1, R2 gegeben:\n\n    R1: S1 S2 C Y A W\n\n    R2: S2 S3 S4 V C Y W D Z", "explanation": "Seien zwei Relationen R1(A1,...,An) und R2(B1,...,Bm) gegeben. Das kartesische Produkt ist die Menge aller Paare aus Tupeln der ersten Relation R1 verkn\u00fcpft mit Tupeln der zweiten Relation R2 unabh\u00e4ngig von irgenwelchen gleichen oder ungleichen Attributwerten f\u00fcr die einzelnen Attribute.", "type": "text", "answers": [{"text": "Welche Operation der Relationalen Algebra hat folgende Ergebnismenge? \n(deutschsprachige Bezeichnung, nur Kleinbuchstaben, W\u00f6rter durch ein Leerzeichen getrennt, keine Bindestriche etc.)\n\nS1 S2 S2 S3 S4\nC  Y  W  D  Z\nC  Y  V  C  Y\nA  W  W  D  Z\nA  W  V  C  Y", "solution": "kartesisches produkt"}]}, {"id": 2582, "category": 8, "difficulty": 1, "text": "Es sind die folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4 gegeben: \n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z\n\nDie folgende Menge ist das Ergebnis der Anwwendung des Natural Joins auf R1 und R2. \n\nS1 S2 S2 S3 S4\nA  W  W  D  Z", "explanation": "Diese Ergebnismenge passt nicht, weil die Projektion auf nur eines der doppelten Attribute S2 fehlt. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 2315, "category": 9, "difficulty": 3, "text": "In welchem/n Befehl/en k\u00f6nnen beim Oracle-ORDBS Constraints definiert werden?", "explanation": "Constraints k\u00f6nnen nicht in der TYP-Deklaration angelegt werden.", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPLACE TYPE <typname> ;", "solution": "false"}, {"text": "CREATE TABLE <tabellenname> AS OBJECT ;", "solution": "true"}, {"text": "Constraints geh\u00f6ren zum relationalen Konzept und k\u00f6nnen f\u00fcr Objekte nicht definiert werden.", "solution": "false"}]}, {"id": 2316, "category": 9, "difficulty": 3, "text": "Beim ORDBS von Oracle gibt es folgende Hierarchien:", "explanation": "Tabellenhierachien gibt es in Standard-SQL, aber nicht unter Oracle.", "type": "multiple-choice", "answers": [{"text": "Typhierarchien", "solution": "true"}, {"text": "Tabellenhierarchien", "solution": "false"}, {"text": "Sichthierarchien", "solution": "true"}]}, {"id": 2317, "category": 9, "difficulty": 2, "text": "Was erbt beim Oracle-DBS wie auch bei OR-SQL ein Subtyp von seinem Supertypen?", "explanation": "Ein Typ beinhaltet keine CONSTRAINTS und die M\u00f6glichkeit, Typenhierarchien zu bilden, ist sowohl bei Oracle als auch im Standard von SQL vorgesehen.", "type": "multiple-choice", "answers": [{"text": "Attribute", "solution": "true"}, {"text": "Constraints", "solution": "false"}, {"text": "Methoden", "solution": "true"}, {"text": "Gar nichts, da keine Typhierarchien gebildet werden k\u00f6nnen.", "solution": "false"}]}, {"id": 2318, "category": 9, "difficulty": 3, "text": "Was erbt beim Oracle-DBS wie auch bei OR-SQL eine Subtabelle von seiner Supertabelle?", "explanation": "Die Vererbung erfolgt \u00fcber den zugeh\u00f6rigen Typ, nicht die Tabelle.", "type": "multiple-choice", "answers": [{"text": "Attribute", "solution": "false"}, {"text": "Constraints", "solution": "false"}, {"text": "Methoden", "solution": "false"}, {"text": "Gar nichts, da keine Tabellenhierarchien gebildet werden k\u00f6nnen", "solution": "true"}]}, {"id": 2319, "category": 9, "difficulty": 2, "text": "Welche Arten von Vererbung gibt es bei Oracle und bei OR-SQL?", "explanation": "In beiden F\u00e4llen ist nur die Einfachvererbung vorgesehen.", "type": "multiple-choice", "answers": [{"text": "Mehrfachvererbung", "solution": "false"}, {"text": "Einfachvererbung", "solution": "true"}, {"text": "kKeine Vererbung", "solution": "false"}]}, {"id": 2320, "category": 9, "difficulty": 1, "text": "Mehrfachvererbung hei\u00dft, dass ein Subtyp von mehreren Supertypen erbt.", "explanation": "Das ist die Definition der Mehrfachvererbung :-).", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht.", "solution": "false"}]}, {"id": 2321, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft bei Oracle die Klausel, mit der man einen potentiellen Supertypen spezifiziert? Wenn es eine solche Klausel nicht gibt, schreiben Sie,  \"gibt es nicht\"", "explanation": "[NOT] FINAL:\n\n    NOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt \u00fcber die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n\n    [NOT] OVERRIDING:\n\n    Damit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n\n    [NOT] INSTANTIABLE:\n\n    \u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "text", "answers": [{"text": "Sie hei\u00dft:", "solution": "NOT FINAL"}]}, {"id": 2322, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft bei Oracle die Klausel, mit der man eine ererbte Methode redefiniert? Wenn es eine solche Klausel nicht gibt, schreiben Sie \"gibt es nicht\".", "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt \u00fcber die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "text", "answers": [{"text": "Sie hei\u00dft:", "solution": "OVERRIDING"}]}, {"id": 2323, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft bei Oracle die Klausel, mit der man einen Typen oder eine Methode als nicht instanzierbar spezifiziert? Wenn es eine solche Klausel nicht gibt, schreiben Sie \"gibt es nicht\"", "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, f\u00fcr die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt \u00fcber die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden k\u00f6nnen. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.", "type": "text", "answers": [{"text": "Sie hei\u00dft:", "solution": "NOT INSTANTIABLE"}]}, {"id": 2324, "category": 9, "difficulty": 3, "text": "Was wird beim Oracle-DBS f\u00fcr einen neuen Typen automatisch nicht erzeugt, wenn dieser Typ als nicht instanzierbar spezifiziert ist?(deutscher Begriff)", "explanation": "Der Konstruktor dienst zum Anlegen von Instanzen eines instanzierbaren strukturierten Datentyps.", "type": "text", "answers": [{"text": ".", "solution": "Konstruktor"}]}, {"id": 2325, "category": 9, "difficulty": 2, "text": "Welche/r Befehl/e sind beim Oracle-DBS syntaktisch richtig und erzeugen einen Subtyp?", "explanation": "Die Klausel zur Vererbung eines Typs hei\u00dft nicht SUPTYP sondern UNDER.", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPLACE TYPE <subtypname> AS SUBTYP OF <supertypname> ;", "solution": "false"}, {"text": "CREATE OR REPLACE TYPE <subtypname> OF SUPERTYP <supertypname> ;", "solution": "false"}, {"text": "CREATE OR REPLACE TYPE <subtypname> UNDER <supertypname> ;", "solution": "true"}]}, {"id": 2327, "category": 9, "difficulty": 3, "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind vollst\u00e4ndig und disjunkte Subklassen der Gesch\u00e4ftspartner. \nWelche Objekttabellen werden ben\u00f6tigt, wenn man diesen Sachverhalt abbilden will?", "explanation": "vollst\u00e4ndig und disjunkte Kunden und Lieferanten  \nwerden abgebildet auf folgende Objekttabellen: \n- Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den kundenspezifischen \n- Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den lieferantenspezifischen\n\nVollst\u00e4ndig hei\u00dft, dass es nur Kunden und Lieferanten gibt, es m\u00fcssen also keine sonstigen Gesch\u00e4ftspartner gespeichert werden, so dass keine Gesch\u00e4ftspartnertabelle notwendig ist. \nDisjunkt hei\u00dft, dass kein Gesch\u00e4ftspartner sowohl Lieferant als auch Kunde sein kann. Um dies zu gew\u00e4hrleisten m\u00fcssten Trigger programmiert werden, die gleiche Daten bei Lieferanten und Kunden kontrollieren und verhindern.", "type": "multiple-choice", "answers": [{"text": "Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den kundenspezifischen", "solution": "true"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den lieferantenspezifischen", "solution": "true"}, {"text": "Kunden, nur mit den kundenspezifischen Attributen", "solution": "false"}, {"text": "Lieferanten, nur mit den lieferantenspezifischen Attributen", "solution": "false"}]}, {"id": 2328, "category": 9, "difficulty": 3, "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind unvollst\u00e4ndig und disjunkte Subklassen der Gesch\u00e4ftspartner. \n\nWelche Objekttabellen werden ben\u00f6tigt, wenn man diesen Sachverhalt abbilden will?", "explanation": "unvollst\u00e4ndig und disjunkte Kunden und Lieferanten \nwerden abgebildet auf folgende Objekttabellen: \n- Kunden, nur mit den kundenspezifischen Attributen \n- Lieferanten, nur mit den lieferantenspezifischen Attributen\n- Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen\n\nUnvollst\u00e4ndig  hei\u00dft, dass es neben Kunden und Lieferanten auch noch sonstigen Gesch\u00e4ftspartner gibt und die werden in nur in der Gesch\u00e4ftspartner-Tabelle gespeichert. Kunden- und Lieferanten-Datens\u00e4tze werden entsprechend in zwei Tabellen gespeichert, der Gesch\u00e4ftspartner- und in der Kunden- bzw. Lieferanten-Tabelle. \nDisjunkt hei\u00dft, dass kein Gesch\u00e4ftspartner sowohl Lieferant als auch Kunde sein kann. Um dies zu gew\u00e4hrleisten m\u00fcssten Trigger programmiert werden, die gleiche Daten bei Lieferanten und Kunden kontrollieren und verhindern.", "type": "multiple-choice", "answers": [{"text": "Gesch\u00e4ftspartner, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "true"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen", "solution": "false"}, {"text": "Kunden, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den kundenspezifischen", "solution": "false"}, {"text": "Lieferanten, mit den Attributen, die alle Gesch\u00e4ftspartner betreffen und den lieferantenspezifischen", "solution": "false"}, {"text": "Kunden, nur mit den kundenspezifischen Attributen", "solution": "true"}, {"text": "Lieferanten, nur mit den lieferantenspezifischen Attributen", "solution": "true"}]}, {"id": 2072, "category": 9, "difficulty": 1, "text": "Welcher JOIN-Tabellen-Typ hat eine USING-Klausel?", "explanation": "Beim CROSS JOIN, dem kartesischen Produkt, gibt es gar keine Verkn\u00fcpfungsspalten. Jeder Datensatz der einen Relation wird \"grundlos\" mit jedem anderen aus der anderen Relation verkn\u00fcpft.\nBeim NATURAL JOIN gibt es zwar eine Bedingung, aber die ist vordefiniert, so dass keine Spalten mittels ON spezifiziert werden m\u00fcssen. Die vordefinierte Bedingung hei\u00dft: Alle Spalten mit gleichen Namen werden auf Gleichheit verglichen und die Teilbedingungen ggf. mit AND verkn\u00fcpft.\nLediglich beim THETA JOIN k\u00f6nnen Spalten f\u00fcr die JOIN-Bedingung angegeben werden.", "type": "multiple-choice", "answers": [{"text": "CROSS-Join", "solution": "false"}, {"text": "THETA-Join", "solution": "true"}, {"text": "NATURAL-Join", "solution": "false"}]}, {"id": 2126, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?", "explanation": "Ja, die CREATE-Anweisung ist syntaktisch korrekt.\n\n    \n\n    Ja, die Angestellten-Vorgesetzten-Beziehung wird hier semantisch korrekt abgebildet, weil der Fremdschl\u00fcssel der Vorgesetzten-Spalte auf den Prim\u00e4rschl\u00fcssel des Angestellten zeigt, der sein Vorgesetzter ist.\n\n    \n\n    z.B.: Emil hat den Vorgesetzten Hugo:\n\n    Angestellter Vorgesetzter\n\n    (\"Hugo\",\"Anton\"),\n\n    (\"Emil\",\"Hugo\"),\n\n    \n\n    Der 1. Datensatz ist der Mitarbeiter-Datensatz von Hugo und der 2. der von Emil. Der Fremdschl\u00fcssel des Emil-Datensatzes verweist auf den Mitarbeiter Hugo, der sein Vorgesetzter ist.", "type": "multiple-choice", "answers": [{"text": "Dieser SQL-Befehl ist syntaktisch nicht korrekt.", "solution": "false"}, {"text": "Dieser SQL-Befehl ist syntaktisch korrekt.", "solution": "true"}, {"text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch nicht korrekt ab.", "solution": "false"}, {"text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch korrekt ab.", "solution": "true"}]}, {"id": 2127, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl: \n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL, Vorgesetzter VARCHAR2(20) NOT NULL, PRIMARY KEY (Angestellter), FOREIGN KEY (Angestellter) REFERENCES Hierarchie (Vorgesetzter) ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?", "explanation": "Nein, die CREATE-Anweisung ist syntaktisch  nicht korrekt, weil eine Spalte referenziert wird, die gar keine Schl\u00fcsselspalte ist. Die Fremdschl\u00fcsselbeziehung kann nur funktionieren, wenn die referenzierte Spalte der Master-Tabelle, hier Vorgesetzter, auch eindeutig ist. F\u00fcr den Vorgesetzten fehlt jedoch ein PRIMARY KEY- oder UNIQUE-Constraint.\n\n    \n\n    Nein, die Angestellten-Vorgesetzten-Beziehung wird hier nicht semantisch korrekt abgebildet, weil der Fremdschl\u00fcssel von der Angestellten-Spalte auf die Vorgesetzten-Spalte referenziert, dort k\u00f6nnen Werte mehrfach auftreten, so dass eine eindeutige Referenz nicht gegeben ist. z.B.\n\n    \n\n    Angestellter Vorgesetzter\n\n    (\"Hugo\",\"Anton\"),\n\n    (\"Emil\",\"Hugo\"),\n\n    (\"Erna\",\"Hugo\")\n\n    \n\n    Emil und Erna haben beide den Vorgesetzten Hugo. Hier tritt jedoch ein Konflikt ein, weil der Fremdschl\u00fcssel immer den Master-Datensatz referenziert und der muss eindeutig sein. Hier w\u00fcrde vom 1. Datensatz mit dem Wert \"Hugo\" auf sowohl den 2. wie auch den 3. referenziert werden - so etwas geht nicht!", "type": "multiple-choice", "answers": [{"text": "Dieser SQL-Befehl ist syntaktisch nicht korrekt.", "solution": "true"}, {"text": "Dieser SQL-Befehl ist syntaktisch korrekt.", "solution": "false"}, {"text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch nicht korrekt ab.", "solution": "true"}, {"text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch korrekt ab.", "solution": "false"}]}, {"id": 2128, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN ORDER BY Nachname ASC\"", "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel.", "type": "multiple-choice", "answers": [{"text": "bewirkt eine Gruppierung", "solution": "false"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "true"}]}, {"id": 2136, "category": 9, "difficulty": 2, "text": "Welcher Operator der Relationalen Algebra verbirgt sich hinter der ORDER BY-Klausel einer SQL-Anfrage?", "explanation": "Order By ist in der Relationalen Algebra nicht vorgesehen, da Relationen als ungegeordnete Mengen vereinbart sind.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Sortierung", "solution": "false"}, {"text": "keiner der RA-Operatoren", "solution": "true"}]}, {"id": 2469, "category": 5, "difficulty": 2, "text": "Folgende Aussagen \u00fcber Subtypen sind wahr:", "explanation": "Bei Subtypen werden identifizierende Beziehungen verwendet, da Supertyp und Subtyp den gleichen  Prim\u00e4rschl\u00fcssel haben", "type": "multiple-choice", "answers": [{"text": "Identifizierende Beziehungen k\u00f6nnen verwendet werden.", "solution": "true"}, {"text": "Nicht-identifizierende Beziehungen k\u00f6nnen verwendet werden.", "solution": "false"}, {"text": "Identifizierende und nicht-identifizierende Beziehungen k\u00f6nnen verwendet werden.", "solution": "false"}, {"text": "Es gibt Entity-Mengen, die aufgrund von 1:n-Beziehungen Fremdschl\u00fcssel besitzen, die aus mehreren Spalten bestehen.", "solution": "false"}]}, {"id": 2501, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Unterabfragen sind wahr?", "explanation": "Korreliert bedeutet, dass die Spalten der \u00e4u\u00dferen Anweisung mit der innneren SELECT-Anweisung durch eine WHERE-Klausel verkn\u00fcpft werden.", "type": "multiple-choice", "answers": [{"text": "Unterabfragen, die mit einem Vergleichsoperator (=,<,>,) aber ohne ANY oder ALL, d\u00fcrfen nur maximal einen Ergebnisdatensatz liefern.", "solution": "true"}, {"text": "Unterabfragen mit einem IN-Operator sind aufgrund der Syntax immer korrelierte Unterabfragen.", "solution": "false"}, {"text": "Unterabfragen k\u00f6nnen in der WHERE-Klausel wie auch der FROM-Klausel auftreten.", "solution": "true"}]}, {"id": 2370, "category": 42, "difficulty": 1, "text": "Berechnen Sie die HASH-Funktion 23 modulo 7!", "explanation": "Die Modul-Funktion ist das Teilen mit Rest, also hier der Rest der beim Teilen von 23 durch 7 entsteht: Das ist 2.", "type": "text", "answers": [{"text": "Das Ergebnis ist", "solution": "2"}]}, {"id": 2380, "category": 9, "difficulty": 3, "text": "Es sei folgende Typdefinition gegeben: \nCREATE OR REPLACE TYPE kd_typ AS OBJECT \n   (kd_id NUMBER, name VARCHAR2(100), adresse VARCHAR2(200));\n\nWelche/r Befehl/e erzeugen bei Oracle eine Objekttabelle?", "explanation": "Bei OBJECT IDENTIFIER IS PRIMARY KEY  muss der Primary KEY auch als CONSTRAINT der Spalte angegeben werde. \n\nOBJECT IDENTIFIER IS SYSTEM  ist auch ohne  GENERATED UNIQUE;  eindeutig.", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE kunden_ot OF kd_typ (kd_id PRIMARY KEY) \n   OBJECT IDENTIFIER IS PRIMARY KEY;", "solution": "true"}, {"text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS PRIMARY KEY (kd_id);", "solution": "false"}, {"text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS SYSTEM GENERATED (kd_id);", "solution": "false"}, {"text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS SYSTEM GENERATED;", "solution": "true"}, {"text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS SYSTEM GENERATED UNIQUE;", "solution": "false"}, {"text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS USER GIVEN (kd_oid);", "solution": "false"}, {"text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS USER GIVEN INTO kd_oid;", "solution": "false"}, {"text": "Keiner der Befehle ist richtig.", "solution": "false"}]}, {"id": 2395, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema mittels Universalrelation. Welche Art der Fragmentierung ist das?", "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp geh\u00f6ren, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch. \nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enth\u00e4lt alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschl\u00fcssel mit dem Supertyp verbunden und haben den gleichen Prim\u00e4rschl\u00fcssel wie der Supertyp. Au\u00dferdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.\nBegriffe wie diagonale, abgeleitete, faktische Fragmentierung gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "virtuelle Fragmentierung", "solution": "true"}, {"text": "vertikale Fragmentierung", "solution": "false"}, {"text": "horizontale Fragmentierung", "solution": "false"}, {"text": "faktische Fragmentierung", "solution": "false"}, {"text": "abgeleitete Fragmentierung", "solution": "false"}, {"text": "diagonale Fragmentierung", "solution": "false"}]}, {"id": 2396, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema. Dabei wird nur f\u00fcr jeden Subtypen eine Relation erstellt. Welche Art der Fragmentierung ist das?", "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp geh\u00f6ren, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch.\n\nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enth\u00e4lt alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschl\u00fcssel mit dem Supertyp verbunden und haben den gleichen Prim\u00e4rschl\u00fcssel wie der Supertyp. Au\u00dferdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\n\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.\n\nBegriffe wie diagonale, abgeleitete, faktische Fragmentierung gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "virtuelle Fragmentierung", "solution": "false"}, {"text": "vertikale Fragmentierung", "solution": "false"}, {"text": "horizontale Fragmentierung", "solution": "true"}, {"text": "faktische Fragmentierung", "solution": "false"}, {"text": "abgeleitete Fragmentierung", "solution": "false"}, {"text": "diagonale Fragmentierung", "solution": "false"}]}, {"id": 2397, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema. Dabei wird f\u00fcr jeden Subtypen und f\u00fcr den Supertypen eine Relation erzeugt. Welche Art der Fragmentierung ist das?", "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp geh\u00f6ren, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch. \nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enth\u00e4lt alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschl\u00fcssel mit dem Supertyp verbunden und haben den gleichen Prim\u00e4rschl\u00fcssel wie der Supertyp. Au\u00dferdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.\nBegriffe wie diagonale, abgeleitete, faktische Fragmentierung gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "virtuelle Fragmentierung", "solution": "false"}, {"text": "vertikale Fragmentierung", "solution": "true"}, {"text": "horizontale Fragmentierung", "solution": "false"}, {"text": "faktische Fragmentierung", "solution": "false"}, {"text": "abgeleitete Fragmentierung", "solution": "false"}, {"text": "diagonale Fragmentierung", "solution": "false"}]}, {"id": 2399, "category": 9, "difficulty": 2, "text": "Welche Eigenschaften hat eine objektrelationale Tabelle?", "explanation": "Welche Tabellenformen kann es in einem ORDBMS geben?\n\nDefinitionsart: untypisiert vs. typisiert \n- Untypisiert: die Struktur ergibt sich direkt aus den Attributstrukturen (RM)\n- Typisiert: Tabellendefinition basiert auf benutzerdefinierten Typ (OR)\n\nZeilentyp: tupelwertig vs. objektwertig \n- Tupelwertig: keine Methodenaufrufe f\u00fcr ein konkretes Tupel (RM)\n- Objektwertig: Methodenaufrufe des zugeh\u00f6rigen Objekttyps direkt \u00fcber die Zeilenvariable (OR)\n\nReferenzierbarkeit: nicht referenzierbar vs. referenzierbar  \n- Nicht referenzierbar: Zeilen sind nicht referenzierbar (RM)\n- Referenzierbar: Zeilen sind mittels Referenzspalten (OIDs) referenzierbar; setzt OIDs voraus (OR)\n\n\nRelationale Tabellen sind: \n- tupelwertig, \n- untypisiert, \n- nicht referenzierbar\n\nObjektorientierte/objektrelationale Klassen/Tabellen sind: \n- objektwertig, \n- typisiert, \n- referenzierbar", "type": "multiple-choice", "answers": [{"text": "Typisiert", "solution": "true"}, {"text": "Untypisiert", "solution": "false"}, {"text": "Tupelwertig", "solution": "false"}, {"text": "Objektwertig", "solution": "true"}, {"text": "Referenzierbar", "solution": "true"}, {"text": "Nicht referenzierbar", "solution": "false"}]}, {"id": 2400, "category": 9, "difficulty": 3, "text": "Das Problem der Stabilit\u00e4t der OID tritt auf bei:", "explanation": "RICHTIG ist, dass das Problem der OID-Stabilit\u00e4t bei objektgenerierenden Objektsichten aufritt.\n\n     \n\n    Welche unterschiedlichen Sichten gibt es im OR-Kontext?\n\n    Relational: Tupelsichten\n\n    \n        Tupelsicht \u00fcber beliebige Tabellen und Sichten\n    \n        Zeilen stellen Tupel dar\n\n\n    Objektrelational: Typisierte Sichten\n\n    \n        Basiert auf einem Strukturdatentyp\n    \n        Mittel der Zugriffskontrolle;\n    \n        erm\u00f6glicht logische Datenunabh\u00e4ngigkeit\n    \n        Objektgenerierend:\n    \n        Typisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\n    \n        OID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\n    \n        Objektrelationale Darstellung relationaler Daten\n    \n        Objekterhaltend:\n    \n        Typisierte Sicht, deren Zeilen bestehende Objekte darstellen\n    \n        Verallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich\n    \n        Bessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen\n    \n        FROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\n    \n        Kann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "Relationalen Tabellen", "solution": "false"}, {"text": "Objektrelationalen Tabellen", "solution": "false"}, {"text": "Relationalen Sichten", "solution": "false"}, {"text": "Objektgenerierenden objektrelationalen Sichten", "solution": "true"}, {"text": "Objekterhaltenden objektrelationalen Sichten", "solution": "false"}, {"text": "Das Problem gibt es nicht.", "solution": "false"}]}, {"id": 2456, "category": 5, "difficulty": 3, "text": "Wie hei\u00dft die Eigenschaft einer Subtypen-Beziehung, wenn es Tupel geben soll, die nur der Super-Entity-Menge angeh\u00f6ren? Wenn es diese Eigenschaft nicht gibt, schreiben Sie \"gibt es nicht\".", "explanation": "Das ist die  Definition eines nicht vollst\u00e4ndigen Systems.", "type": "text", "answers": [{"text": "Das ist:", "solution": "nicht vollst\u00e4ndig"}]}, {"id": 2345, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Indexe sind wahr?", "explanation": "\n    Die L\u00f6sung ergibt sich aus der Definition eines Index.", "type": "multiple-choice", "answers": [{"text": "Ein Index ist eine separate Speicherstruktur, die zus\u00e4tzlich zur Tabelle angelegt wird.", "solution": "true"}, {"text": "F\u00fcr eine Tabelle kann nur ein Index angelegt werden.", "solution": "false"}, {"text": "Einf\u00fcgen und L\u00f6schen von Datens\u00e4tzen sind aufw\u00e4ndiger, als bei Tabellen ohne Index.", "solution": "true"}, {"text": "Indexe beschleunigen die Suche von Datens\u00e4tzen, weil bei ihnen in der Regel mit jedem lesen-dem Zugriff auf einen physischen Block mehr Suchinformationen in den Hauptspeicher geladen wird.", "solution": "true"}, {"text": "Indexe beschleunigen die Suche von Datens\u00e4tzen, weil sie sortiert werden k\u00f6nnen und damit optimierte Suchalgorithmen ausgef\u00fchrt werden k\u00f6nnen.", "solution": "true"}, {"text": "Indexe haben den Vorteil, dass man f\u00fcr eine Tabelle mehrere anlegen kann und damit nach verschiedenen Spalten optimiert suchen kann.", "solution": "true"}]}, {"id": 2393, "category": 9, "difficulty": 3, "text": "Zu dem Problem der Stabilit\u00e4t der OID l\u00e4sst sich folgendes sagen:", "explanation": "Welche unterschiedlichen Sichten gibt es im OR-Kontext?\n  \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht \u00fcber beliebige Tabellen und Sichten \nZeilen stellen Tupel dar \n \n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp \nMittel der Zugriffskontrolle;  \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit \nObjektgenerierend:  \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen \nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet \nObjektrelationale Darstellung relationaler Daten \nObjekterhaltend: \nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen \nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich \nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen  \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "Es tritt bei objekterhaltenden objektrelationalen Sichten auf.", "solution": "false"}, {"text": "F\u00fcr solche Sichten gibt es bei Oracle die M\u00f6glichkeit, benutzerdefinierte OIDs zu definieren.", "solution": "true"}, {"text": "F\u00fcr solche Sichten gibt es bei Oracle die M\u00f6glichkeit, abgeleitete OIDs zu definieren.", "solution": "true"}, {"text": "F\u00fcr solche Sichten gibt es bei Oracle die M\u00f6glichkeit, systemgenerierte OIDs zu definieren.", "solution": "false"}, {"text": "Das Problem gibt es nicht.", "solution": "false"}]}, {"id": 2449, "category": 7, "difficulty": 2, "text": "Welche der folgenden Aussagen \u00fcber Normalformen sind wahr?", "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.", "type": "multiple-choice", "answers": [{"text": "Eine Relation in der 1NF kann Wiederholungsgruppen haben.", "solution": "false"}, {"text": "keine von beiden", "solution": "false"}, {"text": "Eine Relation in der 1NF kann keine Wiederholungsgruppen haben.", "solution": "true"}]}, {"id": 2453, "category": 5, "difficulty": 2, "text": "Wenn Sie im gesamten ERM ausschlie\u00dflich Surrogate Keys als Prim\u00e4rschl\u00fcssel verwenden, sind folgende Aussagen richtig:", "explanation": "Bei Surrogate-Keys werden ausschlie\u00dflich nicht-identifizierende 1:n-Beziehungen benutzt, um zusammengesetzte Schl\u00fcssel zu vermeiden.", "type": "multiple-choice", "answers": [{"text": "Identifizierende Beziehungen k\u00f6nnen in 1:n-Beziehungen nicht verwendet werden.", "solution": "true"}, {"text": "Nicht-identifizierende Beziehungen k\u00f6nnen verwendet werden.", "solution": "true"}, {"text": "Identifizierende und nicht-identifizierende Beziehungen k\u00f6nnen verwendet werden.", "solution": "false"}, {"text": "Es gibt Entity-Mengen, die aufgrund von 1:n-Beziehungen Fremdschl\u00fcssel besitzen, die aus mehreren Spalten bestehen.", "solution": "false"}]}, {"id": 2455, "category": 7, "difficulty": 3, "text": "Auf welche Art/en k\u00f6nnen Sub- und Super-Entity-Mengen eines EERM f\u00fcr die Implementierung fragmentiert werden? Wenn es so etwas nicht gibt, schreiben Sie keine, ansonsten die Typen in alphabetischer Reihenfolge und durch Kommas getrennt!", "explanation": "Zu solch einem System eines Supertyps mit verschiedenen Subtypen wird als Erstes eine Universaltabelle gebildet. Die Universaltabelle besteht aus allen Attributen der beteiligten Entity-Mengen.\n\n\n\nBei der virtuellen Fragmentierung wird die Universaltabelle nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben.\n\n\n\nBei der vertikalen Fragmentierung wird die Universaltabelle auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enth\u00e4lt alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschl\u00fcssel mit dem Supertyp verbunden und haben den gleichen Prim\u00e4rschl\u00fcssel wie der Supertyp. Au\u00dferdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\n\n\n\nBei dieser Art der Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.", "type": "text", "answers": [{"text": "Das sind:", "solution": "horizontal, vertikal, virtuell"}]}, {"id": 2457, "category": 9, "difficulty": 1, "text": "Das SQL-Daten-Modell kann wie folgt definiert werden: SET ( ROW ( Basisdatentyp ) ) .", "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2458, "category": 9, "difficulty": 3, "text": "Ein Index", "explanation": "F\u00fcr einen Prim\u00e4rschl\u00fcssel wird automatisch ein Index erstellt vom DBMS, weil man davon ausgeht, dass \u00fcber diese Prim\u00e4rschl\u00fcsselspalten sehr h\u00e4ufig zugreift und dann soll es m\u00f6glichst schnell gehen. \nEin Index ist kein Werkzeug der Integrit\u00e4tspr\u00fcfung sondern ein Mittel des Tunings. Seine Aufgabe ist es, Anfragen (SELECT) zu beschleunigen, mit dem kleinen Nachteil, dass Einf\u00fcgungen, \u00c4nderungen und L\u00f6schungen (INSERT, UPDATE, DELETE) etwas langsamer werden. Neben der eigentlichen Datenmanipulation muss ja auch noch der Index aktualisiert werden.", "type": "multiple-choice", "answers": [{"text": "wird immer f\u00fcr Prim\u00e4rschl\u00fcssel erstellt.", "solution": "true"}, {"text": "beschleunigt das Einf\u00fcgen von Daten.", "solution": "false"}, {"text": "erleichtert die Integrit\u00e4tspr\u00fcfung.", "solution": "false"}, {"text": "besteht aus wenigstens zwei Spalten der zugeh\u00f6rigen Tabelle.", "solution": "false"}]}, {"id": 2459, "category": 9, "difficulty": 3, "text": "Erstellen Sie einen Nummerngenerator \"beliebig_seq\", der nur gerade positive Zahlen generiert.", "explanation": "CREATE SEQUENCE beliebig_seq INCREMENT BY 2 START WITH 2; \nDer Z\u00e4hler startet mit 2 und es wird jeweils zwei hochgez\u00e4hlt. Damit generiert die Sequenz nur gerade Zahlen: 2,4,6,8,...", "type": "text", "answers": [{"text": "Der Befehl lautet inclusive Semikolon am Ende:", "solution": "CREATE SEQUENCE beliebig_seq INCREMENT BY 2 START WITH 2;"}]}, {"id": 2460, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft der CONSTRAINT, wenn eine Spalte Pflichteingabespalte ist?", "explanation": "Das SQL-Constraint f\u00fcr die Pflichteingabe hei\u00dft NOT NULL und ist als einziges Constraint ausschlie\u00dflich als Spalten-Constraint definierbar und erzwingt f\u00fcr eine Spalte die Eingabe eines Wertes. Diese Spalte kann nicht leer sein (NULL).", "type": "text", "answers": [{"text": "Das ist:", "solution": "NOT NULL"}]}, {"id": 2461, "category": 9, "difficulty": 3, "text": "Welche SQL-Befehle l\u00f6sen eine Integrit\u00e4tspr\u00fcfung aus?", "explanation": "Ziel der Integrit\u00e4tspr\u00fcfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints gen\u00fcgen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erf\u00fcllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Pr\u00fcfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE l\u00f6sen also IMMEDIATE-Integrit\u00e4tspr\u00fcfung aus. \nCOMMIT beendet eine Transaktion und l\u00f6st damit eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie r\u00fcckg\u00e4ngig gemacht wird. Eine Integrit\u00e4tspr\u00fcfung ist daher unn\u00f6tig und wird nicht ausgef\u00fchrt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was daf\u00fcr sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integrit\u00e4tspr\u00fcfung ausl\u00f6sen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Pr\u00fcfung wird damit nicht ausgel\u00f6st.", "type": "multiple-choice", "answers": [{"text": "ROLLBACK", "solution": "false"}, {"text": "DELETE", "solution": "true"}, {"text": "SELECT", "solution": "false"}, {"text": "INSERT", "solution": "true"}, {"text": "CHECK", "solution": "false"}, {"text": "UPDATE", "solution": "true"}, {"text": "COMMIT", "solution": "true"}, {"text": "SAVE", "solution": "false"}, {"text": "ALTER", "solution": "true"}, {"text": "DROP", "solution": "true"}, {"text": "CREATE", "solution": "true"}]}, {"id": 2462, "category": 9, "difficulty": 3, "text": "Welche SQL-Constraints bieten die M\u00f6glichkeit zur Fehlerkorrektur?", "explanation": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird. Dieses Verhalten wird f\u00fcr Integrit\u00e4tsfehler ausschlie\u00dflich bei NOT NULL, PRIMARY KEY, UNIQUE ausgef\u00fchrt. \n\nLediglich die Fremdschl\u00fcssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabh\u00e4ngig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik,wenn Masterdatens\u00e4tze gel\u00f6scht werden, f\u00fcr die noch abh\u00e4ngige Detail-Datens\u00e4tze bestehen. Es besteht dann die M\u00f6glichkeit, z.B. die abh\u00e4ngigen Detaildatens\u00e4tze ebenfalls zu l\u00f6schen (CASCADE) oder deren Fremdschl\u00fcsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION", "type": "multiple-choice", "answers": [{"text": "CHECK (Bedingung)", "solution": "false"}, {"text": "PRIMARY KEY", "solution": "false"}, {"text": "FOREIGN KEY", "solution": "true"}, {"text": "NOT NULL", "solution": "false"}, {"text": "UNIQUE", "solution": "false"}]}, {"id": 2463, "category": 9, "difficulty": 3, "text": "Welche Constraints sind DEFERRED definierbar?", "explanation": "Alle f\u00fcnf SQL-Constraints NULL, CHECK, FOREIGN KEY, PRIMARY KEY, UNIQUE sind unabh\u00e4ngig davon, ob sie Spalten- oder Tabellen-Constraint sind, als DEFERRED definierbar. Der Pr\u00fcfungszeitpunkt \"DEFERRED\" (verz\u00f6gert) bezeichnet den Zeitpunkt zum Transaktionsende, also dann, wenn COMMIT eingegeben wird. \n\nAus dem Syntax-Diagramm wird dies ersichtlich, weil f\u00fcr jeden Spalten-/Tabellenbedingungsausdruck die <CONSTRAINT Chraketristika> gelten und hinter denen verbergen sich u.a. die Optionen DEFERRED und IMMEDIATE.", "type": "multiple-choice", "answers": [{"text": "NULL", "solution": "true"}, {"text": "Foreign Key", "solution": "true"}, {"text": "Primary Key", "solution": "true"}, {"text": "Unique", "solution": "true"}, {"text": "Check", "solution": "true"}]}, {"id": 1789, "category": 1, "difficulty": 2, "text": "ANSI-3-Ebenen-Modell: In einem Anwendungssystem werden neue Daten gespeichert oder bestehende gel\u00f6scht.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Keine Ebene ist betroffen.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "false"}]}, {"id": 1766, "category": 1, "difficulty": 1, "text": "Wann entstand das relationale Datenmodell?", "explanation": "Grundlagen des relationalen Datenmodells wurden vor allem mit den klassischen Arbeiten von E.F. Codd (1970 und 1972) gelegt. Daf\u00fcr wurde er 1999 mit dem Turing-Award ausgezeichnet. Das Entity-Relationship- Modell basiert auf einer Arbeit von P.P. Chen aus dem Jahre 1976. Die heute als B-B\u00e4ume relevanten Speicherstrukturen wurden von Bayer 1972 eingef\u00fchrt. Das Transaktionskonzept ist erstmals in Arbeiten zum System R3, einem Vorl\u00e4ufer von SQL (1976), beschrieben. Eine erste Analyse und systematische Darstellung von Transaktionen findet man in der Arbeit von Gray von 1981. Die 1970er Jahre kann man daher als eine Phase der wissenschaftlichen Formulierung der relationalen Datenbanktheorie bezeichnen, deren Umsetzung in die breite Anwendung erst in den 1980er Jahren erfolgte.", "type": "multiple-choice", "answers": [{"text": "50er Jahre", "solution": "false"}, {"text": "60er Jahre", "solution": "false"}, {"text": "70er Jahre", "solution": "true"}]}, {"id": 2429, "category": 9, "difficulty": 3, "text": "Wann hei\u00dft eine (\u00e4u\u00dfere) SELECT-Abfrage mit einer Unterabfrage (innerer SELECT) korreliert?", "explanation": "Korreliert bedeutet, dass die Spalten der \u00e4u\u00dferen Anweisung mit der innneren SELECT-Anweisung durch eine WHERE-Klausel verkn\u00fcpft werden.", "type": "multiple-choice", "answers": [{"text": "Die Anzahl der Spalten in der Unterabfrage ist kleiner als die Anzahl der Spalten in der \u00e4u\u00dferen SELECT-Anweisung", "solution": "false"}, {"text": "Die \u00e4u\u00dfere SELECT-Anweisung ist durch einen Join-Operator mit der inneren Select-Anweisung verbunden.", "solution": "true"}, {"text": "Die \u00e4u\u00dfere SELECT-Anweisung ist nicht durch einen Join-Operator mit der inneren Select-Anweisung verbunden.", "solution": "false"}, {"text": "In der WHERE-Bedingung der Unterabfrage werden Spalten der \u00e4u\u00dferen SELECT-Anweisung mit den Spalten der inneren SELECT-Anweisung verkn\u00fcpft.", "solution": "true"}]}, {"id": 2475, "category": 9, "difficulty": 3, "text": "Welche Constraints sind IMMEDIATE definierbar?", "explanation": "Alle f\u00fcnf SQL-Constraints NULL, CHECK, FOREIGN KEY, PRIMARY KEY, UNIQUE sind unabh\u00e4ngig davon, ob sie Spalten- oder Tabellen-Constraint sind, als IMMEDIATE definierbar. Der Pr\u00fcfungszeitpunkt \"IMMEDIATE\" (unmittelbar) bezeichnet die Pr\u00fcfung unmittelbar, wenn die Datenmanipulation (INSERT, UPDATE, DELETE) eingegeben wird. \n\nAus dem Syntax-Diagramm wird dies ersichtlich, weil f\u00fcr jeden Spalten-/Tabellenbedingungsausdruck die <CONSTRAINT Chraketristika> gelten und hinter denen verbergen sich u.a. die Optionen DEFERRED und IMMEDIATE.", "type": "multiple-choice", "answers": [{"text": "PRIMARY KEY", "solution": "true"}, {"text": "UNIQUE", "solution": "true"}, {"text": "FOREIGN KEY", "solution": "true"}, {"text": "NULL", "solution": "true"}, {"text": "CHECK", "solution": "true"}]}, {"id": 2165, "category": 7, "difficulty": 2, "text": "Gegeben sei eine Relation R(A, B, C) mit den funktionalen Abh\u00e4ngigkeiten A -> B, C und B -> C. Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 3NF?", "explanation": "In der 3. NF werden f\u00fcr jede funktionale Abh\u00e4ngigkeit eine eigene Relation erstellt, plus eine f\u00fcr den Prim\u00e4rschl\u00fcssel der 1.NF, sollte dieser nicht bereits Teil einer der Relationen sein.\n\n    \n\n    Da es sich oben um eine transitive Abh\u00e4ngigkeit handelt, muss das transitiv abh\u00e4ngige Attribut C aus der einen Relation entfernt werden.", "type": "multiple-choice", "answers": [{"text": "R={A,B,C}", "solution": "false"}, {"text": "R1={A,B,C} und R2 ={A,C}", "solution": "false"}, {"text": "R1={A,B,C} und R2 ={B,C}", "solution": "false"}, {"text": "R1={A,B} und R2 ={B,C}", "solution": "true"}]}, {"id": 2177, "category": 11, "difficulty": 2, "text": "Es ist folgende Tabelle mit zwei persistent gespeicherten Datens\u00e4tzen gegeben:\nCREATE TABLE trans_tab (s1  NUMBER(3) PRIMARY KEY INITIALLY IMMEDIATE, \n                        s2  VARCHAR2(20) UNIQUE INITIALLY DEFERRED);\nINSERT INTO trans_tab VALUES (1, 'Mustermann');\nINSERT INTO trans_tab VALUES (2, 'Musterfrau');\nCOMMIT;\n\nSchauen Sie sich nachfolgende Anweisungen an und geben Sie an, welche Datens\u00e4tze zum Zeitpunkt a) mit der SELECT-Anfrage angezeigt werden. \n\nSELECT * FROM trans_tab;                -- Zeitpunkt a)\nINSERT INTO trans_tab VALUES (3, 'Schmitt');\nINSERT INTO trans_tab VALUES (4, 'Schmidt');\nINSERT INTO trans_tab VALUES (4, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                -- Zeitpunkt b)\nINSERT INTO trans_tab VALUES (5, 'Schmitzchen');\nINSERT INTO trans_tab VALUES (6, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                 -- Zeitpunkt c)\nCOMMIT;\n\nSELECT * FROM trans_tab;                -- Zeitpunkt d)", "explanation": "Nach dem CREATE-TABLE werden zwei Datens\u00e4tze eingef\u00fcgt, die keines der Constraints verletzt, und anschlie\u00dfend mit COMMIT persistent gespeichert, so dass folgender Inhalt beim a)-SeELECT gegen ist. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau", "type": "multiple-choice", "answers": [{"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen", "solution": "false"}, {"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt", "solution": "false"}, {"text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau", "solution": "true"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 2623, "category": 9, "difficulty": 3, "text": "Erstellen Sie einen Nummerngenerator \"beliebig_seq\", der nur ungerade positive Zahlen generiert.", "explanation": "CREATE SEQUENCE beliebig_seq INCREMENT BY 2 START WITH 1; \nDer Z\u00e4hler startet mit 1 und es wird jeweils zwei hochgez\u00e4hlt und somit generiert er nur ungerade Zahlen: 1,3,5,7,...", "type": "text", "answers": [{"text": "Der Befehl lautet inclusive Semikolon am Ende:", "solution": "CREATE SEQUENCE beliebig_seq INCREMENT BY 2 START WITH 1;"}]}, {"id": 2625, "category": 9, "difficulty": 3, "text": "Welche SQL-Befehle l\u00f6sen eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus?", "explanation": "Ziel der Integrit\u00e4tspr\u00fcfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints gen\u00fcgen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erf\u00fcllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Pr\u00fcfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE l\u00f6sen also IMMEDIATE-Integrit\u00e4tspr\u00fcfung aus. \nCOMMIT beendet eine Transaktion und l\u00f6st damit eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie r\u00fcckg\u00e4ngig gemacht wird. Eine Integrit\u00e4tspr\u00fcfung ist daher unn\u00f6tig und wird nicht ausgef\u00fchrt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was daf\u00fcr sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integrit\u00e4tspr\u00fcfung ausl\u00f6sen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Pr\u00fcfung wird damit nicht ausgel\u00f6st.", "type": "multiple-choice", "answers": [{"text": "ROLLBACK", "solution": "false"}, {"text": "DELETE", "solution": "false"}, {"text": "SELECT", "solution": "false"}, {"text": "INSERT", "solution": "false"}, {"text": "CHECK", "solution": "false"}, {"text": "UPDATE", "solution": "false"}, {"text": "COMMIT", "solution": "true"}, {"text": "SAVE", "solution": "false"}, {"text": "CREATE", "solution": "true"}, {"text": "ALTER", "solution": "true"}, {"text": "DROP", "solution": "true"}]}, {"id": 2627, "category": 9, "difficulty": 2, "text": "Wann ist ein Constraint nicht erf\u00fcllt in SQL? D.h. wann schl\u00e4gt die Integrit\u00e4tspr\u00fcfung fehl?", "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\nEin Constraint in SQL ist erf\u00fcllt wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist. ...\n\n\nAchtung: Bei SELECT-Anfragen ist es anders, da wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wurde. Bei UNKNOWN oder FALSE wird der Datensatz \"fallen gelassen\".", "type": "multiple-choice", "answers": [{"text": "Wenn es zu FALSE ausgewertet wird.", "solution": "true"}, {"text": "Wenn es zu UNKNOWN ausgewertet wird.", "solution": "false"}, {"text": "Wenn es zu TRUE ausgewertet wird.", "solution": "false"}]}, {"id": 2628, "category": 9, "difficulty": 1, "text": "Wann wird ein Datensatz in die Ergebnismenge einer SQL-Anfrage aufgenommen?", "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\n\n\nBei SELECT-Anfragen wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedinung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\n\nAchtung: Bei der Integrit\u00e4tspr\u00fcfung ist das etwas anders:\n\nEin Constraint in SQL ist erf\u00fcllt wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\n\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist. ...", "type": "multiple-choice", "answers": [{"text": "Wenn die WHERE-Bedingung zu FALSE ausgewertet wird.", "solution": "false"}, {"text": "Wenn die WHERE-Bedingung zu UNKNOWN ausgewertet wird.", "solution": "false"}, {"text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.", "solution": "true"}]}, {"id": 2629, "category": 9, "difficulty": 2, "text": "Wann wird ein Datensatz nicht in die Ergebnismenge einer SQL-Anfrage aufgenommen?", "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\". \n\n\nAchtung: Bei der Integrit\u00e4tspr\u00fcfung ist das etwas anders: \nEin Constraint in SQL ist erf\u00fcllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist.", "type": "multiple-choice", "answers": [{"text": "Wenn die WHERE-Bedingung zu FALSE ausgewertet wird.", "solution": "true"}, {"text": "Wenn die WHERE-Bedingung zu UNKNOWN ausgewertet wird.", "solution": "true"}, {"text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.", "solution": "false"}]}, {"id": 2901, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Views (Sichten) sind wahr?", "explanation": "Zu dem View -Begriff (sicht ) bitte im DB-Wiki unter   <a target=\"\" title=\"\u00c4nderbare Sicht\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht nachschlagen!", "type": "multiple-choice", "answers": [{"text": "Eine View, in der Spaltenabk\u00fcrzungen benutzt werden (create view  as select spalt1 as neue_Spalte) erlaubt kein UPDATE der Daten.", "solution": "false"}, {"text": "Eine View, mit einer SELECT-Anweisung, die DISTINCT enth\u00e4lt, erlaubt kein UPDATE der Daten.", "solution": "true"}, {"text": "Wenn man in einer virtuellen View Daten l\u00f6scht, bleiben diese Daten in der zugrundeliegenden Tabelle enthalten.", "solution": "false"}, {"text": "Mit CREATE OR REPLACE view wird eine VIEW erst gel\u00f6scht (DROP) und dann wieder angelegt.", "solution": "true"}, {"text": "Mit der ORACLE-Option \"WITH CHECK OPTION\" kann man die in einer View enthaltenen Spalten einschr\u00e4nken.", "solution": "false"}]}, {"id": 2383, "category": 9, "difficulty": 3, "text": "Wozu braucht man objektrelationale Sichten?", "explanation": "Alle Antworten sind richtig \nbis auf die eine: \"um mittels virtueller objektrelationale Sichten die Daten redundant zu speichern und somit einen schnelleren Zugriff zu gew\u00e4hrleisten.\" \nGenau wie im relationalen Modell werden auch bei virtuellen objektrelationalen Sichten keine Datens\u00e4tze gespeichert und somit auch kein Zugriff beschleunigt.", "type": "multiple-choice", "answers": [{"text": "Um Beschr\u00e4nkungen der Benutzersichten realisieren zu k\u00f6nnen.", "solution": "true"}, {"text": "Um eine differenziertere Rechteverwaltung realisieren zu k\u00f6nnen.", "solution": "true"}, {"text": "Um relationaler Tabellen verwenden zu k\u00f6nnen, als wenn es Objekttabellen w\u00e4ren.", "solution": "true"}, {"text": "um mittels virtueller objektrelationale Sichten die Daten redundant zu speichern und somit einen schnelleren Zugriff zu gew\u00e4hrleisten.", "solution": "false"}]}, {"id": 2384, "category": 9, "difficulty": 3, "text": "Objekterhaltende Sichten erm\u00f6glichen eine objektrelationale Darstellung relationaler Daten.", "explanation": "Objekterhaltende Sichten k\u00f6nnen keine objektrelationale Darstellung relationaler Daten sein, da ihnen ja ein Objekt zugrunde liegen muss, dass sie dann nur noch \"erhalten\" m\u00fcssen.\nAnders sieht es bei objektgenerierenden Sichten aus, dort werden relationale Daten \"zu Objekten gemacht\", in dem ihnen u.a. eine OID gegeben wird u.v.m.\n  \nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n- Tupelsicht \u00fcber beliebige Tabellen und Sichten \n- Zeilen stellen Tupel dar  \n\nObjektrelational: Typisierte Sichten\n- Basiert auf einem Strukturdatentyp \n- Mittel der Zugriffskontrolle;  \n- erm\u00f6glicht logische Datenunabh\u00e4ngigkeit \n- Objektgenerierend:  \n- Typisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen \n- OID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet \n- Objektrelationale Darstellung relationaler Daten \n- Objekterhaltend: \n- Typisierte Sicht, deren Zeilen bestehende Objekte darstellen \n- Verallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich \n- Bessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen", "type": "multiple-choice", "answers": [{"text": "stimmt nicht.", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 2386, "category": 9, "difficulty": 2, "text": "Objekterhaltende Sichten haben ein Problem der Stabilit\u00e4t der OID.", "explanation": "Diese Aussage stimmt nicht, es sind die objektgenerierenden Sichten, die Probleme mit der Objektstabilit\u00e4t haben.\n  \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht \u00fcber beliebige Tabellen und Sichten \nZeilen stellen Tupel dar \n \n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp \nMittel der Zugriffskontrolle;  \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit \nObjektgenerierend:  \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen \nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet \nObjektrelationale Darstellung relationaler Daten \nObjekterhaltend: \nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen \nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich \nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen  \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht.", "solution": "true"}]}, {"id": 2388, "category": 9, "difficulty": 1, "text": "Objektrelationale Sichten sind ein Hilfsmittel f\u00fcr die logische Datenunabh\u00e4ngigkeit.", "explanation": "Welche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht \u00fcber beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht.", "solution": "false"}]}, {"id": 2390, "category": 9, "difficulty": 1, "text": "Die Definition einer objektrelationalen Sicht basiert auf einem Strukturdatentyp, also einem benutzerdefinierten Datentyp.", "explanation": "Welche unterschiedlichen Sichten gibt es im OR-Kontext?\n  \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht \u00fcber beliebige Tabellen und Sichten \nZeilen stellen Tupel dar \n \n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp \nMittel der Zugriffskontrolle;  \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit \nObjektgenerierend:  \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen \nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet \nObjektrelationale Darstellung relationaler Daten \nObjekterhaltend: \nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen \nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich \nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen  \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht.", "solution": "false"}]}, {"id": 2391, "category": 9, "difficulty": 2, "text": "Es gibt folgende objektrelationale Sichten:", "explanation": "FALSCH sind: objektmodifizierend und objektl\u00f6schend. \n\nRICHTIG sind: objekterhaltend und objektgenerierend \nobjektgenerierend\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht \u00fcber beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "objektgenerierend", "solution": "true"}, {"text": "objektmodifizierend", "solution": "false"}, {"text": "objektl\u00f6schend", "solution": "false"}, {"text": "objekterhaltend", "solution": "true"}, {"text": "Keine dieser Antworten ist richtig.", "solution": "false"}]}, {"id": 3170, "category": 10, "difficulty": 1, "text": "In Oracle-Instead-Of-Triggern k\u00f6nnen die Transitionsvariablen :NEW.spaltenname beschrieben werden.", "explanation": "Die Transitionsvariablen :NEW.spaltenname k\u00f6nnen unter Oracle-PL/SQL bei INSTEAD-OF-Triggern zwar gelesen, aber nicht beschrieben werden. Die :OLD.Transitionsvariablen k\u00f6nnen nie beschrieben werden, das sie einen alten Zustand enthalten.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3171, "category": 10, "difficulty": 2, "text": "Bei welchen Oracle-Triggern k\u00f6nnen die Transitionsvariablen :OLD.spaltenname beschrieben werden?", "explanation": "Die :OLD.Transitionsvariablen k\u00f6nenn bei keinem Trigger-Typ beschrieben werden, da sie den Zustand vor einer Transaktion beinhalten.", "type": "multiple-choice", "answers": [{"text": "BEFORE INSERT FOR EACH ROW...", "solution": "false"}, {"text": "BEFORE UPDATE FOR EACH ROW...", "solution": "false"}, {"text": "BEFORE DELETE FOR EACH ROW...", "solution": "false"}, {"text": "STATEMENT-TRIGGER", "solution": "false"}, {"text": "INSTEAD-OF-Trigger", "solution": "false"}, {"text": "keiner von allen", "solution": "true"}]}, {"id": 3183, "category": 8, "difficulty": 1, "text": "Welcher Optimierungsvorgang transformiert einen algebraischen Ausdruck der relationalen Algebra auf einen semantisch \u00e4quivalenten Ausdruck?", "explanation": "Bei der logischen Optimierung wird ein algebraischer Ausdruck der relationalen Algebra auf einen semantisch \u00e4quivalenten Ausdruck transformiert, der weniger Laufzeit ben\u00f6tigt. Je weniger Tupel die Zwischenergebnismengen haben, umso schneller ist die Anfrageauswertung.", "type": "multiple-choice", "answers": [{"text": "logische Optimierung", "solution": "true"}, {"text": "physische Optimierung", "solution": "false"}, {"text": "kein von beiden", "solution": "false"}]}, {"id": 3362, "category": 5, "difficulty": 1, "text": "Um welchen Attributtyp handelt es sich hier?\n\n    Studiendauer eines Studenten", "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zus\u00e4tzlich der Gr\u00f6\u00dfe nach ordnen und k\u00f6nnen verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zus\u00e4tzlich auch Multiplikation und  Division,  zulassen.", "type": "multiple-choice", "answers": [{"text": "Intervall", "solution": "true"}, {"text": "Ordinal", "solution": "false"}, {"text": "Nominal", "solution": "false"}, {"text": "Zahl", "solution": "true"}]}, {"id": 2155, "category": 9, "difficulty": 1, "text": "Die Duplikate der Ergebnismenge einer Anfrage sollen nur einmal angezeigt werden. Welches Schl\u00fcsselwort ist in der Anfrage daf\u00fcr zust\u00e4ndig?", "explanation": "Anders als bei der Relationalen Algebra, in der Duplikate nicht zugelassen sind und daher automatisch eliminieren werden, sind in SQL Duplikate zugelassen. Um Duplikate in SQL zu unterdr\u00fccken, muss man in der SELECT-Anweisung explizit die Option DISTINCT verwenden: SELECT DISTINCT spaltenname, .... FROM ....; \n\nUNIQUE ist ein Constraint und zwar das f\u00fcr die Zweitschl\u00fcssel. \nASC/DESC sind die Schl\u00fcsselw\u00f6rter f\u00fcr die ab-/aufsteigende Sortierung in der ORDER BY-Klausel von SELECT-Anfragen.", "type": "multiple-choice", "answers": [{"text": "DESC", "solution": "false"}, {"text": "DISTINCT", "solution": "true"}, {"text": "UNIQUE", "solution": "false"}, {"text": "ASC", "solution": "false"}, {"text": "Diese Problematik gibt es bei SQL nicht, da Duplikate nicht zugelassen sind und automatisch unterdr\u00fcckt werden.", "solution": "false"}]}, {"id": 3181, "category": 42, "difficulty": 1, "text": "Wie viele Eintr\u00e4ge hat ein B-Baum vom Typ 1 der H\u00f6he 1 maximal?", "explanation": "Wurzel: 2 Eintr\u00e4ge\n\n    1. Ebene: 2+2+2=6 Eintr\u00e4ge\n\n    Summe: 8", "type": "text", "answers": [{"text": "Die Anzahl ist", "solution": "8\r"}]}, {"id": 2598, "category": 7, "difficulty": 1, "text": "Eine Relation in der zweiten Normalform mit nur einer funktionalen\nAbh\u00e4ngigkeit ist immer in der dritten Normalform.", "explanation": "Mit nur einer funktionalen Abh\u00e4ngigkeit, w\u00e4re keine M\u00f6glichkeit zur Transitiviti\u00e4t gegeben. z.B. a->b,c. \nAber mit zwei funktionalen Abh\u00e4ngigkeiten ist als Mindestvoraussetzung grunds\u00e4tzlich die M\u00f6glichkeit gegeben, dass es sich dabei um transitive Abh\u00e4ngigkeiten handeln k\u00f6nnte. z.B. a->b,c. und b->c.", "type": "multiple-choice", "answers": [{"text": "Dieser Sachverhalt spielt in diesem Zusammenhang keine Rolle.", "solution": "false"}, {"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 3408, "category": 8, "difficulty": 1, "text": "Der Natural Join ist in der relationalen Algebra der einzige Join-Operator, der ohne Bedingung auskommt", "explanation": "Der Theta Join hat immer eine Bedingung und unterdr\u00fcckt keine doppelten Spalten. Equi-Join und Outer-Joins bauen auf der Definition des Theta-Joins auf.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "false"}, {"text": "stimmt", "solution": "true"}]}, {"id": 2616, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber das Fehlerverhalten des SQL-Integrit\u00e4tspr\u00fcfungskonzepts sind wahr?", "explanation": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird. Dieses Verhalten wird f\u00fcr Integrit\u00e4tsfehler ausschlie\u00dflich bei NOT NULL, PRIMARY KEY, UNIQUE ausgef\u00fchrt.\n\n    \n\n    Lediglich die Fremdschl\u00fcssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabh\u00e4ngig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik,wenn Masterdatens\u00e4tze gel\u00f6scht werden, f\u00fcr die noch abh\u00e4ngige Detail-Datens\u00e4tze bestehen. Es besteht dann die M\u00f6glichkeit, z.B. die abh\u00e4ngigen Detaildatens\u00e4tze ebenfalls zu l\u00f6schen (CASCADE) oder deren Fremdschl\u00fcsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)...\n\n    \n\n     ::=\n\n    REFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n    <\u00dcbereinstimmungstyp>\n\n    [ <fehlerkorrektur definition=\"\"> ]\n\n    \n\n    <fehlerkorrektur definition=\"\"> ::=\n\n    ON UPDATE <fehlerkorrektur aktion=\"\">\n\n    | ON DELETE <fehlerkorrektur aktion=\"\">\n\n    \n\n    <fehlerkorrektur aktion=\"\"> ::=\n\n    CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n\n    \n\n    Wenn man bedenkt, f\u00fcr welche Problemstellung die Fehlerkorrektur gedacht ist, dann kommt man schnell darauf, das es nur die beiden Klauseln \"ON UPDATE\" und \"ON DELETE\" geben kann.\n\n    Werden Fremdschl\u00fcssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datens\u00e4tze, die noch von Detail-Datens\u00e4tze referenziert werden, gel\u00f6scht oder deren Schl\u00fcsselwert ge\u00e4ndert wird und das anschlie\u00dfend Detail-Datens\u00e4tze existieren, f\u00fcr deren Fremdschl\u00fcsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt.\n\n    Das Einf\u00fcgen von Master-Datens\u00e4tzen ist immer unproblematisch, da eine Fremdschl\u00fcsselbedingung es zul\u00e4sst, dass es Master-Datens\u00e4tze gibt, f\u00fcr die es keine Detail-Datens\u00e4tze gibt.", "type": "multiple-choice", "answers": [{"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung nur die fehlerhafte Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird.", "solution": "true"}, {"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird bzw. bei einer DEFERRED-Pr\u00fcfung nur die fehlerhafte Datenmanipulation abgebrochen wird.", "solution": "false"}, {"text": "Das Fremdschl\u00fcsel-Constraint bietet die Option, dass das DBMS eine Fehlerkorrektur durchf\u00fchrt.", "solution": "true"}, {"text": "Die Constraints PRIMARY KEY, FOREIGN KEY und UNIQUE bieten die Option, dass das DBMS eine Fehlerkorrektur durchf\u00fchrt.", "solution": "false"}, {"text": "F\u00fcr die Fehlerkorrektur wird im CREATE TABLE-Befehl eine PL/SQL-Prozedur angegeben, die im Fehlerfall auszuf\u00fchren ist.", "solution": "false"}, {"text": "Die Fehlerkorrektur ist auf einen Spezialfall beschr\u00e4nkt, der im Zusammenhang mit den Fremdschl\u00fcsseln auftreten kann, den sog. \"Dangling Tuples\".", "solution": "true"}, {"text": "F\u00fcr die Fehlerkorrektur stehen drei Anwendungsf\u00e4lle zur Verf\u00fcgung, wann eine Korrektur ausgef\u00fchrt werden soll:\n\n<Fehlerkorrektur Definition> ::=\n  ON INSERT <Fehlerkorrektur Aktion>\n| ON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>", "solution": "false"}]}, {"id": 2619, "category": 9, "difficulty": 2, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    \n\n    Es wird versucht, einen Datensatz in die leere Tabelle einzuf\u00fcgen:\n\n    INSERT INTO HIERACHIE (Hans, Emil);\n\n    Was ist das Ergebnis dieser INSERT-Anweisung?", "explanation": "Der Datensatz kann nicht eingef\u00fcgt werden, weil die Fremdschl\u00fcsselbeziehung mit dem Wert \"Emil\" fehlschl\u00e4gt. Es gibt ja noch keinen anderen Datensatz in der Tabelle.\n\n    \n\n    Fehlerbericht:\n\n    SQL-Fehler: ORA-02291: Integrit\u00e4ts-Constraint (SS_10.SYS_C0015753) verletzt - \u00fcbergeordneter Schl\u00fcssel nicht gefunden\n\n    02291. 00000 - \"integrity constraint (%s.%s) violated - parent key not found\"\n\n    *Cause: A foreign key value has no matching primary key value.\n\n    *Action: Delete the foreign key or add a matching primary key.", "type": "text", "answers": [{"text": "Der Inhalt ist folgender: \n(f\u00fcr einen oder mehrere eingef\u00fcgte Datens\u00e4tze nur die beiden Namen mit Leerzeichen getrennt; f\u00fcr eine leere Tabelle das Wort: leer)", "solution": "leer"}]}, {"id": 2560, "category": 8, "difficulty": 2, "text": "Welche Operatoren der Relationalen Algebra sind bin\u00e4r?", "explanation": "Un\u00e4r:  F1 : Rn -> Rm      mit n , m \u2208 N \nBin\u00e4r: F2 : Rn \u00d7 Rm -> Rk mit n , m , k \u2208 N\nUn\u00e4re Operatoren: Selektion, Projektion\nBin\u00e4re Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "false"}, {"text": "Projektion", "solution": "false"}, {"text": "Division", "solution": "true"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Join-Operatoren (Theta, Equi, Natural, Left Outer, Right Outer, Outer)", "solution": "true"}, {"text": "Vereinigung", "solution": "true"}, {"text": "Differenz", "solution": "true"}, {"text": "Durchschnitt", "solution": "true"}]}, {"id": 2573, "category": 8, "difficulty": 1, "text": "Bestimmen Sie den Full Outer-Join der folgenden beiden Relationen \u00fcber R1.S1 = R2.S3!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z", "explanation": "Der Full Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgef\u00fcllt werden, die beim nat\u00fcrlichen Join herausfallen w\u00fcrden.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z", "solution": "true"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}]}, {"id": 2626, "category": 9, "difficulty": 3, "text": "Wann ist ein Constraint erf\u00fcllt in SQL?", "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\nEin Constraint in SQL ist erf\u00fcllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist. ...\n\n\nAchtung: Bei SELECT-Anfragen ist es anders, da wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wurde. Bei UNKNOWN oder FALSE wird der Datensatz \"fallen gelassen\".", "type": "multiple-choice", "answers": [{"text": "Wenn es zu FALSE ausgewertet wird.", "solution": "false"}, {"text": "Wenn es zu UNKNOWN ausgewertet wird.", "solution": "true"}, {"text": "Wenn es zu TRUE ausgewertet wird.", "solution": "true"}]}, {"id": 2476, "category": 9, "difficulty": 3, "text": "Welche M\u00f6glichkeiten zur Fehlerkorrektur bieten Constraints im SQL-Standard 2003?", "explanation": "Diese drei Optionen gibt es beim Fremdschl\u00fcssel-Constraint, sowohl bei Spalten- als auch bei Tabellen-Constraint. Au\u00dferdem: \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n\nIhre Bedeutung sind: \nON DELETE Die definierte Fehlerkorrekturoption wird ausgef\u00fchrt, wenn der referenzierte Master-Datensatz gel\u00f6scht wird.\nON UPDATE Die definierte Fehlerkorrekturoption wird ausgef\u00fchrt, wenn der Wert des referenzierten Schl\u00fcsselattributs in der Master-Tabelle ge\u00e4ndert wird.\nCASCADE Die Detaildatens\u00e4tze, deren Fremdschl\u00fcssel den manipulierten Master-Datensatz referenzieren, werden ebenfalls gel\u00f6scht kaskadierendes L\u00f6schen) bzw. deren Schl\u00fcsselwert wird entsprechend ge\u00e4ndert (kaskadierendes \u00c4ndern).\nSET DEFAULT Die Fremdschl\u00fcsselspalten des Detaildatensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf den f\u00fcr diese Spalte definierten DEFAULT-Wert gesetzt.\nSET NULL Die Fremdschl\u00fcsselspalten des Detail-Datensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf NULL gesetzt.\nNO ACTION Auf den Integrit\u00e4tsfehler wird je nach Pr\u00fcfungszeitpunkt mit dem Zur\u00fcckrollen der gesamten Transaktion bzw. der fehlerhaften DML-Anweisung reagiert (Reaktion wie bei den anderen CONSTRAINTS auch).\nRESTRICT Diese Option ist analog zur NO ACTION-Funktionalit\u00e4t zu sehen.", "type": "multiple-choice", "answers": [{"text": "CASCADE", "solution": "true"}, {"text": "SET NULL", "solution": "true"}, {"text": "SET DEFAULT", "solution": "true"}]}, {"id": 2632, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft der CONSTRAINT, wenn eine Spalte Fremdschl\u00fcssel ist?", "explanation": "Das Fremdschl\u00fcssel-Constraint hei\u00dft FOREIGN KEY.\n\n    \n\n    Die <font color=\"#000000\" face=\"Arial, Helvetica, Geneva, sans-serif\">\u00fcbrigen vier  Constraints sind: UNIQUE, CHECK, PRIMARY KEY und NOT NULL.", "type": "text", "answers": [{"text": "Das ist:", "solution": "FOREIGN KEY"}]}, {"id": 2341, "category": 42, "difficulty": 3, "text": "Ein B+ -Baum hat folgende Eigenschaften:", "explanation": "RICHTIG sind: \n\"Der B+-Baum ist vollst\u00e4ndig balanciert, d.h. jeder Weg von der Wurzel zum Blatt hat die gleiche L\u00e4nge, die H\u00f6he h.\" \nAlle inneren Knoten mit n Eintr\u00e4gen haben n+1 Nachfolger.\nJeder Knoten au\u00dfer der Wurzel eines B+-Baumes vom Typ k hat zwischen k und 2k Eintr\u00e4ge. \nDie Wurzel hat mindestens einen und h\u00f6chstens 2k Eintr\u00e4ge. \nDer B+-Baum hat in den inneren Knoten nur Schl\u00fcsselinformationen und Verweise auf die nachfolgenden Knoten.  \nDer B+-Baum speichert die Daten ausschlie\u00dflich in den Bl\u00e4ttern.  \nDas hier sind alles Eigenschaften des B+-Baumes - beim B-Baum sieht das etwas anders aus - aber darum geht es hier ja nicht. \n\n\n\nFALSCH sind:  \nJeder Knoten eines B+-Baumes vom Typ k hat zwischen k und 2k Eintr\u00e4ge, denn diese Aussage gilt nicht die Wurzel des Baumes. Sie kann ggf. auch nur einen Eintrag enthalten. \nAlle inneren Knoten haben zwei Nachfolger. Dies gilt nur, wenn der innere Knoten nur einen Eintrag enth\u00e4lt, bei mehr Eintr\u00e4gen, gibt es auch mehr Nachfolgerknoten. \nDer Weg von der Wurzel zum Blatt hat die L\u00e4nge h, h+1 oder h+2, wobei h die H\u00f6he des Baumes ist. Da der Baum beliebig tief sein kann, ist die H\u00f6he nicht auf h+2 beschr\u00e4nkt.", "type": "multiple-choice", "answers": [{"text": "Der B+-Baum ist vollst\u00e4ndig balanciert, d.h. jeder Weg von der Wurzel zum Blatt hat die gleiche L\u00e4nge, die H\u00f6he h.", "solution": "true"}, {"text": "Der Weg von der Wurzel zum Blatt hat die L\u00e4nge h, h+1 oder h+2, wobei h die H\u00f6he des Baumes ist.", "solution": "false"}, {"text": "Alle inneren Knoten haben zwei Nachfolger.", "solution": "false"}, {"text": "Alle inneren Knoten mit n Eintr\u00e4gen haben n+1 Nachfolger.", "solution": "true"}, {"text": "Jeder Knoten eines B+-Baumes vom Typ k hat zwischen k und 2k Eintr\u00e4ge.", "solution": "false"}, {"text": "Jeder Knoten au\u00dfer der Wurzel eines B+-Baumes vom Typ k hat zwischen k und 2k Eintr\u00e4ge.", "solution": "true"}, {"text": "Die Wurzel hat mindestens einen und h\u00f6chstens 2k Eintr\u00e4ge.", "solution": "true"}, {"text": "Der B+-Baum hat in den inneren Knoten nur Schl\u00fcsselinformationen und Verweise auf die nachfolgenden Knoten.", "solution": "true"}, {"text": "Der B+-Baum speichert die Daten ausschlie\u00dflich in den Bl\u00e4ttern.", "solution": "true"}]}, {"id": 2349, "category": 9, "difficulty": 2, "text": "Benutzerdefinierte Typen mit Methodendefinitionen sind f\u00fcr Objekttabellen wie auch f\u00fcr relationale Tabellen verwendbar.", "explanation": "Benutzerdefinierte Typen mit ihren Methoden k\u00f6nnen auch in relationalen Tupeltabellen verwendet werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2350, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber OIDs (object identifier) sind wahr?", "explanation": "Objektgenerierte OIDS sind nicht vorgesehen.", "type": "multiple-choice", "answers": [{"text": "Mit OIDs wird das OO-Paradigma der Zustandsunabh\u00e4ngigkeit realisiert.", "solution": "true"}, {"text": "OIDs sind unver\u00e4nderlich.", "solution": "true"}, {"text": "Systemgenerierte OIDs werden automatisch beim Erzeugen einer Instanz vom DBS erzeugt.", "solution": "true"}, {"text": "Abgeleitete OIDs basieren auf Werten von vorgegebenen Schl\u00fcsselspalten.", "solution": "true"}, {"text": "Bei benutzerdefinierten OIDs gibt der Benutzer beim Erzeugen einer Instanz die zugeh\u00f6rige OID vor.", "solution": "true"}, {"text": "Objektgenerierte OIDs werden bei Erzeugen einer Objekttabelle vom DBS automatisch erzeugt.", "solution": "false"}, {"text": "OIDs aus dem OR-Modell w\u00fcrde man im relationalen Modell mittels k\u00fcnstlicher Prim\u00e4rschl\u00fcssel simulieren.", "solution": "true"}]}, {"id": 2352, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Referenzen im OR-Modell sind wahr?", "explanation": "RICHTIG sind: \n- Eine OID ohne SCOPE-Angabe beschr\u00e4nkt eine Referenz auf Objektinstanzen des angegebenen Typs unabh\u00e4ngig von den Objekttabellen, in denen sie gespeichert sind. \n\nMit der SCOPE-Klausel k\u00f6nnen die Wertebereiche auf Instanzen dieses Typs in einer bestimmten Objekttabelle referenziert werden. \n\n- Fremdschl\u00fcssel im Relationalen Modell sind besser geeignet, um eine SCOPE-Referenz zu simulieren, als eine Referenz ohne SCOPE-Spezifikation, denn Fremdschl\u00fcssel stellen ja ganz konkret Beziehungen zwischen zwei Tabellen her - genau wie die SCOPE-Referenz auch.\n\n\nFALSCH sind: \nEine SCOPE-Klausel f\u00fcr Referenzen gibt es gar nicht. Obige richtige Aussagen belegen ihre Funktionsweise. \n\n- Fremdschl\u00fcssel im Relationalen Modell sind besser geeignet, um eine Referenz ohne SCOPE-Spezifikation zu simulieren, als eine mit SCOPE-Spezifikation. F\u00fcr das OR-Konzept Referenz ohne SCOPE gibt es kein Pendant im relationalen Modell.", "type": "multiple-choice", "answers": [{"text": "Eine SCOPE-Klausel f\u00fcr Referenzen gibt es gar nicht.", "solution": "false"}, {"text": "Eine OID ohne SCOPE-Angabe beschr\u00e4nkt eine Referenz auf Objektinstanzen des angegebenen Typs unabh\u00e4ngig von den Objekttabellen, in denen sie gespeichert sind.", "solution": "true"}, {"text": "Mit der SCOPE-Klausel k\u00f6nnen die Wertebereiche auf Instanzen dieses Typs in einer bestimmten Objekttabelle referenziert werden.", "solution": "true"}, {"text": "Fremdschl\u00fcssel im Relationalen Modell sind besser geeignet, um eine Referenz ohne SCOPE-Spezifikation zu simulieren, als eine mit SCOPE-Spezifikation.", "solution": "false"}, {"text": "Fremdschl\u00fcssel im Relationalen Modell sind besser geeignet, um eine SCOPE-Referenz zu simulieren, als eine Referenz ohne SCOPE-Spezifikation.", "solution": "true"}]}, {"id": 2353, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft bei Oracle die Klausel f\u00fcr systemgenerierte OIDs (object identifier)? Wenn es keine solche Klausel gibt, schreiben Sie \"gibt es nicht\".", "explanation": "Die OID-Generierung bietet zwei M\u00f6glichkeiten: SYSTEM GENERATED bedeutet,dass eine weltweit eindeutige OID erzeugt wird, PRIMARY KEY entspricht dem Konzept eines Prim\u00e4rschl\u00fcssels.", "type": "text", "answers": [{"text": "OBJECT IDENTIFIER IS", "solution": "SYSTEM GENERATED"}]}, {"id": 2354, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft bei Oracle die Klausel f\u00fcr abgeleitete OIDs (object identifier)? Wenn es keine solche Klausel gibt, schreiben Sie \"gibt es nicht\".", "explanation": "Die OID-Generierung bietet zwei M\u00f6glichkeiten: SYSTEM GENERATED bedeutet,dass eine weltweit eindeutige OID erzeugt wird, PRIMARY KEY entspricht dem Konzept eines Prim\u00e4rschl\u00fcssels als abgeleitete OID.", "type": "text", "answers": [{"text": "OBJECT IDENTIFIER IS", "solution": "PRIMARY KEY"}]}, {"id": 2355, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft bei Oracle die Klausel f\u00fcr benutzerdefinierte OIDs (object identifier)? Wenn es keine solche Klausel gibt, schreiben Sie \"gibt es nicht\".", "explanation": "Die OID-Generierung bietet zwei M\u00f6glichkeiten: SYSTEM GENERATED bedeutet,dass eine weltweit eindeutige OID erzeugt wird, PRIMARY KEY entspricht dem Konzept eines Prim\u00e4rschl\u00fcssels. \n\nBenutzerdefinierte OIDs gibt es unter Oracle nicht.", "type": "text", "answers": [{"text": "OBJECT IDENTIFIER IS", "solution": "gibt es nicht"}]}, {"id": 2356, "category": 9, "difficulty": 3, "text": "Bei welchem/n Befehl/en wird  bei Oracle eine OID spezifiziert?", "explanation": "Einer CREATE OID-Befehl gibt es nicht und OIDs werden nicht bei Typen, sondern bei Tabellen deklariert.", "type": "multiple-choice", "answers": [{"text": "CREATE OID FOR <Tabellenname> ", "solution": "false"}, {"text": "CREATE TABLE <Tabellenname> OF <Typname> ", "solution": "true"}, {"text": "CREATE TYPE <Typname> AS OBJECT ", "solution": "false"}, {"text": "Mit keinem dieser Befehle.", "solution": "false"}]}, {"id": 2369, "category": 9, "difficulty": 2, "text": "F\u00fcr jeden bei Oracle definierten benutzerdefinierten Typ wird automatisch ein Konstruktor definiert.", "explanation": "Der Typ kann auch als NOT INSTANTIABLE angelegt werden. Dann wird kein Konstruktor definiert.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2375, "category": 9, "difficulty": 3, "text": "Es sei folgende Methodendefinition gegeben:\n  CREATE OR REPLACE TYPE BODY kdtm AS\n  MEMBER FUNCTION get_plzort RETURN VARCHAR2 IS \n  BEGIN      RETURN (SELF.plz || SELF.ort);      END;\n  END;\nMit welchem/n Befehl/en kann man bei Oracle diese Methode aufrufen?", "explanation": "SELECT k.get_plzort() FROM kunden k WHERE name = \"Meier\";  ist der korrekte Aufruf einer Member-Funktion.", "type": "multiple-choice", "answers": [{"text": "SELECT kdtm.get_plzort(k.plz,k.ort) FROM kunden k WHERE name = \"Meier\";", "solution": "false"}, {"text": "SELECT k.get_plzort(k.plz, k.ort) FROM kunden k WHERE name = \"Meier\";", "solution": "false"}, {"text": "SELECT k.get_plzort() FROM kunden k WHERE name = \"Meier\";", "solution": "true"}, {"text": "SELECT k.get_plzort FROM kunden k WHERE name = \"Meier\";", "solution": "false"}]}, {"id": 2378, "category": 9, "difficulty": 3, "text": "Welche Eigenschaften hat eine relationale Sicht?", "explanation": "Welche Tabellen-/Sichtformen kann es in einem ORDBMS geben? \n\n* Definitionsart: untypisiert vs. typisiert \nUntypisiert: die Struktur ergibt sich direkt aus den Attributstrukturen (RM)\nTypisiert: Sicht-/Tabellendefinition basiert auf benutzerdefinierten Typ (OR)\n\n* Zeilentyp: tupelwertig vs. objektwertig \nTupelwertig: keine Methodenaufrufe f\u00fcr ein konkretes Tupel (RM)\nObjektwertig: Methodenaufrufe des zugeh\u00f6rigen Objekttyps direkt \u00fcber die Zeilenvariable (OR)\n\n* Referenzierbarkeit: nicht referenzierbar vs. referenzierbar  \nNicht referenzierbar: Zeilen sind nicht referenzierbar (RM)\nReferenzierbar: Zeilen sind mittels Referenzspalten (OIDs) referenzierbar; setzt OIDs voraus (OR) \n\n\n* Relationale Sichten/Tabellen sind: \n- tupelwertig, \n- untypisiert, \n- nicht referenzierbar\n\n\n* Objektorientierte Sichten/Klassen/Tabellen sind: \n- objektwertig, \n- typisiert, \n- referenzierbar", "type": "multiple-choice", "answers": [{"text": "Typisiert", "solution": "false"}, {"text": "Untypisiert", "solution": "true"}, {"text": "Tupelwertig", "solution": "true"}, {"text": "Objektwertig", "solution": "false"}, {"text": "Referenzierbar", "solution": "false"}, {"text": "Nicht referenzierbar", "solution": "true"}]}, {"id": 2381, "category": 9, "difficulty": 1, "text": "Es sei folgende Typdefinition gegeben: \nCREATE OR REPLACE TYPE kd_typ AS OBJECT \n   (kd_id NUMBER, name VARCHAR2(100), adresse VARCHAR2(200));\n\nWelche/r Befehl/e erzeugen bei Oracle eine Objekttabelle?", "explanation": "RICHTIG ist: \nCREATE TABLE kunden_ot OF kd_typ (kd_id PRIMARY KEY)  \n   OBJECT IDENTIFIER IS PRIMARY KEY;  \n  \nauf der Basis des folgenden Syntaxdiagramms: \n\n<CREATE typisierte Table Anweisung> ::=\nCREATE TABLE Tabellenname OF Typname [ UNDER Supertabellenname ]\n( [  ]\n  [ ,  ]\n  [ ,  ]\n);", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE kunden_ot  (kd_typ,   kd_id PRIMARY KEY) \n   OBJECT IDENTIFIER IS PRIMARY KEY;", "solution": "false"}, {"text": "CREATE TABLE kunden_ot  (kunde    kd_typ,   kd_id PRIMARY KEY) \n   OBJECT IDENTIFIER IS PRIMARY KEY;", "solution": "false"}, {"text": "CREATE TABLE kunden_ot OF kd_typ (kd_id PRIMARY KEY) \n   OBJECT IDENTIFIER IS PRIMARY KEY;", "solution": "true"}, {"text": "Keiner der Befehle ist richtig.", "solution": "false"}]}, {"id": 2414, "category": 10, "difficulty": 1, "text": "Ein Oracle-Trigger muss ein COMMIT oder ROLLBACK enthalten", "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt  nicht", "solution": "true"}]}, {"id": 2450, "category": 7, "difficulty": 1, "text": "Welche Arten von funktionalen Abh\u00e4ngigkeiten gibt es?", "explanation": "X und Y seien zwei Teilmengen von Attributen einer Relation R. \nY hei\u00dft funktional abh\u00e4ngig von X, wenn Folgendes gilt: \nF\u00fcr alle Tupel r, s aus R gilt: \nAus ProjX(s) = ProjX(r) folgt stets: ProjY(s) = ProjY(r). \nDie funktionale Abh\u00e4ngigkeit wird mit X \u2192 Y abgek\u00fcrzt geschrieben, was man auch \"X bestimmt Y\" (bzw. Y h\u00e4ngt von X ab) lesen kann. ProjX(s) bezeichnet die Projektion von s auf X. \nEine funktionale Abh\u00e4ngigkeit X \u2192 Y wird als volle funktionale Abh\u00e4ngigkeit bezeichnet, wenn jedes Element aus Y von der kompletten Menge X, nicht von einer echten Teilmenge von X, funktional abh\u00e4ngig ist. \nEine partielle funktionale Abh\u00e4ngigkeit besteht, wenn es ein Element y aus Y gibt, das nur von einer echten Teilmenge der Attribute aus X funktional abh\u00e4ngt. \n\nMit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist. \nAlso X \u2192Y \u2192Z, aber nicht Y \u2192X. \n\nDie \u00fcbrigen Begriffe gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "Volle funktionale Abh\u00e4ngigkeit", "solution": "true"}, {"text": "Halbe funktionale Abh\u00e4ngigkeit", "solution": "false"}, {"text": "Transitive funktionale Abh\u00e4ngigkeit", "solution": "true"}, {"text": "Kommutative funktionale Abh\u00e4ngigkeit", "solution": "false"}, {"text": "Distributive funktionale Abh\u00e4ngigkeit", "solution": "false"}, {"text": "Partielle funktionale Abh\u00e4ngigkeit", "solution": "true"}]}, {"id": 2451, "category": 5, "difficulty": 2, "text": "\u00dcber einen k\u00fcnstlichen Prim\u00e4rschl\u00fcssel sind folgende Aussagen wahr:", "explanation": "In der Praxis h\u00e4ufig sogenannte k\u00fcnstliche Schl\u00fcssel (surrogate keys) verwendet. Ein k\u00fcnstlicher Schl\u00fcssel ist ein zus\u00e4tzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Z\u00e4hler vom Datentyp Integer, der systemintern verwaltet wird, nach au\u00dfen nicht sichtbar ist und ausschlie\u00dflich f\u00fcr die Prim\u00e4r- und Fremdschl\u00fcsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und \u00c4hnlichem zu unterscheiden, die nach au\u00dfen sichtbar sind und im Schriftverkehr verwendet oder zur Identifikation beim Kunden erfragt werden. Wenn man sich f\u00fcr die Verwendung von k\u00fcnstlichen Prim\u00e4rschl\u00fcsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen f\u00fcr das gesamte Modell, unabh\u00e4ngig von den sonstigen Schl\u00fcsseln der Entity-Mengen.", "type": "multiple-choice", "answers": [{"text": "Er besteht aus nur einem Attribut.", "solution": "true"}, {"text": "Er besteht aus einem oder mehreren Attributen.", "solution": "false"}, {"text": "Sein Datentyp ist numerisch.", "solution": "true"}, {"text": "Er enth\u00e4lt Schl\u00fcsselwerte, die aus verschiedenen Komponenten zusammengesetzt sind, z.B. wie bei einer EAN (Eurepean Article Number), wo man anhand der Nummer das Herkunftsland, den herstellenden Betrieb und die Artikelnummer ablesen kann.", "solution": "false"}]}, {"id": 2504, "category": 9, "difficulty": 2, "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte f\u00fcr einen Datensatz leer ist?   \n     \nSELECT gehalt*12 AS Jahresgehalt FROM Mitarbeiter;", "explanation": "Eine numerische Operation auf einem Nullwert ergibt immer einen Nullwert.", "type": "text", "answers": [{"text": "Das Ergebnis ist", "solution": "NULL"}]}, {"id": 2503, "category": 9, "difficulty": 3, "text": "Welche SELECT-Anweisungen beantworten die Frage, welche Busse  haben keine Eins\u00e4tze absolviert, wobei die Relationen \"busse\" und \"einsatzplan\" die angegebenen Spalten haben?", "explanation": "SELECT b.kfz_knz \nFROM   busse b  \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e); \nSELECT b.kfz_knz \nFROM   busse b  \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e  \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id); \nDiese beiden Anfragen sind syntaktisch falsch: IN ist ein bin\u00e4rer Operator. Es fehlt der linke Operand.  \n \nSELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);\nist semantisch falsch: Es fehlt die Korrelation zwischen Busse und Einsatzplan. So liefert die Anfrage immer die leere Menge als Ergebnis, sobald in der Einsatzplan-Tabelle irgendein Datensatz gespeichert ist.  \n\nSELECT b.kfz_knz\nFROM   busse b \nWHERE  EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e); \nist doppelt:-) semantisch falsch: Es fehlt das NOT vor EXISTS und es fehlt die Korrelation zwischen Busse und Einsatzplan.\n\nSELECT b.kfz_knz\nFROM   busse b natural join einsatzplan;\nist semantisch falsch: Das sind die Busse, die einen Einsatz gefahren sind. \n\nSELECT b.kfz_knz   FROM  busse b, einsatzplan e\nWHERE  e.fahrzeug_id <> b.fahrzeug_id; \nist unsinnig: So unsinnig, dass es schwer f\u00e4llt, dazu eine Semantik zu finden. Technisch ausgedr\u00fcckt: Es ist die Komplementmenge des Natural Joins zum kartesischen Produkt.", "type": "multiple-choice", "answers": [{"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  b.fahrzeug_id NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e);", "solution": "true"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e);", "solution": "false"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id);", "solution": "true"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id);", "solution": "false"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);", "solution": "false"}, {"text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);", "solution": "false"}, {"text": "SELECT b.kfz_knz\nFROM   busse b natural join einsatzplan;", "solution": "false"}, {"text": "SELECT kfz_knz, COUNT(tag) as Anzahl_Eins\u00e4tze\nFROM   busse LEFT OUTER JOIN einsatzplan USING  (fahrzeug_id)\nGROUP  BY kfz_knz\nhaving count(tag) = 0;", "solution": "true"}, {"text": "SELECT b.kfz_knz   FROM  busse b, einsatzplan e\nWHERE  e.fahrzeug_id <> b.fahrzeug_id;", "solution": "false"}]}, {"id": 1076, "category": 1, "difficulty": 2, "text": "ANSI-3-Ebenen-Modell: In einer Datenbank werden neue Masken auf dem bestehenden Datenbestand entwickelt.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft keine Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "true"}]}, {"id": 1077, "category": 1, "difficulty": 1, "text": "Wie viele Ebenen hat das ANSI-Modell der Datenmodellierung?", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "drei", "solution": "true"}, {"text": "zwei", "solution": "false"}, {"text": "vier", "solution": "false"}]}, {"id": 2502, "category": 11, "difficulty": 3, "text": "Es ist die folgende leere Tabelle gegeben:  busfahrer(mita_id, stundenlohn), wobei mita_id eine Prim\u00e4rschl\u00fcsselspalte (Pr\u00fcfungszeitpunkt: IMMEDIATE) ist und stundenlohn eine Pflichteingabespalte (Pr\u00fcfungszeitpunkt: DEFERRED). Es ist folgende Transaktion gegeben:\n\n    INSERT INTO busfahrer VALUES (4711, 6);\n\n    INSERT INTO busfahrer VALUES (4711, 8);\n\n    SELECT mita_id FROM busfahrer;-- 1. SELECT\n\n    INSERT INTO busfahrer VALUES (4712, 0);\n\n    SELECT mita_id FROM busfahrer;-- 2. SELECT\n\n    INSERT INTO busfahrer VALUES (4713, NULL);\n\n    SELECT mita_id FROM busfahrer;-- 3. SELECT\n\n    COMMIT;\n\n    SELECT mita_id FROM busfahrer;-- 4. SELECT\n\n    Geben Sie f\u00fcr jede SELECT-Anweisung an, welche Ergebnismenge angezeigt wird, wobei mehrere Datens\u00e4tze durch ein Semikolon getrennt sind und schreiben Sie NO ROWS, falls der SELECT keine Zeilen liefert!", "explanation": "1. SELECT: 4711\n\n    Der 2. INSERT (4711,8) wird unmittelbar abgebrochen, weil er die Prim\u00e4rschl\u00fcsselbedingung verletzt.\n\n    \n\n    2. SELECT: 4711; 4712\n\n    Die Einf\u00fcgung (4712,0) verletzt keine Constraints.\n\n    \n\n    3. SELECT: 4711; 4712; 4713\n\n    Die Einf\u00fcgung (4713,NULL) verletzt das Pflichteingabe-Constraint f\u00fcr die 2. Spalte, wird jedoch erst einmal ausgef\u00fchrt, da dieses Constraint mit dem Pr\u00fcfungszeitpunkt DEFERRED definiert ist. Diese Bedingung erst also zum COMMIT gepr\u00fcft.\n\n    \n\n    4. SELECT: NO ROWS\n\n    Vor diesem SELECT wird ein COMMIT ausgef\u00fchrt und damit die gesamte Transaktion, die mit dem ersten INSERT gestartet wurde, abgeschlossen. Abschlie\u00dfen hei\u00dft: erst einmal alle DEFERRED-Constraints pr\u00fcfen und im Fehlerfall - wie hier, weil die Pflichteingabe f\u00fcr den 3. Datensatz verletzt ist - die gesamte Transaktion zur\u00fcckrollen.", "type": "text", "answers": [{"text": "Ergebnis 1.SELECT", "solution": "4711"}, {"text": "Ergebnis 2.SELECT", "solution": "4711; 4712"}, {"text": "Ergebnis 3.SELECT:", "solution": "4711; 4712; 4713"}, {"text": "Ergebnis 4.SELECT:", "solution": "NO ROWS"}]}, {"id": 2515, "category": 42, "difficulty": 1, "text": "Betrachten Sie eine Relation mit drei Spalten. \nWie viele Indizes kann man  anlegen?", "explanation": "Die Reihenfolge der Attribute spielt ja eine Rolle, daher 15 Kombinationsm\u00f6glichkeiten bei drei Spalten a, b, c: \na, b, c, \nab, ac, ba, bc, ca, cb, \nabc, acb, bac, bca, cab, cba,", "type": "multiple-choice", "answers": [{"text": "keine von allen", "solution": "false"}, {"text": "1", "solution": "false"}, {"text": "3", "solution": "false"}, {"text": "5", "solution": "false"}, {"text": "9", "solution": "false"}, {"text": "15", "solution": "true"}, {"text": "18", "solution": "false"}, {"text": "7", "solution": "false"}]}, {"id": 2631, "category": 9, "difficulty": 1, "text": "Es wird eine DELETE-Anweisung mit WHERE-Bedingung ausgef\u00fchrt?", "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\nAchtung: Bei der Integrit\u00e4tspr\u00fcfung ist das etwas anders: \nEin Constraint in SQL ist erf\u00fcllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist.", "type": "multiple-choice", "answers": [{"text": "Die, f\u00fcr die die WHERE-Bedingung zu FALSE ausgewertet wird.", "solution": "false"}, {"text": "Die, f\u00fcr die die WHERE-Bedingung zu UNKNOWN ausgewertet wird.", "solution": "false"}, {"text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.", "solution": "true"}]}, {"id": 2600, "category": 7, "difficulty": 2, "text": "Gegeben sei eine Relation R(A, B, C) mit den funktionalen Abh\u00e4ngigkeiten A -> B, C und B -> C. Um welche funktionale Abh\u00e4ngigkeit handelt es sich hier? Bitte vervollst\u00e4ndigen Sie die Antwort.", "explanation": "Hier ist C von B und B von A abh\u00e4ngig und damit ist C transitiv von A abh\u00e4ngig.\n\n    Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet.\n\n    Z hei\u00dft transitiv abh\u00e4ngig von X, wenn Y voll funktional abh\u00e4ngig von X und Z voll funktional abh\u00e4ngig von Y ist, aber X nicht voll funktional abh\u00e4ngig von Y ist.\n\n    Also X \u2192 Y \u2192 Z, aber nicht Y \u2192 X.", "type": "text", "answers": [{"text": "Um eine ...", "solution": "transitive"}]}, {"id": 2601, "category": 7, "difficulty": 2, "text": "Gegeben sei eine Relation R(A, B, C, D) mit den mit funktionalen Abh\u00e4ngigkeiten A, B -> C, D und B -> C. Um welche funktionale Abh\u00e4ngigkeit handelt es sich hier? Bitte vervollst\u00e4ndigen Sie die Antwort!", "explanation": "Eine partielle funktionale Abh\u00e4ngigkeit besteht, wenn es ein Element y aus Y gibt, das nur von einer echten Teilmenge der Attribute aus X funktional abh\u00e4ngt.", "type": "text", "answers": [{"text": "Um eine ... funktionale Abh\u00e4ngigkeit", "solution": "partielle"}]}, {"id": 2526, "category": 9, "difficulty": 1, "text": "Wenn eine PL/SQL-Prozedur einen IN-Parameter hat, muss sie auch einen OUT-Parameter haben.", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2525, "category": 9, "difficulty": 1, "text": "Mit SET SERVEROUTPUT ON SIZE 80000 kann man", "explanation": "Mit diesem Befehl kann man das Ergebnis von DBMS_OUTPUT.PUT_LINE ()sichtbar machen und die Bildschirmbuffergr\u00f6\u00dfe \u00e4ndern. Ohne SET SERVEROUTPUT ON ist das Ergebnis einer PL/SQL-Prozedur unsichtbar.", "type": "multiple-choice", "answers": [{"text": "nur das Ergebnis von DBMS_OUTPUT.PUT_LINE ()sichtbar machen", "solution": "false"}, {"text": "nur die Bildschirmbuffergr\u00f6\u00dfe \u00e4ndern", "solution": "false"}, {"text": "das Ergebnis von DBMS_OUTPUT.PUT_LINE ()sichtbar machen und die Bildschirmbuffergr\u00f6\u00dfe \u00e4ndern.", "solution": "true"}, {"text": "keine der Antworten ist richtig", "solution": "false"}]}, {"id": 2599, "category": 7, "difficulty": 3, "text": "Gegeben sei eine Relation R(A, B, C) mit den funktionalen Abh\u00e4ngigkeiten A -> B, C und B -> C. Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 2NF?", "explanation": "In der 2.NF werden partielle funktionale Abh\u00e4ngigkeiten aufgel\u00f6st. Hier handelt es sich jedoch um eine transitive funktionale Abh\u00e4ngigkeit, die jedoch erst in der 3.NF aufgel\u00f6st wird. Daher gilt hier 1.NF=2.NF.\n\n    \n\n    Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.\n\n    Eine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut voll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.\n\n    Eine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschl\u00fcsselattribut transitiv abh\u00e4ngig von einem Schl\u00fcsselattribut ist.", "type": "multiple-choice", "answers": [{"text": "R={A,B,C}", "solution": "true"}, {"text": "R1={A,B,C} und R2 ={A,C}", "solution": "false"}, {"text": "R1={A,B,C} und R2 ={B,C}", "solution": "false"}, {"text": "R1={A,B} und R2 ={B,C}", "solution": "false"}]}, {"id": 2603, "category": 9, "difficulty": 2, "text": "Was muss man tun, damit eine mit einer CREATE-Anweisung neu erzeugtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) in der Datenbank existiert?", "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausf\u00fchrung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl \"ALTER TABLE tabellenname persistent\" gibt es nicht und ebenso wenig die CREATE-Option PERSISTENT.", "type": "multiple-choice", "answers": [{"text": "Nach der CREATE-Anweisung ein COMMIT absetzen.", "solution": "false"}, {"text": "Gar nichts, weil bei der Ausf\u00fchrung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgef\u00fchrt wird.", "solution": "true"}, {"text": "Die Option PERSISTENT beim CREATE-Befehl verwenden.", "solution": "false"}, {"text": "F\u00fcr jedes DB-Objekt gibt es einen ALTER-Befehl, der f\u00fcr die dauerhafte Speicherung sorgt. Hier z.B. f\u00fcr eine Tabelle:\nALTER TABLE tabellenname persistent;", "solution": "false"}]}, {"id": 2605, "category": 9, "difficulty": 2, "text": "Was muss man tun, damit eine mit einer ALTER-Anweisung gel\u00f6schtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) in der Datenbank ge\u00e4ndert vorliegt?", "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausf\u00fchrung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl ALTER mit einer Option PERSISTENT gibt es gar nicht.", "type": "multiple-choice", "answers": [{"text": "Nach der ALTER-Anweisung ein COMMIT absetzen.", "solution": "false"}, {"text": "Gar nichts, weil bei der Ausf\u00fchrung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgef\u00fchrt wird.", "solution": "true"}, {"text": "Die Option PERSISTENT beim ALTER-Befehl verwenden.", "solution": "false"}]}, {"id": 2545, "category": 9, "difficulty": 2, "text": "Welcher Typkonstruktor aus dem SQL-Standard SQL2003 entspricht ORACLE den Nested Tables?", "explanation": "VARRAY geh\u00f6rt nicht zu SQL2003-Standard und ARRAY kann nur eine Kollektion von Werten, nicht eine komplette eingebettete Tabelle , aufnehmen.", "type": "multiple-choice", "answers": [{"text": "ARRAY", "solution": "false"}, {"text": "MULTISET", "solution": "true"}, {"text": "VARRAY", "solution": "false"}, {"text": "Solch einen Typkonstruktur gibt es nicht", "solution": "false"}]}, {"id": 2546, "category": 9, "difficulty": 3, "text": "Welcher Typkonstruktor kann auch als unbenannter Typkonstruktor unter ORACLE-SQL verwendet werden?", "explanation": "Den Typkonstruktur ARRAY gibt es im Oracle-SQL nicht. Au\u00dfer REF m\u00fcssen alle Typkonstruktoren explizit mit CREATE TYPE angelegt werden, d.h. ein Befehl wie\n\n CREATE TABLE test (NR number, ARRAY[2]Bezeichnung ) \nist unter Oracle/SQL nicht vorgesehen.", "type": "multiple-choice", "answers": [{"text": "ARRAY", "solution": "false"}, {"text": "VARRAY", "solution": "false"}, {"text": "REF", "solution": "true"}, {"text": "TABLE", "solution": "false"}]}, {"id": 2553, "category": 8, "difficulty": 2, "text": "Jemand schl\u00e4gt vor, als Prim\u00e4rschl\u00fcssel einer Auftragspositionen-Relation nicht die Kombination von AuftragsNr und und ArtikelNr (wie bisher) zu w\u00e4hlen, sondern nur die ArtikelNr. Was w\u00fcrde das bedeuten?", "explanation": "Ist nur die ArtikelNr Prim\u00e4rschl\u00fcsselattribut, so kann in der Auftragspositionen-Relation jede ArtikelNr nur einmal vorkommen, mit der Konsequenz, dass jeder Artikel nur einmal verkauft werden kann.\nGrund daf\u00fcr ist die Eigenschaft der Eindeutigkeit der (Prim\u00e4r-)Schl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Ein Auftrag besteht h\u00f6chsten aus einem Artikel.", "solution": "false"}, {"text": "Ein Artikel kann insgesamt nur einmal bestellt werden.", "solution": "true"}, {"text": "Es macht keinen Unterschied zur anderen L\u00f6sung.", "solution": "false"}, {"text": "Keine dieser Antworten ist korrekt.", "solution": "false"}]}, {"id": 2607, "category": 9, "difficulty": 1, "text": "Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden nur alle neu eingef\u00fcgten Datens\u00e4tze und alle zuk\u00fcnftigen Daten\u00e4nderungen und -l\u00f6schungen in und aus dieser Tabelle gepr\u00fcft, ob sie den CONSTRAINT erf\u00fcllen. Die bereits gespeicherten Daten werden nicht gepr\u00fcft.", "explanation": "Falsch, das Constraint-Konzept bietet einen 100% Schutz. Das Wort \"nur\" stimmt hier nicht. Wenn man in der ORACLE-DBA-View USER_CONSTRAINTS sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabh\u00e4ngig vom Zeitpunkt der Speicherung korrekt sind. Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden zur\u00fcckwirkend alle in der Datenbank vorhanden Daten gepr\u00fcft, ob sie dem CONSTRAINT gen\u00fcgen. Falls dies nicht der Fall ist, kann der CONSTRAINT nicht erzeugt werden.\n\n    \n\n    Das ist einer der Punkte, bei dem sich Integrit\u00e4tspr\u00fcfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden nur f\u00fcr alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2595, "category": 8, "difficulty": 3, "text": "Welche Typkonstruktoren sind inhomogen?", "explanation": "Homogene Elemente lassen nur Elemente gleichen Typs zu, dazu geh\u00f6ren: ARRAY, LIST, MULTISET, SET. \nInhomogene Elemente lassen nur Elemente unterschiedlichen Typs zu, dazu geh\u00f6ren: ROW, UNION", "type": "multiple-choice", "answers": [{"text": "SET", "solution": "false"}, {"text": "ROW", "solution": "true"}, {"text": "UNION", "solution": "true"}, {"text": "ARRAY", "solution": "false"}, {"text": "LIST", "solution": "false"}, {"text": "MULTISET", "solution": "false"}]}, {"id": 2608, "category": 9, "difficulty": 1, "text": "Welcher CONSTRAINT-Typ kann sich nur auf eine Spalte beziehen?", "explanation": "Je nach Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung)\ndifferenziert. Die Spaltenbedingungen werden direkt bei der Spaltendefinition des CREATE TABLE-Befehls programmiert und k\u00f6nnen sich nur auf eine, die gerade definierte Spalte beziehen. Tabellenbedingungen werden auch beim CREATE TALBE-Befehl definiert, sind aber nicht Teil einer Spaltenspezifikation und k\u00f6nnen sich somit auf mehrere Spalten beziehen.", "type": "multiple-choice", "answers": [{"text": "ein TABLE CONSTRAINT", "solution": "false"}, {"text": "ein COLUMN CONSTRAINT", "solution": "true"}, {"text": "keiner von beiden", "solution": "false"}]}, {"id": 2609, "category": 8, "difficulty": 2, "text": "Um welchen Typ einer Integrit\u00e4tsbedingung handelt es sich hier?\n\nBei Privatkunden darf der Rabatt 15 Prozent nicht \u00fcberschreiten.", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingung", "solution": "true"}, {"text": "dynamische, transitionale Bedingung", "solution": "false"}, {"text": "statische, transitionale Bedingung", "solution": "false"}, {"text": "dynamische, temporale Bedingung", "solution": "false"}, {"text": "statische, temporale Bedingung", "solution": "false"}]}, {"id": 2610, "category": 8, "difficulty": 2, "text": "Um welchen Typ einer Integrit\u00e4tsbedingung handelt es sich hier?\n\nEine Rechnung muss einen positiven Gesamtbetrag aufweisen, eine Gutschrift einen negativen.", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingung", "solution": "true"}, {"text": "dynamische, transitionale Bedingung", "solution": "false"}, {"text": "statische, transitionale Bedingung", "solution": "false"}, {"text": "dynamische, temporale Bedingung", "solution": "false"}, {"text": "statische, temporale Bedingung", "solution": "false"}]}, {"id": 2611, "category": 8, "difficulty": 2, "text": "Um welchen Typ einer Integrit\u00e4tsbedingung handelt es sich hier?\n\nDer Einkaufspreis eines Produkts darf innerhalb eines Jahres nicht um mehr als 10 % steigen.", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingung", "solution": "false"}, {"text": "dynamische, transitionale Bedingung", "solution": "false"}, {"text": "statische, transitionale Bedingung", "solution": "false"}, {"text": "dynamische, temporale Bedingung", "solution": "true"}, {"text": "statische, temporale Bedingung", "solution": "false"}]}, {"id": 2554, "category": 8, "difficulty": 1, "text": "Bei einer Projektion wird eine n-stellige Relation auf eine n+m-stellige Relation abgebildet, mit m>0.", "explanation": "Die Projektion kann die Anzahl der Attribute nicht vergr\u00f6\u00dfern, also keine Attribute hinzuf\u00fcgen. Sie kann lediglich die Ergebnismenge auf einzelne Attribute aus einer Relation beschr\u00e4nken.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2556, "category": 8, "difficulty": 3, "text": "Wie viele Attribute hat die Ergebnismenge des kartesischen Produkts von zwei Relationen, die \u00fcber 15 bzw. 25 Attribute verf\u00fcgen, wobei es in der einen Relation drei Attribute gibt, die gleich hei\u00dfen wie in der anderen?", "explanation": "Die Struktur der Ergebnismenge des Kartesischen Produkts verf\u00fcgt \u00fcber alle Attribute aus beiden beteiligten Relationen: 15+25= 40 Attribute. \nDass drei Attribute in beiden Relationen gleich hei\u00dfen, spielt keine Rolle f\u00fcr das Kartesische Produkt, sondern lediglich f\u00fcr den Natural Join.", "type": "text", "answers": [{"text": "Das kartesische Produkt hat ... Attribute.", "solution": "40"}]}, {"id": 2561, "category": 8, "difficulty": 1, "text": "\u00dcber welche Eigenschaften verf\u00fcgt ein bin\u00e4rer Operator in der relationalen Algebra?", "explanation": "Un\u00e4r:  F1 : Rn -> Rm      mit n , m \u2208 N\nBin\u00e4r: F2 : Rn \u00d7 Rm -> Rk mit n , m , k \u2208 N\nUn\u00e4re Operatoren: Selektion, Projektion\nBin\u00e4re Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division", "type": "multiple-choice", "answers": [{"text": "Er liefert zwei Ergebnisdatenmengen.", "solution": "false"}, {"text": "Er verarbeitet zwei Eingangsdatenmengen.", "solution": "true"}, {"text": "Die Ergebnisdatenmenge verf\u00fcgt \u00fcber zwei Attribute.", "solution": "false"}, {"text": "Die Eingangsdatenmengen verf\u00fcgen \u00fcber zwei Attribute.", "solution": "false"}, {"text": "Die Operation wird nur auf zwei Attributen ausgef\u00fchrt.", "solution": "false"}]}, {"id": 2562, "category": 8, "difficulty": 3, "text": "Welche Aussagen \u00fcber die relationalen Algebra sind wahr?", "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen, diese automatisch eliminiert werden. Zu diesen Operatoren geh\u00f6ren Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA. In SQL hei\u00dft das Schl\u00fcsselwort zur Duplikatelimination in SELECT-Anfragen DISTICNT.", "type": "multiple-choice", "answers": [{"text": "Relationen und Ergebnisdatenmengen sind Multimengen, was hei\u00dft, dass doppelte Tupel erlaubt sind.", "solution": "false"}, {"text": "Relationen und Ergebnisdatenmengen sind Mengen, was hei\u00dft, dass doppelte Tupel nicht erlaubt sind.", "solution": "true"}, {"text": "Zur Unterdr\u00fcckung doppelter Tupel gibt es eine eigene Operation: DISTINCT.", "solution": "false"}, {"text": "Die Unterdr\u00fcckung doppelter Tupel erfolgt automatisch. Bei den Operatoren, bei denen Duplikate auftreten k\u00f6nnen (Projektion, Vereinigung, Durchschnitt, Division) werden diese automatisch eliminiert.", "solution": "true"}, {"text": "Es gibt keine Operatoren, bei denen Duplikate auftreten k\u00f6nnen.", "solution": "false"}]}, {"id": 2563, "category": 8, "difficulty": 1, "text": "Die Relationale Algebra basiert auf einem", "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen k\u00f6nnen, diese automatisch eliminiert werden. Zu diesen Operatoren geh\u00f6ren Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: sp\u00e4ter bei SQL sind Duplikate zugelassen, aber nicht in der RA.", "type": "multiple-choice", "answers": [{"text": "Mengenverst\u00e4ndnis f\u00fcr Relationen (Duplikate nicht erlaubt).", "solution": "true"}, {"text": "Multimengenverst\u00e4ndnis f\u00fcr Relationen (Duplikate erlaubt).", "solution": "false"}]}, {"id": 2564, "category": 8, "difficulty": 3, "text": "Welche Priorit\u00e4tenreihenfolge habe die logischen Operatorn der Relationalen Algebra? \nTragen Sie bitte 1, 2, 3 oder 4 ein!", "explanation": "Priorit\u00e4tenreihenfolge der Operatoren (es ist die gleiche wie bei SQL)\nPriorit\u00e4t Operator\n1         Alle Vergleichsoperatoren\n2         NOT\n3         AND\n4         OR", "type": "text", "answers": [{"text": "OR", "solution": "4"}, {"text": "Vergleichssoperatoren", "solution": "1"}, {"text": "AND", "solution": "3"}, {"text": "NOT", "solution": "2"}]}, {"id": 2527, "category": 8, "difficulty": 2, "text": "Welche Join-Operatoren sind immer verlustfrei?", "explanation": "Eine Join-Operation zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis. Bei allen Join-Operatoren bis auf den Full-Outer -Join k\u00f6nnen Tupel, die  in der verkn\u00fcpften Operation kein Gegen\u00fcber haben, wegfallen.", "type": "multiple-choice", "answers": [{"text": "Theta-Join", "solution": "false"}, {"text": "Equi-Join", "solution": "false"}, {"text": "Left Outer Join", "solution": "false"}, {"text": "Right Outer Join", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Full Outer Join", "solution": "true"}, {"text": "Keiner von allen", "solution": "false"}]}, {"id": 2528, "category": 8, "difficulty": 1, "text": "Welche Join-Operatoren gibt es in der relationalen Algebra nicht?", "explanation": "Au\u00dfer Flat Join und Blank Join sind alle Join-Typen in der relationalen Algebra vorgesehen.", "type": "multiple-choice", "answers": [{"text": "Theta-Join", "solution": "false"}, {"text": "Equi-Join", "solution": "false"}, {"text": "Left Outer Join", "solution": "false"}, {"text": "Right Outer Join", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Full Outer Join", "solution": "false"}, {"text": "Flat Join", "solution": "true"}, {"text": "Blank Join", "solution": "true"}]}, {"id": 2529, "category": 9, "difficulty": 1, "text": "Parameter in PL/SQL-Prozeduren m\u00fcssen einen Datentyp (VARCHAR, NUMBER etc.) haben.", "explanation": "Parameter unter PL/SQL m\u00fcssen einen Datentyp habe, allerdings in allgemeiner Form, d.h. ohne L\u00e4ngenangabe. So ist z.B. varchar2(50) nicht zul\u00e4ssig.", "type": "multiple-choice", "answers": [{"text": "Stimmt", "solution": "true"}, {"text": "Stimmt nicht", "solution": "false"}]}, {"id": 2530, "category": 10, "difficulty": 2, "text": "Welche Datenstrukturen sind in Oracle-Triggern beschreibbar?", "explanation": "Wenn man die Werte von OLD-Variablen \u00e4ndert, wirft Oracle eine Exception (ORA-04085). Die Werte von NEW-Variablen lassen sich dagegen sehr wohl \u00e4ndern.", "type": "multiple-choice", "answers": [{"text": "NEW", "solution": "true"}, {"text": "OLD", "solution": "false"}]}, {"id": 2565, "category": 9, "difficulty": 3, "text": "Welche der folgenden SQL-Operatoren  m\u00fcssen der Anforderung gen\u00fcgen, \"vereinigungskonform\" zu sein?", "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) m\u00fcssen die gleichen Spaltendefinitionen aufweisen, d.h.: \n\nDie Anzahl der Spalten muss \u00fcbereinstimmen. \nDie Datentypen der der Spalten m\u00fcssen gleich sein.  \nDie Reihenfolge der Spalten muss \u00fcbereinstimmen.\n\nAchtung: In der RA mussten die Spalten auch noch gleich hei\u00dfen, das ist hier in SQL nicht mehr notwendig. Es werden in SQL die Spaltennamen der links vom Operator stehenden Tabelle verwendet.", "type": "multiple-choice", "answers": [{"text": "Projektion (SELECT-Klausel)", "solution": "false"}, {"text": "Selektion (WHERE-Klausel)", "solution": "false"}, {"text": "Kartesisches Produkt (FROM-Klausel ohne WHERE-Bedingung)", "solution": "false"}, {"text": "Join (NATURAL, THETA, EQUI, )", "solution": "false"}, {"text": "OUTER JOIN (LEFT, RIGHT, FULL)", "solution": "false"}, {"text": "UNION", "solution": "true"}, {"text": "MINUS / EXCEPT", "solution": "true"}, {"text": "INTERSECTION", "solution": "true"}, {"text": "Es gibt keine solche Anforderung in SQL.", "solution": "false"}]}, {"id": 2567, "category": 8, "difficulty": 3, "text": "Welche Anforderungen muss ein \"vereinigungskonformer\" Operator der relationalen Algebra erf\u00fcllen? (relevant f\u00fcr die Durchf\u00fchrung von Mengenoperationen)", "explanation": "Die Forderung in der Relationalen Algebra <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Relationen (Eingangsdatenmengen) m\u00fcssen die gleichen Attributdefinitionen aufweisen: \nDie Anzahl der Attribute muss \u00fcbereinstimmen. \nDie Attribute m\u00fcssen gleich hei\u00dfen. \nDie Datentypen der der Attribute m\u00fcssen gleich sein.  \nDie Reihenfolge der Attribute muss \u00fcbereinstimmen. \nAchtung: In SQL m\u00fcssen die Spalten nicht auch noch gleich hei\u00dfen.", "type": "multiple-choice", "answers": [{"text": "Die Attribute m\u00fcssen gleich hei\u00dfen.", "solution": "true"}, {"text": "Die Anzahl der Attribute muss \u00fcbereinstimmen.", "solution": "true"}, {"text": "Die Datentypen der der Attribute m\u00fcssen gleich sein.", "solution": "true"}, {"text": "Die Reihenfolge der Attribute muss \u00fcbereinstimmen.", "solution": "true"}, {"text": "Es gibt keine solche Anforderung in der RA.", "solution": "false"}]}, {"id": 2571, "category": 8, "difficulty": 1, "text": "Der Right Outer Join ist kommutativ.", "explanation": "Der rechte Outer-Join (rechter \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdr\u00fcckt werden, als Tupel mit aufgef\u00fchrt und in den Attributen, die zu R1 geh\u00f6ren, mit NULL-Werten aufgef\u00fcllt werden.\n\nDie rechten und linken Outer-Joins sind nicht kommutativ, da entweder nur die rechte oder nur die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden. \nDer Full-Outer-Join (beidseitiger, vollst\u00e4ndiger \u00e4u\u00dferer Join) zweier Relationen R1 und R2 ist ist jedoch kommutativ, da bei ihn sowohl die rechte als aich die linke Relation vollst\u00e4ndig mit allen Tupeln in die Ergebnismenge aufgenommen werden.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2576, "category": 8, "difficulty": 1, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2!\n\nR1:\nS1  S2     \nA    W\nC    Y\n\nR2:\nS1  S2\nC    Y\nD    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "text", "answers": [{"text": "Geben Sie die Attributwerte in Gro\u00dfbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.", "solution": "C Y"}]}, {"id": 2578, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attriguten S1, S2, S3, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z", "explanation": "Keine dieser Ergebnismengen ist richtig, weil bei R1 und R2 keine Attribute gleich hei\u00dfen. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. Hei\u00dfen keine Attribute gleich, so wird die leere Menge zur\u00fcck geliefert.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "true"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y", "solution": "false"}, {"text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z", "solution": "false"}]}, {"id": 2583, "category": 8, "difficulty": 3, "text": "Wie hei\u00dfen Programmiersprachen, bei denen der Programmierer die L\u00f6sung beschreibt, aber nicht den L\u00f6sungsweg im Detail programmieren muss?", "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.", "type": "text", "answers": [{"text": "Die Programmiersprachen hei\u00dfen: (Kleinbuchstaben)", "solution": "deklarativ"}]}, {"id": 2574, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4!\n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. Hei\u00dfen keine Attribute gleich, so wird die leere Menge zur\u00fcckgeliefert.", "type": "multiple-choice", "answers": [{"text": "S1 S2 S2 S3 S4\nC  Y  ?  ?  ?\nA  W  W  D  Z\n?  ?  V  C  Y", "solution": "false"}, {"text": "Keine dieser Ergebnismengen ist richtig.", "solution": "false"}, {"text": "S1 S2 S2 S3 S4\nC  Y  W  D  Z\nC  Y  V  C  Y\nA  W  W  D  Z\nA  W  V  C  Y", "solution": "false"}, {"text": "S1 S2 S2 S3 S4\nA  W  W  D  Z", "solution": "false"}, {"text": "S1 S2 S3 S4\nA  W  D  Z", "solution": "true"}]}, {"id": 2577, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS1  S4 \nC    Y\nD    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft. Hei\u00dfen keine Attribute gleich, so wird die leere Menge zur\u00fcck geliefert.", "type": "text", "answers": [{"text": "Geben Sie die Attributwerte in Gro\u00dfbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.", "solution": "C Y Y"}]}, {"id": 2581, "category": 8, "difficulty": 2, "text": "Es sind die folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4 gegeben: \n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "text", "answers": [{"text": "Welche Operation der Relationalen Algebra hat folgende Ergebnismenge? \n(englischsprachige Bezeichnung, nur Kleinbuchstaben, W\u00f6rter durch ein Leerzeichen getrennt, keine Bindestriche etc.)\n\nS1 S2 S3 S4\nA  W  D  Z", "solution": "natural join"}]}, {"id": 2585, "category": 8, "difficulty": 1, "text": "Welcher Programmiersprachen sind deklarativ?", "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.", "type": "multiple-choice", "answers": [{"text": "Java", "solution": "false"}, {"text": "C++", "solution": "false"}, {"text": "SQL", "solution": "true"}]}, {"id": 2959, "category": 5, "difficulty": 2, "text": "Wie hei\u00dft eine Beziehung, die mit beiden Enden die gleiche Entity-Menge verbindet?", "explanation": "Eine rekursive Beziehung ist eine Beziehung, die mit beiden Enden auf die gleiche Entity-Menge verweist.", "type": "text", "answers": [{"text": "So eine Beziehung hei\u00dft:", "solution": "rekursiv"}]}, {"id": 2926, "category": 9, "difficulty": 3, "text": "Die beiden weitgehend unver\u00e4ndert dem objektrelationalen Modell zugrunde liegenden Modelle des SQL-92-Standards sowie des Basisobjektmodells werden beim SQL-2003-Standard um drei Typkonstruktoren erweitert. Nennen Sie die Namen ohne Sonderzeichen und in alphabetischer Reihenfolge.", "explanation": "Die beiden grundlegenden Konzepte, die im objektrelationalen SQL2003 zusammengef\u00fchrt wurden sind: SQL-92 und das Basisobjektmodell. (vgl. auch T\u00fcrker/Saake in \"Objektrelationale Datenbanken\", dpunkt-Verlag, 2006, Kap.3, insbesondere S.95) Diese beiden Modelle werden zudem um drei Typkonstruktoren erweitert:\n\nin SQL: REF, MULTISET, ARRAY \nbei Oracle REF, (NESTED) TABLE, VARRAY \n\nZu beachten ist insbesondere, dass sowohl bei Oracle wie auch beim SQL2003-Standard nicht das relationalen Modell mit seiner Mengensemantik sondern das SQL-92-Modell mit seinem Verst\u00e4ndnis einer Tabelle als Multimenge zugrunde liegt.", "type": "text", "answers": [{"text": "Das ist zum einen ...", "solution": "REF"}, {"text": "Das ist zum zweiten ...", "solution": "MULTISET"}, {"text": "Und zum dritten das ...", "solution": "ARRAY"}]}, {"id": 2904, "category": 9, "difficulty": 3, "text": "Welche Aussage(n) \u00fcber Unterabfragen sind wahr?", "explanation": "Wenn ein Wert kleiner ist als irgendein Wert des Ergebnis einer Unterabfrage, ist er insbesondere auch kleiner als das Maximum der Werte der Unterabfrage. Wenn ein Wert kleiner als das Maximum des Ergebnises einer Unterbafrage ist, ist er auch kleiner als ein beliebiger Wert des Ergebnises der Unterabfrage.\n\n    Wenn ein Wert kleiner ist als jeder Wert des Ergebnis einer Unterabfrage, ist er insbesondere auch kleiner als das Minimum der Werte der Unterabfrage. Wenn ein Wert kleiner als das Minimum des Ergebnises einer Unterabfrage ist, ist er auch kleiner als alle Werte der Unterabfrage.\n\n    Die Aussage (< ANY(Unterabfrage)) ist schw\u00e4cher als < ALL(Unterabfrage) und genauso ist das die Aussage (kleiner als das Maximum) schw\u00e4cher als (kleiner als das Minimum).\n\n    siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "< ANY(Unterabfrage) ist \u00e4quivalent zu kleiner als das Maximum.", "solution": "true"}, {"text": "< ANY(Unterabfrage) ist \u00e4quivalent zu kleiner als das Minimum.", "solution": "false"}, {"text": "< ALL(Unterabfrage) ist \u00e4quivalent zu kleiner als das Minimum.", "solution": "true"}, {"text": "< ALL(Unterabfrage) ist \u00e4quivalent zu kleiner als das Maximum.", "solution": "false"}, {"text": "keine von allen", "solution": "false"}]}, {"id": 3479, "category": 9, "difficulty": 1, "text": "Identische SQL-Anweisungen werden in der Oracle-DB in der SGA (Hauptspeicherbereich)  zwischengespeichert, samt Query-Execution-Plan  und sorgen dabei f\u00fcr eine h\u00f6here Performance.\n\nZwei SQL-Anweisungen sind in diesem Sinne identisch, wenn", "explanation": "Der Oracle-Server betrachtet zwei SQL-Anweisungen nicht als identisch, wenn sie sich auch nur geringf\u00fcgig unterscheiden, z.B. durch Leerzeichen oder Gro\u00df/Kleinschreibung.", "type": "multiple-choice", "answers": [{"text": "sie in allen Zeichen \u00fcbereinstimmen, wobei Gro\u00df/Kleinschreibung eine Rolle spielt.", "solution": "true"}, {"text": "sie auch bei den Leerzeichen hinsichtlich Anzahl und Position \u00fcbereinstimmen.", "solution": "true"}, {"text": "Die Leerzeichen spielen bei dieser Frage keine Rolle.", "solution": "false"}, {"text": "sie in allen Zeichen \u00fcbereinstimmen, wobei Gro\u00df/Kleinschreibung keine Rolle spielt.", "solution": "false"}]}, {"id": 2698, "category": 9, "difficulty": 2, "text": "Wie wird eine Prozedur mit dem Bezeichner prozedurname aufgerufen?", "explanation": "Beispiele f\u00fcr Prozeduraufrufe sind: \nSQL-Plus \nEXECUTE prozedurname(var_y, var_x)\nIm PL/SQL-Programm:\nprozedurname(var_y, var_x) \n\nSELECT/DML-Anweisung, IF-Bedingung und Zuweisungen sind Aufrufformen f\u00fcr Funktionen.\n\nUnd Trigger werden \"durch ein eingetretenes Ereignis\" gefeuert und zu einem \"einen eingetretenen Ausf\u00fchrungszeitpunkt\" ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "Im PL/SQL-Programm einfach nur mit dem prozedurname", "solution": "true"}, {"text": "Durch einen eingetretenen Ausf\u00fchrungszeitpunkt", "solution": "false"}, {"text": "In SELECT- und DML-Anweisungen durch Verwendung von   prozedurname", "solution": "false"}, {"text": "In IF-Bedingungen", "solution": "false"}, {"text": "In Zuweisungen", "solution": "false"}]}, {"id": 2703, "category": 10, "difficulty": 3, "text": "Woran kann man rein syntaktisch erkennen, das ein Mutating Table-Problem in einem Oracle-Trigger vorliegt?", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "multiple-choice", "answers": [{"text": "Im Aktionsteil wird mit SELECT und/oder INSERT, UPDATE, DELETE auf eine beliebige Tabelle des Schemas zugegriffen.", "solution": "false"}, {"text": "Im Aktionsteil wird mit SELECT und/oder INSERT, UPDATE, DELETE auf eine Tabelle zugegriffen, die mittels Fremdschl\u00fcssel verbunden ist mit der Tabelle des Triggers.", "solution": "false"}, {"text": "Im Aktionsteil wird mit SELECT und/oder INSERT, UPDATE, DELETE auf die Tabelle zugegriffen, f\u00fcr die der Trigger definiert wurde.", "solution": "true"}, {"text": "Im Aktionsteil wird ein COMMIT oder ROLLBACK ausgef\u00fchrt.", "solution": "false"}, {"text": "Es ist ein zeilenorientierter ORACLE-Trigger.", "solution": "true"}, {"text": "Es ist ein befehlsorientierter orientierter ORACLE-Trigger.", "solution": "false"}, {"text": "Es ist ein befehls- oder zeilenorientierter orientierter ORACLE-Trigger.", "solution": "false"}]}, {"id": 2720, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle:\n\n    CREATE TABLE Zeitschrift\n\n    ( Zeitschrift_id INTEGER NOT NULL,\n\n    Namen VARCHAR2(20) NULL,\n\n    PRIMARY KEY (Zeitschrift_id));\n\n    \n\n    CREATE TABLE Aufsatz\n\n    ( Aufsatz_id INTEGER NOT NULL,\n\n    Titel VARCHAR2(20) NULL,\n\n    Zeitschrift_id INTEGER NOT NULL,\n\n    PRIMARY KEY (Aufsatz_id),\n\n    FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\n    Auf welcher der beiden Tabellen ist ein ON DELETE CASCADE m\u00f6glich, mit dem Zweck, dass zu einer Zeitschrift auch die zuh\u00f6rigen Aufs\u00e4tze gel\u00f6scht werden?", "explanation": "ON DELETE CASCADE ist eine Option des Fremdschl\u00fcssel-Constraints und da bei der Zeitschriften-Tabelle gar kein Fremdschl\u00fcssel definiert ist, kann auch kein ON DELETE CASCADE spezifiziert werden.", "type": "multiple-choice", "answers": [{"text": "Zeitschrift", "solution": "false"}, {"text": "Aufsatz", "solution": "true"}]}, {"id": 2728, "category": 9, "difficulty": 2, "text": "Welche Parametertypen m\u00fcssen registriert werden?", "explanation": "Anders als bei IN-Parametern, m\u00fcssen OUT- und INOUT-Parameter explizit registriert werden, damit der Datentyp des Parameters im Programm bekannt ist. Bei IN-Parametern ist der Datentyp \u00fcber den \u00dcbergabewert beim Aufruf bekannt und wird nur f\u00fcr den Aufruf ben\u00f6tigt. F\u00fcr die R\u00fcckgabe von Werten nach der Prozedur-/Funktionsausf\u00fchrung m\u00fcssen jedoch die Datentypen der OUT- und INOUT-Parameter explizit bekannt gemacht werden. \n\n\nHier ein Beispiel:\n\nCREATE OR REPLACE PROCEDURE gibAnzahlEintraege(anzahl OUT INTEGER) \nBEGIN\n   SELECT COUNT( * )INTO anzahl FROM person;\nEND;\n\n\nCallableStatement cstmt = \n     con.prepareCall(\"{call gibAnzahlEintraege(?)}\"); \n//OUT- (und INOUT-) Parameter: Festlegung des Datentyps\ncstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n//Abfrage ausf\u00fchren\ncstmt.executeQuery();\n//Wert auslesen\nSystem.out.println(\"Anzahl der Eintr\u00e4ge: \"+ cstmt.getInt(1));", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "false"}, {"text": "OUT", "solution": "true"}, {"text": "INOUT", "solution": "true"}]}, {"id": 2730, "category": 9, "difficulty": 1, "text": "Zu wie vielen verschiedenen Datenbanken k\u00f6nnen in einem Java-Programm  Verbindungen aufgebaut werden?", "explanation": "Ein Java-Programm kann eine oder mehrere Verbindungen zu einer oder mehreren Datenbanken unterhalten.", "type": "multiple-choice", "answers": [{"text": "1", "solution": "false"}, {"text": "2", "solution": "false"}, {"text": "3", "solution": "false"}, {"text": "keine", "solution": "false"}, {"text": "mehrere", "solution": "true"}]}, {"id": 2731, "category": 9, "difficulty": 3, "text": "Mit welchem Methodenaufruf wird Transaktionsverarbeitung m\u00f6glich, die ein explizites COMMIT oder ROLLBACK von der Anwendung erfordern? Wenn es die Default-Einstellung ist, schreiben Sie \"default\". Wenn ein Methodenaufruf notwendig ist, rufen Sie die Methode f\u00fcr das Verbindungsobjekt \"con\".", "explanation": "Nach Verbindungsaufbau ist der Modus defaultm\u00e4\u00dfig auf \n       Auto-Commit-Modus = true  \ngesetzt. D.h. jede einzelne SQL-Anweisung wird als Transaktion \u000b      behandelt, und nach dem Ausf\u00fchren automatisch festgeschrieben.\n\nUm mehr als eine SQL-Anweisung als Transaktion zu erlauben, muss der Auto-Commit-Modus ausgeschaltet werden:\n\n    verbindung.setAutoCommit(false);\nIn diesem Modus muss die Java-Anwendung selbst die Transaktionen mit COMMIT oder ROLLBACK abschlie\u00dfen.", "type": "text", "answers": [{"text": "Das ist ...", "solution": "con.setAutoCommit(FALSE)"}]}, {"id": 2742, "category": 9, "difficulty": 3, "text": "Ausgehend von der Klassifikation von Stonebraker und Morre sind objektorientierte DBS f\u00fcr welche Art von Anwendungen gut geeignet?\n\nQuelle: \nStonebraker, M., Morre, D.: \"Objektrelationale Datenbanken \u0096 Die n\u00e4chste gro\u00dfe Welle\", Hanser, M\u00fcnchen, 1999", "explanation": "Stonebraker und Morre haben in ihrem Buch \"Objektrelationale Datenbanken \u0096 Die n\u00e4chste gro\u00dfe Welle\" 1999 folgende Klassifikation postuliert, die sich gut bew\u00e4hrt hat. Interessant wird es, wenn es um Anwendungen geht, die mehrere dieser Eigenschaften abdecken. \n\n* Einfache Daten und wenig Anfragen erfordern Dateisysteme\n* Einfache Daten und viele Anfragen erfordern relationale DBMS\n* Komplexe Daten und viele Anfragen erfordern objektrelationale DBMS\n* Komplexe Daten und wenig Anfragen erfordern objektorientierte DBMS\n\nBei objektorientierten Datenbanksystemen bestehen \"Anfragen\" in der Regel aus Spezialoperationen, die mittels Methoden implementiert sind z.B. bei Geo-Informationssystemen: schneiden sich zwei Stra\u00dfen, haben zwei Orte die gleichen H\u00f6henmeter, \u00fcberlagern sich zwei Gesteinsformationen etc. ... \nund kaum aus Mengenanfragen, wie man es aus der relationalen Welt gewohnt ist.\nBei objektrelationalen Datenbanksystemen m\u00f6chte man komplexere Objektstrukturen analog zur Realit\u00e4t abbilden k\u00f6nnen und nicht wie im relationalen Modell Objekte ggf. \u00fcber mehrere Relationen verteilen. Es stehen weiterhin die Mengenanfragen zur Verf\u00fcgung aber auch \u00fcber die Methoden die Programmierung beliebige Spezialoperationen.", "type": "multiple-choice", "answers": [{"text": "einfache Daten und wenige Anfragen", "solution": "false"}, {"text": "einfache Daten und viele Anfragen", "solution": "false"}, {"text": "komplexe Daten und viele Anfragen", "solution": "false"}, {"text": "komplexe Daten und wenig Anfragen", "solution": "true"}]}, {"id": 2744, "category": 9, "difficulty": 1, "text": "Welcher Befehl ist richtig, um einen benutzerdefinierten Datentyp \"strasse\" bestehend aus den beiden Informationen \"strassenname\" (50 alphanumerische Zeichen) und  \"hausnummer\" (5 alphanumerische Zeichen) anzulegen?", "explanation": "Die richtig Syntax ist: \n\nCREATE OR REPALCE TYPE strasse AS OBJECT \n(strassenname   VARCHAR2(50), \n hausnummer     VARCHAR2(5)\n);", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPALCE TYPE strasse \n(strassenname   VARCHAR2(50), \n hausnummer     VARCHAR2(5)\n);", "solution": "false"}, {"text": "CREATE OR REPALCE strasse AS TYPE \n(strassenname   VARCHAR2(50), \n hausnummer     VARCHAR2(5)\n);", "solution": "false"}, {"text": "CREATE OR REPALCE TYPE strasse AS OBJECT \n(strassenname   VARCHAR2(50), \n hausnummer     VARCHAR2(5)\n);", "solution": "true"}]}, {"id": 2746, "category": 9, "difficulty": 1, "text": "Welche Arten von Tabellen lassen sich mit einer Referenzspalte REF referenzieren?", "explanation": "Eine Referenz kann nur auf eine Objekttabelle (Oracle) / Typisierte Tabelle (SQL) verweisen, da f\u00fcr den Verweis eine OID ben\u00f6tigt wird, die in relationalen Tabellen nicht gegeben ist.  \n\nAndererseits kann die Referenz aus einer relationalen wie auch objektrelationale Tabelle (Objekttabelle (Oracle)/Typisierte Tabelle (SQL)) erfolgen,  d.h. eine relationale Tabelle kann eine Spalte aufweisen, deren Datentyp REF ist und auf eine  Objekttabelle (Oracle)/Typisierte Tabelle (SQL) verweist.", "type": "multiple-choice", "answers": [{"text": "relationale Tabellen (Tupeltabellen)", "solution": "false"}, {"text": "Objekttabellen (Oracle) / Typisierte Tabellen (SQL)", "solution": "true"}]}, {"id": 2708, "category": 9, "difficulty": 2, "text": "Folgende Prozedur sei gegeben:\n\n    CREATE OR REPLACE PROCEDURE test_proc (p1 IN NUMBER, p2 INOUT NUMBER) ... ;\n\n    Wie kann diese Prozedur innerhalb eines PL/SQL-Programms aufgerufen werden?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist.\n\n    \n\n    Beim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. Daher sind als Aufrufparameter Konstanten und Variablen zul\u00e4ssig.\n\n    Beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten.\n\n    Beim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann. Daher sind als Aufrufparameter keine Konstanten sondern nur Variablen zul\u00e4ssig.\n\n    Der Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann. Daher sind als Aufrufparameter keine Konstanten sondern nur Variablen zul\u00e4ssig.", "type": "multiple-choice", "answers": [{"text": "test_proc (4711, 4122);", "solution": "false"}, {"text": "test_proc (4711, var2);", "solution": "true"}, {"text": "test_proc (var1, 4122);", "solution": "false"}, {"text": "test_proc (var1, var2);", "solution": "true"}]}, {"id": 2709, "category": 9, "difficulty": 3, "text": "Es sei eine Funktion test_check(sp1 IN NUMBER) RETURN BOOLEAN ; gegeben. Welche Aufrufe sind richtig?", "explanation": "Da der R\u00fcckgabewert (RETURN-Wert) vom Typ BOOLEAN ist, ist eine Verwendung innerhalb von Bedingungen z.B. von WHILE-Schleifen oder IF-Anweisungen sehr komfortabel m\u00f6glich. Mit EXECUTE k\u00f6nnen Prozeduren ausgef\u00fchrt werden und zwar  nicht innerhalb von PL/SQL-Programmen (dort nur durch Verwendung des Prozedurnamens) sondern in Tools wie  SQL-Developer. Bei Funktionen muss zus\u00e4tzlich der Return-Wert verarbeitet werden.  Die Anweisung \"SELECT funktionsname FROM DUAL;\" eignet sich hervorragend f\u00fcr den Aufruf von Funktionen mit nur IN-Parametern, solange f\u00fcr sie nicht BOOLEAN als RETURN-Wert definiert ist. Der Grund ist, im SQL-Kontext kennt Oracle leider immer noch nicht den Datentyp BOOLEAN sondern nur in PL/SQL-Programmen.", "type": "multiple-choice", "answers": [{"text": "EXECUTE test_check(123);", "solution": "false"}, {"text": "IF test_check(var_x) THEN  END IF;", "solution": "true"}, {"text": "SELECT test_check(sp1) FROM DUAL;", "solution": "false"}, {"text": "WHILE test_check(var_y) LOOP  ;", "solution": "true"}, {"text": "v_rueck := test_check(123);", "solution": "true"}]}, {"id": 2705, "category": 10, "difficulty": 3, "text": "Welches Konzept bei den DML-Triggern erm\u00f6glicht die Pr\u00fcfung transitionaler Integrit\u00e4tsbedingungen?", "explanation": "Mittels der in den ROW-Triggern verf\u00fcgbaren Transitionsvariablen :OLD.Spaltenname / :NEW.Spaltenname ist es m\u00f6glich, den alten und den neuen Zustand von Spalten zu vergleichen. Dies stellt einen Zustands\u00fcbergangsvergleich dar, wie er in transitionalen Bedingungen formuliert wird.", "type": "text", "answers": [{"text": "Es sind die ...", "solution": "Transitionsvariablen"}]}, {"id": 2707, "category": 9, "difficulty": 2, "text": "Folgende Prozedur sei gegeben: \n\n  CREATE OR REPLACE PROCEDURE \n         test_proc (p1 IN NUMBER, p2 OUT NUMBER) ... ;\n\nWie kann diese Prozedur innerhalb eines PL/SQL-Programms aufgerufen werden?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. Daher sind als Aufrufparameter Konstanten und Variablen zul\u00e4ssig. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann. Daher sind als Aufrufparameter keine Konstanten sondern nur Variablen zul\u00e4ssig.  \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann. Daher sind als Aufrufparameter keine Konstanten sondern nur Variablen zul\u00e4ssig.", "type": "multiple-choice", "answers": [{"text": "test_proc (4711, 4122);", "solution": "false"}, {"text": "test_proc (4711, var2);", "solution": "true"}, {"text": "test_proc (var1, 4122);", "solution": "false"}, {"text": "test_proc (var1, var2);", "solution": "true"}]}, {"id": 2726, "category": 9, "difficulty": 3, "text": "Die beiden weitgehend unver\u00e4ndert dem objektrelationalen Modell zugrunde liegenden Modelle des SQL-92-Standards sowie des Basisobjektmodells werden beim SQL-2003-Standard um drei Typkonstruktoren erweitert. Nennen Sie die Namen ohne Sonderzeichen und in alphabetischer Reihenfolge.", "explanation": "Die beiden grundlegenden Konzepte, die im objektrelationalen SQL2003 zusammengef\u00fchrt wurden sind: SQL-92 und das Basisobjektmodell. (vgl. auch T\u00fcrker/Saake in \"Objektrelationale Datenbanken\", dpunkt-Verlag, 2006, Kap.3, insbesondere S.95) Diese beiden Modelle werden zudem um drei Typkonstruktoren erweitert:\n\nin SQL: ARRAY, MULTISET, REF\nbei Oracle REF, (NESTED) TABLE, VARRAY \n\nZu beachten ist insbesondere, dass sowohl bei Oracle wie auch beim SQL2003-Standard nicht das relationale Modell mit seiner Mengensemantik sondern das SQL-92-Modell mit seinem Verst\u00e4ndnis einer Tabelle als Multimenge zugrunde liegt.", "type": "text", "answers": [{"text": "Das ist zum einen das ...", "solution": "ARRAY"}, {"text": "Das ist zum anderen das ...", "solution": "MULTISET"}, {"text": "", "solution": "REF"}]}, {"id": 2727, "category": 9, "difficulty": 3, "text": "Was muss in einem JDBC-Programm beim Aufruf von gespeicherten Prozeduren und Funktionen mittels CallableStatement-Objekten mit OUT- und INOUT-Parametern zus\u00e4tzlich gemacht werden, was f\u00fcr IN-Parameter nicht durchgef\u00fchrt werden muss?", "explanation": "Anders als bei IN-Parametern, m\u00fcssen OUT- und INOUT-Parameter explizit registriert werden, damit der Datentyp des Parameters im Programm bekannt ist. Bei IN-Parametern ist der Datentyp \u00fcber den \u00dcbergabewert beim Aurfuf bekannt und wird nur f\u00fcr den Aufruf ben\u00f6tigt. F\u00fcr die R\u00fcckgabe von Werten nach der Prozedur-/Funktionsausf\u00fchrung m\u00fcssen jedoch die Datentypen der OUT- und INOUT-Parameter explizit bekannt gemacht werden. \n\n\nHier ein Beispiel:\n\nCREATE OR REPLACE PROCEDURE gibAnzahlEintraege(anzahl OUT INTEGER) \nBEGIN\n   SELECT COUNT( * )INTO anzahl FROM person;\nEND;\n\n\nCallableStatement cstmt = \n     con.prepareCall(\"{call gibAnzahlEintraege(?)}\"); \n//OUT- (und INOUT-) Parameter: Festlegung des Datentyps\ncstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n//Abfrage ausf\u00fchren\ncstmt.executeQuery();\n//Wert auslesen\nSystem.out.println(\"Anzahl der Eintr\u00e4ge: \"+ cstmt.getInt(1));", "type": "text", "answers": [{"text": "OUT- und INOUT-Parameter m\u00fcssen ______ werden.", "solution": "\r\n    registriert\r"}]}, {"id": 2732, "category": 9, "difficulty": 1, "text": "Welcher Status ist die Defaulteinstellung f\u00fcr den Auto-Commit-Modus bei Transaktionen f\u00fcr Datenbankverbindungen, die unter JDBC aufgebaut werden?", "explanation": "Nach Verbindungsaufbau ist der Modus defaultm\u00e4\u00dfig auf \n       Auto-Commit-Modus = true  \ngesetzt. D.h. jede einzelne SQL-Anweisung wird als Transaktion \u000b      behandelt, und nach dem Ausf\u00fchren automatisch festgeschrieben.\n\nUm mehr als eine SQL-Anweisung als Transaktion zu erlauben, muss der Auto-Commit-Modus ausgeschaltet werden:\n\n    verbindung.setAutoCommit(false);\nIn diesem Modus muss die Java-Anwendung selbst die Transaktionen mit COMMIT oder ROLLBACK abschlie\u00dfen.", "type": "multiple-choice", "answers": [{"text": "TRUE", "solution": "true"}, {"text": "FALSE", "solution": "false"}, {"text": "UNKNOWN", "solution": "false"}]}, {"id": 2736, "category": 9, "difficulty": 2, "text": "Das relationale Modell kann wie folgt definiert werden:   \nMULTISET ( ROW ( Basisdatentyp ) )", "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt  nicht", "solution": "true"}]}, {"id": 2740, "category": 9, "difficulty": 1, "text": "Ausgehend von der Klassifikation von Stonebraker und Morre sind objektrelationale DBS f\u00fcr welche Art von Anwendungen gut geeignet?\n\nQuelle: \nStonebraker, M., Morre, D.: \"Objektrelationale Datenbanken \u0096 Die n\u00e4chste gro\u00dfe Welle\", Hanser, M\u00fcnchen, 1999", "explanation": "Stonebraker und Morre haben in ihrem Buch \"Objektrelationale Datenbanken \u0096 Die n\u00e4chste gro\u00dfe Welle\" 1999 folgende Klassifikation postuliert, die sich gut bew\u00e4hrt hat. Interessant wird es, wenn es um Anwendungen geht, die mehrere dieser Eigenschaften abdecken. \n\n* Einfache Daten und wenig Anfragen erfordern Dateisysteme\n* Einfache Daten und viele Anfragen erfordern relationale DBMS\n* Komplexe Daten und viele Anfragen erfordern objektrelationale DBMS\n* Komplexe Daten und wenig Anfragen erfordern objektorientierte DBMS\n\nBei objektorientierten Datenbanksystemen bestehen \"Anfragen\" in der Regel aus Spezialoperationen, die mittels Methoden implementiert sind z.B. bei Geo-Informationssystemen: schneiden sich zwei Stra\u00dfen, haben zwei Orte die gleichen H\u00f6henmeter, \u00fcberlagern sich zwei Gesteinsformationen etc. ... \nund kaum aus Mengenanfragen, wie man es aus der relationalen Welt gewohnt ist.\nBei objektrelationalen Datenbanksystemen m\u00f6chte man komplexere Objektstrukturen analog zur Realit\u00e4t abbilden k\u00f6nnen und nicht wie im relationalen Modell Objekte ggf. \u00fcber mehrere Relationen verteilen. Es stehen weiterhin die Mengenanfragen zur Verf\u00fcgung aber auch \u00fcber die Methoden die Programmierung beliebige Spezialoperationen.", "type": "multiple-choice", "answers": [{"text": "einfache Daten und wenige Anfragen", "solution": "false"}, {"text": "einfache Daten und viele Anfragen", "solution": "false"}, {"text": "komplexe Daten und viele Anfragen", "solution": "true"}, {"text": "komplexe Daten und wenig Anfragen", "solution": "false"}]}, {"id": 2741, "category": 9, "difficulty": 2, "text": "Ausgehend von der Klassifikation von Stonebraker und Morre sind relationale DBS f\u00fcr welche Art von Anwendungen gut geeignet?\n\nQuelle: \nStonebraker, M., Morre, D.: \"Objektrelationale Datenbanken \u0096 Die n\u00e4chste gro\u00dfe Welle\", Hanser, M\u00fcnchen, 1999", "explanation": "Stonebraker und Morre haben in ihrem Buch \"Objektrelationale Datenbanken \u0096 Die n\u00e4chste gro\u00dfe Welle\" 1999 folgende Klassifikation postuliert, die sich gut bew\u00e4hrt hat. Interessant wird es, wenn es um Anwendungen geht, die mehrere dieser Eigenschaften abdecken. \n\n* Einfache Daten und wenig Anfragen erfordern Dateisysteme\n* Einfache Daten und viele Anfragen erfordern relationale DBMS\n* Komplexe Daten und viele Anfragen erfordern objektrelationale DBMS\n* Komplexe Daten und wenig Anfragen erfordern objektorientierte DBMS\n\nBei objektorientierten Datenbanksystemen bestehen \"Anfragen\" in der Regel aus Spezialoperationen, die mittels Methoden implementiert sind z.B. bei Geo-Informationssystemen: schneiden sich zwei Stra\u00dfen, haben zwei Orte die gleichen H\u00f6henmeter, \u00fcberlagern sich zwei Gesteinsformationen etc. ... \nund kaum aus Mengenanfragen, wie man es aus der relationalen Welt gewohnt ist.\nBei objektrelationalen Datenbanksystemen m\u00f6chte man komplexere Objektstrukturen analog zur Realit\u00e4t abbilden k\u00f6nnen und nicht wie im relationalen Modell Objekte ggf. \u00fcber mehrere Relationen verteilen. Es stehen weiterhin die Mengenanfragen zur Verf\u00fcgung aber auch \u00fcber die Methoden die Programmierung beliebige Spezialoperationen.", "type": "multiple-choice", "answers": [{"text": "einfache Daten und wenige Anfragen", "solution": "false"}, {"text": "einfache Daten und viele Anfragen", "solution": "true"}, {"text": "komplexe Daten und viele Anfragen", "solution": "false"}, {"text": "komplexe Daten und wenig Anfragen", "solution": "false"}]}, {"id": 3117, "category": 10, "difficulty": 3, "text": "Sie m\u00f6chten einen Trigger schreiben, der angesto\u00dfen wird, nachdem Zeilen aus einer Tabelle gel\u00f6scht werden und es sollen dabei die Anzahl der verbliebenen Zeilen der Tabelle angezeigt werden. Welchen Triggertyp ben\u00f6tigen Sie?", "explanation": "Der Ausf\u00fchrungszeitpunkt AFTER ist wichtig, da ein BEFORE-Trigger bei DELETE keinen Sinn macht. Ein zeilenorientierter Trigger w\u00fcrde das Mutating-Table-Problem ausl\u00f6sen.\n\n    Nach dem Ausf\u00fchrungsmodell von zeilenorientierten Triggern werden diese nur angesto\u00dfen, wenn sich tats\u00e4chlich Daten in der Datenbank ver\u00e4ndert haben. (siehe < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\"target = \"_blank\"> zeilenorientierten Trigger.. Die verbliebenen Datens\u00e4tze werden nur beim Ausf\u00fchrungszeitpunkt AFTER angezeigt (siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\" target=\"_blank\"> CREATE-TRIGGER )", "type": "multiple-choice", "answers": [{"text": "Einen zeilenorientierten Trigger", "solution": "false"}, {"text": "Einen befehlsorientierten Trigger", "solution": "true"}, {"text": "Einen AFTER-Trigger", "solution": "true"}, {"text": "Einen BEFORE-Trigger", "solution": "false"}, {"text": "Das kann ein Trigger zum Ausf\u00fchrungszeitpunkt  \"AFTER\" oder \"BEFORE\" sein.", "solution": "false"}, {"text": "Das kann ein zeilenorientierter oder ein befehlsorientierter  Trigger  sein.", "solution": "false"}]}, {"id": 3137, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden PL/SQL-Block:\n\n    SET SERVEROUTPUT ON\n\n    DECLARE\n\n    ang_rec angestellte%ROWTYPE\n\n    BEGIN\n\n    SELECT * into ang_rec from angestellte where ang_nr = 12:\n\n    IF SQL%NOTFOUND\n\n    THEN DBMS_OUTPUT:PUT_LINE (\"Keine Daten gefunden!\");\n\n    ELSE DBMS_OUTPUT:PUT_LINE (ang_rec.nachname);\n\n    \n\n    END IF ;\n\n    END;\n\n    \n\n    Welche Antwort(en) ist korrekt?", "explanation": "PL/SQL-Bl\u00f6cke werfen einen Fehler, wenn eine SELECT-Anweisung keine Datens\u00e4tze liefert. Dieser Fehler muss mit NO_ROWS_FOUND abgefangen werden.", "type": "multiple-choice", "answers": [{"text": "Der Block wirft einen Fehler, wenn der Angestellte mit der ang_nr 12 nicht existiert.", "solution": "true"}, {"text": "Der Block wird ausgef\u00fchrt und gibt NULL aus, wenn der Angestellte mit der ang_nr 12 nicht existiert.", "solution": "false"}, {"text": "Es wird ein Fehler geworfen, weil SELECT INTO keinen Record f\u00fcllen kann", "solution": "false"}, {"text": "Der Block wird ausgef\u00fchrt und gibt NO DATA FOUND aus.", "solution": "false"}]}, {"id": 3138, "category": 9, "difficulty": 1, "text": "Welche Aussage ist wahr \u00fcber Transaktionen in PL/SQL-Bl\u00f6cken?", "explanation": "PL/SQL-Blocke k\u00f6nnen als Bestandteil einer Transaktion geschrieben werden. Daher kann eine Transaktion auch mehrere Bl\u00f6cke umfassen.", "type": "multiple-choice", "answers": [{"text": "Eine Transaktion kann mehrere Blocke umfassen..", "solution": "true"}, {"text": "Ein Block kann immer nur eine einzelne Transaktion enthalten", "solution": "false"}, {"text": "Mit dem Schl\u00fcsselwort END wird ein PL/SQL-Block nicht nur beendet, sondern auch automatisch die zugeh\u00f6rige Transaktion mit einem COMMIT abgeschlossen.", "solution": "false"}]}, {"id": 3151, "category": 9, "difficulty": 3, "text": "Welche Tipps sollte man beim SQL-Tuning unter ORACLE verwenden, um die Performance zu steigern?", "explanation": "siehe ORACLE-<a target=\"_blank\" title=\"ORACLE-SQL-Tuning-Guide\" href=\"http://www.orafaq.com/tuningguide/\">SQL-Tuning-Guide", "type": "multiple-choice", "answers": [{"text": "SELECT * vermeiden", "solution": "true"}, {"text": "Indizes verwenden, falls m\u00f6glich", "solution": "true"}, {"text": "Unterabfragen  verwenden statt Joins", "solution": "false"}, {"text": "vollst\u00e4ndig qualifizierte Spaltennamen", "solution": "true"}, {"text": "Die Reihenfolge der Tabellen in der FROM-Klausel ist irrelevant", "solution": "false"}]}, {"id": 3116, "category": 10, "difficulty": 2, "text": "Welche Aussagen \u00fcber zeilenorientierter Trigger und befehlsorientierte Trigger sind richtig?", "explanation": "Nach dem Ausf\u00fchrungsmodell von zeilenorientierten Triggern werden diese \nnur angesto\u00dfen, wenn sich tats\u00e4chlich Daten in der Datenbank ver\u00e4ndert \nhaben. (siehe <a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\"target = \"_blank\"> zeilenorientierten Triggern  , bei befehlsorientierten Triggern ist das anders.", "type": "multiple-choice", "answers": [{"text": "Ein zeilenorientierter Trigger feuert immer mindestens einmal, sogar \nwenn keine Zeilen im feuernden DML-Ereignis (INSERT, UPDATE oder DELETE)\n ver\u00e4ndert werden.", "solution": "false"}, {"text": "Ein befehlsorientierter Triggern feuert immer mindestens einmal, sogar \nwenn keine Zeilen im feuernden DML-Ereignis (INSERT, UPDATE oder DELETE)\n ver\u00e4ndert werden.", "solution": "true"}, {"text": "Zeilenorientierter Trigger sind sinnvoll, wenn man auf \u00c4nderungen in einzelnen Datens\u00e4tzen reagieren m\u00f6chte.", "solution": "true"}, {"text": "Befehlsorientierte Triggern sind sinnvoll, wenn man auf \u00c4nderungen in einzelnen Datens\u00e4tzen reagieren m\u00f6chte.", "solution": "false"}]}, {"id": 3118, "category": 9, "difficulty": 1, "text": "Betrachten Sie den folgenden anonymen PL-SQL-Block: <font face=\"courier new\">SET SERVEROUTPUT ON;\n\n    DECLARE\n\n    v_alter NUMBER;\n\n    BEGIN\n\n    IF v_alter < 14 THEN\n\n    DBMS_OUTPUT.PUT_LINE(\"Ich bin ein Kind!\");\n\n    ELSE\n\n    DBMS_OUTPUT.PUT_LINE(\"Ich bin kein Kind mehr!\");\n\n    END;\n\n    Welche Aussagen sind wahr?", "explanation": "In der dreiwertigen Logik ergibt der Vergleich von einem Null Wert mit einem numerischen Wert UNKNOWN und die Ausgabe springt in der IF-Anweisung  in den ELSE-Ast (siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/IF\" target=\"_blank\">IF ).", "type": "multiple-choice", "answers": [{"text": "Der anonyme Block wird ausgef\u00fchrt und gibt nichts aus.", "solution": "false"}, {"text": "Der anonyme Block wirft einen Fehler, weil v_alter kein Wert zugewiesen wird.", "solution": "false"}, {"text": "Der anonyme Block wird ausgef\u00fchrt und springt in den ELSE-Ast.", "solution": "true"}, {"text": "Der anonyme Block wird ausgef\u00fchrt und f\u00fchrt den THEN-Ast aus.", "solution": "false"}]}, {"id": 3100, "category": 9, "difficulty": 2, "text": "Welche Join-Operator ist f\u00fcr gr\u00f6\u00dfere Datenmengen geignet, wenn kein Equi-Join vorliegt?", "explanation": "Das ist der Sort Merge Join, \nsiehe <a ==\"\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#MERGE_JOIN\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#MERGE_JOIN  .", "type": "multiple-choice", "answers": [{"text": "Cartesian Join", "solution": "false"}, {"text": "Nested Loop Join", "solution": "false"}, {"text": "Hash Join", "solution": "false"}, {"text": "Sort Merge Join", "solution": "true"}, {"text": "Outer Join", "solution": "false"}, {"text": "Index Join", "solution": "false"}]}, {"id": 3087, "category": 9, "difficulty": 1, "text": "In welcher Reihenfolge arbeitet der Cost-Based-Optimizer (CBO) von Oracle verschiedene Tabellen in der FROM-Klausel ab?", "explanation": "W\u00e4hrend der RBO (Ruled Based Optimizer) noch selbst\u00e4ndig die richtige Reihenfolge bestimmt, ist das beim CBO nicht mehr der Fall, \nsiehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\" target = \"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer . Die Abarbeitungsreihenfolge ist beim CBO von rechts nach links", "type": "multiple-choice", "answers": [{"text": "Abarbeitungsreihenfolge von rechts nach links", "solution": "true"}, {"text": "Abarbeitungsreihenfolge von links nach rechts", "solution": "false"}]}, {"id": 3096, "category": 9, "difficulty": 2, "text": "Welche Tabellenzugriffsmethode liest bei Oracle alle Datens\u00e4tze einer Tabelle sortiert ein?", "explanation": "Der Full Table Scan liest alle Zeilen einer Tabelle sortiert ein, siehe \n<a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen , beim Index Full Scan werden die Daten zus\u00e4tzlich sortiert \u00fcber den Index", "type": "multiple-choice", "answers": [{"text": "RowidScan", "solution": "false"}, {"text": "Full Table Scan", "solution": "false"}, {"text": "Index Full Scan", "solution": "true"}, {"text": "Hash Scan", "solution": "false"}, {"text": "Cluster Scan", "solution": "false"}]}, {"id": 3103, "category": 9, "difficulty": 1, "text": "Wie kann man einen Ausf\u00fchrungsplan unter Oracle beeinflussen?", "explanation": "Hints sind Hinweise f\u00fcr den Oracle-<a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\">Optimizer, wie er den <a class=\"wikilink\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Ausfuehrungsplan-einer-SQL-Abfrage\">Ausf\u00fchrungsplan erstellen und die SQL-Abfrage ausf\u00fchren soll. Ein Hint kann bestimmen, welche <a class=\"wikilink\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Ausfuehrungsplanoperationen\">Operation der <a class=\"wikilink\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\">Optimizer ausw\u00e4hlen und verwenden soll.\u00a0", "type": "multiple-choice", "answers": [{"text": "Durch das Setzen von Hints", "solution": "true"}, {"text": "Durch das L\u00f6schen von Statistiken", "solution": "false"}, {"text": "Durch den Umstieg auf den RBO (Rule Based Optimizer)", "solution": "false"}, {"text": "Durch Erh\u00f6hung der Systemprivilegien", "solution": "false"}]}, {"id": 3127, "category": 10, "difficulty": 2, "text": "Welche Aussage \u00fcber PL/SQL-Variable ist wahr?", "explanation": "Einfach Ausprobieren, ist allerdings auch logisch. Eine Variable mit dem NOT NULL CONSTRAINT muss einen Wert haben.", "type": "multiple-choice", "answers": [{"text": "Mit NOT NULL deklarierte Variablen m\u00fcssen initialisiert werden.", "solution": "true"}, {"text": "Mit NOT NULL deklarierte Variablen m\u00fcssen nicht initialisiert werden.", "solution": "false"}]}, {"id": 2634, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft der CONSTRAINT, dessen Semantik durch den Programmierer festgelegt wird?", "explanation": "Das Zweitschl\u00fcssel-Constraint hei\u00dft UNIQUE.\n\n    \n\n    Die \u00fcbrigen vier Constraints sind: FOREIGN KEY, CHECK, PRIMARY KEY und NOT NULL.", "type": "text", "answers": [{"text": "Das ist:", "solution": "CHECK"}]}, {"id": 3077, "category": 9, "difficulty": 1, "text": "Was versteht man unter Selektivit\u00e4t?", "explanation": "Unter der Selektivit\u00e4t versteht man das Verh\u00e4ltnis der zu findendenden Datens\u00e4tze gegen\u00fcber ihrer Gesamtzahl. Eine hohe Selektivit\u00e4t bedeutet also viele unterschiedliche Werte in einer Spalte.", "type": "multiple-choice", "answers": [{"text": "Verh\u00e4ltnis zu findender Datens\u00e4tze gegen\u00fcber ihrer Gesamtzahl.", "solution": "true"}, {"text": "Differenz aus der Anzahl der Datens\u00e4tze in einer Spalte minus der Gesamtzahl von Spalten in einer Tabelle", "solution": "false"}, {"text": "Produkt aus der Gesamtzahl der gefundenen Datens\u00e4tze dividiert durch die Gesamtzahl der Datens\u00e4tze in einer Spalte", "solution": "false"}]}, {"id": 2889, "category": 7, "difficulty": 2, "text": "Das Versicherungsb\u00fcro Schutzengel hat die Daten \u00fcber Versicherungspolicen in einer Relation \nVertraege(Vertrags_Nr, Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision) \ngespeichert, wobei die Vertrags_Nr der Prim\u00e4rschl\u00fcssel dieser Relation ist.\n\nBei der \u00dcberf\u00fchrung in eine Normalform entstehen die Relationen Kunden, Vertraege und Vertragsarten.", "explanation": "Aus der Relation lassen Vertraege(Vertrags_Nr, Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision) lassen sich folgende funktioanle Abh\u00e4ngigkeiten ableiten: \nVertrags_Nr -> Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision \nweil Vertrags_Nr einziges Prim\u00e4rschk\u00fcsselattribut ist \nKunden_NR -> Kundenname, Kundenadresse  \nVertragsart -> Abschlussprovision \nBei den beiden Abh\u00e4ngigkeiten von Kunden_NR und Vertragsart handelt es sich um transitive Abh\u00e4ngigkeiten, da diese wiederum von Kunden_NR abh\u00e4ngig sind. \nUnd daraus ergeben sich dann folgende drei Relationen: \nKunden (Kunden_NR (PK), Kundenname, Kundenadresse)  \nVertragsarten (Vertragsart (PK), Abschlussprovision) \nVertraege (Vertrags_Nr (PK), Vertragsart, Betrag, Kunden_NR)", "type": "multiple-choice", "answers": [{"text": "Es handelt sich um eine \u00dcberf\u00fchrung in die 1NF.", "solution": "false"}, {"text": "Es handelt sich um eine \u00dcberf\u00fchrung in die 3NF.", "solution": "true"}, {"text": "Es handelt sich um eine \u00dcberf\u00fchrung in die 2NF.", "solution": "false"}]}, {"id": 2604, "category": 9, "difficulty": 2, "text": "Was muss man tun, damit eine mit einer DROP-Anweisung gel\u00f6schtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) aus der Datenbank entfernt ist?", "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausf\u00fchrung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl \"ALTER TABLE tabellenname DROP persistent\" gibt es nicht und ebenso wenig die DROP-Option PERSISTENT.", "type": "multiple-choice", "answers": [{"text": "Nach der DROP-Anweisung ein COMMIT absetzen.", "solution": "false"}, {"text": "Gar nichts, weil bei der Ausf\u00fchrung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgef\u00fchrt wird.", "solution": "true"}, {"text": "Die Option PERSISTENT beim DROP-Befehl verwenden.", "solution": "false"}, {"text": "F\u00fcr jedes DB-Objekt gibt es einen ALTER-Befehl, der f\u00fcr die dauerhafte L\u00f6schung sorgt. Hier z.B. f\u00fcr eine Tabelle:\nALTER TABLE tabellenname DROP persistent;", "solution": "false"}]}, {"id": 3172, "category": 10, "difficulty": 2, "text": "Bei welchen Oracle-Triggern k\u00f6nnen die Transitionsvariablen :NEW.spaltenname beschrieben werden?", "explanation": "Die NEW-Transitionsvariablen k\u00f6nenn nur bei Zeilentriggern und zwar beim Ereignis \"INSERT\" und  UPDATE,  beschrieben werden. Beim Ereignis \"DELETE\"\" existiert keine NEW-Transitionsvariable. Statement-Trigger (Befehlstrigger) haben generell  keinen Zugriff auf  Transitionsvariable. INSTEAD-OF-Trigger k\u00f6nnen zwar Transitionvariable lesen, aber nicht \u00e4ndern.", "type": "multiple-choice", "answers": [{"text": "BEFORE INSERT FOR EACH ROW...", "solution": "true"}, {"text": "BEFORE UPDATE FOR EACH ROW...", "solution": "true"}, {"text": "BEFORE DELETE FOR EACH ROW...", "solution": "false"}, {"text": "STATEMENT-TRIGGER", "solution": "false"}, {"text": "INSTEAD-OF-Trigger", "solution": "false"}, {"text": "keiner von allen", "solution": "false"}]}, {"id": 2620, "category": 9, "difficulty": 1, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    Es wird versucht, folgenden Datensatz einzuf\u00fcgen in die leere Tabelle einzuf\u00fcgen:\n\n    INSERT INTO hierarchie VALUES (\"Hugo\",NULL);\n\n    Geben Sie den Inhalt der Tabelle nach dem Einf\u00fcgen des Datensatzes an!", "explanation": "Der Datensatz kann nicht eingef\u00fcgt werden, weil das Pflichteingabe-Constraint (NOT NULL) der Spalte Vorgesetzter fehl schl\u00e4gt.", "type": "text", "answers": [{"text": "Der Inhalt ist folgender: \n(f\u00fcr einen oder mehrere eingef\u00fcgte Datens\u00e4tze nur die beiden Namen mit Leerzeichen getrennt; f\u00fcr eine leere Tabelle das Wort: leer)", "solution": "leer"}]}, {"id": 2624, "category": 9, "difficulty": 3, "text": "Welche SQL-Befehle l\u00f6sen eine IMMEDIATE-Integrit\u00e4tspr\u00fcfung aus?", "explanation": "Ziel der Integrit\u00e4tspr\u00fcfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints gen\u00fcgen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erf\u00fcllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Pr\u00fcfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE l\u00f6sen also IMMEDIATE-Integrit\u00e4tspr\u00fcfung aus. \nCOMMIT beendet eine Transaktion und l\u00f6st damit eine DEFERRED-Integrit\u00e4tspr\u00fcfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie r\u00fcckg\u00e4ngig gemacht wird. Eine Integrit\u00e4tspr\u00fcfung ist daher unn\u00f6tig und wird nicht ausgef\u00fchrt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was daf\u00fcr sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integrit\u00e4tspr\u00fcfung ausl\u00f6sen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Pr\u00fcfung wird damit nicht ausgel\u00f6st.", "type": "multiple-choice", "answers": [{"text": "ROLLBACK", "solution": "false"}, {"text": "DELETE", "solution": "true"}, {"text": "SELECT", "solution": "false"}, {"text": "INSERT", "solution": "true"}, {"text": "CHECK", "solution": "false"}, {"text": "UPDATE", "solution": "true"}, {"text": "COMMIT", "solution": "false"}, {"text": "SAVE", "solution": "false"}, {"text": "DROP", "solution": "false"}, {"text": "CREATE", "solution": "false"}, {"text": "ALTER", "solution": "false"}]}, {"id": 2630, "category": 9, "difficulty": 1, "text": "Wann wird eine UPDATE-Anweisung mit WHERE-Bedingung ausgef\u00fchrt?", "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\nAchtung: Bei der Integrit\u00e4tspr\u00fcfung ist das etwas anders: \nEin Constraint in SQL ist erf\u00fcllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal gepr\u00fcft und damit \u00fcber der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt w\u00fcrde, k\u00f6nnte der CREATE TABLE gar nicht ausgef\u00fchrt werden. Der andere Punkt sind die (potentiell) leeren Spalten f\u00fcr die die Constraints trotzdem erf\u00fcllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschl\u00fcsselspalte leer sein oder UNIQUE-Spalten d\u00fcrfen leer sein, ohne dass das Constraint gleich verletzt ist.", "type": "multiple-choice", "answers": [{"text": "Die, f\u00fcr die die WHERE-Bedingung zu FALSE ausgewertet wird.", "solution": "false"}, {"text": "Die, f\u00fcr die die WHERE-Bedingung zu UNKNOWN ausgewertet wird.", "solution": "false"}, {"text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.", "solution": "true"}]}, {"id": 2633, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft der CONSTRAINT, wenn eine Spalte Zweitschl\u00fcssel ist?", "explanation": "Das Zweitschl\u00fcssel-Constraint hei\u00dft UNIQUE.\n\n    \n\n    Die \u00fcbrigen vier Constraints sind: FOREIGN KEY, CHECK, PRIMARY KEY und NOT NULL.", "type": "text", "answers": [{"text": "Das ist:", "solution": "UNIQUE"}]}, {"id": 3739, "category": 9, "difficulty": 1, "text": "Welche(s) Datenbankobjekte(e) sind/ ist unabh\u00e4ngig von einer Tabelle?", "explanation": "Sequenzen  k\u00f6nnen auch in mehreren Tabellen verwendet werden, auch wenn das in der Regel wenig Sinn macht.", "type": "multiple-choice", "answers": [{"text": "SEQUENCE", "solution": "true"}, {"text": "CONSTRAINT", "solution": "false"}, {"text": "INDEX", "solution": "false"}, {"text": "VIEW", "solution": "false"}]}, {"id": 3740, "category": 9, "difficulty": 1, "text": "F\u00fcr welche Datenbankobjekte gibt es einen CREATE-Befehl?", "explanation": "Constraints werden mit der Tabelle angelegt, alle anderen Objekte mittels CREATE ....", "type": "multiple-choice", "answers": [{"text": "SEQUENCE", "solution": "true"}, {"text": "CONSTRAINT", "solution": "false"}, {"text": "INDEX", "solution": "true"}, {"text": "VIEW", "solution": "true"}]}, {"id": 2618, "category": 9, "difficulty": 2, "text": "Betrachten Sie die folgende Definition einer Sequence:\nCREATE SEQUENCE Kun_seq\n        INCREMENT BY 2\n    START WITH 3\n    NOMAXVALUE\n    NOCYCLE\n    CACHE 10;", "explanation": "Die Sequenz startet mit 3, z\u00e4hlt immer 2 hoch, daher: 3 5 7 9 11 \nDie Caching-Option steuert das Zwischenspeichern von Sequenznummer, eine interne Optimierung und spielt bei der Nummernvergabe keine Rolle.", "type": "text", "answers": [{"text": "Geben Sie die ersten 5 Ziffern in Folge und nur mit Leerzeichen getrennt an, die diese Sequenz erzeugt.", "solution": "3 5 7 9 11"}]}, {"id": 2555, "category": 8, "difficulty": 1, "text": "Bei einer Projektion wird eine n-stellige Relation auf eine (n-m)-stellige Relation abgebildet, mit m>=0.", "explanation": "Die Projektion ist die Operation der RA, die die Ergebnismenge auf einzelne Attribute aus einer Relation beschr\u00e4nken kann.  \nListet man bei der Projektion alle Attributnamen der Relation auf, so w\u00e4re das der Fall, dass m=0 ist (eine recht \u00fcberfl\u00fcssige Operation, da die Eingangstupelmenge identisch ist mit der Ergebnismenge). Listet man hingegen nur einige Attributnamen auf, so ist m>0.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2566, "category": 9, "difficulty": 3, "text": "Welche Anforderungen muss ein \"vereinigungskonformer\" SQL-Operator  erf\u00fcllen? (relevant f\u00fcr die Durchf\u00fchrung von Mengenoperationen)", "explanation": "Die Forderung in SQL \"<a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt f\u00fcr alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) m\u00fcssen die gleichen Spaltendefinitionen aufweisen, d.h.:\n\nDie Anzahl der Spalten muss \u00fcbereinstimmen.\nDie Datentypen der der Spalten m\u00fcssen gleich sein. \nDie Reihenfolge der Spalten muss \u00fcbereinstimmen.\n\nAchtung: In der RA mussten die Spalten auch noch gleich hei\u00dfen, das ist hier in SQL nicht mehr notwendig. Es werden in SQL die Spaltennamen der links vom Operator stehenden Tabelle verwendet.", "type": "multiple-choice", "answers": [{"text": "Die Anzahl der Spalten muss \u00fcbereinstimmen.", "solution": "true"}, {"text": "Die Spalten m\u00fcssen gleich hei\u00dfen.", "solution": "false"}, {"text": "Die Datentypen der der Spalten m\u00fcssen gleich sein.", "solution": "true"}, {"text": "Die Reihenfolge der Spalten muss \u00fcbereinstimmen.", "solution": "true"}, {"text": "Es gibt keine solche Anforderung in SQL.", "solution": "false"}]}, {"id": 2568, "category": 8, "difficulty": 3, "text": "Mit welchen Operatoren aus der relationalen Algebra l\u00e4sst sich der Divisions-Operator simulieren?", "explanation": "Die Division l\u00e4sst sich aus den relationalen Grundoperationen Selektion, Projektion, kartesisches Produkt und Differenz ableiten.", "type": "multiple-choice", "answers": [{"text": "Selektion", "solution": "true"}, {"text": "Projektion", "solution": "true"}, {"text": "Theta-Join", "solution": "false"}, {"text": "Natural Join", "solution": "false"}, {"text": "Kartesisches Produkt", "solution": "true"}, {"text": "Outer Join (Left, Right, Full)", "solution": "false"}, {"text": "Vereinigung", "solution": "false"}, {"text": "Durchschnitt", "solution": "false"}, {"text": "Differenz", "solution": "true"}]}, {"id": 2569, "category": 9, "difficulty": 3, "text": "Eine Menge von Tabellen besitzt die Eigenschaft, dass jede Tabelle einen Prim\u00e4rschl\u00fcssel besitzt.", "explanation": "Eine Menge von Tabellen R1,...,Rk besitzt die Entity-Integrit\u00e4t, wenn jede Tabelle einen Prim\u00e4rschl\u00fcssel besitzt.", "type": "text", "answers": [{"text": "Diese Eigenschaft hei\u00dft", "solution": "Entity-Integrit\u00e4t"}]}, {"id": 2575, "category": 8, "difficulty": 2, "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS1  S4 \nC    Y\nD    Z", "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich hei\u00dfen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Hei\u00dfen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verkn\u00fcpft.", "type": "text", "answers": [{"text": "Geben Sie die Attributwerte in Gro\u00dfbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.", "solution": "C Y Y"}]}, {"id": 2639, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Vorname FROM KUNDEN ORDER BY Nachname ASC\"", "explanation": "Die Sortierung kann ausgef\u00fchrt werden, weil die ORDER BY-Klausel als vorletzte Klausel ausgef\u00fchrt wird, unmittelbar vor der letzten Klausel der SELECT-Klausel. Daher kann auch \u00fcber Spalten sortiert werden, die anschlie\u00dfend mittels der SELECT-Klausel \"weg projiziert\" werden.\n\n    Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.", "type": "multiple-choice", "answers": [{"text": "ist nicht ausf\u00fchrbar, da \u00fcber eine Spalte \"Nachname\" sortiert wird, die gar nicht angezeigt wird.", "solution": "false"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "true"}]}, {"id": 2640, "category": 9, "difficulty": 1, "text": "Der Ausdruck \"SELECT Vorname FROM KUNDEN ORDER BY Nachname DESC\"", "explanation": "Die Sortierung kann ausgef\u00fchrt werden, weil die ORDER BY-Klausel als vorletzte Klausel ausgef\u00fchrt wird, unmittelbar vor der letzten Klausel der SELECT-Klausel. Daher kann auch \u00fcber Spalten sortiert werden, die anschlie\u00dfend mittels der SELECT-Klausel \"weg projiziert\" werden.\n\n    Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel.", "type": "multiple-choice", "answers": [{"text": "ist nicht ausf\u00fchrbar, da \u00fcber eine Spalte \"Nachname\" sortiert wird, die gar nicht angezeigt wird.", "solution": "false"}, {"text": "bewirkt eine absteigende Sortierung \u00fcber den Nachnamen", "solution": "true"}, {"text": "bewirkt eine aufsteigende Sortierung \u00fcber den Nachnamen", "solution": "false"}]}, {"id": 2641, "category": 9, "difficulty": 1, "text": "Welche Semantik hat folgender SELECT-Ausdruck? \n\nSELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'K\u00f6ln'\nOR    NOT (Ort = 'Gummersbach')", "explanation": "Der Begriff Semantik meint die Aufgabenstellung, die zu dieser SELECT-Anfrage geh\u00f6rt. \nDie Semantik obiger Anfrage ist: \"Zeigen Sie die Kunden, die nicht in Gummersbach wohnen oder in K\u00f6ln leben?\"", "type": "multiple-choice", "answers": [{"text": "Welche Kunden wohnen weder in Gummersbach noch in K\u00f6ln?", "solution": "false"}, {"text": "Welche Kunden wohnen nicht in Gummersbach aber in K\u00f6ln?", "solution": "false"}, {"text": "Welche Kunden wohnen nicht in Gummersbach oder in K\u00f6ln?", "solution": "true"}]}, {"id": 2584, "category": 8, "difficulty": 2, "text": "Wie hei\u00dfen Programmiersprachen, bei denen der Programmierer den L\u00f6sungsweg im Detail und Schritt f\u00fcr Schritt programmmieren muss?", "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.", "type": "text", "answers": [{"text": "Die Programmiersprachen hei\u00dfen: (Kleinbuchstaben)", "solution": "prozedural"}]}, {"id": 3683, "category": 11, "difficulty": 1, "text": "Welche Arten von Sperren gibt es in SQL?", "explanation": "Lesesperren (read lock, shared lock oder SLOCK) auf Objekt und Schreibsperren (write lock, exclusive lock oder XLOCK)\n\n    geh\u00f6ren zum SQL-Standard.", "type": "multiple-choice", "answers": [{"text": "Lesesperre", "solution": "true"}, {"text": "Schreibsperre", "solution": "true"}, {"text": "COMMIT-Sperre", "solution": "false"}, {"text": "ROLLBACK-Sperre", "solution": "false"}, {"text": "Transaktionssperre", "solution": "false"}]}, {"id": 3684, "category": 11, "difficulty": 1, "text": "Welche Aussagen \u00fcber Sperren in SQL sind wahr?", "explanation": "Lesesperren (read lock, shared lock oder SLOCK) auf Objekt und Schreibsperren (write lock, exclusive lock oder XLOCK)\n\n    geh\u00f6ren zum SQL-Standard. Lesesperren k\u00f6nen mehrfach auf eine Objekt ausgef\u00fchrt werden, Schreibsperren nicht.", "type": "multiple-choice", "answers": [{"text": "Mehrere Lesesperren auf dem gleichen Objekt x sind erlaubt.", "solution": "true"}, {"text": "Mehrere Schreibsperren auf dem gleichen Objekt x  sind erlaubt.", "solution": "false"}]}, {"id": 3686, "category": 11, "difficulty": 1, "text": "Aus welchen Phasen besteht das 2PL-Sperrprotokoll?", "explanation": "In der Wachstumspahse werden alle Sperren gesetzt, danach die \u00c4nderungn durchgef\u00fchrt und in der Schrumpfungsphase werden alle Sperren aufgehoben.", "type": "text", "answers": [{"text": "Bitte in alpahabetischer Reihenfolge ohne Komma aufschreiben!", "solution": "\r\n    Schrumpfungsphase Wachstumsphase\r"}]}, {"id": 2612, "category": 9, "difficulty": 2, "text": "Um welchen Typ einer Integrit\u00e4tsbedingung handelt es sich hier?\n\nInnerhalb eines Jahres d\u00fcrfen die Ausgaben der Abteilung nicht st\u00e4rker steigen, als die vom Bundesministrium prognostizierte Preissteigerungsrate.", "explanation": "Die Integrit\u00e4tsbedingungen k\u00f6nnen statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integrit\u00e4tsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erf\u00fcllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze \u00fcbersteigen darf. Dazu geh\u00f6ren die Entity-Integrit\u00e4t und die referentielle Integrit\u00e4t. Sie k\u00f6nnen mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integrit\u00e4tsbedingungen beschreiben, welche Bedingungen beim \u00dcbergang eines Zustands in einen anderen erf\u00fcllt sein m\u00fcssen. Ein Beispiel w\u00e4re, dass das Gehalt eines Angestellten nur erh\u00f6ht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur \u00fcber Datenbanktrigger realisieren. \nTemporale dynamische Integrit\u00e4tsbedingungen sind Anforderungen, die an eine Folge von Zustands\u00fcberg\u00e4ngen gestellt werden. Eine solche Bedingung k\u00f6nnte f\u00fcr die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den g\u00e4ngigen SQL-Konzepten unterst\u00fctzt. Die L\u00f6sung dieses Problems m\u00fcsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.", "type": "multiple-choice", "answers": [{"text": "statische Bedingung", "solution": "false"}, {"text": "dynamische, transitionale Bedingung", "solution": "false"}, {"text": "statische, transitionale Bedingung", "solution": "false"}, {"text": "dynamische, temporale Bedingung", "solution": "true"}, {"text": "statische, temporale Bedingung", "solution": "false"}]}, {"id": 2621, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    \n\n    Welche Aussagen sind wahr?", "explanation": "Das Problem hier ist: Die leere Tabelle Hierarchie kann gar nicht gef\u00fcllt werden mit Datens\u00e4tzen.\n\n    \n\n    F\u00fcgt man erst (\"Emil\", \"Hugo\") ein, so schl\u00e4gt dies fehl, weil die Fremdschl\u00fcsselbeziehung verletzt ist. Es gibt keinen Master-Datensatz mit Hugo als Angestellten z.B.: (\"Hugo\", ...).\n\n    \n\n    F\u00fcgt man erst (\"Hugo\", NULL) ein, so schl\u00e4gt dies fehl, weil die NOT NULL-Bedingung f\u00fcr die Vorgesetzten-Spalte verletzt ist.\n\n    \n\n    Da beide Constraints als IMMEDIATE definiert sind (Default, wenn eine Angabe des Pr\u00fcfungszeitpunkts fehlt) macht es keinen Unterschied, ob man beide Einf\u00fcgungen in einer Transaktion ablaufen l\u00e4sst.\n\n    \n\n    Wenn man beide Constraints als DEFERRED definiert h\u00e4tte, dann w\u00e4re es jedoch unerheblich, ob erst der eine oder erst der andere Satz eingef\u00fcgt w\u00fcrde, dann w\u00fcrden also beide Einf\u00fcgereihenfolgen funktionieren. Es w\u00fcrde ja erst zum COMMIT-Zeitpunkt gepr\u00fcft, ob der Endzustand ok ist und keine Zwischenzust\u00e4nde.\n\n    \n\n    Der Datensatz kann nicht eingef\u00fcgt werden, weil das Pflichteingabe-Constraint (NOT NULL) der Spalte Vorgesetzter fehl schl\u00e4gt. Der Datensatz kann nicht eingef\u00fcgt werden, weil die Fremdschl\u00fcsselbeziehung mit dem Wert \"Emil\" fehlschl\u00e4gt. Es gibt ja noch keinen anderen Datensatz in der Tabelle.", "type": "multiple-choice", "answers": [{"text": "Der Datensatz ('Emil', 'Hugo') kann in die leere Tabelle eingef\u00fcgt werden. ", "solution": "false"}, {"text": "Der Datensatz ('Hugo', NULL) kann in die leere Tabelle eingef\u00fcgt werden. \nNULL bezeichnet die leere Spalte.", "solution": "false"}, {"text": "Innerhalb einer Transaktion k\u00f6nnen die beiden Datens\u00e4tze ('Hugo', NULL) ('Emil', 'Hugo') in dieser Reihenfolge in die leere Tabelle eingef\u00fcgt werden. ", "solution": "false"}, {"text": "Innerhalb einer Transaktion k\u00f6nnen die beiden Datens\u00e4tze ('Emil', 'Hugo') ('Hugo', NULL) in dieser Reihenfolge in die leere Tabelle eingef\u00fcgt werden. ", "solution": "false"}, {"text": "Es kann gar kein Datensatz in die leere Tabelle eingef\u00fcgt werden.", "solution": "true"}]}, {"id": 2622, "category": 9, "difficulty": 3, "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Vorgesetzte\n\n    ( Mitarbeiter VARCHAR2(20),\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Mitarbeiter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Vorgesetzte (Mitarbeiter) ON DELETE CASCADE);\n\n    Diese Tabelle hat ein Problem: Es k\u00f6nnen keine Datens\u00e4tze eingef\u00fcgt werden. \u00dcberlegen Sie, warum! Welche Aktionen, jede einzeln f\u00fcr sich, k\u00f6nnten dieses Problem l\u00f6sen?", "explanation": "Das Einf\u00fcge-Problem besteht darin, dass kein Mitarbeiter-Datensatz mit Vorgesetztem (z.B. (\"Hugo\",\"Anton\")) als erste eingef\u00fcgt werden kann, weil dann die Fremdschl\u00fcsselbeziehung verletzt ist. Es fehlt ein Master-Datensatz f\u00fcr den Anton.\n\n    Wird hingegen versucht, den Datensatz des obersten Chefs, der ja keinen Vorgesetzten hat (z.B. (\"Anton\", NULL)), einzuf\u00fcgen, dann verweigert das NOT NULL-Constraint auf der Vorgesetzten-Spalte den Datensatz.\n\n    \n\n    Jede der folgenden Aktionen l\u00f6st das Einf\u00fcge-Problem der Tabelle Vorgesetzter:\n\n    - Die Spalte Vorgesetzter als NULL-Spalte definieren.\n\n    - Die Spalte Vorgesetzter ohne FOREIGN KEY definieren.\n\n    - Wenigstens eines der Constraints als DEFERRED programmieren.\n\n    \n\n    Irgendein oder mehrere Constraints als IMMEDIATE zu programmieren hilft nicht weiter, das sind die Constraints bereits. IMMEDIATE ist der Default-Pr\u00fcfungszeitpunkt, wenn nichts programmiert ist.\n\n    Wird hingegen eines oder auch mehrere Constraints als DEFERRED programmiert, so wird dieses bzw. diese erst dann gepr\u00fcft, wenn die Transaktion mit COMMIT abgeschlossen wird. Etwaige fehlerhafte Zwischenzust\u00e4nde w\u00fcrden dann nicht bemerkt. Aber hier w\u00fcrde es bereits gen\u00fcgen, wenn eines der problematischen Constraints als DEFERRED definiert w\u00fcrde.\n\n    \n\n    Der Verzicht auf die ON DELETE CASCADE-Klausel hilft \u00fcberhaupt nicht weiter, weil sie mit dem Problem nichts zu tun hat.\n\n    \n\n    Gleiches gilt f\u00fcr das PRIMARY KEY-Constraint.\n\n    \n\n    Auf die REFERENCES-Klausel zu verzichten geht rein syntaktisch nicht, weil sonst die FOREIGN KEY-Klausel nicht mehr richtig w\u00e4re.", "type": "multiple-choice", "answers": [{"text": "Wenigstens eines der Constraints als IMMEDIATE programmieren.", "solution": "false"}, {"text": "Es m\u00fcssen beide Constraints als IMMEDIATE programmiert werden.", "solution": "false"}, {"text": "Die Spalte Vorgesetzter ohne ON DELETE CASCADE-Klausel definieren.", "solution": "false"}, {"text": "Die Spalte Vorgesetzter als NULL-Spalte definieren.", "solution": "true"}, {"text": "Die Spalte Vorgesetzter ohne FOREIGN KEY definieren.", "solution": "true"}, {"text": "Die Spalte Vorgesetzter ohne REFERENCES-Klausel definieren.", "solution": "false"}, {"text": "Die Spalte Mitarbeiter ohne PRIMARY KEY definieren.", "solution": "false"}, {"text": "Wenigstens eines der Constraints als DEFERRED programmieren.", "solution": "true"}, {"text": "Es m\u00fcssen beide Constraints als DEFERRED programmiert werden.", "solution": "false"}]}, {"id": 2829, "category": 9, "difficulty": 3, "text": "Betrachten Sie eine Tabelle Kunden (K_ID, Nachname, Vorname, Kontonummer, BLZ, ....) .\n\nMit welcher SELECT-Anweisung kann mann die Anzahl der Kunden bestimmen, deren BLZ (Bankleitzahl) leer, das hei\u00dft NULL ist?", "explanation": "Alle Antworten sind syntaktisch richtg, aber nur die Antwort \n\nSELECT COUNT(NVL(BLZ, 0))\nFROM KUNDEN \nWHERE BLZ IS NULL;\n\nliefert das gew\u00fcnschte Ergebnis. \n\nNull-Werte werden nicht mit = NULL abgefragt. Die DISTINCT-Abfrage liefert die falsche Zahl. Die Funktion NVL ist hier notwendig, da sonst COUNT(BLZ) = 0 ist, wenn eine BLZ in der Spalte den Wert NULL hat", "type": "multiple-choice", "answers": [{"text": "SELECT COUNT(BLZ)\nFROM KUNDEN \nWHERE BLZ IS NULL;", "solution": "false"}, {"text": "SELECT COUNT(BLZ)\nFROM KUNDEN \nWHERE BLZ = NULL;", "solution": "false"}, {"text": "SELECT COUNT(DISTINCT BLZ)\nFROM KUNDEN \nWHERE BLZ IS NULL;", "solution": "false"}, {"text": "SELECT COUNT(NVL(BLZ, 0))\nFROM KUNDEN \nWHERE BLZ IS NULL;", "solution": "true"}]}, {"id": 2540, "category": 10, "difficulty": 2, "text": "Es ist f\u00fcr die Linien-Tabelle folgender Constraint gegeben: ALTER TABLE linien ADD CONSTRAINT linien_typ_check CHECK (UPPER(linien_typ) IN (\"BA\", \"BU\", \"SB\")) INITIALLY DEFERRED; Kann dieser Constraint auch mit Triggern gel\u00f6st werden?", "explanation": "Nein, weil es sich um eine DEFERRED-Pr\u00fcfung handelt und daf\u00fcr fehlt ein BEFORE-COMMIT-Trigger.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "false"}, {"text": "nein", "solution": "true"}]}, {"id": 2541, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgende Typdefinition:\n\nCREATE OR REPLACE TYPE adresse_t\nAS\n   OBJECT (Ort varchar2 (50),\n           PLZ integer,\n           strasse varchar2 (50),\n           hausnummer integer);\n\nIst diese Typedefinition ORACLE-spezifisch?", "explanation": "Die Klausel \"AS OBJECT\" geh\u00f6rt nicht zum SQL-Standard.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "true"}, {"text": "nein", "solution": "false"}]}, {"id": 2606, "category": 9, "difficulty": 3, "text": "Ein Tabellen-Constraint (TABLE CONSTRAINT) kann folgende Klauseln haben:", "explanation": "FALSCH ist:\nDie REFERENCES-Klausel gibt es nur bei den Spalten-Constraints, als Tabellen-Constraint hei\u00dft diese Funktion FOREIGN KEY. Die NULL-Klausel gibt es ausschlie\u00dflich als Spalten-Constraint.\n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n\n ::= \nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... )\n\n| CHECK (  )\n\n\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]", "type": "multiple-choice", "answers": [{"text": "NULL", "solution": "false"}, {"text": "CHECK", "solution": "true"}, {"text": "UNIQUE", "solution": "true"}, {"text": "PRIMARY KEY", "solution": "true"}, {"text": "FOREIGN KEY", "solution": "true"}, {"text": "REFERENCES", "solution": "false"}]}, {"id": 2642, "category": 9, "difficulty": 2, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr}\n\nAbteilungen hat den Prim\u00e4rschl\u00fcssel Abt_nr und den Fremdschl\u00fcssel Leiter_Ang_Nr.\nAngestellte hat den Prim\u00e4rschl\u00fcssel Ang_nr und den Fremdschl\u00fcssel Abt_Nr.\n\nWelche der folgenden SELECT-Anweisungen liefern das gleiche Ergebnis?", "explanation": "RICHTIG sind: \nSELECT *\nFROM Angestellte NATURAL JOIN Abteilungen; \n und \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr; \n\ndenn der NATURAL JOIN verkn\u00fcpft alle Spalten, die gleich hei\u00dfen, Abt_NR und Ort, auf Gleichheit und mit AND.\n \nDie Semantik ist: \"Welche Mitarbeiter arbeiten in \nAbteilungen, die im Wohnort des Mitarbeiters liegen?\"\n\n\nFALSCH ist: \nSELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;\nweil nur \u00fcber eine der beiden gleich lautenden Spalte verkn\u00fcpft wird und nicht \u00fcber beide.", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;", "solution": "false"}, {"text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr;", "solution": "true"}, {"text": "SELECT *\nFROM Angestellte NATURAL JOIN Abteilungen;", "solution": "true"}]}, {"id": 2613, "category": 9, "difficulty": 3, "text": "Welches SQL-Constraint bietet die M\u00f6glichkeit zur Fehlerkorrektur?", "explanation": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird. Dieses Verhalten wird f\u00fcr Integrit\u00e4tsfehler ausschlie\u00dflich bei NOT NULL, PRIMARY KEY, UNIQUE ausgef\u00fchrt. \n\nLediglich die Fremdschl\u00fcssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabh\u00e4ngig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik, wenn Masterdatens\u00e4tze gel\u00f6scht werden, f\u00fcr die noch abh\u00e4ngige Detail-Datens\u00e4tze bestehen. Es besteht dann die M\u00f6glichkeit, z.B. die abh\u00e4ngigen Detaildatens\u00e4tze ebenfalls zu l\u00f6schen (CASCADE) oder deren Fremdschl\u00fcsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION", "type": "text", "answers": [{"text": "Bitte geben Sie den deutschsprachigen Namen ein (ohne Zus\u00e4tze wie Bedignung oder Constraint):", "solution": "Fremdschl\u00fcssel"}]}, {"id": 2617, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgende Definition einer Sequence:\nCREATE SEQUENCE Kun_seq\n        INCREMENT BY 1\n    START WITH 1\n    NOMAXVALUE\n    NOCYCLE\n    CACHE 10;", "explanation": "Die Sequenz startet mit 1, z\u00e4hlt immer 1 hoch, daher: 1 2 3 4 5 6 7 8 9 10 \nDie Caching-Option steuert das Zwischenspeichern von Sequenznummer, eine interne Optimierung und spielt bei der Nummernvergabe keine Rolle.", "type": "text", "answers": [{"text": "Geben Sie die ersten 10 Ziffern in Folge und nur mit Leerzeichen getrennt an, die diese Sequenz erzeugt.", "solution": "1 2 3 4 5 6 7 8 9 10"}]}, {"id": 2643, "category": 9, "difficulty": 3, "text": "In welcher Reihenfolge werden die Klauseln eines SELECT-Befehls ausgef\u00fchrt bzw. geparst? (Geben Sie Zahlen von 1 bis 6 an!)", "explanation": "Die Reihenfolge Ausf\u00fchrung der Klauseln einer SELECT-Anfrage sind:\n\n    6. SELECT ...\n\n    1. FROM ...\n\n    2. [ WHERE ... ]\n\n    3. [ GROUP BY ... ]\n\n    4. [ HAVING ... ]\n\n    5. [ ORDER BY ... ]\n\n    Die eckigen Klammern geben die Optionalit\u00e4t der Klauseln an.", "type": "text", "answers": [{"text": "WHERE", "solution": "2"}, {"text": "FROM", "solution": "1"}, {"text": "ORDER BY", "solution": "5"}, {"text": "HAVING", "solution": "4"}, {"text": "GROUP BY", "solution": "3"}, {"text": "SELECT", "solution": "6"}]}, {"id": 2649, "category": 9, "difficulty": 1, "text": "Welche der beiden folgenden SELECT-Anweisungen ist liefert das gleiche Ergebnis, wenn die Tabelle TEST die Spalte \"Spalte1\" hat?", "explanation": "Eine ORDER_BY-Klausel kann in zwei SELECTs, die mit UNION verkn\u00fcpft werden, nicht verwendet werden.\n\nBei einem UNION werden doppelte Tupel unterdr\u00fcckt.", "type": "multiple-choice", "answers": [{"text": "SELECT Spalte1 FROM TEST", "solution": "true"}, {"text": "SELECT Spalte_1 FROM TEST ORDER BY Spalte1\nUNION\nSELECT Spalte_2 FROM TEST ORDER BY Spalte1", "solution": "false"}, {"text": "SELECT Spalte1 FROM TEST\nUNION\nSELECT Spalte1 FROM TEST", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 2614, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber das Fehlerverhalten des SQL-Integrit\u00e4tspr\u00fcfungskonzepts sind wahr?", "explanation": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird. Dieses Verhalten wird f\u00fcr Integrit\u00e4tsfehler ausschlie\u00dflich bei NOT NULL, PRIMARY KEY, UNIQUE ausgef\u00fchrt. \n\nLediglich die Fremdschl\u00fcssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabh\u00e4ngig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik, wenn Masterdatens\u00e4tze gel\u00f6scht werden, f\u00fcr die noch abh\u00e4ngige Detail-Datens\u00e4tze bestehen. Es besteht dann die M\u00f6glichkeit, z.B. die abh\u00e4ngigen Detaildatens\u00e4tze ebenfalls zu l\u00f6schen (CASCADE) oder deren Fremdschl\u00fcsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION", "type": "multiple-choice", "answers": [{"text": "Im Falle eines Integrit\u00e4tsfehlers wird mit einer Warnmeldung reagiert, die Datenmanipulation persistent in der Datenbasis gespeichert.", "solution": "false"}, {"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und die Datenmanipulation abgebrochen wird.(IMMEDIATE sowie DEFERRED)", "solution": "false"}, {"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird.", "solution": "true"}, {"text": "Das \"Normalverhalten\" bei einem Integrit\u00e4tsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Pr\u00fcfung die ganze Transaktion zur\u00fcckgerollt wird bzw. bei einer DEFERRED-Pr\u00fcfung die Datenmanipulation abgebrochen wird.", "solution": "false"}, {"text": "Das Fremdschl\u00fcsel-Constraint bietet die Option, dass das DBMS eine Fehlerkorrektur durchf\u00fchrt.", "solution": "true"}, {"text": "Die Constraints PRIMARY KEY, FOREIGN KEY und UNIQUE bieten die Option, dass das DBMS eine Fehlerkorrektur durchf\u00fchrt.", "solution": "false"}]}, {"id": 2549, "category": 42, "difficulty": 2, "text": "Betrachten Sie eine Relation mit drei Spalten. Wie viele Indizes kann man anlegen?", "explanation": "Die Reihenfolge der Attribute spielt ja eine Rolle, daher 15 Kombinationsm\u00f6glichkeiten bei drei Spalten a, b, c:\n\n    a, b, c,\n\n    ab, ac, ba, bc, ca, cb,\n\n    abc, acb, bac, bca, cab, cba", "type": "text", "answers": [{"text": "Bitte tragen Sie eine Zahl ein:", "solution": "15"}]}, {"id": 2552, "category": 42, "difficulty": 3, "text": "Welche Aussagen \u00fcber Indexe sind wahr?", "explanation": "Die L\u00f6sung ergibt sich aus der Definition von Indizes.", "type": "multiple-choice", "answers": [{"text": "Indexe sind separate Speicherstrukturen, die zus\u00e4tzlich zur Tabelle angelegt werden.", "solution": "true"}, {"text": "F\u00fcr eine Tabelle kann nur ein Index angelegt werden", "solution": "false"}, {"text": "Einf\u00fcgen und L\u00f6schen von Datens\u00e4tzen in Tabellen mit Indizes sind aufw\u00e4ndiger, als bei Tabellen ohne Index.", "solution": "true"}, {"text": "Indexe beschleunigen die Suche von Datens\u00e4tzen, weil sie sortiert werden k\u00f6nnen und damit optimierte Suchalgorithmen ausgef\u00fchrt werden k\u00f6nnen.", "solution": "true"}, {"text": "Indexe haben den Vorteil, dass man f\u00fcr eine Tabelle mehrere anlegen kann und damit nach verschiedenen Spalten optimiert suchen kann.", "solution": "true"}, {"text": "Indexe beschleunigen immer den lesenden Zugriff.", "solution": "false"}, {"text": "Indexe verlangsamen den lesenden Zugriff, wenn die Tabelle so klein ist, dass alle Daten in einen physischen Block passen und so mit einer Schreiblese-Operation gelesen werden k\u00f6nnen", "solution": "true"}]}, {"id": 2596, "category": 8, "difficulty": 1, "text": "Einen Operatorbaum liest man", "explanation": "Um Anfragen an einen Datenbestand zu formulieren, k\u00f6nnen Operationen der relationalen Algebra beliebig ineinander geschachtelt werden. Bei komplexen Anfragen ist daher die oben verwendete sogenannte \"Inline-Notation\" schwer lesbar. F\u00fcr diesen Zweck verwendet man Operatorb\u00e4ume statt der Inline-Notation. Bei dieser grafischen Darstellung erstellt und liest man die Abfrage von unten nach oben. Operationen, die miteinander verkn\u00fcpft sind, sind durch Kanten im Graphen miteinander verbunden. Gestartet wird mit den relvanten Relationen als unterster Teil des OP-Baumes.", "type": "multiple-choice", "answers": [{"text": "von unten nach oben", "solution": "true"}, {"text": "von oben nach unten", "solution": "false"}]}, {"id": 2699, "category": 9, "difficulty": 2, "text": "Wozu kann man den Befehl execute unter Oracle-SQL benutzen?", "explanation": "Beispiele f\u00fcr Prozeduraufrufe sind in SQL*PLus\n\nEXECUTE prozedurname(var_y, var_x)\nIm PL/SQL-Programm:\nprozedurname(var_y, var_x) Funktionen brauchen einen Return-Wert und k\u00f6nnen daher nicht diekt mit excute aufgerufen werden", "type": "multiple-choice", "answers": [{"text": "Zum direkten Aufruf einer Funktion", "solution": "false"}, {"text": "Zum direkten Aufruf einer Prozedur", "solution": "true"}]}, {"id": 2615, "category": 9, "difficulty": 3, "text": "Die Fehlerkorrektur beim Fremdschl\u00fcssel bietet welche Klauseln an?", "explanation": "Wenn man bedenkt, f\u00fcr welche Problemstellung die Fehlerkorrektur gedacht ist, dann kommt man schnell darauf, das es nur die beiden Klauseln \"ON UPDATE\" und \"ON DELETE\" geben kann.  \nWerden Fremdschl\u00fcssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datens\u00e4tze, die noch von Detail-Datens\u00e4tze referenziert werden, gel\u00f6scht oder deren Schl\u00fcsselwert ge\u00e4ndert wird und das anschlie\u00dfend Detail-Datens\u00e4tze existieren, f\u00fcr deren Fremdschl\u00fcsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt. \nDas Einf\u00fcgen von Master-Datens\u00e4tzen ist immer unproblematisch, da eine Fremdschl\u00fcsselbedingung es zul\u00e4\u00dft, dass es Master-Datens\u00e4tze gibt, f\u00fcr die es keine Detail-Datens\u00e4tze gibt. \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION", "type": "multiple-choice", "answers": [{"text": "ON INSERT <Fehlerkorrektur Aktion>", "solution": "false"}, {"text": "ON UPDATE <Fehlerkorrektur Aktion>", "solution": "true"}, {"text": "ON DELETE <Fehlerkorrektur Aktion>", "solution": "true"}, {"text": "Es gibt gar keine Fehlerkorrektur bei den Fremdschl\u00fcsseln in SQL.", "solution": "false"}, {"text": "Es gibt zwar eine Fehlerkorrektur bei den Fremdschl\u00fcsseln in SQL, die Klauseln hei\u00dfen aber ganz anders.", "solution": "false"}]}, {"id": 2786, "category": 9, "difficulty": 2, "text": "In einem Spaltenausdruck einer SELECT-Klausel k\u00f6nnen Gruppenfunktionen mit Single-Row-Funktionen gemischt werden", "explanation": "In einem Spaltenausdruck k\u00f6nnen keine Gruppenfunktionen mit Single-Row-Funktionen gemischt werden, da sich Gruppenfunktionen auf mehrere Tupel beziehen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2767, "category": 9, "difficulty": 2, "text": "Welcher der folgenden Mengenoperatoren hat die h\u00f6chste Priorit\u00e4t?", "explanation": "Die Mengenoperatoren union, intersect und minus haben unter SQL keine Priorit\u00e4tsreihenfolge, sondern werden in der Reihenfolge abgearbeitet, in der sie in der SELECT-Abfrage stehen.", "type": "multiple-choice", "answers": [{"text": "union", "solution": "false"}, {"text": "intersect", "solution": "false"}, {"text": "minus", "solution": "false"}, {"text": "Keiner von allen", "solution": "true"}]}, {"id": 2739, "category": 9, "difficulty": 3, "text": "Ausgehend von den Basisdatentypen und den zugelassenen Typkonstruktoren l\u00e4sst sich das Basisobjektmodell in inline-Notation wie folgt beschreiben: (nur der zum relationalen Modell und zu SQL92 \"quasi analoge\" Ausschnitt)", "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben. Und das Basisobjektmodell entspricht an dieser Stelle der Grundstruktur SET ( OBJECT ( Basisdatentyp ) ). Diese Beschreibung ist jedoch noch sehr unvollst\u00e4ndig.", "type": "text", "answers": [{"text": "Das ist:", "solution": "SET(OBJECT(Basisdatentyp))"}]}, {"id": 2783, "category": 9, "difficulty": 1, "text": "Was bewirken Klammern in einem Ausdruck einer SELECT-Anweisung?", "explanation": "In SQL gilt wie in der Mathematik die Merkregel  \"Punktrechnung geht vor Strichrechnung\". Durch Klammern kann man diese Reihenfolge \u00fcberschreiben. (siehe <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Operator\"> Operatoren in SQL )", "type": "multiple-choice", "answers": [{"text": "Man kann in SQL reservierte W\u00f6rter als Spaltennamen benutzen.", "solution": "false"}, {"text": "Das ist eine Matrix-Schreibweise f\u00fcr komplexe Vektoren.", "solution": "false"}, {"text": "Damit kann man die Priorit\u00e4tsreihenfolge numerischer Operatoren \u00fcberschreiben.", "solution": "true"}]}, {"id": 2710, "category": 9, "difficulty": 3, "text": "Es sei eine Funktion \n\n     test_check(sp1 IN NUMBER) RETURN NUMBER ; \n\ngegeben. Welche Aufrufe sind richtig?", "explanation": "Da der R\u00fcckgabewert (RETURN-Wert) vom Typ NUMBER ist, ist eine Verwendung wie innerhalb der Bedingung dieser IF-Anweisung unzul\u00e4ssig, da diese Syntax keine zu einem Wahrheitswert auswertbare Bedingung darstellt. \n\nAnders sieht es bei der Bedingung der WHILE-Schleifen aus. Aufgrund des Vergleichs ist dies eine auswertbare Bedingung mit einem Wahrheitswert. \n\nMit EXECUTE k\u00f6nnen nur Prozeduren ausgef\u00fchrt werden und das auch nicht innerhalb von PL/SQL-Programmen (dort nur durch Verwendung des Prozedurnamens) sondern in Tools wie SQL-Plus oder SQL-Developer etc.\n\nDie Anweisung \"SELECT funktionsname FROM DUAL;\" eignet sich hervorragend f\u00fcr den Aufruf von Funktionen mit nur IN-Parametern, solange f\u00fcr sie nicht BOOLEAN als RETURN-Wert definiert ist. Der Grund ist, im SQL-Kontext kennt Oracle leider immer noch nicht den Datentyp BOOLEAN sondern nur in PL/SQL-Programmen.", "type": "multiple-choice", "answers": [{"text": "EXECUTE test_check(123);", "solution": "false"}, {"text": "IF test_check(var_x) THEN  END IF;", "solution": "false"}, {"text": "SELECT test_check(sp1) FROM DUAL;", "solution": "true"}, {"text": "WHILE ( test_check(var_y) < var_z ) LOOP  ;", "solution": "true"}]}, {"id": 2711, "category": 10, "difficulty": 2, "text": "Mit welchem/n PL/SQL-Konzept/en k\u00f6nnen Informationen zwischen Triggern ausgetauscht werden?", "explanation": "Um zwischen ORACLE-Trigger Informationen austauschen zu k\u00f6nnen, steht das PL/SQL-Konzept der public Package-Variablen zur Verf\u00fcgung. Die privaten Package-Variablen scheiden aus, weil sie ja eh nur innerhalb des Packages verwendbar sind. \n\nEin Trigger verf\u00fcgt \u00fcber keine Parameter. Dieses Konzept ist nur bei Funktionen und Prozeduren bekannt. \n\nDer Informationsaustausch \u00fcber die Zwischenspeicherung in Tabellen stellt eine alternative Austauschform dar. Sie hat jedoch das Problem, dass der Mehrbenutzerbetrieb explizit vom Entwickler gel\u00f6st werden muss (USER-Kennung mitspeichern, etc.). W\u00e4hrend bei den Package-Variablen jeder angemeldete User seine eigene Instanziierung dieser Variable bekommt und es zu keinen Mehrbenutzerproblemen kommt.", "type": "multiple-choice", "answers": [{"text": "Public Package-Variable", "solution": "true"}, {"text": "Private Package-Variable", "solution": "false"}, {"text": "Dies geht nicht als PL/SQL-L\u00f6sung sondern nur in SQL mittels einer Tabelle, die vom einen Trigger gef\u00fcllt und vom anderen ausgelesen werden.", "solution": "false"}, {"text": "Paramter\u00fcbergabe", "solution": "false"}]}, {"id": 2542, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgenden Typdefinitionen unter Oracle-SQL:\n\nCREATE OR REPLACE TYPE adresse_t\nAS\n   OBJECT (Ort varchar2 (50),\n           PLZ integer,\n           strasse varchar2 (50),\n           hausnummer integer);\n\nCREATE OR REPLACE TYPE DATUM_T\nAS\n   OBJECT (gekauft_am DATE,\n           VERKAUFT_AM DATE);\n           \nCREATE OR REPLACE TYPE autos_t\nAS\n   OBJECT (fahrzeug_nummer varchar2 (50), datum datum_t);\n\nCREATE OR REPLACE TYPE verkaufen_t as table of autos_t;\n\n\nWelche CREATE-Table-Anweisung ist korrekt?", "explanation": "Der Name der NESTED-Table muss mit dem Namen der Spalte, hier autos \u00fcbereinstimmen und NESTED TABLE ist das erste Schl\u00fcsselwort nach der schlie\u00dfenden Klammer.", "type": "multiple-choice", "answers": [{"text": "CREATE TABLE kunde_NT\n(Name varchar2(50),\n adresse adresse_t,\n autos verkaufen_t) NESTED TABLE autos STORE as verkauf_table;", "solution": "true"}, {"text": "CREATE TABLE kunde_NT\n(Name varchar2(50),\n adresse adresse_t,\n autos verkaufen_t) NESTED TABLE autos_t STORE as verkauf_table;", "solution": "false"}, {"text": "CREATE TABLE kunde_NT\n(Name varchar2(50),\n adresse adresse_t,\n autos verkaufen_t) STORE as NESTED TABLE autos verkauf_table;", "solution": "false"}]}, {"id": 2548, "category": 42, "difficulty": 3, "text": "Es sei folgender Index \u00fcber zwei Spalten gegeben: \n    CREATE INDEX namens_idx (Nachname, Vorname). \n\u00dcber welche Spalten kann schnell gesucht werden?", "explanation": "Da der Index so aufgebaut ist, dass der Nachname als erster Eintrag ber\u00fccksichtigt wird, kann man nicht schnell zugreifen, wenn der Vorname die Einstigsspalte ist.", "type": "multiple-choice", "answers": [{"text": "Nachname", "solution": "true"}, {"text": "Vorname", "solution": "false"}, {"text": "Nachname, Vorname", "solution": "true"}, {"text": "Vorname, Nachname", "solution": "false"}]}, {"id": 2550, "category": 42, "difficulty": 2, "text": "Wie viele Eintr\u00e4ge sind in einem B-Baum vom Typ k mit der H\u00f6he h in der Wurzel mindestens enthalten?", "explanation": "Das ist die Definition eines B-Baumes.", "type": "text", "answers": [{"text": "Bitte tragen sie eine Zahl ein!", "solution": "1"}]}, {"id": 2551, "category": 42, "difficulty": 3, "text": "Wie viele Eintr\u00e4ge sind in einem B-Baum vom Typ k mit der H\u00f6he h in den inneren Knoten mindestens enthalten?", "explanation": "Das ist die Definition eines B-Baums.", "type": "text", "answers": [{"text": "Bitte tragen sie eine Zahl ein!", "solution": "k"}]}, {"id": 2760, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber eine PL/SQL-Funktion bzw. Prozedur sind korrekt?", "explanation": "Mit EXECUTE k\u00f6nnen direkt Prozeduren ausgef\u00fchrt werden und das auch nicht innerhalb von PL/SQL-Programmen (dort nur durch Verwendung des Prozedurnamens). Bei Funktioen muss zus\u00e4tzlich der RETURN-Wert verarbeitet werden. \n\nDie Anweisung \"SELECT funktionsname FROM DUAL;\" eignet sich hervorragend f\u00fcr den Aufruf von Funktionen mit nur IN-Parametern, solange f\u00fcr sie nicht BOOLEAN als RETURN-Wert definiert ist. Der Grund ist, im SQL-Kontext kennt Oracle leider immer noch nicht den Datentyp BOOLEAN sondern nur in PL/SQL-Programmen.", "type": "multiple-choice", "answers": [{"text": "Eine PL/SQL-Prozedur kann mit EXECUTE prozedurname innerhalb eines PL/SQL-Programms aufgerufen werden.", "solution": "true"}, {"text": "Eine PL/SQL-Funktion kann mit EXECUTE functionname innerhalb eines PL/SQL-Programms aufgerufen werden.", "solution": "false"}]}, {"id": 2724, "category": 9, "difficulty": 3, "text": "Auf welchen grundlegenden Datenmodellen basiert das objektrelationale Modell des SQL2003-Standards bzw. Oracle im wesentlichen, also abgesehen von einigen kleineren \u00c4nderungen? Nennen Sie die Namen ohne Sonderzeichen und in aphabetischer Reihenfolge. Beide Namen enden auf \"modell\".", "explanation": "Die beiden grundlegenden Konzepte, die im objektrelaitonalen SQL2003 zusammengef\u00fchrt wurden sind: SQL-92 und das Basisobjektmodell. (vgl. auch T\u00fcrker/Saake in \"Objektrelationale Datenbanken\", dpunkt-Vderlag, 2006, Kap.3, insbesondere S.95) Diese beiden Modelle werden zudem um drei Typkonstruktoren erweitert:\n\nin SQL: REF, MULTISET, ARRAY \nbei Oracle REF, (NESTED) TABLE, VARRAY \n\nZu beachten ist insbesondere, dass sowohl bei Oracle wie auch beim SQL2003-Standard nicht das relationalen Modell mit seiner Mengensemantik sondern das SQL-92-Modell mit seinem Verst\u00e4ndnis einer Tabelle als Multimenge zugrunde liegt.", "type": "text", "answers": [{"text": "Das ist zum einen das ...", "solution": "Basisobjektmodell"}, {"text": "Das ist zum anderen das ...", "solution": "SQL92Modell"}]}, {"id": 2747, "category": 9, "difficulty": 3, "text": "Aus welchen Arten von Tabellen lassen sich mit einer Referenzspalte REF Objekte referenzieren?", "explanation": "Eine Referenz kann nur auf eine Objekttabelle (Oracle) / Typisierte Tabelle (SQL) verweisen, da f\u00fcr den Verweis eine OID ben\u00f6tigt wird, die in relationalen Tabellen nicht gegeben ist. \n\nAndererseits kann die Referenz aus einer relationalen wie auch objektrelationale Tabelle (Objekttabelle (Oracle)/Typisierte Tabelle (SQL)) erfolgen,  d.h. eine relationale Tabelle kann eine Spalte aufweisen, deren Datentyp REF ist und auf eine  Objekttabelle (Oracle)/Typisierte Tabelle (SQL) verweist.", "type": "multiple-choice", "answers": [{"text": "relationale Tabellen (Tupeltabellen)", "solution": "true"}, {"text": "Objekttabellen (Oracle) / Typisierte Tabellen (SQL)", "solution": "true"}]}, {"id": 2776, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden CREATE-TABLE-Befehl: \n\nCREATE TABLE Person (\nID NUMBER PRIMARY KEY,\nNACHNAME VARCHAR2(20) PRIMARY KEY,\nTYP CHAR(1));\n\nWelche Aussage/n sind/ist korrekt?", "explanation": "Eine Tabelle kann nur einen PRIMRY KEY haben, der die physische Struktur der Tabelle festlegt.", "type": "multiple-choice", "answers": [{"text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil eine Tabelle nur eine PRIMARY KEY haben kann.", "solution": "true"}, {"text": "Der CREATE-TABLE -Befehl wirft keinen Fehler.", "solution": "false"}, {"text": "Der CREATE-TABLE -Befehl wirft keinen Fehler, aber es wird nur der erste PRIMARY KEY erzeugt.", "solution": "false"}]}, {"id": 2779, "category": 9, "difficulty": 2, "text": "Betrachten Sie die folgenden SQL-Befehl: \n\nCREATE TABLE Person (\nID NUMBER PRIMARY KEY,\nNACHNAME VARCHAR2(20),\nTYP CHAR(1));\n\n\nINSERT INTO PERSON (1, NULL, NULL);\nINSERT INTO PERSON (2, WILLI, 'B');\n\nUPDATE PERSON\n  SET TYP = 'A' WHERE TYP = 'B';\nCOMMIT;\n\nWelche Aussage/n sind/ist korrekt?\n\n", "explanation": "Die WHERE-Klausel 'WHERE TYP = 'B' greift nur, wenn der TYP keinen Nullwert hat.", "type": "multiple-choice", "answers": [{"text": "Eine Zeile wird ver\u00e4ndert.", "solution": "true"}, {"text": "Zwei Zeilen werden ver\u00e4ndert.", "solution": "false"}, {"text": "Keine Zeile wird ver\u00e4ndert.", "solution": "false"}]}, {"id": 2787, "category": 9, "difficulty": 2, "text": "Welchen Wert gibt die SQL-Gruppenfunktionen auf einer Tabelle test wieder, wnn diese Tabelle keine Zeilen enth\u00e4lt?\n\nSELECT COUNT(*) FROM test;", "explanation": "COUNT gibt immer einen numerischen Wert zur\u00fcck. Dieser ist 0,  wenn die Tabelle keine Tupel enth\u00e4lt", "type": "multiple-choice", "answers": [{"text": "0", "solution": "true"}, {"text": "NULL", "solution": "false"}]}, {"id": 2788, "category": 9, "difficulty": 3, "text": "Bis zu welcher Tiefe k\u00f6nnen Gruppenfunktionen (COUNT, MIN, MAX , SUM, AVG) in Oracle -SQL verschachtelt werden?", "explanation": "Gruppenfunktionen k\u00f6nnen mit Single-Row-Funktionen  oder untereinander verschachtelt werden, wenn die Datentypen passen. Es ist auch m\u00f6glich, Gruppenfunktionen untereinander zu verschachteln, allerdings nur bis zur Stufe 2.", "type": "multiple-choice", "answers": [{"text": "1", "solution": "false"}, {"text": "2", "solution": "true"}, {"text": "3", "solution": "false"}]}, {"id": 2700, "category": 9, "difficulty": 2, "text": "Welche/r Parametertyp/en erfordern eine Variable beim Aufruf der Routine (Prozedur oder Funktion) ?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann.", "type": "multiple-choice", "answers": [{"text": "IN", "solution": "false"}, {"text": "INOUT", "solution": "true"}, {"text": "OUT", "solution": "true"}]}, {"id": 2701, "category": 9, "difficulty": 3, "text": "Overloading-Routinen werden unterschieden durch ", "explanation": "Beim Overloading in PL/SQL k\u00f6nnen Paketroutinen gleich hei\u00dfen:   Gleichnamige Prozeduren oder Funktionen werden durch eine unterschiedliche Anzahl, eine unterschiedliche Reihenfolge von Parametern oder durch unterschiedliche Datentypen der Parameter unterschieden.", "type": "multiple-choice", "answers": [{"text": "Datentyp der Parameter.", "solution": "true"}, {"text": "Reihenfolge unterschiedlicher Datentypen der Parameter.", "solution": "true"}, {"text": "unterschiedliche Parameternamen.", "solution": "false"}, {"text": "unterschiedliche Variablennamen.", "solution": "false"}, {"text": "unterschiedliche Prozedur-/Funktionsnamen.", "solution": "false"}, {"text": "Anzahl der Parameter.", "solution": "true"}]}, {"id": 2702, "category": 9, "difficulty": 3, "text": "Unter welchen Voraussetzungen kann bei der Programmierung von SELECT INTO-Anweisungen auf die eine oder andere EXCEPTION, die \u00fcblicherweise immer im Zusammenhang mit SELECT-INTOs zu programmieren sind, ganz sicher verzichtet werden?", "explanation": "SELECT INTO \u00fcbergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datens\u00e4tze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datens\u00e4tze verarbeiten kann.\n\n    \n\n    Es reicht nicht aus, wenn in Tabellen Datens\u00e4tze vorhanden sind. Relevant ist, dass immer wdenigstens ein Datensatz gefunden wird, um auf die NO_DATA_FOUND verzichten zu k\u00f6nnen.\n\n    \n\n    Werden Anfragen \u00fcber Prim\u00e4r- oder Eindeutigkeitsschl\u00fcssel an eine einzige Tabelle formuliert, steht fest, dass es keine TOO_MANY_ROWS geben kann.\n\n    \n\n    Werden Anfragen \u00fcber Prim\u00e4r- oder Eindeutigkeitsschl\u00fcssel an die Detail-Tabelle von Joins formuliert, die mittels Fremdschl\u00fcsseln verknp\u00fcft sind, so steht fest, dass es keine TOO_MANY_ROWS geben kann.\n\n    \n\n    Aggregatfunktionen haben die Eigenschaft, dass sie je Gruppe nur einen Ergenbisdatensatz liefern. Steht also zwingend fest, dass es nur eine Gruppe gibt - z.B. bei fehlender Gruppierung nur \u00fcber die GEsamtmenge - dann kann auch auf die TOO_MANY_ROWS verzichtet werden.", "type": "multiple-choice", "answers": [{"text": "Wenigstens eine der beteiligten Tabellen enth\u00e4lt Datens\u00e4tze.", "solution": "false"}, {"text": "Die Anfrage liefert immer wenigstens einen Datensatz.", "solution": "true"}, {"text": "Es wird bei Anfragen ohne JOINs in der WHERE-Klausel \u00fcber die Prim\u00e4rschl\u00fcssel der beteiligten Tabelle zugegriffen.", "solution": "true"}, {"text": "Es wird bei Anfragen mit JOINs in der WHERE-Klausel \u00fcber die Fremdschl\u00fcssel verkn\u00fcpft und \u00fcber die Prim\u00e4rschl\u00fcssel bei den Detail-Tabellen eingeschr\u00e4nkt.", "solution": "true"}, {"text": "Es wird bei Anfragen ohne JOINs in der WHERE-Klausel \u00fcber die UNIQUE-Schl\u00fcssel der beteiligten Tabelle zugegriffen.", "solution": "true"}, {"text": "Alle beteiligten Tabellen enthalten Datens\u00e4tze.", "solution": "false"}, {"text": "Es wird bei Anfragen mit JOINs in der WHERE-Klausel \u00fcber die Fremdschl\u00fcssel verkn\u00fcpft und \u00fcber die UNIQUE-Schl\u00fcssel der Detail-Tabellen eingeschr\u00e4nkt.", "solution": "true"}, {"text": "Wenn in der SELECT-Klausel Aggregatfunktionen ohne Gruppierung verwendet werden.", "solution": "true"}, {"text": "Wenn in der SELECT-Klausel Aggregatfunktionen verwendet werden.", "solution": "false"}]}, {"id": 2704, "category": 10, "difficulty": 3, "text": "Die Einhaltung welchen Paradigmas des relationalen Modells und der relationalen Datenbanksysteme hat das Mutating Table-Problem zur Folge?", "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausf\u00fchrungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabh\u00e4ngigkeit des Resultats einer \u00c4nderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.", "type": "text", "answers": [{"text": "Das ist die ...", "solution": "Reihenfolgeunabh\u00e4ngigkeit"}]}, {"id": 2706, "category": 9, "difficulty": 3, "text": "Folgende Prozedur sei gegeben: \n\n  CREATE OR REPLACE PROCEDURE \n         test_proc (p1 IN NUMBER, p2 OUT NUMBER) ... ;\n\nWelche Parameterverwendungen im Programm sind korrekt?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. Daher nicht in Zuweisungen verwendbar sondern nur in Bedingungen etc. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. \n\nBeim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzur\u00fcckgeben kann Daher in Zuweisungen, Bedingungen, etc. verwendbar. \n\nDer Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann. Daher in Zuweisungen, Bedingungen etc. verwendbar.", "type": "multiple-choice", "answers": [{"text": "p1 := 1234;", "solution": "false"}, {"text": "p2 := 6543;", "solution": "true"}, {"text": "WHILE p2 < 345 LOOP ;", "solution": "true"}, {"text": "IF p1 = 456 THEN ;", "solution": "true"}]}, {"id": 2763, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Fremdschl\u00fcssel (Foreign Keys) sind wahr?", "explanation": "F\u00fcr die Definition eines Fremdschl\u00fcssels reicht ein UNIQUE-Constraint auf der referenzierten Spalte aus. Ein Prim\u00e4rschl\u00fcssel ist hinreichend, aber nicht notwendig.", "type": "multiple-choice", "answers": [{"text": "Die Syntax eines Foreign-Key-Constraints setzt voraus, dass auf der referenzierten Spalte ein Prim\u00e4rschl\u00fcssel definiert ist.", "solution": "false"}, {"text": "Die Syntax eines Foreign-Key-Constraints setzt voraus, dass auf der referenzierten Spalte ein UNIQUE-Constraint oder ein Prim\u00e4rschl\u00fcssel definiert ist.", "solution": "true"}, {"text": "Keine von bedien Antworten ist richtig.", "solution": "false"}]}, {"id": 2762, "category": 9, "difficulty": 1, "text": "Welcher Operator unterdr\u00fcckt doppelte Datens\u00e4tze?", "explanation": "UNION unterdr\u00fcckt mehrfach vorkommende Datens\u00e4tze, bei UNION ALL bleiben sie erhalten. UNION ANY gibt es in SQL nicht.", "type": "multiple-choice", "answers": [{"text": "UNION ALL", "solution": "false"}, {"text": "UNION ANY", "solution": "false"}, {"text": "UNION", "solution": "true"}]}, {"id": 2713, "category": 10, "difficulty": 3, "text": "Wenn innerhalb eines DML-Triggers einer Spalte des aktuell eingef\u00fcgten oder ge\u00e4nderten Datensatzes ein Wert zugewiesen werden soll, sollte am besten welcher Trigger verwendet werden?", "explanation": "AFTER-ROW/STATEMENT-Trigger funktionieren gar nicht, da diese ja erst ausgef\u00fchrt werden, wenn der Datensatz in der DB eingef\u00fcgt bzw. ge\u00e4ndert wurde, BEFORE-STATEMENT-Trigger nicht, da sie \u00fcber keine Transitionsvariablen verf\u00fcgen.\n\n    Am besten geht es mit den BEFORE-ROW-Triggern und den darin verf\u00fcgbaren Transitionsvariablen. Die NEW.Transitionsvariablen bekommen einfach den neuen Wert zugewiesen und anschlie\u00dfend wird der manipulierte Datensatz mit den Werten der NEW-Transitionsvarialben in die DB eingef\u00fcgt bzw. ge\u00e4ndert,  z.B.: :NEW.eingefuegt_am := SYSDATE;\n\n    Auch INSTEAD OF-Trigger eignen sich auch - nur etwas anders. Sie sind f\u00fcr Sichten (VIEWs) definierbar und nicht f\u00fcr Tabellen. Es gibt sie nur als ROW-Variante - nicht als STATEMENT-Trigger.  Und die Transitionsvariablen k\u00f6nnen nur gelesen, aber nicht ge\u00e4ndert werden. Die Inhalte der Transitionsvariablen k\u00f6nnen dann per INSERT/UPDATE-Anweisung in eine oder mehrere Tabellen umgeleitet werden.", "type": "multiple-choice", "answers": [{"text": "AFTER-ROW-Trigger", "solution": "false"}, {"text": "BEFORE-ROW-Trigger", "solution": "true"}, {"text": "AFTER-STATEMENT-Trigger", "solution": "false"}, {"text": "BEFORE-STATEMENT-Trigger", "solution": "false"}, {"text": "INSTEAD OF-ROW-Trigger", "solution": "true"}, {"text": "INSTEAD OF-STATEMENT-Trigger", "solution": "false"}]}, {"id": 2725, "category": 9, "difficulty": 3, "text": "Auf welchen grundlegenden Datenmodellen basiert das objektrelationale Modell des SQL2003-Standards bzw. Oracle im wesentlichen, also abgesehen von einigen kleineren \u00c4nderungen? Nennen Sie die Namen ohne Sonderzeichen und in aphabetischer Reihenfolge. Beide Namen enden auf \"modell\".", "explanation": "Die beiden grundlegenden Konzepte, die im objektrelaitonalen SQL2003 zusammengef\u00fchrt wurden sind: SQL-92 und das Basisobjektmodell. (vgl. auch T\u00fcrker/Saake in \"Objektrelationale Datenbanken\", dpunkt-Vderlag, 2006, Kap.3, insbesondere S.95) Diese beiden Modelle werden zudem um drei Typkonstruktoren erweitert:\n\nin SQL: REF, MULTISET, ARRAY \nbei Oracle REF, (NESTED) TABLE, VARRAY \n\nZu beachten ist insbesondere, dass sowohl bei Oracle wie auch beim SQL2003-Standard nicht das relationalen Modell mit seiner Mengensemantik sondern das SQL-92-Modell mit seinem Verst\u00e4ndnis einer Tabelle als Multimenge zugrunde liegt.", "type": "text", "answers": [{"text": "Das ist zum einen das ...", "solution": "Basisobjektmodell"}, {"text": "Das ist zum anderen das ...", "solution": "SQL92Modell"}]}, {"id": 2733, "category": 9, "difficulty": 3, "text": "Welche Methode des Interfaces ResultSet pr\u00fcft, ob der letzte gelesene Wert NULL war? Gibt es keine solche Methode, schreiben Sie \"keine\", sonst schreiben Sie den Methodennamen mit den Klammern.", "explanation": "Mit der Methode boolean wasNull() des Interface ResutlSet kann nachgepr\u00fcft werden, ob der letzte ausgelesene Wert einer Spalte NULL war oder nicht. Dazu muss vorher eine getXXX()-Methode f\u00fcr die Spalte aufgerufen werden.", "type": "text", "answers": [{"text": "Das ist ...", "solution": "wasNull()"}]}, {"id": 2734, "category": 9, "difficulty": 2, "text": "Welche Aussagen \u00fcber das Konzept des ResultSets bei JDBC und das des Cursors bei PL/SQL sind wahr?", "explanation": "Das Konzept des Cursors bei PL/SQL und das des ResultSet bei JDBC stellt in beiden F\u00e4llen einen Speicherbereich f\u00fcr die Eregebnisdatens\u00e4tze einer SELECT-Anfrage dar. \n\nIn Cursorn kann nur immer vorw\u00e4rts eine Datensatz nach dem anderen eingelesen werden in die PL/SQL-Variablen. \n\nBei ResultSets kann beliebig innerhalb der Ergebnismenge navigiert werden mit Methoden wie: next(), previous(), absolute(), relative(), first(), last(), ...", "type": "multiple-choice", "answers": [{"text": "Beide Konzepte haben nichts miteinander zu tun.", "solution": "false"}, {"text": "Beide Konzepte sind prinzipiell analog, wobei der Cursor funktional umfangreicher ist.", "solution": "false"}, {"text": "Beide Konzepte sind prinzipiell analog, wobei das ResultSet funktional umfangreicher ist.", "solution": "true"}, {"text": "Beide Konzepte sind prinzipiell identisch von der Funktionsweise und dem Funktionsumfang.", "solution": "false"}, {"text": "Zwischen den Datens\u00e4tzen eines Cursors kann komfortabel hin und her navigiert werden.", "solution": "false"}, {"text": "Zwischen den Datens\u00e4tzen eines ResultSet kann komfortabel hin und her navigiert werden.", "solution": "true"}]}, {"id": 2743, "category": 9, "difficulty": 2, "text": "Wie hei\u00dft das Problem, das speziell bei objektgenerierenden Sichten auftritt?", "explanation": "RICHTIG ist, dass das Problem der OID-Stabilit\u00e4t bei objektgenerierenden Objektsichten auftritt.  \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nTupelsicht \u00fcber beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nerm\u00f6glicht logische Datenunabh\u00e4ngigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen m\u00f6glich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterst\u00fctzung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.", "type": "multiple-choice", "answers": [{"text": "Es gibt kein solches Problem.", "solution": "false"}, {"text": "Stabilit\u00e4t der OID", "solution": "true"}, {"text": "Stabilit\u00e4t der Daten", "solution": "false"}, {"text": "Vereinigungskonformit\u00e4t", "solution": "false"}, {"text": "Reihenfolgeunabh\u00e4ngigkeit", "solution": "false"}, {"text": "\u00c4quivalenz der Daten", "solution": "false"}]}, {"id": 2712, "category": 10, "difficulty": 3, "text": "Welchen Unterschied macht es, ob eine Integrit\u00e4tspr\u00fcfung in einem BEFORE- oder AFTER-Trigger durchgef\u00fchrt wird?", "explanation": "Wenn kein Fehler auftritt, ist es eigentlich egal, ob erst gepr\u00fcft (BEFORE-Trigger) und dann manipiliert wird, oder ob erst manipuliert und dann gepr\u00fcft wird (AFTER-Trigger).\n\nEs macht wohl einen Unterschied wenn ein Fehler auftritt - in der Fehlerreaktion und seiner Laufzeit. \n\nWird in einem BEFORE-Trigger der Fehler erkannt, sind bislang nur ggf. einige andere BEFORE-Trigger ausgef\u00fchrt worden, die r\u00fcckg\u00e4ngig gemacht werden m\u00fcssen. \n\nWird erst in einem AFTER-Trigger der Fehler erkannt, sind alle BEFORE-Trigger mit ihren Aktionen wieder r\u00fcckgn\u00e4ngig zu machen, die Manipulation des Datensatzes selbst und auch noch die bislang ausgef\u00fchrten AFTER-Trigger mit ihren Aktionen. Das kann dann etwas l\u00e4nger dauern.", "type": "multiple-choice", "answers": [{"text": "Keinen Unterschied.", "solution": "false"}, {"text": "Wenn kein Fehler auftritt, dann macht es keinen Unterschied.", "solution": "true"}, {"text": "Wenn ein Fehler auftritt macht es keinen Unterschied.", "solution": "false"}, {"text": "Wenn ein Fehler bei einer Pr\u00fcfung in einem AFTER-Trigger auftritt, wird die bereits in der Datenbasis vorgenommene Manipulation des Datensatzes wieder r\u00fcckg\u00e4ngig gemacht.", "solution": "true"}, {"text": "Wenn ein Fehler bei einer Pr\u00fcfung in einem AFTER-Trigger auftritt, werden alle BEFORE-Trigger r\u00fcckg\u00e4ngig gemacht.", "solution": "true"}, {"text": "Wenn ein Fehler bei einer Pr\u00fcfung in einem AFTER-Trigger auftritt, werden alle AFTER-Trigger r\u00fcckg\u00e4ngig gemacht, die bis dahin bereits ausgef\u00fchrt wurden.", "solution": "true"}, {"text": "Wenn ein Fehler bei einer Pr\u00fcfung in einem BEFORE-Trigger auftritt, wird die bereits in der Datenbasis vorgenommene Manipulation des Datensatzes wieder r\u00fcckg\u00e4ngig gemacht.", "solution": "false"}, {"text": "Wenn ein Fehler bei einer Pr\u00fcfung in einem BEFORE-Trigger auftritt, werden alle BEFORE-Trigger r\u00fcckg\u00e4ngig gemacht, die bis dahin bereits ausgef\u00fchrt wurden.", "solution": "true"}, {"text": "Wenn ein Fehler bei einer Pr\u00fcfung in einem BEFORE-Trigger auftritt, werden alle AFTER-Trigger r\u00fcckg\u00e4ngig gemacht.", "solution": "false"}]}, {"id": 2745, "category": 9, "difficulty": 3, "text": "Was wird bei Oracle im TYPE-Body programmiert?", "explanation": "Einen CREATE METHOD-Befehl gibt es bei Oracle nicht. Die Methoden-Deklaration und -Definition wird im CREATE TYPE-Befehl vorgenommen analog zum Package-Konzept und zwar die Deklaration des Methoden-Kopfs im CREATE TYPE und die Definition mit Programmcode im CREATE TYPE BODY. \n\nCREATE [OR REPLACE] TYPE  AS OBJECT\u000b\n(  )\u000b\n[[NOT] FINAL] \u000b[[NOT] INSTANTIABLE] \n\u000b[]\n\nCREATE [OR REPLACE] TYPE BODY  AS \n[]", "type": "text", "answers": [{"text": "Wenn es dieses Konzept nicht gibt, schreiben Sie \"gibt es nicht\", sonst die Antwort im Plural eingeben.", "solution": "Methoden"}]}, {"id": 2748, "category": 9, "difficulty": 3, "text": "Welche Arten typisierter Sichten (Objektsichten) basieren typischer Weise auf nur einer typisierten Tabelle (Objekttabelle)?", "explanation": "Objektklassifizerende typisierte Sichten gibt es gar nicht. \n  \nDie objektgenerierenden typisierten Sichten erzeugen in der Regel Objekte aus relationalen Daten. Deren Daten k\u00f6nnen in beliebig komplexen SELECT-Anfragen zusammengestellt werden.  \n  \nDie objekterzeugenden typisierten Sichten erzeugen eine andere Sicht auf ein bereits bestehendes Objekt in einer typisierten Tabelle bzw. typisierten Sicht (Objekttabelle/-sicht), dies kann hei\u00dfen, dass nur einige Attribute des Objekts angezeigt werden und/oder, dass nur eine Teilmenge der Objekte angezeigt wird und/oder verschiedene Objektmengen gleichen Typs mittels UNION vereinigt werden. Bei allen M\u00f6glichkeiten steht in der SELECT-Anfrage eine typisierten Tabelle bzw. typisierten Sicht (Objekttabelle/-sicht).  \n\nerstellen Spezialformen von", "type": "multiple-choice", "answers": [{"text": "Objektgenerierende typisierte Sicht", "solution": "false"}, {"text": "Objekterhaltende typisierte Sicht", "solution": "true"}, {"text": "Diese Restriktion gilt f\u00fcr keine der typisierten Sichten.", "solution": "false"}, {"text": "Objektklassifizerende typisierte Sicht", "solution": "false"}]}, {"id": 2749, "category": 9, "difficulty": 2, "text": "F\u00fcr die sog. nicht \u00e4nderbaren typisierten Sichten (Objektsichten) gibt es folgende L\u00f6sungen, um trotzdem \u00c4nderungen der Sichtdaten an die Basisdaten der zugrunde liegenden Tabellen weiterleiten zu k\u00f6nnen?", "explanation": "Das Problem der nicht \u00e4nderbaren Sichten gibt es doch. Nur Sichten mit sehr einfachen SELECT-Anfragen (i.d.R. nur eine Tabelle und alle Pflichtspalten sind in der Sicht, ...) sind automatisch vom DBMS \u00e4nderbar. Auf allen anderen Sichten kann der Anwender trotzdem DML-Operationen ausf\u00fchren, es muss nur ein INSTEAD-OF-Trigger programmiert sein, der die f\u00fcr diese Sichtdaten\u00e4nderungen relevanten DML-Anweisungen mit \u00c4nderungen der zugrunde liegenden Tabellendaten enth\u00e4lt, die dann anstelle der Sicht-DML-Operation ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "BEFORE-Trigger", "solution": "false"}, {"text": "AFTER-Trigger", "solution": "false"}, {"text": "STATEMENT-Trigger", "solution": "false"}, {"text": "INSTEAD-OF-Trigger", "solution": "true"}, {"text": "DDL-Trigger", "solution": "false"}, {"text": "Dieses Problem gibt es nicht. F\u00fcr alle Sichten sind Daten\u00e4nderungen vom DBMS automatisch in Basisdaten\u00e4nderungen transformierbar.", "solution": "false"}, {"text": "Dieses Problem gibt es nicht, da DML-Operationen nicht auf Sichten ausf\u00fchrbar sind, sondern nur auf Tabellen.", "solution": "false"}]}, {"id": 2752, "category": 9, "difficulty": 3, "text": "Es sei eine typisierte Tabelle (Objekttabelle) kunden_ot gegeben. Es soll bei DML-Anweisungen auf diese Tabelle objektorientiert zugegriffen werden, also kein relationaler Zugriff. F\u00fcr die Tabelle wird der Tabellenalias kdot in der DML-Anweisung vergeben. Wie hei\u00dft die f\u00fcr diesen instanzierten Zugriff relevante Funktion?", "explanation": "Welche Betrachtungsweisen gibt es f\u00fcr Objekttabellen? \n\nRelational / Multi-Column: \nAls mehrspaltige Tabelle, in der jedes Attribut des object types die Anwendung von relationalen Operationen erlaubt.\u000b\n\nObjektorientiert / Single-Column: \nAls einspaltige Tabelle, in der jeder Datensatz ein Objekt darstellt, die die Anwendung von OO-Operationen erlaubt.\nVALUE-Funktion:\u000b \nArgument: Tabellenalias einer object table:\n \u000b     VALUE (table_alias)\u000b\nR\u00fcckgabewerte:    Objektinstanzen, die den Datens\u00e4tzen der Objekttabelle entsprechen. Der Typ der Objektinstanz ist der Typ der Objekttabelle.", "type": "text", "answers": [{"text": "Das ist ... (alles in Gro\u00dfbuchstaben)", "solution": "VALUE(KDOT)"}]}, {"id": 2754, "category": 42, "difficulty": 3, "text": "Erstellen Sie einen B-Baum vom Typ 1 f\u00fcr folgende Eingabewerte: 1, 15, 22, 4, 17, 3. \n\nGeben Sie die Zahlen f\u00fcr jeden Knoten mit Komma und Leerzeichen getrennt in der richtigen Reihenfolge an.", "explanation": "Hier die einzelnen Schritte: \n* 1\n* 1, 15\nBei Typ 1 ist mit 2 Eintr\u00e4gen der Knoten gef\u00fcllt und muss gesplittet werden f\u00fcr das Einf\u00fcgen von 22. \nlinker Knoten:  1 \nWurzel:         15\nrechter Knoten: 22\n\nEinf\u00fcgen von 4 und 17:\nlinker Knoten:  1, 4\nWurzel:         15\nrechter Knoten: 17, 22\n\nEinf\u00fcgen von 3:\nlinker Knoten:     1\nmittlerer Knoten:  4\nWurzel:            3, 15\nrechter Knoten:    17, 22", "type": "text", "answers": [{"text": "Linker Knoten", "solution": "1"}, {"text": "Wurzel", "solution": "3, 15"}, {"text": "rechter Knoten", "solution": "17, 22"}, {"text": "mittlerer Knoten", "solution": "4"}]}, {"id": 2769, "category": 9, "difficulty": 3, "text": "Wenn man eine SELECT-Abfrage, die aus mehrere Mengenoperatoren (UNION, INTERSECT, MINUS)  besteht, sortieren will, welche ORDER By-Form kann man benutzen?", "explanation": "Da die Spaltennamen nicht eindeutig festliegen, kann man nur ORDER BY POSITION (z.B. ORDER BY 3) benutzen.", "type": "multiple-choice", "answers": [{"text": "ORDER by Spaltenname", "solution": "false"}, {"text": "ORDER BY postion", "solution": "true"}, {"text": "Das geht \u00fcberhaupt nicht.", "solution": "false"}]}, {"id": 2784, "category": 9, "difficulty": 1, "text": "Mit welchem Datenbankobjekt kann man eine SELECT-Abfrage beschleunigen?", "explanation": "Indizes werden genau zu dem Zweck in der Datenbank abgelegt, n\u00e4mlich um Abfragen zu beschleunigen.", "type": "multiple-choice", "answers": [{"text": "ROWID", "solution": "false"}, {"text": "VIEW", "solution": "false"}, {"text": "INDEX", "solution": "true"}, {"text": "SEQUENCE", "solution": "false"}]}, {"id": 2789, "category": 9, "difficulty": 2, "text": "Betrachten Sie die folgende SELECT-Abfrage gegen eine Angestellten-Tabelle, wobei die entsprechenden Spalten vorhanden sein sollten:\n\n SELECT Abt_nr, SUM(gehalt) \n FROM Angestellte\n\nWelche Aussagen sind korrekt?", "explanation": "Alle Spalten, die in der SELECT-Klausel kein GRPOUB-BY haben, hier Abt_nr, m\u00fcssen in der GROUP-BY-Klasuel vorhanden sein.\n\nsiehe < href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Gruppenfunktionen\"> Gruppenfunktionen", "type": "multiple-choice", "answers": [{"text": "Diese Abfrage wirft einen Fehler, da skalare und aggregierte Daten vermischt werden.", "solution": "true"}, {"text": "Dieser SELECT-Anweisung fehlt eine GROUP-BY-Klausel", "solution": "true"}, {"text": "Die Anweisung wirft keinen Fehler.", "solution": "false"}, {"text": "Die Anweisung wirft keine Fehler, gibt aber keine Daten aus.", "solution": "false"}]}, {"id": 2737, "category": 9, "difficulty": 3, "text": "Das SQL-Daten-Modell kann wie folgt definiert werden: \nSET ( ROW ( Basisdatentyp ) ) .", "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 2790, "category": 9, "difficulty": 3, "text": "Eine SQL-Gruppenfunktion(SUM, MIN, MAX, etc..)  kann aufgerufen werden", "explanation": "Eine SELECT-Klausel kann Gruppenfunktionen beinhalten. Eine INSERT-Anweisung  hat keine SELECT-Klausel, eine DELETE hat keinen .\n\nsiehe < href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Gruppenfunktionen\" > Gruppenfunktionen", "type": "multiple-choice", "answers": [{"text": "aus der HAVING-Klausel einer SELECT-Anweisung", "solution": "true"}, {"text": "aus der ORDER-BY--Klausel einer SELECT-Anweisung", "solution": "true"}, {"text": "aus einem Ausdruck in einer DELETE-Anweisung", "solution": "false"}, {"text": "innerhalb einer SELECT-Klausel in einer SELECT-Anweisung", "solution": "true"}, {"text": "an keiner Stelle von allen", "solution": "false"}]}, {"id": 2750, "category": 10, "difficulty": 3, "text": "F\u00fcr die nicht \u00e4nderbaren typisierten Sichten (Objektsichten) wie auch relationalen Sichten gibt es folgende L\u00f6sungen, um trotzdem \u00c4nderungen der Sichtdaten an die Basisdaten der zugrunde liegenden Tabellen weiterleiten zu k\u00f6nnen.", "explanation": "Das Problem der nicht \u00e4nderbaren Sichten gibt es schon. Nur Sichten mit sehr einfachen SELECT-Anfragen (i.d.R. nur eine Tabelle und alle Pflichtspalten sind in der Sicht, ...) sind automatisch vom DBMS \u00e4nderbar. Auf allen anderen Sichten kann der Anwender DML-Operationen ausf\u00fchren, es muss nur ein INSTEAD-OF-Trigger programmiert sein, der die f\u00fcr diese Sichtdaten\u00e4nderungen relevanten DML-Anweisungen mit \u00c4nderungen der zugrunde liegenden Tabellendaten enth\u00e4lt, die dann anstelle der Sicht-DML-Operation ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "BEFORE-Trigger", "solution": "false"}, {"text": "AFTER-Trigger", "solution": "false"}, {"text": "STATEMENT-Trigger", "solution": "false"}, {"text": "INSTEAD-OF-Trigger", "solution": "true"}, {"text": "DDL-Trigger", "solution": "false"}, {"text": "Dieses Problem gibt es nicht. F\u00fcr alle Sichten sind Daten\u00e4nderungen vom DBMS automatisch in Basisdaten\u00e4nderungen transformierbar.", "solution": "false"}, {"text": "Dieses Problem gibt es nicht, da DML-Operationen nicht auf Sichten ausf\u00fchrbar sind, sondern nur auf Tabellen.", "solution": "false"}]}, {"id": 2751, "category": 9, "difficulty": 2, "text": "F\u00fcr die  nicht \u00e4nderbaren Sichten  gibt es folgende L\u00f6sungen, um \u00c4nderungen der Sichtdaten an die Basisdaten der zugrunde liegenden Tabellen weiterleiten zu k\u00f6nnen:", "explanation": "Das Problem der nicht \u00e4nderbaren Sichten gibt es schon. Nur Sichten mit sehr einfachen SELECT-Anfragen (i.d.R. nur eine Tabelle und alle Pflichtspalten sind in der Sicht, ...) sind automatisch vom DBMS \u00e4nderbar. Auf allen anderen Sichten kann der Anwender trotzdem DML-Operationen ausf\u00fchren, es muss nur ein INSTEAD-OF-Trigger programmiert sein, der die f\u00fcr diese Sichtdaten\u00e4nderungen relevanten DML-Anweisungen mit \u00c4nderungen der zugrunde liegenden Tabellendaten enth\u00e4lt, die dann anstelle der Sicht-DML-Operation ausgef\u00fchrt wird.", "type": "multiple-choice", "answers": [{"text": "BEFORE-Trigger", "solution": "false"}, {"text": "AFTER-Trigger", "solution": "false"}, {"text": "STATEMENT-Trigger", "solution": "false"}, {"text": "INSTEAD-OF-Trigger", "solution": "true"}, {"text": "DDL-Trigger", "solution": "false"}, {"text": "Dieses Problem gibt es nicht. F\u00fcr alle Sichten sind Daten\u00e4nderungen vom DBMS automatisch in Basisdaten\u00e4nderungen transformierbar.", "solution": "false"}, {"text": "Dieses Problem gibt es nicht, da DML-Operationen nicht auf Sichten ausf\u00fchrbar sind, sondern nur auf Tabellen.", "solution": "false"}]}, {"id": 2753, "category": 42, "difficulty": 2, "text": "Erstellen Sie einen B-Baum vom Typ 2 f\u00fcr folgende Eingabewerte: 1, 15, 22, 4, 17, 3. \n\nGeben Sie die Zahlen f\u00fcr jeden Knoten mit Komma und Leerzeichen getrennt in der richtigen Reihenfolge an.", "explanation": "Hier die einzelnen Schritte: \n* 1\n* 1, 15\n* 1, 15, 22\n* 1,  4, 15, 22\n\nDa Typ 2 ist mit 4 Eintr\u00e4gen der Knoten gef\u00fcllt und muss gesplittet werden f\u00fcr das Einf\u00fcgen von 17. \nlinker Knoten:  1, 4\nWurzel:         15\nrechter Knoten: 17, 22\n\nEinf\u00fcgen von 3:\nlinker Knoten:  1, 3, 4\nWurzel:         15\nrechter Knoten: 17, 22", "type": "text", "answers": [{"text": "Linker Knoten", "solution": "1, 3, 4"}, {"text": "Wurzel", "solution": "15"}, {"text": "rechter Knoten", "solution": "17, 22"}]}, {"id": 2755, "category": 42, "difficulty": 2, "text": "Welche Speicherstrukturen  k\u00f6nnen aufgrund von \u00dcberlaufseiten langsamer werden? (nur die K\u00fcrzel in Gro\u00dfbuchstaben und in alphabetischer Reihenfolge)", "explanation": "\u00dcberlaufseiten verlangsamen den Lesezugriff bei ISAM und HASH, da die urspr\u00fcngliche Speicherstruktur zu einer linearen Liste ausarten kann, die sequentiell beim Lesen durchsucht werden muss.\n\n    \n\n    Die anderen Speicherstrukturen haben keine \u00dcberlaufseiten.", "type": "text", "answers": [{"text": "Das ist einmal bei ...", "solution": "HASH"}, {"text": "und dann noch bei ...", "solution": "ISAM"}]}, {"id": 2756, "category": 42, "difficulty": 3, "text": "Bei welchen Speicherstrukturen  werden Bereichsvergleiche wie z.B. <, >, >=, >= \u00fcber den Schl\u00fcssel schlecht unterst\u00fctzt? (K\u00fcrzel in Gro\u00dfbuchstaben und in alphabetischer Reihenfolge)", "explanation": "Bei HEAP werden die Datens\u00e4tze unsortiert in der Reihenfolge der Eingabe gespeichert und dann auch wieder gelesen.\n\n    \n\n    Bei HASH wird ein in der Regel numerischer Schl\u00fcsselwert in eine Art logischer Seitennummer umgerechnet (z.B. Modulo-Verfahren). Benachbarte Nummern k\u00f6nnen somit in v\u00f6llig unterschiedlichen Seiten gespeichert werden.", "type": "text", "answers": [{"text": "Das ist einmal:", "solution": "\r\n    HASH\r"}, {"text": "und zum anderen ...", "solution": "HEAP"}]}, {"id": 2761, "category": 9, "difficulty": 2, "text": "Welche  der folgenden Code-Abschnitte aus PL/SQL sind syntaktisch korrekt?", "explanation": "Funktionen m\u00fcssen in PL/SQL einen R\u00fcckgabewert haben, PL/SQL-Prozeduren haben dagegen keinen R\u00fcckgabewert.", "type": "multiple-choice", "answers": [{"text": "\n\nCREATE OR REPLACE FUNCTION durchschnitt_berechnen \n  (p_wert1  IN  NUMBER, p_wert2  IN  NUMBER)\n  RETURN number\nIS \nBEGIN\n  RETURN (p_wert1 + p_wert2) / 2;\nEND;", "solution": "true"}, {"text": "\n\nCREATE OR REPLACE FUNCTION durchschnitt_berechnen \n  (p_wert1  IN  NUMBER, p_wert2  IN  NUMBER)\n  RETURN number\nIS \nBEGIN\n  p_wert1 + p_wert2 / 2;\nEND;", "solution": "false"}, {"text": "\n\nCREATE OR REPLACE procedure durchschnitt_berechnen \n  (p_wert1  IN  NUMBER, p_wert2  IN  NUMBER)\n  RETURN number\nIS \nBEGIN\n  RETURN (p_wert1 + p_wert2) / 2;\nEND;", "solution": "false"}, {"text": "\n\nCREATE OR REPLACE procedure durchschnitt_berechnen \n  (p_wert1  IN  NUMBER, p_wert2  IN  NUMBER)\nIS \n  ergebnis number;\nBEGIN\n  ergebnis := (p_wert1 + p_wert2) / 2;\nEND;", "solution": "true"}]}, {"id": 2765, "category": 9, "difficulty": 2, "text": "Welche CONSTRAINTS k\u00f6nnen als Spalten-Constraint definiert werden?", "explanation": "Alle 5 Constraint-Typen k\u00f6nnen als Spaltenbedingung formuliert werden. NOT NULL ist der einzige CONSTRAINT-Typ, der nicht als Tabellenbedingung geschrieben werden kann.", "type": "multiple-choice", "answers": [{"text": "NOT NULL", "solution": "true"}, {"text": "PRIMARY KEY", "solution": "true"}, {"text": "CHECK", "solution": "true"}, {"text": "UNIQUE", "solution": "true"}, {"text": "REFERENCES", "solution": "true"}]}, {"id": 2768, "category": 9, "difficulty": 3, "text": "Welche abh\u00e4ngigen Objekte werden unter ORACLE-SQL gel\u00f6scht, wenn eine Tabelle gel\u00f6scht wird, f\u00fcr die dieses Objekt definiert ist?", "explanation": "Synonyme und Views bleiben bestehen, allerdings wird der Status auf INVALID gesetzt. Nur abh\u00e4ngige Indizes werden gel\u00f6scht, z.B. der Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "VIEWS", "solution": "false"}, {"text": "SYNONYME", "solution": "false"}, {"text": "INDIZES", "solution": "true"}]}, {"id": 2770, "category": 11, "difficulty": 2, "text": "Betrachten Sie die folgenden Anweisungen in Oracle-SQL:\n\n    COMMIT; SAVEPOINT POINT_A;\n\n    CREATE TABLE CLASSES CLASS_ID NUMBER(13) PRIMARY KEY, INSTRUCTOR_ID NUMBER(13));\n\n    INSERT INTO CLASSES VALUES (1,1);\n\n    INSERT INTO CLASSES VALUES (2,2);\n\n    SAVEPOINT POINT_B; INSERT INTO CLASSES VALUES (3,3);\n\n    ROLLBACK WORK TO POINT_A; INSERT INTO CLASSES VALUES (4,4);\n\n    ROLLBACK WORK TO POINT_B; COMMIT;\n\n    Wieviele Datens\u00e4tze stehen nach diesen Anweisungen in der Tabelle CLASSES?", "explanation": "CREATE TABLE bewirkt ein implizites COMMIT, so dass der SAVEPOINT A aufgehoben wird. Die Datens\u00e4tze 3 und 4 werden dagegen vor dem endg\u00fcltigen COMMIT zur\u00fcckgerollt.", "type": "text", "answers": [{"text": "Tragen Sie eine Zahl ein!", "solution": "\r\n    2\r"}]}, {"id": 2771, "category": 9, "difficulty": 2, "text": "Verursachen die folgenden SQL-Befehle unter ORACLE einen Fehler? \n\n    CREATE TABLE TEST (nr number);\n\n    CREATE VIEW TEST AS SELECT * FROM TEST;", "explanation": "Unter Oracle-SQL k\u00f6nnen nicht zwei Objekte mit dem gleichen Namen angelegt werden, auch wenn sie unterschiedlichen Typs, wie Tabellen und Sichten sind. Alle Objekte, auf die ein Benutzer Zugriff hat, findet man in der Dictionary-View USER_OBJECTS.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2772, "category": 9, "difficulty": 2, "text": "Welche SELECT-Abfrage mit DISTINCT filtert aus einer Tabelle(Spalte1, Spalte2) alle Werte heraus, dies sowohl in der Spalte1 als auch in der Spalte2 verschiedene Werte haben?", "explanation": "Das Schl\u00fcsselwort DISTINCT kann nur einmal in der SELECT-Klausel vorkommen, und zwar vor dem ersten Spaltennamen.", "type": "multiple-choice", "answers": [{"text": "SELECT DISTINCT SPALTE1, SPALTE2\nFROM Tabelle;", "solution": "true"}, {"text": "SELECT DISTINCT SPALTE1, DISTINCT SPALTE2\nFROM Tabelle;", "solution": "false"}, {"text": "SELECT SPALTE1, DISTINCT SPALTE2\nFROM Tabelle;", "solution": "false"}]}, {"id": 2735, "category": 9, "difficulty": 3, "text": "Ausgehend von den Basisdatentypen und den zugelassenen Typkonstruktoren l\u00e4sst sich das SQL-92-Modell in inline-Notation wie folgt beschreiben:", "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.", "type": "text", "answers": [{"text": "Das ist:", "solution": "MULTISET(ROW(Basisdatentyp))"}]}, {"id": 2764, "category": 9, "difficulty": 3, "text": "Welche CONSTRAINTS k\u00f6nnen nicht als Tabellen-Constraint definiert werden?", "explanation": "NOT NULL ist der einzige CONSTRAINT-Typ, der nicht als Tabellenbedingung geschrieben werden kann.", "type": "multiple-choice", "answers": [{"text": "NOT NULL", "solution": "true"}, {"text": "PRIMARY KEY", "solution": "false"}, {"text": "CHECK", "solution": "false"}, {"text": "UNIQUE", "solution": "false"}, {"text": "REFERENCES", "solution": "false"}]}, {"id": 2773, "category": 9, "difficulty": 3, "text": "Welche SQL-Anweisung einh\u00e4lt ein implizites COMMIT?", "explanation": "Alle DDL-Anweisungen(CREATE, DROP, ALTER..)  beinhalten ein implizites COMMIT, im Gegensatz zu den DML-Anweisungen INSERT, UPDATE und DELETE.", "type": "multiple-choice", "answers": [{"text": "DROP TABLE", "solution": "true"}, {"text": "INSERT", "solution": "false"}, {"text": "UPDATE", "solution": "false"}, {"text": "DELETE", "solution": "false"}, {"text": "SELECT", "solution": "false"}, {"text": "CREATE TABLE", "solution": "true"}, {"text": "CREATE VIEW", "solution": "true"}]}, {"id": 2774, "category": 9, "difficulty": 2, "text": "Welchem Schemaobjekt kann man ein CONSTRAINT zuweisen?", "explanation": "CONSTRAINTS sind immer an eine Tabelle angeh\u00e4ngt und k\u00f6nnen mit CREATE TABLE oder ALTER TABLE.. erzeugt werden.", "type": "multiple-choice", "answers": [{"text": "TABLE", "solution": "true"}, {"text": "VIEW", "solution": "false"}, {"text": "INDEX", "solution": "false"}, {"text": "SEQUENCE", "solution": "false"}]}, {"id": 2775, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden CREATE-TABLE-Befehl:\n\n    CREATE TABLE Person (\n\n    ID NUMBER,\n\n    NACHNAME VARCHAR2,\n\n    TYP CHAR);\n\n    \n\n    Welche Aussage/n sind/ist korrekt?", "explanation": "NUMBER und CHAR kommen ohne L\u00e4ngenangabe aus, NUMBER ist eine Flie\u00dfkommazahl, CHAR ein Textfeld der L\u00e4nge 1.", "type": "multiple-choice", "answers": [{"text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil NUMBER ohne Nachkommastellen nicht zugelassen ist.", "solution": "false"}, {"text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil CHAR eine L\u00e4nge , z.B. CHAR(10) haben muss.", "solution": "false"}, {"text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil VARCHAR2 eine L\u00e4nge , z.B. VARCHAR(10) haben muss.", "solution": "true"}]}, {"id": 2777, "category": 11, "difficulty": 3, "text": "Mit welchem Schl\u00fcsselwort kann man eine Stelle definieren, bis zu der ein ROLLBACK zur\u00fcckrollen soll?", "explanation": "SAVEPOINT ist ein SQL-Befehl, der angibt, bis zu welcher SQL-DML-Anweisung ein ROLLBACK zur\u00fcckrollen soll.", "type": "text", "answers": [{"text": "Das ist ein", "solution": "\r\n    SAVEPOINT\r"}]}, {"id": 2778, "category": 9, "difficulty": 2, "text": "Welche Klauseln muss ein UPDATE-STATEMENT haben?", "explanation": "Ein UPDATE ohne WHERE ist zul\u00e4ssig und \u00e4ndert alle Tupel der Tabelle. UPDATE selber und SET sind notwendig.", "type": "multiple-choice", "answers": [{"text": "UPDATE", "solution": "true"}, {"text": "SET", "solution": "true"}, {"text": "WHERE", "solution": "false"}]}, {"id": 2738, "category": 9, "difficulty": 3, "text": "Ausgehend von den Basisdatentypen und den zugelassenen Typkonstruktoren l\u00e4sst sich das relationale Modell in inline-Notation wie folgt beschreiben:", "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.", "type": "text", "answers": [{"text": "Das ist:", "solution": "SET(ROW(Basisdatentyp))"}]}, {"id": 2780, "category": 9, "difficulty": 2, "text": "SEQUENZEN sind immer automatisch mit einer Tabelle verbunden und dienen dazu, Werte in einer Spalte beim Einf\u00fcgen von Daten automatisch zu erh\u00f6hen.", "explanation": "SEQUENZEN werden mit einem CREATE SEQUENCE(...) -Befehl angelegt und sind damit als eigenst\u00e4ndige Datenbankobjekte nicht mit einer Tabelle verkn\u00fcpft. Theoretisch k\u00f6nnen Sie daher zum Generieren von fortlaufenden Nummern in mehreren Tabellen verwendet werden, auch wenn das aus Gr\u00fcnden der \u00dcbersichtlichkeit nicht empfehlenswert ist.  \n\nsiehe <a  href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-SEQUENCE\"> SEQUENCE im DB-Wiki", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 2785, "category": 9, "difficulty": 1, "text": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX)", "explanation": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX) geh\u00f6ren zum SQL-Standard und fassen Werte aus unterschiedlichen Tupeln zu genau einem Wert zusammen.", "type": "multiple-choice", "answers": [{"text": "geben immer genau einen Wert zur\u00fcck.", "solution": "true"}, {"text": "K\u00f6nnen auch mehrere Werte zur\u00fcckgeben.", "solution": "false"}]}, {"id": 2674, "category": 11, "difficulty": 1, "text": "Welcher Pr\u00fcfungszeitpunkt (CONSTRAINT_CHARACTERISTICA) f\u00fchrt dazu, dass beim Erkennen eines Fehlers nur die fehlerhafte DML-Anweisung zur\u00fcckgesetzt wird und die \u00fcbrigen Datens\u00e4tze der laufenden Transaktion nicht betroffen sind?", "explanation": "Werden Daten\u00e4nderungen ausgef\u00fchrt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integrit\u00e4tsbedingung gepr\u00fcft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung r\u00fcckg\u00e4ngig gemacht. Die \u00fcbrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl l\u00f6st das Transaktionsende aus und damit die Pr\u00fcfung aller CONSTRAINTs (Integrit\u00e4tsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \n\nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden w\u00e4hrend einer Transaktion erst mal akzeptiert und er zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs gepr\u00fcft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, f\u00fchrt dies zur Anzeige einer Fehlermeldung und zum Zur\u00fcckrollen der gesamten Transaktion.", "type": "multiple-choice", "answers": [{"text": "INITIALLY DEFERRED", "solution": "false"}, {"text": "INITIALLY IMMEDIATE", "solution": "true"}]}, {"id": 2659, "category": 9, "difficulty": 3, "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte folgende Werte enth\u00e4lt: 3000, 4000, NULL, 2000, 4000.    \n     \nSELECT SUM(gehalt*12) Jahresgehalt FROM Mitarbeiter;", "explanation": "Die numerische Operation gehalt*12 liefert f\u00fcr den NULL-Datensatz zwar als Ergebnis wieder NULL, der SUM-Oerator ignoriert hingegen die NULL-Werte und kommt zu dem Ergebnis: 3000+4000+2000+4000 = 13000.", "type": "text", "answers": [{"text": "Das Ergebnis ist:", "solution": "156000"}]}, {"id": 2662, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle:\nCREATE TABLE Zeitschrift (\n       Zeitschrift_id           INTEGER NOT NULL,\n       Namen                    VARCHAR2(20) NULL,\n       PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz (\n       Aufsatz_id              INTEGER NOT NULL,\n       Titel                      VARCHAR2(20) NULL,\n       Zeitschrift_id            INTEGER NOT NULL,\n       PRIMARY KEY (Aufsatz_id), \n       FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);      \n\nDie Tabellen enthalten folgende Datens\u00e4tze: \nZeitschrift (1, 'DB-Spektrum');\nZeitschrift (2, 'Informatik-Spektrum');\n\nAufsatz (1, 'Tuning', 1); \nAufsatz (2, 'DWH', 1); \n\nKann es problematisch werden, wenn Aufsatz-Datens\u00e4tze gel\u00f6scht werden?", "explanation": "Es ist kein Problem, weil Aufsatz die Detail-Tabelle ist. \nProblematisch w\u00e4re es, wenn Master-Datens\u00e4tze (hier Zeitschrift) gel\u00f6scht werden, weil dann vor dem L\u00f6schen gepr\u00fcft wird, ob es abh\u00e4ngige Datens\u00e4tze (Detail: Aufsatz) mit einem passenden Fremdschl\u00fcsselwert gibt. Wenn ja, wird nicht gel\u00f6scht. Nur wenn nicht, wird der Master-Datensatz gel\u00f6scht.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "false"}, {"text": "nein", "solution": "true"}]}, {"id": 2663, "category": 9, "difficulty": 1, "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle: \nCREATE TABLE Zeitschrift (\n       Zeitschrift_id           INTEGER NOT NULL,\n       Namen                    VARCHAR2(20) NULL,\n       PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz (\n       Aufsatz_id              INTEGER NOT NULL,\n       Titel                      VARCHAR2(20) NULL,\n       Zeitschrift_id            INTEGER NOT NULL,\n       PRIMARY KEY (Aufsatz_id), \n       FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift); Die Tabellen enthalten folgende Datens\u00e4tze: Zeitschrift (1, \"DB-Spektrum\"); Zeitschrift (2, \"Informatik-Spektrum\"); Aufsatz (1, \"Tuning\", 1); Aufsatz (2, \"DWH\", 1); Kann es problematisch werden, wenn Zeitschrift-Datens\u00e4tze gel\u00f6scht werden?", "explanation": "Es kann ein Problem sein, weil Zeitschrift die Master-Tabelle ist.\n\n    Wenn Master-Datens\u00e4tze (hier Zeitschrift) gel\u00f6scht werden wird vor dem L\u00f6schen gepr\u00fcft, ob es abh\u00e4ngige Datens\u00e4tze (Detail: Aufsatz) mit einem passenden Fremdschl\u00fcsselwert gibt. Wenn ja, wird nicht gel\u00f6scht. Nur wenn nicht, wird der Master-Datensatz gel\u00f6scht.", "type": "multiple-choice", "answers": [{"text": "ja", "solution": "true"}, {"text": "nein", "solution": "false"}]}, {"id": 2687, "category": 1, "difficulty": 1, "text": "ANSI-3-Ebenen-Modell: Die Organisation der physischen Speicherung wird ge\u00e4ndert.", "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enth\u00e4lt die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen ben\u00f6tigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabh\u00e4ngig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird prim\u00e4r vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation \u00fcber die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.", "type": "multiple-choice", "answers": [{"text": "Diese \u00c4nderung betrifft die interne Ebene.", "solution": "true"}, {"text": "Diese \u00c4nderung betrifft die externe Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft die konzeptionelle Ebene.", "solution": "false"}, {"text": "Diese \u00c4nderung betrifft keine Ebene.", "solution": "false"}]}, {"id": 2652, "category": 42, "difficulty": 2, "text": "Die Anordnung der Schl\u00fcsselwerte in einem B-Baum h\u00e4ngt von der Reihenfolge der Eingabe der Werte ab, d.h. z.B. {1,2,3,4,5,6,7,8,9} ergibt einen anderen B-Baum als [9,8,7,6,5,4,3,2,1}.", "explanation": "Es gibt verschiedene B-B\u00e4ume mit den gleichen Werten, aber unterschiedlichem Aufbau. Dies h\u00e4ngt mit der Konstruktionsvorschrift f\u00fcr B-B\u00e4ume zusammen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2653, "category": 11, "difficulty": 3, "text": "Es ist die folgende leere Tabelle gegeben: busfahrer(mita_id, stundenlohn), wobei mita_id eine Prim\u00e4rschl\u00fcsselspalte (Pr\u00fcfungszeitpunkt: IMMEDIATE) ist und stundenlohn eine Pflichteingabespalte (Pr\u00fcfungszeitpunkt: DEFERRED).\n\n    Es sind folgende Transaktionen gegeben:\n\n    INSERT INTO busfahrer VALUES (4711, 6);\n\n    INSERT INTO busfahrer VALUES (4712, 0);\n\n    SELECT mita_id FROM busfahrer; -- 1. SELECT\n\n    INSERT INTO busfahrer VALUES (4711, 8);\n\n    SELECT mita_id FROM busfahrer; -- 2. SELECT\n\n    COMMIT;\n\n    SELECT mita_id FROM busfahrer; -- 3.SELECT\n\n    INSERT INTO busfahrer VALUES (4713, NULL);\n\n    SELECT mita_id FROM busfahrer; -- 4. SELECT\n\n    INSERT INTO busfahrer VALUES (4714, 9);\n\n    SELECT mita_id FROM busfahrer; -- 5. SELECT\n\n    COMMIT;\n\n    SELECT mita_id FROM busfahrer; -- 6. SELECT\n\n    Geben Sie f\u00fcr jedes SELECT-Anweisung an, welche Ergebnismenge angezeigt wird, wobei mehrere Datens\u00e4tze durch ein Semikolon getrennt sind und schreiben Sie NO ROWS, falls der SELECT keine Zeilen liefert!", "explanation": "1. SELECT: 4711; 4712\n\n    \n\n    2. SELECT: 4711; 4712\n\n    Der 3. INSERT (4711,8) wird unmittelbar abgebrochen, weil er die Prim\u00e4rschl\u00fcsselbedingung verletzt.\n\n    \n\n    3. SELECT: 4711; 4712\n\n    COMMIT beendet die 1. Transaktion und da durch die beiden Datens\u00e4tze das DEFERRED-Constraint nicht verletzt ist, werden die beiden Datens\u00e4tze persistent gespeichert und k\u00f6nnen durch kein Zur\u00fcckrollen von Transaktionen mehr entfernt werden.\n\n    \n\n    4. SELECT: 4711; 4712\n\n    Mit der Einf\u00fcgung (4713, NULL) startet die 2. Transaktion. Sie verletzt das Pflichteingabe-Constraint f\u00fcr die 2. Spalte, wird jedoch erst einmal eingef\u00fcgt, da dieses Constraint mit dem Pr\u00fcfungszeitpunkt DEFERRED definiert ist. Diese Bedingung erst also zum COMMIT gepr\u00fcft.\n\n    \n\n    5. SELECT: 4711; 4712; 4713; 4714\n\n    Die Einf\u00fcgung (4714, 9) verletzt keine Constraints.\n\n    \n\n    6. SELECT: 4711; 4712 Dieses 2. COMMIT schlie\u00dft die 2. Transaktion mit einer DEFERRED-Integrit\u00e4tspt\u00fcgung ab, stellt einen Fehler fest f\u00fcr (4713, NULL) und rollt diese 2. Transaktion bis zum 1. COMMIT zur\u00fcck, so dass nur noch die Datens\u00e4tze der 1. Transaktion persistent in der DB gespeichert sind.", "type": "text", "answers": [{"text": "Ergebnis 1.SELECT", "solution": "4711; 4712"}, {"text": "Ergebnis 2.SELECT", "solution": "4711; 4712"}, {"text": "Ergebnis 3.SELECT:", "solution": "4711; 4712"}, {"text": "Ergebnis 4.SELECT:", "solution": "4711; 4712; 4713"}, {"text": "Ergebnis 5. SELECT:", "solution": "4711; 4712; 4713; 4714"}, {"text": "Ergebnis 6. SELECT:", "solution": "4711; 4712"}]}, {"id": 2676, "category": 11, "difficulty": 3, "text": "Wie nennt man das folgende Problem:\nW\u00e4hrend einer Transaktion A wird eine Anfrage mehrmals gestellt und zwischenzeitlich werden durch andere Transaktionen neue Datens\u00e4tze eingef\u00fcgt.", "explanation": "LOST UPDATE (verlorene \u00c4nderungen) ist das Problem, das auf dem \u00dcberschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgef\u00fchrter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn \u00c4nderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zu\u00fcckgerollt werden (ROLLBACK, Integrit\u00e4tsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgef\u00fchrte Transaktionen die Daten zwischenzeitlich ge\u00e4ndert bzw. gel\u00f6scht haben (NON REPEATABLE READ) oder neue Datens\u00e4tze eingef\u00fcgt wurden (PHANTOME).", "type": "multiple-choice", "answers": [{"text": "DIRTY READ", "solution": "false"}, {"text": "PHANTOM", "solution": "true"}, {"text": "NON REPEATABLE READ", "solution": "false"}, {"text": "LOST UPDATE", "solution": "false"}]}, {"id": 2677, "category": 11, "difficulty": 2, "text": "Wie nennt man das folgende Problem:\nW\u00e4hrend einer Transaktion A wird eine Anfrage mehrmals gestellt und zwischenzeitlich werden durch andere Transaktionen Datens\u00e4tze gel\u00f6scht bzw. ihre Werte ge\u00e4ndert.", "explanation": "LOST UPDATE (verlorene \u00c4nderungen) ist das Problem, das auf dem \u00dcberschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgef\u00fchrter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn \u00c4nderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zu\u00fcckgerollt werden (ROLLBACK, Integrit\u00e4tsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgef\u00fchrte Transaktionen die Daten zwischenzeitlich ge\u00e4ndert bzw. gel\u00f6scht haben (NON REPEATABLE READ) oder neue Datens\u00e4tze eingef\u00fcgt wurden (PHANTOME).", "type": "multiple-choice", "answers": [{"text": "DIRTY READ", "solution": "false"}, {"text": "PHANTOM", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "true"}, {"text": "LOST UPDATE", "solution": "false"}]}, {"id": 2673, "category": 11, "difficulty": 1, "text": "Bei welchem Pr\u00fcfungszeitpunkt (= CONSTRAINT_CHARACTERISTICA ) wird die Datenpr\u00fcfung sofort nach einer Daten\u00e4nderung (INSERT, UPDATE, DELETE) durchgef\u00fchrt?", "explanation": "Werden Daten\u00e4nderungen ausgef\u00fchrt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integrit\u00e4tsbedingung gepr\u00fcft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung r\u00fcckg\u00e4ngig gemacht. Die \u00fcbrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl l\u00f6st das Transaktionsende aus und damit die Pr\u00fcfung aller CONSTRAINTs (Integrit\u00e4tsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden w\u00e4hrend einer Transaktion erst mal akzeptiert und er zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs gepr\u00fcft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, f\u00fchrt dies zur Anzeige einer Fehlermeldung und zum Zur\u00fcckrollen der gesamten Transaktion.", "type": "multiple-choice", "answers": [{"text": "INITIALLY IMMEDIATE", "solution": "true"}, {"text": "INITIALLY DEFERRED", "solution": "false"}]}, {"id": 2660, "category": 9, "difficulty": 3, "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte folgende Werte enth\u00e4lt: 1000, 4000, NULL, 3000, 2000.    \n     \nSELECT AVG(gehalt*12) Durchschnitt_Jahresgehalt FROM Mitarbeiter;", "explanation": "Die numerische Operation gehalt*12 liefert f\u00fcr den NULL-Datensatz zwar als Ergebnis wieder NULL, der AVG-Operator ignoriert hingegen, die Datens\u00e4tze mit NULL-Werten und kommt zu dem Ergebnis: (1000+4000+3000+2000)/4 = 10000/4 = 2500.", "type": "text", "answers": [{"text": "Das Ergebnis ist:", "solution": "30000"}]}, {"id": 2661, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche SELECT-Abfrage entspricht dem nat\u00fcrlichen Join?", "explanation": "RICHTIG w\u00e4re: \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr\nAND   Angestellte.ORT = Abteilungen.ORT\nAND   Angestellte.ANG_Nr = Abteilungen.ANG_NR;\" \nweil ein Natural Join, \u00fcber alle Spalten dieser Tabellen, die gleich hei\u00dfen, Abt_Nr, Ort, Ang_Nr, auf Gleichheit verglichen werden und die Teilbedingungen mit AND verkn\u00fcpft werden. \noder diese Anfrage: \nSELECT * FROM Angestellte NATURAL JOIN Abteilungen;\n\n\nDie Semantik dieses nat\u00fcrlichen Joins hei\u00dft: \"Welche Mitarbeiter arbeiten in Abteilungen, deren Leiter sie sind und deren Abteilung an ihrem Wohnort liegt.\"\n\n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verkn\u00fcpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN weil nur \u00fcber eine der drei gleich lautenden Spalten verkn\u00fcpft wird und nicht \u00fcber alle drei!", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Angestellte, Abteilungen;", "solution": "false"}, {"text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;", "solution": "false"}, {"text": "keine von allen", "solution": "true"}]}, {"id": 2667, "category": 11, "difficulty": 3, "text": "Wie nennt man das Verfahren, das nach folgender Methode verf\u00e4hrt:\n\n- Man nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden.\n- Lesende Zugriffe (SELECT) l\u00f6sen keine Sperren aus.\n- Jeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird.\n- Bei \u00c4nderungen wird zun\u00e4chst gepr\u00fcft, ob der Zeitstempel unver\u00e4ndert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unver\u00e4ndert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.", "explanation": "Passive und dynamische Sperrverfahren gibt es nicht.\n\nOptimistisches Sperrverfahren \nMan nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden. Lesende Zugriffe (SELECT) l\u00f6sen keine Sperren aus.\nJeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird. Bei \u00c4nderungen wird zun\u00e4chst gepr\u00fcft, ob der Zeitstempel unver\u00e4ndert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unver\u00e4ndert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.\n\nPessimistisches Sperrverfahren\nMan nimmt an, dass viele schreibende Zugriffe auf der Datenbank stattfinden.Auch lesende Zugriffe (SELECT FOR UPDATE statt SELECT) l\u00f6sen Sperren f\u00fcr andere Benutzer aus.Die Daten werden erst wieder freigegeben, wenn alle \u00c4nderungen abgespeichert sind.", "type": "multiple-choice", "answers": [{"text": "optimistisch", "solution": "true"}, {"text": "pessimistisch", "solution": "false"}, {"text": "dynamisch", "solution": "false"}, {"text": "passiv", "solution": "false"}]}, {"id": 2679, "category": 11, "difficulty": 3, "text": "Welche Probleme sind Probleme der Nebenl\u00e4ufigkeitskontrolle?", "explanation": "Bei der Nebenl\u00e4ufigkeitskontrolle geht es darum, dass mehrere Transaktionen parallel ausgef\u00fchrt werden und das Ergebnis das gleiche wie im \"Single User-Betrieb\" ist, die Transaktionen sich also nicht gegenseitig beeinflussen. Es ist das I der ACID-Eigenschaften (I f\u00fcr Isolation).\n\nDaraus resultieren im wesentlichen zwei Probleme:\n\n\"Lost Update\" ist ein Problem der Nebenl\u00e4ufigkeitskontrolle weniger der Lesekonsistenz. \n\"Dirty Read\" ist ein Problem, das beiden Aufgabenstellungen, Nebenl\u00e4ufigkeitskontrolle wie auch Lesekonsistenz betrifft. \n\n\"Phantome\" und \"Non Repeatable Reads\" sind vorrangig Probleme der Lesekonsistenz.", "type": "multiple-choice", "answers": [{"text": "LOST UPDATE", "solution": "true"}, {"text": "DIRTY READ", "solution": "true"}, {"text": "PHANTOM", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 2678, "category": 11, "difficulty": 3, "text": "Welche Probleme sind Probleme der Lesekonsistenz?", "explanation": "Lesekonsistenz ist ein weiteres Problem, welches beim Mehrbenutzerbetrieb auftritt. Bei l\u00e4nger andauernden Transaktionen stellt sich die Frage, auf welchem Datenbankzustand die Anfragen eigentlich ausgewertet werden, wenn parallel andere Benutzer die zu lesenden Daten \u00e4ndern.\n\nDaraus resultieren mehrere Probleme: \n\nBei innerhalb einer Transaktion wiederholten Anfragen k\u00f6nnen bei der Wiederholung Datens\u00e4tze angezeigt werden, die vorher nicht da waren, also \"Phantome\", bzw. es werden Datens\u00e4tze nicht mehr angezeigt oder mit ge\u00e4nderten Inhalt, also \"nicht wiederholbares Lesen\".  Grund daf\u00fcr sind jeweils andere Transaktionen, die ihre \u00c4nderungen persistent gespeichert haben (COMMIT).\n\nEin anderes Problem stellt sich bei langandauernden Anfragen, was passiert mit den \u00c4nderungen parallel ausgef\u00fchrter Transaktionen, die zwischenzeitlich ihre \u00c4nderungen persistent gespeichert haben. (COMMIT).\n\n\"Dirty Read\" ist ein Problem, das beiden Aufgabenstellungen, Nebenl\u00e4ufigkeitskontrolle wie auch Lesekonsistenz betrifft.\n\n\"Lost Update\" ist ein Problem der Nebenl\u00e4ufigkeitskontrolle weniger der Lesekonsistenz.", "type": "multiple-choice", "answers": [{"text": "LOST UPDATE", "solution": "false"}, {"text": "DIRTY READ", "solution": "true"}, {"text": "PHANTOM", "solution": "true"}, {"text": "NON REPEATABLE READ", "solution": "true"}]}, {"id": 2937, "category": 5, "difficulty": 1, "text": "In obligatorischen Attributen (ER-Modell) sind NULL-Werte erlaubt.", "explanation": "Obligatorisch bedeutet, dass das Attribut einen Wert haben muss, also nicht NULL sein darf.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3159, "category": 10, "difficulty": 1, "text": "INSTEAD-OF-TRIGGER  geh\u00f6ren zum SQL-Standard.", "explanation": "INSTEAD-OF-Trigger sind ein ORACLE-Feature, das nur f\u00fcr Views definert ist und damit Views \u00e4nderbar macht.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3160, "category": 9, "difficulty": 2, "text": "INSTEAD-OF-TRIGGER  k\u00f6nnen unter Oracle-SQL definiert werden", "explanation": "INSTEAD-OF.Trigger sind ein ORACLE-Feature, das nur f\u00fcr Views definert ist und damit Views \u00e4nderbar macht.", "type": "multiple-choice", "answers": [{"text": "auf Tabellen", "solution": "false"}, {"text": "auf views", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 3182, "category": 8, "difficulty": 1, "text": "Welcher Join-Operator ist immer verlustfrei?", "explanation": "Eine Join-Operation zwischen R und S hei\u00dft verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis. Bei allen Join-Operatoren bis auf den Full-Outer-Join k\u00f6nnen Tupel, die in der verkn\u00fcpften Operation kein Gegen\u00fcber haben, wegfallen.", "type": "text", "answers": [{"text": "Das ist der:", "solution": "Full Outer Join"}]}, {"id": 3084, "category": 9, "difficulty": 1, "text": "Jahr ist eine Spalte vom Typ DATE. Welche der WHERE-Bedingungen ist die kosteng\u00fcnstigeste/schnellste?", "explanation": "Die Konvertierungsfunktionen TO_NUMBER und TO_CHAR sind f\u00fcr die Spalte Jahr programmiert und werden somit in diesem Beispiel f\u00fcr jeden Spaltenwert ausgef\u00fchrt, also f\u00fcr jeden Datensatz. Die TO_DATE-Funktion hingegen ist hier f\u00fcr einen String programmiert und wird daher nur einmal bei der Kompilierung der Anweisung ausgef\u00fchrt. Je mehr Datens\u00e4tze die Tabelle hat, umso mehr Zeit spart die TO_DATE-Funktion mit dem String als Parameter.", "type": "multiple-choice", "answers": [{"text": "WHERE TO_CHAR(Jahr, 'RRRR') BETWEEN '2010' AND '2012'", "solution": "false"}, {"text": "WHERE Jahr BETWEEN TO_DATE('01.01.2010', 'DD.MM.RRRR') AND TO_DATE('31.12.2012', 'DD.MM.RRRR')", "solution": "true"}, {"text": "WHERE TO_NUMBER(Jahr) BETWEEN 2010 AND 2012", "solution": "false"}]}, {"id": 3115, "category": 9, "difficulty": 3, "text": "Betrachten Sie den folgenden PL/SQL-Programm-Code:\n\nCREATE OR REPLACE ang_insert(\n  p_ang_nr number,p_nachname varchar) is\nBEGIN\n  INSERT INTO mitarbeiter values (p_ang_nr, p_nachname)\nEND;\n\nDie obige Prozedur wird von Benutzer Hugo angelegt, auch Paul soll die Prozedur ausf\u00fchren.\n\nWelche Aussagen sind korrekt?", "explanation": "Unter Oracle-PL/SQL werden Prozeduren und Funktionen per Definition mit den Objektprivilegien des Prozedureigent\u00fcmers ausgef\u00fchrt.\n(siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/GRANT#EXECUTE\" target=\"_blank\"> GRANT EXECUTE ).", "type": "multiple-choice", "answers": [{"text": "Hugo muss Paul nur einen GRANT EXCEUTE auf der Prozedur ang_insert erteilen.", "solution": "true"}, {"text": "Hugo muss Paul einen GRANT EXCEUTE auf der Prozedur ang_insert und einen GRANT INSERT auf mitarbeiter erteilen", "solution": "false"}, {"text": "Die Prozedur ang_insert wird mit den Objektpriviliegien des Benutzer Hugo ausgef\u00fchrt.", "solution": "true"}, {"text": "Die Prozedur ang_insert  wird mit den Objektpriviliegien des Benutzer Paul ausgef\u00fchrt.", "solution": "false"}]}, {"id": 3129, "category": 9, "difficulty": 2, "text": "Ein PL/SQL CURSOR enth\u00e4lt immer eine SELECT-Anweisung mit einer INTO-Klausel.", "explanation": "Ein CURSOR ersetzt gerade die INTO -Klausel einer SELECT-.Abweisung. SELECT mit INTO deklariert einen impliziten CURSOR. Der Grund daf\u00fcr ist, dass Sie im deklarativen Bereich nur einen Cursor definieren, aber keine Zeilen in den Cursor abrufen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3488, "category": 9, "difficulty": 3, "text": "Welche Aussage \u00fcber Unterabfragen ist wahr?\n\n    Unterabfragen mit ALL und ANY k\u00f6nnen verneint werden, d.h. eine Unterabfrage der Form\n\n    SELECT  Nachname, Gehalt\n\n    FROM  Angestellte\n\n    WHERE  Gehalt > NOT ALL\n\n    (SELECT  Gehalt\n\n    FROM  Angestellte a, Abteilungen b\n\n    WHERE  a.Abt_Nr = b.Abt_Nr  AND Leiter = 4);\n\n    ist syntaktisch korrekt.", "explanation": "Unterabfragen mit ANY oder All k\u00f6nen leider nicht verneint werden.\n\n    siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3478, "category": 9, "difficulty": 1, "text": "Welche Aussage \u00fcber den Query-Executen-Plan bei Oracle ist wahr?", "explanation": "Wenn man unter Oracle z.B. mit \"EXPLAIN PLAN SET ..sql_anweisung...\" den Query-Executen-Plan erzeugt, wird f\u00fcr die genannte SQL-Anweisung nur der Query-Executen-Plan erzeugt und in der plan_tabelle abgespeichert. Die Anweisung selber wird dabei nicht ausgef\u00fchrt.", "type": "multiple-choice", "answers": [{"text": "Wenn man den Oracle-Query-Executen-Plan erzeugt, wird nur der Query-Executen-Plan  erzeugt und die SQL-Anweisung selber nicht ausgef\u00fchrt.", "solution": "true"}, {"text": "Wenn man den Oracle-Query-Executen-Plan erzeugt, wird der Query-Executen-Plan erzeugt und die SQL-Anweisung selber ausgef\u00fchrt.", "solution": "false"}]}, {"id": 2915, "category": 7, "difficulty": 1, "text": "F\u00fcr die Festlegung der 2NF braucht man einen Prim\u00e4rschl\u00fcssel", "explanation": "Die Definition der 2NF lautet:Eine Relation R mit Prim\u00e4rschl\u00fcssel S befindet sich in der zweiten \nNormalform (2NF), wenn sie (1NF) ist und jedes Nichtschl\u00fcsselattribut \nvoll funktional abh\u00e4ngig vom Prim\u00e4rschl\u00fcssel S ist.  Daher kann man die 2NF nur festlegen, wenn man vorher den Prim\u00e4rschl\u00fcssel kennt.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 2899, "category": 7, "difficulty": 2, "text": "Jede \u00dcberf\u00fchrung in eine Normalform (1NF, 2NF odr 3NF) verringert Redundanz in der Datenbank.", "explanation": "Die \u00dcberf\u00fchrung einer Relation in die 1NF erh\u00f6ht in der Regel die Redundanz.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3099, "category": 9, "difficulty": 2, "text": "Welcher Join-Operator ist f\u00fcr gr\u00f6\u00dfere Datenmengen und Equi-Joins geeignet?", "explanation": "Das ist der Hash Join, siehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#HASH_JOIN\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#HASH_JOIN", "type": "multiple-choice", "answers": [{"text": "Cartesian Join", "solution": "false"}, {"text": "Nested Loop Join", "solution": "false"}, {"text": "Hash Join", "solution": "true"}, {"text": "Sort Merge Join", "solution": "false"}, {"text": "Outer Join", "solution": "false"}, {"text": "Index Join", "solution": "false"}]}, {"id": 2878, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgenden SQL-Anweisungen:\n\n    CREATE TABLE test (spalte varchar2(10));\n\n    INSERT INTO TEST VALUES (\"Ja\");\n\n    INSERT INTO TEST VALUES (\"Nein\");\n\n    INSERT INTO TEST VALUES (NULL);\n\n    COMMIT;\n\n    SELECT * FROM TEST WHERE Spalte in (\"Ja\", \"Nein\");\n\n    Welches Ergebnis hat diese SELECT-Abfrage?", "explanation": "Wegen der <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Dreiwertige-Logik\"> dreiwertigen Logik  in SQL liefert der Vergleich mit einem NULL-Wert den Wahrheitswert UNKNOWN, der in der WHERE-Klauesel zu FALSE ausgewertet wird. Es werden daher in der SELECT-Abfrage die Zeilen mit \"Ja\" und \"Nein\" ausgegeben.", "type": "multiple-choice", "answers": [{"text": "Die beiden Tupel mit den Werten 'Ja' und 'Nein'", "solution": "true"}, {"text": "Keine Zeilen (no Rows)", "solution": "false"}, {"text": "Diese Abfrage wirft einen Fehler.", "solution": "false"}]}, {"id": 3412, "category": 7, "difficulty": 2, "text": "Aus wie vielen Attributen muss ein Prim\u00e4rschl\u00fcssel einer Relation bestehen, damit es partielle funktionale Abh\u00e4ngigkeiten geben kann?", "explanation": "Falls der Prim\u00e4rschl\u00fcsel nur aus einem Attribut besteht, kann es keine partiellen Abh\u00e4ngigkeiten geben, da der Prim\u00e4rschl\u00fcssel nicht weiter aufgespalten werden kann.", "type": "multiple-choice", "answers": [{"text": "ein Attribut", "solution": "false"}, {"text": "Dies ist unabh\u00e4ngig voneinander", "solution": "false"}, {"text": "zwei Attribute", "solution": "true"}, {"text": "drei Attribute", "solution": "true"}]}, {"id": 3360, "category": 5, "difficulty": 1, "text": "Um welchen Attributtyp handelt es sich hier prim\u00e4r?\n\n    Die Noten einer Hochschule k\u00f6nnen die Werte 1.0, 1.3, 1,7, ... ,5.0 annehmen.", "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zus\u00e4tzlich der Gr\u00f6\u00dfe nach ordnen und k\u00f6nnen verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zus\u00e4tzlich auch Multiplikation und  Division,  zulassen.", "type": "multiple-choice", "answers": [{"text": "Zahl", "solution": "false"}, {"text": "Intervall", "solution": "false"}, {"text": "Ordinal", "solution": "true"}, {"text": "Nominal", "solution": "false"}]}, {"id": 3409, "category": 8, "difficulty": 1, "text": "Der Natural Join ist in der relationalen Algebra der einzige Join-Operator, der die Join-Spalten nur einmal ausgibt", "explanation": "Der Theta Join hat immer eine Bedingung und unterdr\u00fcckt keine doppelten Spalten. Equi-Join und Outer-Joins bauen auf der Definition des Theta-Joins auf.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "false"}, {"text": "stimmt", "solution": "true"}]}, {"id": 3067, "category": 7, "difficulty": 3, "text": "Eine 1:1/1:c1-Beziehung zwischen zwei Entity-Mengen kann auf wie viele Relationen im Datenmodell abgebildet werden?", "explanation": "F\u00fcr 1:1 bzw. 1:c1-Beziehungen gilt, dass die beiden Entity-Mengen entweder auf zwei Relationen abgebildet werden oder eben zu einer zusammengefasst werden. Das Zusammenfassen ist problemlos m\u00f6glich, da beide Entity-Mengen \u00fcber den gleichen Prim\u00e4rschl\u00fcssel verf\u00fcgen.", "type": "multiple-choice", "answers": [{"text": "nicht abbildbar", "solution": "false"}, {"text": "1 Relation", "solution": "true"}, {"text": "2 Relationen", "solution": "true"}, {"text": "3 Relationen", "solution": "false"}]}, {"id": 3070, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C und den folgenden funktionalen Abh\u00e4ngigkeiten. Welche Arten funktionaler Abh\u00e4ngigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abh\u00e4ngigkeit als Antwort eintragen, also volle, partielle oder transitive.", "explanation": "B, D, E sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig.\n\n    F ist von C abh\u00e4ngig, also nur von einem Teil des Prim\u00e4rschl\u00fcssels und damit ist F partiell von A,C abh\u00e4ngig.\n\n    E ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig.", "type": "text", "answers": [{"text": "A, C -> B, D, E", "solution": "volle"}, {"text": "D -> E", "solution": "transitive"}, {"text": "C -> F", "solution": "partielle"}]}, {"id": 3072, "category": 5, "difficulty": 1, "text": "Wie werden n:m-/cn:cm-Beziehungen mit eigenen Attributen in einem ERD in ERwin dargestellt?", "explanation": "Im ERD-Zeichentool ERwin der Firma CA wird eine n:m-/cn:cm-Beziehung  mit eigenen Attributen als eine Zuordnungs-Entity-Menge dargestellt, die mit zwei 1:n/1:cn-Beziehungen mit den bestehenden Entiy-Mengen verkn\u00fcpft wird.", "type": "multiple-choice", "answers": [{"text": "Es gibt keine Attribute f\u00fcr n:m-/cn:cm-Beziehungen.", "solution": "false"}, {"text": "Es wird eine Zuordnungs-Entity-Menge erstellt, die mit zwei 1:n/1:cn-Beziehungen mit den bestehenden Entiy-Mengen verkn\u00fcpft wird.", "solution": "true"}, {"text": "Es wird eine Zuordnungs-Entity-Menge erstellt, die mit zwei n:m-/cn:cm-Beziehungen mit den bestehenden Entiy-Mengen verkn\u00fcpft wird.", "solution": "false"}, {"text": "Es wird eine Zuordnungs-Entity-Menge erstellt, die mit zwei 1:1/1:c1-Beziehungen mit den bestehenden Entiy-Mengen verkn\u00fcpft wird.", "solution": "false"}]}, {"id": 3095, "category": 9, "difficulty": 1, "text": "Welche Tabellenzugriffsmethode liest bei Oracle alle Datens\u00e4tze einer Tabelle unsortiert ein?", "explanation": "Der Full Table Scan liest alle Zeilen einer Tabelle sortiert ein, siehe \n<a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen  beim Index Full Scan werden die Daten zus\u00e4tzlich sortiert \u00fcber den Index", "type": "multiple-choice", "answers": [{"text": "RowidScan", "solution": "false"}, {"text": "Full Table Scan", "solution": "true"}, {"text": "Index Full Scan", "solution": "false"}, {"text": "Hash Scan", "solution": "false"}, {"text": "Cluster Scan", "solution": "false"}]}, {"id": 3097, "category": 9, "difficulty": 2, "text": "Welche Tabellenzugriffsmethoden gibt es bei Oracle?", "explanation": "Alle aufgef\u00fchrten Zugriffsmethoden gibt es bei Oracle,  siehe \n<a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen .", "type": "multiple-choice", "answers": [{"text": "RowidScan", "solution": "true"}, {"text": "Full Table Scan", "solution": "true"}, {"text": "Index Full Scan", "solution": "true"}, {"text": "Hash Scan", "solution": "true"}, {"text": "Cluster Scan", "solution": "true"}]}, {"id": 3098, "category": 9, "difficulty": 1, "text": "Welcher Join-Operator ist f\u00fcr kleinere Datenmengen geeignet und enth\u00e4lt ineinander verschachtelte Schleifen?", "explanation": "Das ist der Nested Loop Join, \nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#NESTED_LOOPS\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#NESTED_LOOPS  .", "type": "multiple-choice", "answers": [{"text": "Cartesian Join", "solution": "false"}, {"text": "Nested Loop Join", "solution": "true"}, {"text": "Hash Join", "solution": "false"}, {"text": "Sort Merge Join", "solution": "false"}, {"text": "Outer Join", "solution": "false"}, {"text": "Index Join", "solution": "false"}]}, {"id": 3102, "category": 9, "difficulty": 1, "text": "Welcher Join-Operator sollte in der Regel vermieden werden, da er bei gro\u00dfen Datenmengen einen \"OUT OF MEMORY ERROR\" verursachen kann?", "explanation": "Das ist der Cartesian Join, der jeden Datensatz der einen Tabelle mit dem der anderen Tabelle verkn\u00fcpft und daher die Datenmengen immens vergr\u00f6\u00dfert, \nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#MERGE_JOIN_CARTESIAN\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#MERGE_JOIN_CARTESIAN  .", "type": "multiple-choice", "answers": [{"text": "Cartesian Join", "solution": "true"}, {"text": "Nested Loop Join", "solution": "false"}, {"text": "Hash Join", "solution": "false"}, {"text": "Sort Merge Join", "solution": "false"}, {"text": "Outer Join", "solution": "false"}, {"text": "Index Join", "solution": "false"}]}, {"id": 3126, "category": 10, "difficulty": 3, "text": "Sie m\u00f6chten einen Trigger schreiben, der angesto\u00dfen wird, nachdem Zeilen aus einer Tabelle gel\u00f6scht werden oder eingef\u00fcgt werden. Und es sollen dabei die Anzahl der verbliebenen Zeilen der Tabelle angezeigt werden. Welchen Triggertyp ben\u00f6tigen Sie?", "explanation": "Der Ausf\u00fchrungszeitpunkt AFTER ist wichtig, da ein BEFORE-Trigger bei DELETE keinen Sinn macht. Die verbliebenen Datens\u00e4tze werden nur beim Ausf\u00fchrungszeitpunkt AFTER angezeigt.\n\n    Ein zeilenorientierter Trigger w\u00fcrde das Mutating-Table-Problem ausl\u00f6sen.\n\n    Nach dem Ausf\u00fchrungsmodell von zeilenorientierten Triggern werden diese nur angesto\u00dfen, wenn sich tats\u00e4chlich Daten in der Datenbank ver\u00e4ndert haben. (siehe < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\"target = \"_blank\"> zeilenorientierten Trigger. (siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\" target=\"_blank\"> CREATE-TRIGGER )", "type": "multiple-choice", "answers": [{"text": "CREATE OR REPLACE TRIGGER LOESCHE_ANGESTELLTE\n\n    AFTER INSERT OR DELETE  ON ANGESTELLTE\n\n    DECLARE\n\n    num_rows NUMBER;\n\n    BEGIN\n\n    SELECT COUNT(*) INTO num_rows FROM angestellte ;\n\n    dbms_output.put_line(\"Die Anzahl der Angestellten ist \" || to_char(num_rows));\n\n    END;", "solution": "true"}, {"text": "CREATE OR REPLACE TRIGGER LOESCHE_ANGESTELLTE\n\n    BEFORE INSERT OR DELETE  ON ANGESTELLTE\n\n    DECLARE\n\n    num_rows NUMBER;\n\n      BEGIN\n\n    \n\n    SELECT COUNT(*) INTO num_rows FROM angestellte ;\n\n    dbms_output.put_line(\"Die Anzahl der Angestellten ist \" || to_char(num_rows));\n\n    END;\n\n    /", "solution": "false"}, {"text": "CREATE OR REPLACE TRIGGER LOESCHE_ANGESTELLTE\n\n    BEFORE INSERT OR DELETE ON ANGESTELLTE\n\n    FOR EACH ROW\n\n    DECLARE\n\n    num_rows NUMBER;\n\n    BEGIN\n\n    SELECT COUNT(*) INTO num_rows FROM angestellte ;\n\n    dbms_output.put_line(\"Die Anzahl der Angestellten ist \" || to_char(num_rows));\n\n    END;\n\n    /", "solution": "false"}]}, {"id": 3135, "category": 9, "difficulty": 3, "text": "Sie m\u00f6chten in PL/SQL Daten unterschiedlichen Typs in einer Variable eines PL/SQL-Blocks speichern. Welcher Kollektionstyp ist daf\u00fcr geeignet?", "explanation": "Das ist die Definition einen PL/SQL-Records, siehe auch  im <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/PL-SQL-RECORD\" title=\"PL/SQL-Record\" target=\"_blank\">DB-Wiki.", "type": "multiple-choice", "answers": [{"text": "VARRAY", "solution": "false"}, {"text": "Nested Table", "solution": "false"}, {"text": "PL/SQL-Record", "solution": "true"}, {"text": "PL/SQL-Tabellen (Assoziative Arrays)", "solution": "false"}]}, {"id": 3361, "category": 5, "difficulty": 1, "text": "Um welchen Attributtyp handelt es sich hier prim\u00e4r?\n\n    L\u00e4nderk\u00fcrzel weltweit, wie \"D\" f\u00fcr Deutschland", "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zus\u00e4tzlich der Gr\u00f6\u00dfe nach ordnen und k\u00f6nnen verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zus\u00e4tzlich auch Multiplikation und  Division,  zulassen.", "type": "multiple-choice", "answers": [{"text": "Intervall", "solution": "false"}, {"text": "Ordinal", "solution": "false"}, {"text": "Nominal", "solution": "true"}, {"text": "Zahl", "solution": "false"}]}, {"id": 3425, "category": 9, "difficulty": 2, "text": "Auf welchen Spalten ist ein Verweis \u00fcber einen Fremdschl\u00fcssel m\u00f6glich?", "explanation": "Fremdschl\u00fcssel k\u00f6nnen auf Spalten verweisen, die einen Prim\u00e4rschl\u00fcssel oder einen Zweitschl\u00fcssel haben. Ein Zweitschl\u00fcssel wird in SQL durch einen UNIQUE-Constraint oder einen CREATE UNIQUE INDEX .. implementiert.", "type": "multiple-choice", "answers": [{"text": "Auf Spalten, die als Zweitschl\u00fcssel (UNIQUE CONSTRAINT) definiert sind.", "solution": "true"}, {"text": "keine von allen", "solution": "false"}, {"text": "Auf Spalten, die als Prim\u00e4rschl\u00fcssel (Primary Key) definiert sind.", "solution": "true"}]}, {"id": 2797, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C und den folgenden funktionalen Abh\u00e4ngigkeiten Welche Arten funktionaler Abh\u00e4ngigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abh\u00e4ngigkeit als Antwort eintragen, also volle, partielle oder transitive.", "explanation": "B, D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig.\n\n    F ist von B abh\u00e4ngig und B von A,C und damit ist F transitiv von A,C abh\u00e4ngig.\n\n    E ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig.", "type": "text", "answers": [{"text": "A, C -> B, D, E, F", "solution": "volle"}, {"text": "D -> E", "solution": "transitive"}, {"text": "B -> F", "solution": "transitive"}]}, {"id": 2799, "category": 5, "difficulty": 2, "text": "Welche Aussagen \u00fcber eine IS-A-Beziehung sind richtig?", "explanation": "Eine \"IS-A-Beziehung\" ist eine Beziehung zwischen einem Supertyp und einem Subtyp \n\u0095 Die Subtypen erben alle Attribute des Supertyps\n\u0095 Die Attribute des Subtyps k\u00f6nnen um eigene Attribute und Methoden erg\u00e4nzt werden.\n\u0095 Supertyp und Subtyp besitzen den gleichen Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Eine IS-A-Beziehung ist eine andere Bezeichnung f\u00fcr eine identifizierende 1:n-Beziehung.", "solution": "false"}, {"text": "Eine IS-A-Beziehung ist eine andere Bezeichnung f\u00fcr eine nicht-identifizierende 1:n-Beziehung.", "solution": "false"}, {"text": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp.", "solution": "true"}, {"text": "Bei einer IS-A-Beziehung werden alle Attribute des Subtypen an den Supertyp vererbt.", "solution": "false"}, {"text": "Supertyp und Subtyp haben die gleichen Prim\u00e4rschl\u00fcsselattribute und auch -werte.", "solution": "true"}]}, {"id": 3074, "category": 9, "difficulty": 1, "text": "Wo liegen die gr\u00f6\u00dften Tuning-Potentiale?", "explanation": "Nach einer Studie von Forrester-Research liegt das gr\u00f6\u00dfte Potential im SQL-Tuning,\nsiehe: <a href = \"http://www.dailymotion.com/video/xtpc8a_researching-sql-performance-tuning-tips_school\" target=\"_blank\"> http://www.dailymotion.com/video/xtpc8a_researching-sql-performance-tuning-tips_school", "type": "multiple-choice", "answers": [{"text": "SQL-Tuning, insbesondere von SELECT-Anweisungen", "solution": "true"}, {"text": "Erzeugen von zus\u00e4tzlichen Indizes in der Datenbank", "solution": "false"}, {"text": "\u00c4nderungen an den Parametern der Datenbankinstance", "solution": "false"}, {"text": "Verbesserungen des Netzwerks", "solution": "false"}]}, {"id": 3079, "category": 9, "difficulty": 2, "text": "Welche der folgenden SELECT-Abfragen haben in der Regel eine schlechte Performance und k\u00f6nnen daher getunt werden?", "explanation": "SELECT * muss alle Spalten der Tabelle ermitteln, was zus\u00e4tzliche Zeit kostet. Ein Sortiervorgang bedeutet bei gro\u00dfen Tabellen eine schlechte Performance und muss auch bei DISTINCT erfolgen.", "type": "multiple-choice", "answers": [{"text": "SELECT * FROM Tabelle;", "solution": "true"}, {"text": "SELECT t.Spalte FROM Tabelle t;", "solution": "false"}, {"text": "SELECT Spalte FROM Tabelle ORDER BY Spalte;", "solution": "true"}, {"text": "SELECT DISTINCT Spalte FROM Tabelle;", "solution": "true"}]}, {"id": 3086, "category": 9, "difficulty": 1, "text": "Welcher Anfragetyp ist schneller?", "explanation": "Falls die Spaltennamen ohne Tabellennamen angegeben werden, muss das Datenbanksystem zus\u00e4tzlich ermitteln, in welchen Tabellen die Spalten enthalten sind.", "type": "multiple-choice", "answers": [{"text": "Eine SELECT-Anweisung mit vollst\u00e4ndig qualifizierten Spaltennamen, also in der Form Tabellennamen.Spaltennamen", "solution": "true"}, {"text": "Eine SELECT-Anweisung ohne vollst\u00e4ndig qualifizierte Spaltennamen, also in der Form Spaltennamen", "solution": "false"}]}, {"id": 3088, "category": 9, "difficulty": 2, "text": "Welche Datenbankoperationen kosten in der Regel unn\u00f6tige Zeit?", "explanation": "Bei UNION wird zus\u00e4tzlich eine DISTINCT-Operation ausgef\u00fchrt, um Duplikate zu eliminieren, bei UNION ALL ist das nicht der Fall. Funktionsaufrufe wie UPPER() , LOWER() oder andere k\u00f6nnen den \nzugeh\u00f6rigen Index auf einer Spalte nicht nutzen, wenn er nicht ein funktionsbasierter Index ist. Dies ist auch bei Typkonvertierungen der Fall. (siehe \n< a href \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Funktionsbasierter-Index\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Funktionsbasierter-Index ).", "type": "multiple-choice", "answers": [{"text": "Typkonvertierungen", "solution": "true"}, {"text": "Funktionsaufrufe wie UPPER, LOWER, etc", "solution": "true"}, {"text": "UNION", "solution": "true"}, {"text": "UNION ALL", "solution": "false"}]}, {"id": 2792, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C \nund den folgenden funktionalen Abh\u00e4ngigkeiten \nA, C -> D, E, F\nD-> E\nC -> B\n\nWelche Aussagen sind richtig?", "explanation": "D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig. \nB ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von C. \n\nE ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig. \n\nDamit gibt es hier eine partielle Abh\u00e4ngigkeit, die bei der 2. NF zu ber\u00fccksichtigen ist und es gibt eine transitive Abh\u00e4ngigkeit, die erst bei der 3. NF aufzul\u00f6sen ist. Damit sind 2. und 3. NF verschieden.", "type": "multiple-choice", "answers": [{"text": "Die 2. NF ist von der 3. NF verschieden.", "solution": "true"}, {"text": "Die 2. NF und die 3. NF sind gleich.", "solution": "false"}, {"text": "Diese Aussagen lassen sich mit diesen Informationen so nicht ziehen.", "solution": "false"}]}, {"id": 2793, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C \nund den folgenden funktionalen Abh\u00e4ngigkeiten \nA, C -> D, E, F\nD-> E\nC -> B\n\nWie sieht die 2. NF aus? Welche Relationen geh\u00f6ren dazu?", "explanation": "D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig. \nB ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von C. \n\nE ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig. \n\nDaraus ergeben sich folgende Relationen f\u00fcr die 2. NF, wo ja nur partielle Abh\u00e4ngigkeit aufgel\u00f6st wird: \nT(C (PK), B)\nR(A (PK), C (PK, FK), D, E, F)", "type": "multiple-choice", "answers": [{"text": "R(A (PK), C (PK, FK), B, D (FK), F)", "solution": "false"}, {"text": "S(D (PK), E)", "solution": "false"}, {"text": "T(C (PK), B)", "solution": "true"}, {"text": "R(A (PK), C (PK), B, D, E, F)", "solution": "false"}, {"text": "R(A (PK), C (PK, FK), D, E, F)", "solution": "true"}, {"text": "R(A (PK), C (PK, FK), D (FK), F)", "solution": "false"}]}, {"id": 2794, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C \nund den folgenden funktionalen Abh\u00e4ngigkeiten \nA, C -> D, E, F\nD-> E\nC -> B\n\nWie sieht die 3. NF aus? Welche Relationen geh\u00f6ren dazu?", "explanation": "D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig. \nB ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von C. \n\nE ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig. \n\nDaraus ergeben sich folgende Relationen f\u00fcr die 3. NF, ausgehend von der Aufl\u00f6sung der partiellen Abh\u00e4ngigkeit f\u00fcr die 2. NF nun auch die transitive Abh\u00e4ngigkeit aufgel\u00f6st wird: \nT(C (PK), B)\nR(A (PK), C (PK, FK), D (FK), F)\nS(D (PK), E)", "type": "multiple-choice", "answers": [{"text": "R(A (PK), C (PK), B, D, F)", "solution": "false"}, {"text": "S(D (PK), E)", "solution": "true"}, {"text": "T(C (PK), B)", "solution": "true"}, {"text": "R(A (PK), C (PK, FK), B, D, E, F)", "solution": "false"}, {"text": "R(A (PK), C (PK, FK), D, E, F)", "solution": "false"}, {"text": "R(A (PK), C (PK, FK), D (FK), F)", "solution": "true"}]}, {"id": 2791, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C und den folgenden funktionalen Abh\u00e4ngigkeiten Welche Arten funktionaler Abh\u00e4ngigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abh\u00e4ngigkeit als Antwort eintragen, also volle, partielle oder transitive.", "explanation": "D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig.\n\n    B ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von C.\n\n    E ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig.", "type": "text", "answers": [{"text": "A, C -> D, E, F", "solution": "volle"}, {"text": "D-> E", "solution": "transitive"}, {"text": "C -> B", "solution": "partielle"}]}, {"id": 2798, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C \nund den folgenden funktionalen Abh\u00e4ngigkeiten \nA, C -> B, D, E, F\nD -> E\nB -> F\n\nWelche Aussagen sind richtig?", "explanation": "B, D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig. \nF ist von B abh\u00e4ngig und B von A,C und damit ist F transitiv von A,C abh\u00e4ngig. \nE ist von D abh\u00e4ngig und D von A,C und damit ist E transitiv von A,C abh\u00e4ngig. \n\nDamit gibt es hier keine partiellen Abh\u00e4ngigkeiten, die bei der 2. NF zu ber\u00fccksichtigen w\u00e4ren, daf\u00fcr gibt es aber zwei transitive Abh\u00e4ngigkeit, die erst bei der 3. NF aufzul\u00f6sen ist. Damit sind 1. und 2. NF gleich.", "type": "multiple-choice", "answers": [{"text": "Die 1. NF und die 2. NF sind gleich.", "solution": "true"}, {"text": "Die 1. NF ist von der 2. NF verschieden.", "solution": "false"}, {"text": "Die 2. NF ist von der 3. NF verschieden.", "solution": "true"}, {"text": "Die 2. NF und die 3. NF sind gleich.", "solution": "false"}, {"text": "Diese Aussagen lassen sich mit diesen Informationen so nicht ziehen.", "solution": "false"}]}, {"id": 2795, "category": 7, "difficulty": 2, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C \nund den folgenden funktionalen Abh\u00e4ngigkeiten \nA, C -> D, E, F\nA -> E\nC -> B\n\nWelche Aussagen sind richtig?", "explanation": "D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig. \nB ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von C. \nE ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von A. \n\n\nDamit gibt es hier nur partielle Abh\u00e4ngigkeiten, die bei der 2. NF zu ber\u00fccksichtigen ist und es gibt keine transitiven Abh\u00e4ngigkeiten, die erst bei der 3. NF aufzul\u00f6sen sind. Damit sind 2. und 3. NF gleich.", "type": "multiple-choice", "answers": [{"text": "Die 2. NF ist von der 3. NF verschieden.", "solution": "false"}, {"text": "Die 2. NF und die 3. NF sind gleich.", "solution": "true"}, {"text": "Diese Aussagen lassen sich mit diesen Informationen so nicht ziehen.", "solution": "false"}]}, {"id": 2796, "category": 7, "difficulty": 3, "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Prim\u00e4rschl\u00fcssel A, C und den folgenden funktionalen Abh\u00e4ngigkeiten Welche Arten funktionaler Abh\u00e4ngigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abh\u00e4ngigkeit als Antwort eintragen, also volle, partielle oder transitive.", "explanation": "D, E, F sind voll funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig.\n\n    B ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von C.\n\n    E ist nur partiell funktional vom gesamten Prim\u00e4rschl\u00fcssel A,C abh\u00e4ngig, n\u00e4mlich nur von einem Teil des Schl\u00fcssel, von A.", "type": "text", "answers": [{"text": "A, C -> D, E, F", "solution": "volle"}, {"text": "A -> E", "solution": "partielle"}, {"text": "C -> B", "solution": "partielle"}]}, {"id": 2800, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine Relation in der 2NF, die au\u00dfer Prim\u00e4rschl\u00fcsselattributen nur ein einziges Nichtschl\u00fcsselattribut besitzt. Solch eine Relation ist immer automatisch in der 3NF.", "explanation": "Eine Relation, die nur ein Nichtschl\u00fcsselattribute hat, kann nie transitive Abh\u00e4ngigkeiten (siehe <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Transitive-Abhaengigkeit/\">DB-Wiki ) aufweisen.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "true"}, {"text": "stimmt nicht", "solution": "false"}]}, {"id": 3093, "category": 9, "difficulty": 1, "text": "Welche Tabellenzugriffsmethode ist bei Oracle die schnellste, wenn man nur einen Datensatz lesen m\u00f6chte?", "explanation": "Der Zugriff \u00fcber die ROWID ist die schnellste M\u00f6glichkeit, um eine einzelne Zeile aus einer Tabelle zu lesen, weil die genaue Adresse der \nZeile in der Datenbank angegeben wird, \nsiehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen", "type": "multiple-choice", "answers": [{"text": "RowidScan", "solution": "true"}, {"text": "Full Table Scan", "solution": "false"}, {"text": "Index Scan", "solution": "false"}, {"text": "Hash Scan", "solution": "false"}, {"text": "Cluster Scan", "solution": "false"}]}, {"id": 3094, "category": 9, "difficulty": 1, "text": "Welche Join-Operatoren gibt es bei Oracle?", "explanation": "Alle oben aufgef\u00fchrten Join-Operatoren  gibt es bei Oracle.\nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen  .", "type": "multiple-choice", "answers": [{"text": "Cartesian Join", "solution": "true"}, {"text": "Nested Loop Join", "solution": "true"}, {"text": "Hash Join", "solution": "true"}, {"text": "Sort Merge Join", "solution": "true"}, {"text": "Outer Join", "solution": "true"}, {"text": "Index Join", "solution": "true"}]}, {"id": 2813, "category": 8, "difficulty": 3, "text": "Es ist ein Datenmodell einer Auto-Vermietung gegeben mit einer Kunden-Relation (Prim\u00e4rschl\u00fcssel: Kunden_Nr), einer Fahrzeuge-Relation  (Prim\u00e4rschl\u00fcssel: KFZ-Nr) und einer Ausleihen-Relation, in der alle get\u00e4tigten Ausleihen erfa\u00dft werden. \nDie Ausleihen-Relation hat nun folgenden Prim\u00e4rschl\u00fcssel: \nKFZ_Nr, Kunden_Nr, ausgeliehen_am. \n\nEs ist nun angedacht, das Datum \"ausgeliehen_am\" aus dem Prim\u00e4rschl\u00fcssel herauszunehmen. Welche Konsequenzen h\u00e4tte dies.", "explanation": "Die beiden richtigen Antworten beschreiben den gleichen Sachverhalt nur mal anders herum ausgedr\u00fcckt. \n\nMit einem Prim\u00e4rschl\u00fcssel KFZ_Nr, Kunden_Nr, ausgeliehen_am \nsind folgende Daten m\u00f6glich: \nKFZ_NR(PK), Kunden_Nr(PK), ausgeliehen_am(PK)\n1234,        4000,   14.09.2011\n1234,        4000,   06.10.2011\n\nSomit kann ein Fahrzeug von einem Kunden mehrfach zu verschiedenen Zeitpunkten gebucht werden. \n\nMit dem ge\u00e4nderten Prim\u00e4rschl\u00fcssel KFZ_Nr, Kunden_Nr \nsieht das schon ganz anders aus. Die folgenden Daten gehen dann nicht mehr, weil der Prim\u00e4rschl\u00fcssel nicht eindeutig ist: \nKFZ_NR(PK), Kunden_Nr(PK), ausgeliehen_am\n1234,        4000,   14.09.2011\n1234,        4000,   06.10.2011\n\nF\u00fcr die Werte 1234, 4000, gibt es dann nur noch einen Datensatz und damit kann ein Kunde ein Fahrzeug nur noch einmal ausleihen. Andere Fahrzeuge kann er ruhig mehrfach ausleichen.", "type": "multiple-choice", "answers": [{"text": "Ein Fahrzeug (KFZ_Nr) kann nur einmal ausgeliehen werden.", "solution": "false"}, {"text": "Ein Kunde (Kunden_Nr) kann nur einmal ausleihen.", "solution": "false"}, {"text": "Ein Kunde kann nur einmal ein bestimmtes Fahrzeug ausleihen.", "solution": "true"}, {"text": "Ein Fahrzeug kann nur einmal von einem bestimmten Kunden ausgeliehen werden.", "solution": "true"}, {"text": "Diese \u00c4nderung hat gar keine Auswirkungen. Sie minimiert nur die Anzahl der Attribute des Prim\u00e4rschl\u00fcssels.", "solution": "false"}]}, {"id": 2814, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber die GROUP-BY-Klausel sind wahr?", "explanation": "Siehe die Syntaxbeschreibung der SELECT -Anweisung im Datenbankwiki unter <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/SELECT\"> SELECT-Anweisung", "type": "multiple-choice", "answers": [{"text": "Man kann in einer GROUP-BY-Klausel Spaltenabk\u00fcrzungen benutzen.", "solution": "false"}, {"text": "Die WHERE-Klausel kann nach der GROUP-BY-Klausel stehen und Zeilen ausschlie\u00dfen, bevor gruppiert wird.", "solution": "false"}, {"text": "Die WHERE-Klausel kann vor der GROUP-BY-Klausel stehen und Zeilen ausschlie\u00dfen, bevor gruppiert wird.", "solution": "true"}, {"text": "Wenn die SELECT-Klausel Gruppenfunktionen (SUM, MIN, MAX, COUNT..) hat, dann m\u00fcssen alle Spalten der SELECT-Klausel, die keine Gruppenfunktion haben, in der GROUP-BY-Klausel vorkommen.", "solution": "true"}]}, {"id": 2815, "category": 9, "difficulty": 3, "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\nCREATE TABLE Auftraege\n(AuftragsNr         NUMBER(38) NOT NULL,\n Auftrags_Typ         VARCHAR2(50) NOT NULL,\n Kun_Nr         NUMBER(38) NOT NULL,\n Ang_Nr         NUMBER(38),\n auftragssumme             NUMBER);\n\nCREATE TABLE Auftragspositionen\n(TNr             NUMBER(38) NOT NULL,\n AuftragsNr         NUMBER(38) NOT NULL,\n Menge             NUMBER);\n\nWelche DELETE-Anweisungen sind korrekt?", "explanation": "Mit der DELETE-Anweisung kann man keine einzelnen Werte in Spalten, sondern nur komplette Zeilen l\u00f6schen. Siehe die Syntaxbeschreibung der DELETE-Anweisung im Datenbankwiki unter\n<a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/DELETE\"> DELETE-Anweisung", "type": "multiple-choice", "answers": [{"text": "DELETE AuftragsNr FROM Auftraege WHERE auftragssumme < 1000;", "solution": "false"}, {"text": "DELETE Auftraege WHERE auftragssumme < 1000;", "solution": "true"}, {"text": "DELETE FROM Auftraege WHERE (SELECT AuftragsNr FROM Auftragspositionen);", "solution": "false"}, {"text": "DELETE * FROM Auftraege, Auftragspositionen\nWHERE Auftraaege.auftragssumme < 1000\nAND Auftraege.AuftragsNr = Auftragspositionen.AuftragsNr;", "solution": "false"}]}, {"id": 2818, "category": 9, "difficulty": 3, "text": "Mit welchem Befehl legt man einen CONSTRAINT nachtr\u00e4glich auf einer Tabelle an? Es soll nachtr\u00e4glich auf einer Tabelle Artikel die Spalte Verkaufspreis in NOT NULL ver\u00e4ndert werden.", "explanation": "Constraints sind keine eigenen Datenbankobjekte, sie der geh\u00f6ren zu einer Tabelle und werden daher auch nicht mit einem eigenen DROP-Befehl gel\u00f6scht, sondern mit einem ALTER TABLE-Befehl. Die genaue Syntax finden Sie im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/ALTER-TABLE\"> ALTER-Table", "type": "multiple-choice", "answers": [{"text": "ALTER  TABLE  artikel \nMODIFY verkaufspreis CONSTRAINT BEZ_NN NOT NULL;", "solution": "true"}, {"text": "ALTER  TABLE  artikel \nADD CONSTRAINT BEZ_NN NOT NULL(verkaufspreis);", "solution": "false"}, {"text": "ALTER TABLE XYZ DROP CONSTRAINT ...", "solution": "false"}, {"text": "ALTER  TABLE  artikel \nMODIFY verkaufspreis CONSTRAINT BEZ_NN NOT NULL(Verkaufspreis);", "solution": "false"}, {"text": "ALTER  TABLE  artikel \nADD verkaufspreis NUMBER  CONSTRAINT BEZ_NN NOT NULL;", "solution": "false"}]}, {"id": 2819, "category": 11, "difficulty": 2, "text": "Betrachten Sie die folgende Tabelle:\n\n    create table test (test_id INTEGER, text varchar2(15));\n\n    und die folgenden SQL-Befehle:\n\n    ALTER TABLE test ADD CONSTRAINT Test_pk primary KEY(test_id) DEFERRABLE INITIALLY DEFFERRED;\n\n    INSERT INTO test VALUES (1, \"Ute\"); -- Zeile 1\n\n    INSERT INTO test VALUES (1, \"Udo\"); -- Zeile 2\n\n    COMMIT;\n\n    SET CONSTRAINT Test_pk IMMEDIATE;\n\n    INSERT INTO test VALUES (1, \"Edda\"); -- Zeile 3\n\n    INSERT INTO test VALUES (2, \"Willi\");-- Zeile 4\n\n    COMMIT;\n\n    Welche Zeilen werden persistent in der Tabelle test gespeichert?", "explanation": "Bei INITIALLY DEFFERRED wird die ganze Transaktion zur\u00fcckgerollt, wenn ein Fehler auftritt, so dass die Tabelle nach dem ersten COMMIT leer ist.", "type": "multiple-choice", "answers": [{"text": "Keine der Zeilen, da die SQL-Syntax fehlerhaft ist.", "solution": "false"}, {"text": "nur Zeile 4", "solution": "false"}, {"text": "Zeile 2 und 4", "solution": "false"}, {"text": "Zeile 3 und 4", "solution": "true"}, {"text": "Zeile 1 und 4", "solution": "false"}]}, {"id": 2820, "category": 9, "difficulty": 2, "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\n    CREATE TABLE Auftraege\n\n    (AuftragsNr NUMBER(38) PRIMARY KEY,\n\n    Auftrags_Typ VARCHAR2(50) NOT NULL,\n\n    Kun_Nr NUMBER(38) NOT NULL,\n\n    Ang_Nr NUMBER(38),\n\n    auftragssumme NUMBER);\n\n    \n\n    CREATE TABLE Auftragspositionen ,\n\n    (TNr NUMBER(38),\n\n    AuftragsNr NUMBER(38),\n\n    Menge NUMBER,\n\n    PRIMARY KEY Auftragspositionen(TNR, AuftragsNr));\n\n    \n\n    Welche CREATE-Index-Anweisungen sind korrekt?", "explanation": "Ein Index kann immer nur auf einer Tabelle definiert werden und auch nicht, wenn schon ein entsprechender Prim\u00e4rschl\u00fcssel mit den gleichen Spalten existiert. Siehe die Syntaxbeschreibung der CREATE-INDEX-Anweisung im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-INDEX\"> CREATE-INDEX-Anweisung.", "type": "multiple-choice", "answers": [{"text": "CREATE UNIQUE INDEX Auftr_INDEX ON Auftraege(TNr);", "solution": "false"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX1 ON Auftragspositionen(TNr);", "solution": "true"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX2 ON Auftragspositionen(AuftragsNr);", "solution": "true"}]}, {"id": 2821, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden CREATE-Table-Befehl:\n\nCREATE TABLE Auftraege\n(AuftragsNr     NUMBER(38)   PRIMARY KEY\n Auftrags_Typ   VARCHAR2(50) NOT NULL,\n Kun_Nr         NUMBER(38)   NOT NULL,\n Ang_Nr         NUMBER(38),\n auftragssumme  NUMBER);\n\nF\u00fcr welche Datenbankabfrage braucht man eine Unterabfrage?", "explanation": "Bei Abfragen vom Typ \"Berechnen Sie die Summe \u00fcber alle Auftragssummen eines bestimmten Kunden, der vom Angestellten mit der ang_nr = 1 betreut wird!  \" braucht man eine SELECT-Anweisung mit GROUP BY kund_nr zus\u00e4tzlichem WHERE oder HABING-Klausel, je nach Datenbankabfrage.", "type": "multiple-choice", "answers": [{"text": "Berechnen Sie die Summe \u00fcber alle Auftragssummen eines bestimmten Kunden!", "solution": "false"}, {"text": "Berechnen Sie die Summe \u00fcber alle Auftragssummen eines bestimmten Kunden, der vom Angestellten mit der ang_nr = 1 betreut wird!", "solution": "false"}, {"text": "Geben Sie alle Auftrage aus, deren Auftragssumme h\u00f6her ist als der Durchschnitt aller Auftragssummen aus der Tabelle Auftraege!", "solution": "true"}]}, {"id": 2825, "category": 9, "difficulty": 3, "text": "Welche Ausage(n) \u00fcber Constraints ist wahr?", "explanation": "Die einzige Spaltenbedingung, die nicht als Tabellenbedingung fomuliert werden kann, ist der NOT NULL-Constraint. \n\nFOREIGN-KEY-Constraints und UNIQUE-Constraints k\u00f6nnen auch NULL -Werte enthalten. \n\nCONSTRAINTS werden auch bei UPDATE und DELETE \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "Eine Spalte mit FOREIGN KEY-Constraint kann keine NULL-Werte enthalten.", "solution": "false"}, {"text": "Eine Spalte mit UNIQUE-Constraint kann keine NULL-Werte enthalten.", "solution": "false"}, {"text": "Ein Constraint wird nur bei einer INSERT-Anweisung \u00fcberpr\u00fcft.", "solution": "false"}, {"text": "Ein Constraint kann unter Oracle auch DISABLED werden, wenn die Spalte Daten enth\u00e4lt.", "solution": "true"}, {"text": "Jeder Spaltenbedingung kann auch als Tabellenbedingung formuliert werden.", "solution": "false"}]}, {"id": 2823, "category": 9, "difficulty": 3, "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nDer Vertriebsleiter Dr. Guck der Firma Byce & Co. m\u00f6chte herausfinden, f\u00fcr welche Artikel \u00fcberhaupt Auftr\u00e4ge vorliegen. Er stellt folgende Abfrage an die Datenbank:\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   NOT EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr <> b.TNr);\n\nWelche Aussage(n) sind korrekt?", "explanation": "Die korrekte Abfrage w\u00e4re\n\n SELECT  a.TNr, a.Bezeichnung\n FROM    Artikel a\n WHERE   NOT EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);", "type": "multiple-choice", "answers": [{"text": "Die Abfrage wird ausgef\u00fchrt und liefert das gew\u00fcnschte Ergebnis.", "solution": "false"}, {"text": "Die Abfrage wird ausgef\u00fchrt und liefert nicht das gew\u00fcnschte Ergebnis.", "solution": "true"}, {"text": "Die Abfrage wird ausgef\u00fchrt und liefert keine Zeilen als Ergebnis, da der Vergleichsoperator \"=\" in der inneren Abfrage an Stelle von \"<>\" genutzt werden muss.", "solution": "true"}, {"text": "Die Abfrage wirft einen Fehler, da die WHERE-Klausel der \u00e4u\u00dferen Abfrage auf einen Spalte der inneren Abfrage verweisen muss.", "solution": "false"}, {"text": "Die Abfrage wirft einen Fehler, da die WHERE-Klausel der \u00e4u\u00dferen Abfrage einen Vergleichsoperator enthalten muss.", "solution": "false"}]}, {"id": 2826, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Unterabfragen sind wahr?", "explanation": "siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Unterabfrage\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "Eine Unterabfrage kann Daten aus ein oder mehreren Tabellen oder Views auslesen.", "solution": "true"}, {"text": "In einer SELECT-Anweisung k\u00f6nnen nur zwei Unterabfragen parallel genutzt werden.", "solution": "false"}, {"text": "Falls eine Unterabfrage als Ergebnis 0 Zeilen hat, wird NULL zur\u00fcckgegeben.", "solution": "true"}, {"text": "Die Spalten einer Unterabfrage m\u00fcssen immer einen Tabellennamen oder einen Tabellealias haben.", "solution": "false"}, {"text": "In einer WHERE-Klausel k\u00f6nnen Unterabfragen h\u00f6chstens dreimal ineinander geschachtelt werden.", "solution": "false"}]}, {"id": 2827, "category": 9, "difficulty": 3, "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank: Abteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Ang_Nr} Angestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr } Es sollen alle Abteilungen mit den zugeh\u00f6rigen Angestellten ausgegeben werden, deren Budget mehr als 5000 \u0080 betr\u00e4gt. Es wird dazu das folgende SELECT-Statement abgesetzt:\n\n    SELECT abt_nr, Name, Budget, Nachname FROM abteilungen WHERE leiter > 2 JOIN angestellte USING (Abt_nr);\n\n    Welche der folgenden Aussagen ist wahr?", "explanation": "Auch in einer SELECT-Anweisung mit JOIN..... USING steht die WHERE-Klausel immer nach der FROM-Klausel.", "type": "multiple-choice", "answers": [{"text": "Die SELECT-Abfrage wird ausgef\u00fchrt und liefert das gew\u00fcnschte Ergebnis.", "solution": "false"}, {"text": "Die SELECT-Abfrage wird nicht ausgef\u00fchrt, da eine ON-Klausel fehlt.", "solution": "false"}, {"text": "Die SELECT-Abfrage wird nicht ausgef\u00fchrt, da die WHERE-Klausel an der falschen Stelle der SELECT-Anweisung steht.", "solution": "true"}]}, {"id": 2828, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Sequenzen (CREATE SEQUENCE....) sind wahr?", "explanation": "Siehe < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-SEQUENCE\"> CREATE SEQUENCE", "type": "multiple-choice", "answers": [{"text": "Mit DELETE SEQUENCE <sequencename>; wird eine Sequenz wieder gel\u00f6scht.", "solution": "false"}, {"text": "CURVAL enth\u00e4lt die zuletzt verwendete fortlaufende Nummer.", "solution": "true"}, {"text": "Mit ALTER SEQUENCE ... kann eine Sequenz nachtr\u00e4glich ver\u00e4ndert werden, wenn z.B. der MAXVALUE erreicht ist.", "solution": "true"}, {"text": "Sequenzen k\u00f6nnen auch absteigende Nummern erzeugen.", "solution": "false"}, {"text": "Sequenzen k\u00f6nnen nur in einer Tabelle genutzt werden.", "solution": "false"}, {"text": "Sequenzen werden ausschlie\u00dflich nur f\u00fcr k\u00fcnstliche Prim\u00e4rschl\u00fcssel verwendet.", "solution": "false"}]}, {"id": 2836, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber Constraints sind wahr?", "explanation": "Der einzige Spalten-Constraint, der nicht als Tabellenbedingung geschrieben werden kann, ist der NOT NULL CONSTRAINT.\nsiehe auch < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CONSTRAINT\"> CONSTRAINT im DB-Wiki.", "type": "multiple-choice", "answers": [{"text": "Eine Foreign-Key-Spalte kann keine NULL-Werte enthalten.", "solution": "false"}, {"text": "Eine UNIQUE-Spalte kann NULL-Werte enthalten.", "solution": "true"}, {"text": "Ein Constraint wird wird nur bei Insert-Anweisungen \u00fcberpr\u00fcft.", "solution": "false"}, {"text": "Ein Constraint kann unter Oracle-SQL auch disabled werden, wenn er Daten enth\u00e4lt", "solution": "true"}, {"text": "Alle Spalten-Constraints k\u00f6nnen auch als Tabellen-Constraint dfdefiniert werden.", "solution": "true"}]}, {"id": 3114, "category": 9, "difficulty": 2, "text": "Sie m\u00f6chten zwei gespeicherte Prozeduren schreiben, die in Oracle PL/SQL das \u00dcberladen (Overloading) erm\u00f6glichen. \nWelche Regeln gelten unter PL/SQL f\u00fcr das \u00dcberladen?", "explanation": "\u00dcberladen (Overlaoding) ist in PL/SQL  nur in Routinen aus Packages, anonymen Bl\u00f6cken und Objekttypen (member-Methoden) m\u00f6glich. \nStandalone-ROUTINEN, die z.B. mit CREATE PROZEDURE(...) angelegt werden, k\u00f6nnen nicht \u00fcberladen werden.\n(siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Overloading\" target=\"_blank\"> Overloading .)", "type": "multiple-choice", "answers": [{"text": "Die beiden Prozeduren k\u00f6nnen gepackt als Bestandteil eines Packages oder als  Stand-Alone-Prozedur definiert werden.", "solution": "false"}, {"text": "Die beiden Prozeduren k\u00f6nnen als Bestandteil eines Packages definiert werden.", "solution": "true"}, {"text": "Die beiden Prozeduren k\u00f6nnen jeweils als Stand-Alone-Prozeduren definiert werden.", "solution": "false"}, {"text": "Die beiden Prozeduren m\u00fcssen sich im Namen und dem Parametertyp unterscheiden", "solution": "false"}, {"text": "Die beiden Prozeduren k\u00f6nnen den gleichen Namen haben, aber sich im Parametertyp oder der Anzahl der Parameter unterscheiden.", "solution": "true"}]}, {"id": 3092, "category": 9, "difficulty": 2, "text": "Welche Datenbankoperation ist in der Regel schneller?", "explanation": "SELECT COUNT(*) erfordert einen Zugriff auf alle Spalten der Tabelle und ist daher in der Regel langsamer. DISTINCT f\u00fchrt zus\u00e4tzlich eine Sortierung durch.", "type": "multiple-choice", "answers": [{"text": "EXISTS mit\nSELECT c.Country \u000b  FROM Country c \u000b WHERE EXISTS            (SELECT \n1\u000b  FROM Language l \u000b  WHERE c.country = \nl.country);", "solution": "true"}, {"text": "SELECT COUNT(*)...", "solution": "false"}, {"text": "SELECT COUNT(Spaltenname)...", "solution": "true"}, {"text": "DISTINCT mit SELECT DISTINCT Country FROM Language;", "solution": "false"}]}, {"id": 3480, "category": 9, "difficulty": 1, "text": "Betrachten Sie die folgenden SQL-Anweisungen:\n\n    CREATE TABLE test (spalte varchar2(10));\n\n    INSERT INTO TEST VALUES (\"Ja\");\n\n    INSERT INTO TEST VALUES (\"Nein\");\n\n    INSERT INTO TEST VALUES (NULL);\n\n    COMMIT;\n\n    SELECT * FROM TEST WHERE Spalte not in (\"Ja\", \"Nein\");\n\n    Welches Ergebnis hat diese SELECT-Abfrage?", "explanation": "Wegen der <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Dreiwertige-Logik\"> dreiwertigen Logik  in SQL liefert der Vergleich mit einem NULL-Wert den Wahrheitswert UNKNOWN, der in der WHERE-Klauesel zu FALSE ausgewertet wird.  Da UNKNOWN mit UNKNOWN  verneint wird, wird die Zeile mit dem NULL-Wert nicht ausgegeben,", "type": "multiple-choice", "answers": [{"text": "Die beiden Tupel mit den Werten \"Ja\" und \"Nein\"", "solution": "false"}, {"text": "Keine Zeilen (no Rows)", "solution": "true"}, {"text": "Diese Abfrage wirft einen Fehler.", "solution": "false"}, {"text": "Das Tupel mit dem Null-Wert in der Spalte", "solution": "false"}]}, {"id": 2846, "category": 9, "difficulty": 3, "text": "Mit welcher Abfrage kann man ausgeben, wieviele Angestellte keine tel_nr haben (tel_nr ist NULL as Spalteneintrag)?", "explanation": "Einen NULL-Wert fragt man mit IS NULL ab. Wenn COUNT auf eine Spalte mit NULL trifft, ist das Ergebis COUNT(tel_nr) = 0, unabh\u00e4ngig davon, wie oft der NULL-Wert auftaucht. Daher ist die NVL-Funktion notwendig.", "type": "multiple-choice", "answers": [{"text": "SELECT COUNT(tel_nr)\nFROM angestellte\nWHERE tel_nr IS NULL:", "solution": "false"}, {"text": "SELECT COUNT(tel_nr)\nFROM angestellte\nWHERE tel_nr = NULL:", "solution": "false"}, {"text": "SELECT COUNT(DISTINCT tel_nr)\nFROM angestellte\nWHERE tel_nr IS NULL:", "solution": "false"}, {"text": "SELECT COUNT(NVL(tel_nr, 0))\nFROM angestellte\nWHERE tel_nr IS NULL:", "solution": "true"}]}, {"id": 2900, "category": 7, "difficulty": 2, "text": "Welche Normalform reduziert die Redundanz in einer relationalen Datenbank?", "explanation": "Die \u00dcberf\u00fchrung einer Relation in die 1NF erh\u00f6ht in der Regel die Redundanz, bei der 2NF und der 3NF ist es umgekehrt.", "type": "multiple-choice", "answers": [{"text": "3NF", "solution": "true"}, {"text": "Jede der drei Normalfomen (1NF, 2NF und 3NF)", "solution": "false"}, {"text": "1NF", "solution": "false"}, {"text": "2NF", "solution": "true"}]}, {"id": 2902, "category": 9, "difficulty": 2, "text": "Welche Aussagen sind wahr bez\u00fcglich der USING-Klausel eines SELECT-Statements?", "explanation": "Die  USING-Klausel setzt den EQUI-Join aus der relationalen Algebra um und kann alternativ zur ON-Klausel benutzt werden. (siehe  http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Tabelle )", "type": "multiple-choice", "answers": [{"text": "Die  USING-Klausel kann nur bis zu drei Tabellen verkn\u00fcpfen.", "solution": "false"}, {"text": "Mit der USING-Klausel kann man Equi-Joins und allgemeine Theta-Joins (Vergleichopertaor z.B. >) abgebildet werden.", "solution": "false"}, {"text": "Die USING-Klausel kann auf Spalten mit gleichem Namen und vergleichbarem Datentyp angewendet werden,.", "solution": "true"}]}, {"id": 3128, "category": 9, "difficulty": 3, "text": "Welche Aussagen \u00fcber INDEX-By-Tabellen (assoziative Arrays) sind unter Oracle PL/SQL wahr?", "explanation": "Kollektionen mit Gr\u00f6\u00dfenbeschr\u00e4nkung hei\u00dfen unter Oracle PL/SQL ARRAYS.ein. Bei  INDEX BY-Tabellen sind die Schl\u00fcsseltypen BINARY_INTEGER , PLS_INTEGER und VARCHAR2-Typ\n vorgesehen.", "type": "multiple-choice", "answers": [{"text": "INDEX-By-Tabellen habe keine Gr\u00f6\u00dfenbeschr\u00e4nkung", "solution": "true"}, {"text": "INDEX BY-Tabellen sind Gruppen von Schl\u00fcsselwertpaaren", "solution": "true"}, {"text": "Die Schl\u00fcssel INDEX BY-Tabellen k\u00f6nnen vom Typ BINARY_INTEGER , PLS_INTEGER oder VARCHAR2-Typ sein", "solution": "true"}, {"text": "Die Schl\u00fcssel INDEX BY-Tabellen k\u00f6nnen nur vom Typ BINARY_INTEGER oder PLS_INTEGER sein", "solution": "false"}, {"text": "INDEX-By-Tabellen habe eine Gr\u00f6\u00dfenbeschr\u00e4nkung", "solution": "false"}]}, {"id": 3130, "category": 9, "difficulty": 1, "text": "Ein ge\u00f6ffneter CURSOR l\u00f6st eine EXCEPTION aus, wenn eine FETCH- Anweisung keine Zeilen liefert.", "explanation": "Eine EXCEPTIOn wird nur bei einem impliziten CURSOR mit SELECT INTO... geworfen, wenn der SELECT keine Zeilen liefert.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3131, "category": 9, "difficulty": 2, "text": "Die maximale Anzahl der ge\u00f6ffneten Cursor pro Session ist begrenzt", "explanation": "Die maximale Anzahl der ge\u00f6ffneten Cursor pro Session wird durch den \nOracle-Initialisierungsparameter OPEN_CURSORS eingestellt.", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "false"}, {"text": "stimmt", "solution": "true"}]}, {"id": 3139, "category": 9, "difficulty": 1, "text": "Betrachten Sie den folgenden anonymen PL/SQL-Block:\n\nSET SERVEROUTPUT ON \nDECLARE x NUMBER := 1000; \n  y NUMBER;\nBEGIN\n  IF x = y THEN\n  dbms_output.put_line('x=y');\n  ELSIF x<>y THEN\n     dbms_output.put_line('x<>y');\n  ELSE \n     dbms_output.put_line('nicht entscheidbar!'); END IF;\nEND; \n\n\nWelche Meldung gibt der Oracle-Server aus?", "explanation": "Der Vergleich zwischen einem Wert und einer NULL-Variablen wird unter PL/SQL wegen der dreiwertigen Logik immer mit falsch bewertet..", "type": "multiple-choice", "answers": [{"text": "x <> y", "solution": "false"}, {"text": "nicht entscheidbar!", "solution": "true"}, {"text": "x=y", "solution": "false"}]}, {"id": 3069, "category": 7, "difficulty": 3, "text": "Was wird ben\u00f6tigt, wenn eine 1:1- bzw. 1:c1-Beziehung auf zwei Relationen abgebildet wird?", "explanation": "F\u00fcr 1:1 bzw. 1:c1-Beziehungen gilt, dass die beiden Entity-Mengen entweder auf zwei Relationen abgebildet werden oder eben zu einer zusammengefasst werden. Das Zusammenfassen ist problemlos m\u00f6glich, da beide Entity-Mengen \u00fcber den gleichen Prim\u00e4rschl\u00fcssel verf\u00fcgen. \n\nBeim Abbilden auf zwei Relationen wird die 1:1/1:c1-Beziehung auf eine Fremdschl\u00fcsselbeziehung abgebildet. Da aber Fremdschl\u00fcsselbeziehungen eigentlich nur 1:n/1:cn-Beziehungen realisieren, muss f\u00fcr eine 1:1-Beziehung zus\u00e4tzlich gew\u00e4hrleistet sein, dass die Prim\u00e4rschl\u00fcssel beider Relationen gleich sind, also aus dem/den gleichen Attributen bestehen.", "type": "multiple-choice", "answers": [{"text": "Die Eigenschaft \"1:1/1:c1\" wird durch gemeinsame Zweitschl\u00fcssel (Alternate Key/UNIQUE KEY) realisiert.", "solution": "false"}, {"text": "Eine Fremdschl\u00fcsselbeziehung zwischen den Relationen.", "solution": "true"}, {"text": "Zwei Fremdschl\u00fcsselbeziehungen zwischen den Relationen jeweils entgegengesetzt.", "solution": "false"}, {"text": "Das geht gar nicht, 1:1-Beziehungen werden immer nur auf eine Relation abgebildet.", "solution": "false"}, {"text": "Die Prim\u00e4rschl\u00fcssel der beiden Relationen m\u00fcssen gleich sein, also das bzw. die gleichen Attribute.", "solution": "true"}, {"text": "Der Prim\u00e4rschl\u00fcssel des Master-Endes der 1:1-/1:c1-Beziehung muss Teil des Prim\u00e4rschl\u00fcssels der anderen Relation sein, d.h. dass  der Prim\u00e4rschl\u00fcssel des Detail-Endes \u00fcber zumindest ein Attribut mehr im Prim\u00e4rschl\u00fcssel verf\u00fcgen muss.", "solution": "false"}]}, {"id": 3152, "category": 9, "difficulty": 3, "text": "Welche Tipps sollte man beim SQL-Tuning unter ORACLE verwenden, um die Performance zu steigern?", "explanation": "siehe ORACLE-<a target=\"_blank\" title=\"ORACLE-SQL-Tuning-Guide\" href=\"http://www.orafaq.com/tuningguide/\">SQL-Tuning-Guide", "type": "multiple-choice", "answers": [{"text": "keine unn\u00f6tigen Typkonvertierungen", "solution": "true"}, {"text": "BETWEEN statt IN", "solution": "true"}, {"text": "HAVING gegen\u00fcber WHERE bevorzugen, falls m\u00f6glich", "solution": "false"}, {"text": "Die Reihenfolge der Tabellen in der FROM-Klausel  ist irrelevant", "solution": "false"}, {"text": "EXISTS statt distinct oder IN", "solution": "true"}, {"text": "Kein count(*) verwenden", "solution": "true"}, {"text": "CASE statt mehrere Anfragen", "solution": "true"}, {"text": "UNION ALL statt UNION", "solution": "true"}]}, {"id": 2957, "category": 5, "difficulty": 2, "text": "\u00dcber einen k\u00fcnstlichen Prim\u00e4rschl\u00fcssel sind folgende Aussagen wahr:", "explanation": "In der Praxis h\u00e4ufig sogenannte k\u00fcnstliche Schl\u00fcssel (surrogate keys) verwendet. Ein k\u00fcnstlicher Schl\u00fcssel ist ein zus\u00e4tzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Z\u00e4hler vom Datentyp Integer, der systemintern verwaltet wird, nach au\u00dfen nicht sichtbar ist und ausschlie\u00dflich f\u00fcr die Prim\u00e4r- und Fremdschl\u00fcsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und \u00c4hnlichem zu unterscheiden, die nach au\u00dfen sichtbar sind und im Schriftverkehr verwendet oder zur Identifikation beim Kunden erfragt werden. Wenn man sich f\u00fcr die Verwendung von k\u00fcnstlichen Prim\u00e4rschl\u00fcsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen f\u00fcr das gesamte Modell, unabh\u00e4ngig von den sonstigen Schl\u00fcsseln der Entity-Mengen.\nUnd da Prim\u00e4rschl\u00fcssel Pflichteingabespalten sind, sind es auch die k\u00fcnstlichen Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Er ist Pflichteingabeattribut.", "solution": "true"}, {"text": "Er besteht aus einem oder mehreren Attributen.", "solution": "false"}, {"text": "Sein Datentyp ist beliebig (numerisch oder alphanumerisch oder ).", "solution": "false"}, {"text": "Er enth\u00e4lt eine fortlaufende Nummer.", "solution": "true"}, {"text": "Anfragen k\u00f6nnen mit seiner Hilfe schneller beantwortet werden.", "solution": "true"}, {"text": "Fremdschl\u00fcssel k\u00f6nnen keine k\u00fcnstlichen Prim\u00e4rschl\u00fcssel referenzieren.", "solution": "false"}]}, {"id": 3071, "category": 9, "difficulty": 3, "text": "Mit welchen Befehlen werden Eintr\u00e4ge im Data Dictionary verwaltet?", "explanation": "Die \"Daten\" im Data Dictionary sind die im Schema angelegten DB-Objekte wie Tabellen, Sichten, Indexe, Sequenzen, ... Dem entsprechend werden die Strukturbeschreibungen neuer Objekte mittels CREATE-Befehlen im Data Dictionary eingef\u00fcgt, mittels ALTER-Befehlen ge\u00e4ndert und DROP-Befehlen gel\u00f6scht.  \n\nDas Dictionary von Oracle umfasst eine Vielzahl von Tabellen bzw. Sichten. Sie sind in verschiedene Gruppen aufgeteilt, die im Namen deutlich werden:\nUSER_...: Sichten f\u00fcr alle DB-Objekte, die ein Benutzer selbst angelegt hat.\nALL_...: Sichten f\u00fcr alle DB-Objekte, die ein Benutzer selbst angelegt hat bzw. f\u00fcr die er von anderen Anwendern Zugriffsrechte bekommen hat.\nDBA_...: Sichten f\u00fcr alle DB-Objekte, die \u00fcberhaupt in der Datenbank existieren. Auf diese Sichten hat nur ein Benutzer mit Administrationsrechten Zugriff.\nV$-Views: Sichten mit statistischen Informationen. \nUSER_CONSTRAINTS gibt Auskunft \u00fcber die vom Anwender angelegten Constraints.\nUSER_CONS_COLUMNS gibt Auskunft \u00fcber die von den Constraints betroffenen Spalten.", "type": "multiple-choice", "answers": [{"text": "CREATE", "solution": "true"}, {"text": "ALTER", "solution": "true"}, {"text": "DROP", "solution": "true"}, {"text": "INSERT", "solution": "false"}, {"text": "UPDATE", "solution": "false"}, {"text": "DELETE", "solution": "false"}]}, {"id": 3477, "category": 9, "difficulty": 1, "text": "Welcher Oracle-Optimizer entspricht der logischen Optimierung der relationalen Algebra?", "explanation": "Der CBO ist Standard bei Oracle-Versionen ab Version 10g und benutzt Statistiken, die in der Datenbank gespeichert sind.\n\n    Der RBO (Rule Based Optimizer) benutzt \u00e4hnliche Heuristiken (12 Regeln)  wie die Heuristiken der logischen Optimierung in der relationalen Algebra. Er war Standard bis Oracle 9i.\n\n    siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer .", "type": "multiple-choice", "answers": [{"text": "CBO \u0096 Cost Based Optimizer", "solution": "false"}, {"text": "keiner von beiden.", "solution": "false"}, {"text": "RBO \u0096 Rule Based Optimizer", "solution": "true"}]}, {"id": 2816, "category": 9, "difficulty": 2, "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\n    CREATE TABLE Auftraege\n\n    (AuftragsNr NUMBER(38) PRIMARY KEY,\n\n    Auftrags_Typ VARCHAR2(50) NOT NULL,\n\n    Kun_Nr NUMBER(38) NOT NULL,\n\n    Ang_Nr NUMBER(38),\n\n    auftragssumme NUMBER);\n\n    \n\n    CREATE TABLE Auftragspositionen ,\n\n    (TNr NUMBER(38),\n\n    AuftragsNr NUMBER(38),\n\n    Menge NUMBER,\n\n    PRIMARY KEY Auftragspositionen(TNR, AuftragsNr));\n\n    \n\n    Welche CREATE-Index-Anweisungen sind korrekt?", "explanation": "Ein Index kann immer nur auf einer Tabelle definiert werden und auch nicht, wenn schon ein entsprechender Prim\u00e4rschl\u00fcssel mit den gleichen Spalten existiert. Siehe die Syntaxbeschreibung der CREATE-INDEX-Anweisung im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-INDEX\"> CREATE-INDEX-Anweisung", "type": "multiple-choice", "answers": [{"text": "CREATE UNIQUE INDEX Auftr_INDEX ON Auftraege(TNr);", "solution": "false"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX1 ON Auftragspositionen(TNr);", "solution": "true"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX2 ON Auftragspositionen(AuftragsNr);", "solution": "true"}, {"text": "CREATE UNIQUE INDEX Auftragspos_INDEX3 ON Auftraege, Auftragspositionen(AuftragsNr, Menge);", "solution": "false"}]}, {"id": 2817, "category": 9, "difficulty": 3, "text": "Betrachten Sie die folgende CREATE-Table-Anweisung und die anschlie\u00dfende ALTER-Anweisung:\n\n    CREATE TABLE Artikel (TNr NUMBER(38) PRIMARY KEY,\n\n    Bezeichnung VARCHAR2(50) NOT NULL,\n\n    Artikel_Typ VARCHAR2(50) NOT NULL,\n\n    Verkaufspreis NUMBER,\n\n    Jahresumsatz NUMBER,\n\n    Zeitstempel DATE);\n\n     ALTER TABLE Artikel DROP COLUMN Jahresumsatz;\n\n    Welche Aussagen sind wahr?", "explanation": "ALTER-Table geh\u00f6rt zur DDL-Sprache und kann daher nicht zur\u00fcckgerollt werden, da sie ein AUTOCOMMIT beinhaltet. Siehe auch <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/ALTER-TABLE\"> ALTER-TABLE", "type": "multiple-choice", "answers": [{"text": "Die Spalte Jahresumsatz wird gel\u00f6scht, auch wenn Daten enthalten sind.", "solution": "true"}, {"text": "Die Spalte Jahresumsatz wird nur gel\u00f6scht, wenn keine Daten enthalten sind.", "solution": "false"}, {"text": "Die Spalte Jahresumsatz wird nur gel\u00f6scht, wenn mindestens eine Spalte in der Tabelle verbleibt.", "solution": "true"}, {"text": "Eine Alter-Table-Anweisung kann \u00fcber die ROLLBACK-Anweisung wieder zur\u00fcckgerollt werden.", "solution": "false"}, {"text": "Die Spalte Jahresumsatz kann sogar gel\u00f6scht werden, wenn sie Bestandteil eines zusammengesetzten Prim\u00e4rschl\u00fcssels ist.", "solution": "true"}]}, {"id": 3136, "category": 10, "difficulty": 3, "text": "Betrachten Sie den folgenden Trigger:\n\nCREATE OR REPLACE  TRIGGER LOESCHE_ANGESTELLTE\nAFTER UPDATE ON   ANGESTELLTE\nDECLARE num_rows NUMBER; \nBEGIN      \n:NEW.zeitstempel := sysdate;      \n WHEN OTHERS THEN      \n DBMS_OUTPUT.PUT_LINE('Fehler aufgetreten!');\n            END;Welche Aussage(n) sind wahr?", "explanation": "Nur Zeilentrigger d\u00fcrfen die Transitionsvariablem :NEW und :OLD verwenden  Dieser Fehler wird schon zur \u00dcbersetzungszeit erkannt (siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\" title=\"Zeilentrigger\" target=\"_blank\">Zeilentrigger).", "type": "multiple-choice", "answers": [{"text": "Es wird ein \u00dcbersetzungsfehler geworfen, da der Trigger kein Zeilentrigger ist.", "solution": "true"}, {"text": "Es wird ein \u00dcbersetzungsfehler geworfen, da der Trigger keine EXCEPTION werfen darf.", "solution": "false"}, {"text": "Es wird ohne Fehler \u00fcbersetzt, aber der Trigger wirft einen Laufzeitfehler.", "solution": "false"}, {"text": "Der Trigger wird \u00fcbersetzt und funktioniert fehlerfrei.", "solution": "false"}]}, {"id": 2824, "category": 9, "difficulty": 3, "text": "Welche Aussage(n) \u00fcber Unterabfragen sind wahr?", "explanation": "siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "Der NOT-Operator kann zusammen mit IN, ALL oder ANY benutzt werden.", "solution": "false"}, {"text": "NOT IN ist \u00e4quivalent zu IS NULL", "solution": "false"}, {"text": "= ANY und = All haben die gleiche Funktionalit\u00e4t", "solution": "false"}, {"text": "Der IN-Operator kann benutzt werden, wenn die Unterabfrage nur eine Zeile liefert.", "solution": "true"}]}, {"id": 2905, "category": 9, "difficulty": 2, "text": "Welche SELECT-Abfrage beantwortet die Frage :\n\n    \n\n    \"In welchem Land leben die meisten Menschen?\"\n\n    \n\n    auf der Tabelle country:\n\n    \n\n    CREATE TABLE Country\n\n    (Name VARCHAR2(35) NOT NULL UNIQUE,\n\n    COUNTRY VARCHAR2(4) CONSTRAINT CountryKey PRIMARY KEY,\n\n    Capital VARCHAR2(35),\n\n    Province VARCHAR2(35),\n\n    Population NUMBER);", "explanation": "Die Abfrage mit <> ALL ist syntaktisch korrekt, liefert aber nicht die gew\u00fcnschten L\u00e4nder.", "type": "multiple-choice", "answers": [{"text": "SELECT   country, Name, population    FROM   country  WHERE population <>  ALL (  SELECT   population from country);", "solution": "false"}, {"text": "keine von allen", "solution": "false"}, {"text": "SELECT   country, Name, population    FROM   country  WHERE population >= ALL (  SELECT   population from country);", "solution": "true"}, {"text": "SELECT   country, Name, population    FROM   country  WHERE population = (SELECT MAX(population) from country)", "solution": "true"}]}, {"id": 2927, "category": 42, "difficulty": 1, "text": "Betrachten Sie eine Relation mit drei Spalten. \nWie viele Indizes kann man  anlegen?", "explanation": "Bei vier Spalten berechnet sich die Anzahl der m\u00f6gliche Indizes x nach der Formel: x = Summe [k=1..n] (n!/(n-k)!), wobei n! die Fakult\u00e4t ist.F\u00fcr n= 4 erh\u00e4lt man:    x = 4x3x2x1 + 4x3x2 + 4x3 + 4 = 64F\u00fcr n= 3 bei drei Spalten entsprechend:    x = 3x2x1 + 3x2 + 3x1 = 15Das ist die Anzahl der m\u00f6glichen nicht leeren geordneten Teilmengen einer vierelementigen Menge. Diese Mengen hei\u00dfen in der Kombinatorik Variationen, siehe auch http://de.wikipedia.org/wiki/Abz\u00e4hlende_Kombinatorik.", "type": "multiple-choice", "answers": [{"text": "keine von allen", "solution": "false"}, {"text": "1", "solution": "false"}, {"text": "3", "solution": "false"}, {"text": "5", "solution": "false"}, {"text": "9", "solution": "false"}, {"text": "15", "solution": "true"}, {"text": "18", "solution": "false"}, {"text": "64", "solution": "false"}]}, {"id": 3424, "category": 9, "difficulty": 2, "text": "Welche Auswirkung hat die folgende Anweisung?\n\n    \n\n    CREATE TABLE ist_mitglied\n\n    ( Staat_id          INTEGER NOT NULL,\n\n       Organisation_id   INTEGER NOT NULL,\n\n       TYPE              VARCHAR2 (20)\n\n             UNIQUE\n\n             CONSTRAINT TYPE_CHECK CHECK\n\n                (TYPE IN (\"Mitglied\", \"Anw\u00e4rter\", \"Gast\", \"Beobachter\")),\n\n       PRIMARY KEY (Staat_id, Organisation_id) );", "explanation": "Durch das UNIQUE k\u00f6nnen die Werte \"Mitglied\", \"Anw\u00e4rter\", \"Gast\", \"Beobachter\" nur genau enmal in die Tabelle eingef\u00fcgt werden. Daher k\u00f6nnen h\u00f6chsten vier Werte in die Tabelle Mitglied eingef\u00fcgt werden.", "type": "multiple-choice", "answers": [{"text": "Es wird gepr\u00fcft, ob in der Spalte Type die Werte Mitglied, Anw\u00e4rter, Gast oder Beobachter steht, wobei Gro\u00dfschreibung und Kleinschreibung keine Rolle spielen.", "solution": "false"}, {"text": "In  die Tabelle ist_Mitglied k\u00f6nnen nicht mehr als vier  in Datens\u00e4tze eingef\u00fcgt werden.", "solution": "true"}, {"text": "keine von allen", "solution": "false"}, {"text": "Es wird gepr\u00fcft, ob in der Spalte Type die Werte Mitglied, Anw\u00e4rter, Gast oder Beobachter steht, wobei Gro\u00dfschreibung und Kleinschreibung eine Rolle spielen.", "solution": "true"}]}, {"id": 3068, "category": 7, "difficulty": 3, "text": "Welche Aussagen \u00fcber 1:1- bzw. 1:c1-Beziehungen zwischen zwei Entity-Mengen sind wahr?", "explanation": "F\u00fcr 1:1 bzw. 1:c1-Beziehungen gilt, dass die beiden Entity-Mengen entweder auf zwei Relationen abgebildet werden oder eben zu einer zusammengefasst werden. Das Zusammenfassen ist problemlos m\u00f6glich, da beide Entity-Mengen \u00fcber den gleichen Prim\u00e4rschl\u00fcssel verf\u00fcgen. \n\nBeim Abbilden auf zwei Relationen wird die 1:1/1:c1-Beziehung auf eine Fremdschl\u00fcsselbeziehung abgebildet. Da aber Fremdschl\u00fcsselbeziehungen eigentlich nur 1:n/1:cn-Beziehungen realisieren, muss f\u00fcr eine 1:1-Beziehung zus\u00e4tzlich gew\u00e4hrleistet sein, dass die Prim\u00e4rschl\u00fcssel beider Relationen gleich sind, also aus dem/den gleichen Attributen bestehen.", "type": "multiple-choice", "answers": [{"text": "Sie k\u00f6nnen nur auf eine Relation abgebildet werden.", "solution": "false"}, {"text": "Sie k\u00f6nnen auf eine oder zwei Relationen abgebildet werden.", "solution": "true"}, {"text": "Bei der Abbildung auf zwei Relationen wird eine Fremdschl\u00fcsselbeziehung ben\u00f6tigt.", "solution": "true"}, {"text": "Bei der Abbildung auf zwei Relationen m\u00fcssen die beiden Prim\u00e4rschl\u00fcssel gleich sein.", "solution": "true"}, {"text": "Bei der Abbildung auf zwei Relationen m\u00fcssen gleiche Zweitschl\u00fcssel (UNIQUE KEY) definiert sein.", "solution": "false"}]}, {"id": 3075, "category": 9, "difficulty": 2, "text": "Welche Datenbank-Situationen k\u00f6nnen eine schlechte Performance mit langen Wartezeiten verursachen?", "explanation": "Bei einer View-Hierarchie muss das Datenbanksystem unter Umst\u00e4nden alle beteiligten Views parsen, was einen erh\u00f6hten Zeitaufwand bedeutet. Kartesische Produkte k\u00f6nnen zu einem sehr gro\u00dfen Datenvolumen f\u00fchren, das von der Festplatte gelesen werden muss. Natural-Join sind in der Regel schnell, da Sie \u00fcber die Prim\u00e4rschl\u00fcssel auf die Tabellen zugreifen.", "type": "multiple-choice", "answers": [{"text": "Die Anfrage bezieht sich auf eine View, die an oberster Stelle in ener View-Hierachie steht.", "solution": "true"}, {"text": "Die SELECT-Anfrage enth\u00e4lt ein kartesisches Produkt.", "solution": "true"}, {"text": "Die SELECT-Anfrage enth\u00e4lt einen Natural-Join.", "solution": "false"}]}, {"id": 3101, "category": 9, "difficulty": 1, "text": "Welcher Join-Operator passt, wenn alle Spalten in der Anfrage Index-Spalten sind?", "explanation": "Das ist der Index Join,\nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#INDEX _JOIN\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#INDEX _JOIN  .", "type": "multiple-choice", "answers": [{"text": "Cartesian Join", "solution": "false"}, {"text": "Nested Loop Join", "solution": "false"}, {"text": "Hash Join", "solution": "false"}, {"text": "Sort Merge Join", "solution": "false"}, {"text": "Outer Join", "solution": "false"}, {"text": "Index Join", "solution": "true"}]}, {"id": 3078, "category": 9, "difficulty": 1, "text": "Welcher Optimizer wird bei Oracle seit Version 10g benutzt?", "explanation": "Der CBO ist Standard bei Oracle-Versionen ab Version 10g und benutzt Statistiken, die in der Datenbank gespeichert sind.\nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer .", "type": "multiple-choice", "answers": [{"text": "RBO \u0096 Rule Based Optimizer", "solution": "false"}, {"text": "CBO \u0096 Cost Based Optimizer", "solution": "true"}, {"text": "keiner von beiden.", "solution": "false"}]}, {"id": 3083, "category": 9, "difficulty": 1, "text": "Es gibt eine Tabelle Nation mit den Spalten Nation_id, Name, Flagge und auf der Nation_id ist der Prim\u00e4rschl\u00fcssel definiert. Welcher Befehl ist der kosteng\u00fcnstigste/schnellste?", "explanation": "Da f\u00fcr einen Prim\u00e4rschl\u00fcssel automatisch ein Index definiert wird und die Anfrage auf keine weiteren Spalten zugreift, ist der COUNT \u00fcber die Nation_id die kosteng\u00fcnstigste und schnellste L\u00f6sung. Die Anfrage kann so ausschlie\u00dflich \u00fcber den Index und ohne Zugriff auf die eigentlichen Datens\u00e4tze ausgewertet werden.", "type": "multiple-choice", "answers": [{"text": "SELECT COUNT(*) FROM Nation n;", "solution": "false"}, {"text": "SELECT COUNT(n.Name) FROM Nation n;", "solution": "false"}, {"text": "SELECT COUNT(n.Nation_id) FROM Nation n;", "solution": "true"}]}, {"id": 3104, "category": 9, "difficulty": 2, "text": "Betrachten Sie den folgenden PL/SQL-Code:\n\n    <font face=\"courier new\">create table ang_temp \n\n    <font face=\"courier new\">  (angid number not null primary key,\n\n       abtid number check (abtid between 100 and 500),\n\n       abtname varchar2(500) default \"test\");\n\n    \n\n    <font face=\"courier new\">declare\n\n    ang_c ang_temp%rowtype;\n\n    BEGIN\n\n    \n\n    ang_c.angid := NULL;\n\n    ang_c.abtid := 50;\n\n    dbms_output.PUT_LINE(\"Hallo\" || ang_c.abtname);\n\n    END;\n\n    /\n\n    \n\n    Welche Aussagen treffen zu?", "explanation": "Im Record -Typ ang_c <font face=\"courier new\">ang_temp%rowtype werden nur die  Datentypen \u00fcbernommen, aber nicht die zugeh\u00f6rigen CONSTRAINTS der Tabelle ang_temp gepr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "Der PL/SQL-Code wird ausgef\u00fchrt und liefert das Ergebnis Hallo.", "solution": "true"}, {"text": "Der PL/SQL-Code wird ausgef\u00fchrt und liefert das Ergebnis test", "solution": "false"}, {"text": "Der anonyme Block wird nicht ausgef\u00fchrt sondern wirft einen Fehler, weil <font face=\"courier new\">ang_c.angid keinen NULL-Wert haben darf.", "solution": "false"}, {"text": "Der anonyme Block wird nicht ausgef\u00fchrt sondern wirft einen Fehler, weil ang_c.abtid den CHECK-Constraint der Tabelle ang_temp verletzt.", "solution": "false"}]}, {"id": 3090, "category": 9, "difficulty": 1, "text": "Welche Datenbankoperation ist in der Regel unter Oracle-SQL die langsamste?", "explanation": "EXISTS und BETWEEN haben in der Regel eine bessere Performance als IN.", "type": "multiple-choice", "answers": [{"text": "EXISTS", "solution": "false"}, {"text": "BETWEEN", "solution": "false"}, {"text": "IN", "solution": "true"}]}, {"id": 3119, "category": 9, "difficulty": 3, "text": "Betrachten Sie den folgenden anonymen PL-SQL-Block auf der Tabelle\n\n    Angestellte(ang_nr, Name, abt_nr, gehalt, ....)\n\n    <font face=\"courier new\">SET SERVEROUTPUT ON; \n\n    <font face=\"courier new\">DECLARE\n\n       v_summe NUMBER;\n\n       abt_nr angestellte.ang_nr%TYPE = 5;\n\n    BEGIN\n\n       SELECT SUM(gehalt)\n\n       FROM angestellte v_summe INTO v_summe\n\n       WHERE abt_nr = abt_nr;\n\n       DBMS_OUTPUT.PUT_LINE(\"Die Gehaltssumme in Abteilung 5 ist \" || to_char(v_summe);\n\n    \n\n    END;\n\n    \n\n    Welche Aussagen sind wahr?", "explanation": "Ein anonymer PL/SQL-Block ignoriert leider in SQL-Angeweisungen Variablenamen, die gleich Spaltennamen sind. Es wird die Bedingung \"abt_nr = abt_nr\" gepr\u00fcft, die immer wahr ist. Es wird daher die Summe \u00fcber alle Geh\u00e4lter \u00fcber alle Abteilungen berechnet.", "type": "multiple-choice", "answers": [{"text": "Der anonyme Block wirft einen Fehler, weil Gruppenfunktionen (SUM) nicht in anonymen Bl\u00f6cken genutzt werden d\u00fcrfen.", "solution": "false"}, {"text": "Der  anonyme Block wird ausgef\u00fchrt und gibt die Summe \u00fcber alle Geh\u00e4lter in Abteilung 5 aus.", "solution": "false"}, {"text": "Der  anonyme Block wird ausgef\u00fchrt und gibt nicht die Summe \u00fcber alle Geh\u00e4lter in Abteilung 5 aus.", "solution": "true"}, {"text": "Der anonyme Block wirft einen Fehler, weil der Variablenname in der SELECT-Anweisung gleich dem Spaltennamen ist.", "solution": "false"}]}, {"id": 3134, "category": 9, "difficulty": 2, "text": "Mit welchem Schleifentyp k\u00f6nnen Sie die Verarbeitung expliziter Cursor verk\u00fcrzen?", "explanation": "FOR record_name IN cursor_name LOOP   \n  statement1;\n  statement2;\n  . . .\nEND LOOP;", "type": "text", "answers": [{"text": "Das sind:", "solution": "Cursor-FOR-Schleifen"}]}, {"id": 3073, "category": 9, "difficulty": 1, "text": "Was ist eine Grundanforderung beim SQL-Tuning, auf die man nicht verzichten kann?", "explanation": "Es geht nur um das SQL-Tuning, da bleibt die Datenbankinstance unver\u00e4ndert. Die  Semantik muss dabei erhalten bleiben, die Syntax nicht.", "type": "multiple-choice", "answers": [{"text": "Beibehalten der korrekten Semantik", "solution": "true"}, {"text": "Beibehalten einer unver\u00e4nderten Syntax der SQL-Anweisung", "solution": "false"}, {"text": "\u00c4nderung an den Parametern der Datenbankinstance", "solution": "false"}]}, {"id": 3423, "category": 9, "difficulty": 2, "text": "Welche Auswirkung hat die folgende Anweisung, wenn die Tabelle Mitglied die Spalte TYPE enth\u00e4lt?\n\n    \n\n    ALTER TABLE  Mitglied\n\n    ADD CONSTRAINT  TYPE_CHECK CHECK (UPPER(TYPE) IN (\"Mitglied\", \"Anw\u00e4rter\", \"Gast\", \"Beobachter\"));", "explanation": "Da die Werte \"Mitglied\", \"Anw\u00e4rter\" etc . nicht in Gro\u00dfbuchstaben geschrieben sind, kann die Check-Bedingung TYPE CHECK nie erf\u00fcllt sein. Daher  k\u00f6nnen keine Werte in die Tabelle Mitglied eingef\u00fcgt werden.", "type": "multiple-choice", "answers": [{"text": "Es wird gepr\u00fcft, ob in der Spalte Type die Werte Mitglied, Anw\u00e4rter, Gast oder Beobachter steht, wobei Gro\u00dfschreibung und Kleinschreibung keine Rolle spielen.", "solution": "false"}, {"text": "In  die Tabelle Mitglied kann nie wieder ein Datensatz eingef\u00fcgt werden.", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 3487, "category": 9, "difficulty": 3, "text": "Welche Aussage(n) \u00fcber Unterabfragen sind wahr?", "explanation": "Der In-Operator kann immer benutzt werden, unabh\u00e4ngig davon, wieviele Zeilen die Unterabfrage liefert.\n\n    siehe Erkl\u00e4rungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen", "type": "multiple-choice", "answers": [{"text": "keine von allen", "solution": "false"}, {"text": "Der IN-Operator kann auch benutzt werden, wenn die Unterabfrage nur eine Zeile liefert.", "solution": "true"}, {"text": "Der IN-Operator kann auch benutzt werden, wenn die Unterabfrage mehr als eine Zeile liefert.", "solution": "true"}]}, {"id": 2866, "category": 9, "difficulty": 3, "text": "Welche abh\u00e4ngigen Objekte werden mit dem  DROP TABLE Befehl gel\u00f6scht?", "explanation": "Bis auf die Views werden alle abh\u00e4ngigen Objekte gel\u00f6scht. Die Views bleiben als Definition erhalten, sind aber erst wieder benutzbar, wenn die Tabelle neu angelegt wird. Unter Oracle wird der Status in user_objects auf 'invalid' gesetzt und die View muss neu \u00fcbersetzt werden.", "type": "multiple-choice", "answers": [{"text": "Indizes, die auf der Tabelle definiert sind", "solution": "true"}, {"text": "Constraints, die auf der Tabelle definiert sind", "solution": "true"}, {"text": "Views, die auf der Tabelle definiert sind", "solution": "false"}, {"text": "Die Daten der Tabelle", "solution": "true"}, {"text": "Trigger, die auf der Tabelle definiert sind.", "solution": "true"}]}, {"id": 2868, "category": 10, "difficulty": 3, "text": "Auf einer Tabelle Test soll ein Oracle-Trigger geschrieben werden, der verhindert, dass mehr als 2 Datens\u00e4tze in der Tabelle angelegt werden. Welcher Trigger erf\u00fcllt diese Aufgabe?\n\nCREATE TABLE test (\n       NR NUMBER ,\n       Bezeichnung VARCHAR2(20));", "explanation": "Der Trigger kann nicht als Zeilentrigger (FOR EACH ROW) definiert werden, da der SELECT das Mutating-Table-Problem ausl\u00f6sen w\u00fcrde.\n\nDer BEFORE-INSERT-Trigger wird zum falschen Zeitpunkt angestossen, da vor dem eigentlichen INSERT die Anzahl der Datens\u00e4tze noch nicht bekannt ist, die nach dem INSERT in der Datenbank stehen.", "type": "multiple-choice", "answers": [{"text": "CREATE TRIGGER pruefen\nAFTER INSERT ON test\nDECLARE\nMY_VAR NUMBER;\nBEGIN\n      SELECT count(*) INTO MY_VAR FROM Test;        \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-20001, 'Zu viele Daten!');\n    END IF;\nEND;\n", "solution": "true"}, {"text": "CREATE TRIGGER pruefen\nBEFORE INSERT ON test\nDECLARE\nMY_VAR NUMBER;\nBEGIN\n      SELECT count(*) INTO MY_VAR FROM Test;        \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-20001, 'Zu viele Daten!');\n    END IF;\nEND;", "solution": "false"}, {"text": "CREATE TRIGGER pruefen\nBEFORE INSERT ON test\nFOR EACH ROW\nDECLARE\nMY_VAR NUMBER;\nBEGIN\n        SELECT count(*) INTO MY_VAR FROM Test;        \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-20001, 'Zu viele Daten!');\n    END IF;\nEND;", "solution": "false"}]}, {"id": 3363, "category": 10, "difficulty": 1, "text": "In Oracle-Instead-Of-Triggern k\u00f6nnen die Transitionsvariablen :OLD.spaltenname beschrieben werden.", "explanation": "Die Transitionsvariablen :NEW.spaltenname k\u00f6nnen unter Oracle-PL/SQL bei INSTEAD-OF-Triggern zwar gelesen, aber nicht beschrieben werden. Die :OLD.Transitionsvariablen k\u00f6nnen nie beschrieben werden, das sie einen alten Zustand enthalten.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3192, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber Views (Sichten) sind wahr?", "explanation": "Den View -Begriff (\u00e4nderbare Sicht)  bitte im DB-Wiki unter   <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht\" target=\"\" title=\"\u00c4nderbare Sicht\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht nachschlagen!", "type": "multiple-choice", "answers": [{"text": "Eine View, in der Spaltenabk\u00fcrzungen benutzt werden (create view  as select spalte1 as neue_Spalte) erlaubt kein UPDATE der Daten.", "solution": "false"}, {"text": "Eine View, mit einer SELECT-Anweisung, die DISTINCT enth\u00e4lt, erlaubt kein UPDATE der Daten.", "solution": "true"}, {"text": "Wenn man in einer virtuellen View Daten l\u00f6scht, bleiben diese Daten in der zugrundeliegenden Tabelle enthalten.", "solution": "false"}, {"text": "Mit CREATE OR REPLACE view wird eine VIEW erst gel\u00f6scht (DROP) und dann wieder angelegt.", "solution": "true"}, {"text": "Mit der ORACLE-Option \"WITH CHECK OPTION\" kann man die in einer View enthaltenen Spalten einschr\u00e4nken.", "solution": "false"}]}, {"id": 3507, "category": 9, "difficulty": 3, "text": "Folgende Prozedur sei gegeben:\n\n    CREATE OR REPLACE PROCEDURE test_proc (p1   IN   NUMBER,  p2   IN OUT   NUMBER, p3   OUT    NUMBER) ... ;\n\n    Welche Parameterverwendungen im Programm sind korrekt?", "explanation": "PL/SQL unterschiedet drei Typen der Parameter\u00fcbergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist.\n\n    \n\n    Beim Typ IN wird der \u00dcbergabewert beim Aufruf in das Programm \u00fcbernommen, Dieser Typ verh\u00e4lt sich daher wie eine Konstante innerhalb eines Programms. Parameter vom Typ IN sind daher nicht in Zuweisungen verwendbar sondern nur in Bedingungen etc..\n\n    \n\n    Beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm \u00fcbergeben und IN OUT ist eine Kombination aus beiden M\u00f6glichkeiten. Beim Typ OUT gibt es eine Wert\u00fcbergabe in initialisierter Form an die Prozedur und R\u00fcckgabe eines ver\u00e4nderten Werts an das aufrufende Objekt. Dieser Typ verh\u00e4lt sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann. Parameter vom Typ OUT  sind daher in Zuweisungen, Bedingungen, etc. verwendbar.\n\n    \n\n    Der Typ IN OUT verh\u00e4lt sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zur\u00fcckgeben kann. Parameter vom Typ IN OUT sind daher in Zuweisungen, Bedingungen etc. verwendbar.", "type": "multiple-choice", "answers": [{"text": "p1 := p2;", "solution": "false"}, {"text": "p2 := p1;", "solution": "true"}, {"text": "WHILE p2 < 345 LOOP ;", "solution": "true"}, {"text": "IF p3 = 456 THEN ;", "solution": "true"}, {"text": "p3:= p1;", "solution": "true"}, {"text": "RETURN p3;", "solution": "false"}]}, {"id": 3523, "category": 9, "difficulty": 1, "text": "Welche Aussagen zu PHP sind richtig?", "explanation": "PHP ist eine weit verbreitete Scriptsprache bei gut 80% aller Websites und seit vielen Jahren im Web etabliert. PHP ist einfach zu erlernen, aber dennoch sehr m\u00e4chtig und performant. PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL m\u00f6glich macht. PHP hat sich zu einem Quasi-Standard f\u00fcr Server-seitige Programmiersprachen von Webanwendungen entwickelt.\n\n    \n\n    Erfunden wurde sie 1994 von Rasmus Lerdorf (urspr\u00fcnglich: Personal Home Page) und besteht aus einfachen Textdateien mit .php\u2013Endung. Mittlerweilse steht das Akronym PFP: Hypertext Preprocessor. Die Ausgabe erfolgt vielfach im HTML-Format.  \n\n    \n\n    Seit PHP Version 5 ist objektorientiertesProgrammieren m\u00f6glich. Somit ist eine Klassifizierung von Objekten der reelenWelt auf einen bestimmten Kontext umsetzbar.\n\n    \u2013Vereinfacht: Funktionen/Methoden k\u00f6nnen in Klassen zusammengefasst werden, um unendlich viele Objekte (mit verschiedenen Auspr\u00e4gungen) instanzierenzu k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "PHP ist eine weit verbreitete Scriptsprache und seit vielen Jahren im Web etabliert.", "solution": "true"}, {"text": "PHP ist einfach zu erlernen, weil sie nicht so m\u00e4chtig ist.", "solution": "false"}, {"text": "PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL m\u00f6glich macht.", "solution": "true"}, {"text": "Es sind einfache Textdateien mit .php-Endung.", "solution": "true"}, {"text": "PHP unterst\u00fctzt als Ausgabeformat leider kein HTML.", "solution": "false"}, {"text": "PHP ist bislang immer noch eine rein prozedurale Programmiersprache.", "solution": "false"}]}, {"id": 3529, "category": 9, "difficulty": 2, "text": "<div style=\"margin-left:.38in;\">\n    In PHP gibt es interne Funktionen, die eine Verwendung von MySQL-Datenbanken einfach machen. Wie hei\u00dfen sie?", "explanation": "<div style=\"margin-left:.38in;\">\n    In PHP gibt es interne Funktionen, die eine Verwendung von MySQL-Datenbanken einfach machen.\n<div style=\"margin-left:.81in;\">\n    \u2013MySQLi (MySQL Improved Extension)\n<div style=\"margin-left:1.25in;\">\n    \u2022<a href=\"http://www.php.net/manual/en/book.mysqli.php\">http://<a href=\"http://www.php.net/manual/en/book.mysqli.php\">www.php.net/manual/en/book.mysqli.php\n<div style=\"margin-left:.81in;\">\n    \u2013PDO (PHP Data Objects)\n<div style=\"margin-left:1.25in;\">\n    \u2022<a href=\"http://www.php.net/manual/de/book.pdo.php\">http://<a href=\"http://www.php.net/manual/de/book.pdo.php\">www.php.net/manual/de/book.pdo.php", "type": "multiple-choice", "answers": [{"text": "MySQLphp", "solution": "false"}, {"text": "MySQLi", "solution": "true"}, {"text": "PHPConnect", "solution": "false"}, {"text": "PDO", "solution": "true"}, {"text": "MPC", "solution": "false"}]}, {"id": 3579, "category": 10, "difficulty": 1, "text": "Sobald ein Trigger erzeugt und aktiviert wird, werden r\u00fcckwirkend alle in der Datenbank vorhandenen Daten gepr\u00fcft, ob sie dem Trigger  gen\u00fcgen. Falls dies nicht der Fall ist, kann der Trigger nicht erzeugt werden.", "explanation": "Genau das ist der Schutz, den Datenbanksysteme bei Constraints, aber nicht bei Triggerrn bieten. Werden Trigger verwendet, besteht diese Sicherheit nicht. Es werden nur alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung \u00fcberpr\u00fcft.", "type": "multiple-choice", "answers": [{"text": "stimmt", "solution": "false"}, {"text": "stimmt nicht", "solution": "true"}]}, {"id": 3643, "category": 5, "difficulty": 1, "text": "Welche Einschr\u00e4nkungen hat das klassische ER-Modell?", "explanation": "Die Anzahl der Attribute sind weder in UML noch im ER-Modell beschr\u00e4nkt, nur in manchen konkreten Datenbanksystemen. Die anderen Eigenschaften sind gerade die wesentlichen n Einschr\u00e4nkungren des klasischen ER-Modells.", "type": "multiple-choice", "answers": [{"text": "Mehrwertige Attribute fehlen", "solution": "true"}, {"text": "Die Anzahl der Attribute ist beschr\u00e4nkt.", "solution": "false"}, {"text": "Zusammengesetzte Attribute fehlen", "solution": "true"}, {"text": "Es gibt keine Vererbung", "solution": "true"}]}, {"id": 3682, "category": 11, "difficulty": 1, "text": "Bei welchem Problem werden nicht freigegebene \u00c4nderungen (ohne commit) \u00fcberschrieben?", "explanation": "Beim LOST UPDATE Problem handelt es sich um das \u00dcberschreiben von ge\u00e4nderten Daten. Bei allen anderen Problemen werden nicht freigegebene \u00c4nderungen in unterschiedlicher Weise verwendet.", "type": "multiple-choice", "answers": [{"text": "PHANTOM", "solution": "false"}, {"text": "LOST UPDATE", "solution": "true"}, {"text": "DIRTY READ", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 3640, "category": 5, "difficulty": 1, "text": "Welche Beziehungstypen sieht das EERM (Erweitertes Entity-Relationship-Modell) vor?", "explanation": "Das ist die Definition des EERM!\n\n    Ein ER-Modell, das zus\u00e4tzlich zu den klassischen Beziehungsarten und Attributen, IS-A-Beziehungen und Aggregation sowie, mehrwertige und zusammengesetzte Attribute vorsieht,  bezeichnen wir als EERM. \n\n    (min-max) Beziehungen mit numerisch exakter Kardinalit\u00e4t, wie z.B. 1-10-Beziehungen,. sind nur in UML vorgesehen.", "type": "multiple-choice", "answers": [{"text": "Alle Beziehungstypen des klassischen ER-Modells k\u00f6nnen verwendet werden.", "solution": "true"}, {"text": "IS-A-Beziehungen", "solution": "true"}, {"text": "(Min-Max)-Beziehungen, bei denen die Kardinalit\u00e4t numerisch festgelegt werden kann, z.B- 1-10-Beziehungen", "solution": "false"}, {"text": "Aggregationen", "solution": "true"}]}, {"id": 3518, "category": 10, "difficulty": 2, "text": "In welchen Triggern sind die Transitionsvariablen :OLD gef\u00fcllt?", "explanation": ":OLD-Transitionsvariablen sind nur in ROW-Triggern f\u00fcr DELETE und UPDATE gef\u00fcllt und unabh\u00e4ngig von AFTER und BEFORE, ebenso wie in INSTEAD-OF-Trigger f\u00fcr diese Ereignisse.", "type": "multiple-choice", "answers": [{"text": "BEFORE UPDATE STATEMENT", "solution": "false"}, {"text": "AFTER INSERT ROW", "solution": "false"}, {"text": "INSTEAD OF UPDATE-Trigger", "solution": "true"}, {"text": "AFTER DELETE ROW", "solution": "true"}, {"text": "BEFORE UPDATE ROW", "solution": "true"}]}, {"id": 3522, "category": 9, "difficulty": 1, "text": "Welche Aussagen zu MySQL sind richtig?", "explanation": "W\u00e4hrend ORACLE den Markt im Enterprise-Segment anf\u00fchrt, f\u00fchrt MySQL im Web. MySQL ist eine etablierte und kostenfreie Alternative f\u00fcr \u201ekleinere\u201c Datenbankanwendungen. MySQL ist einfach zu installieren und zu administrieren. MySQL geh\u00f6rt seit dem Verkauf von SUN Microsystems auch zum Unternehmen ORACLE, ist aber weiterhin OpenSource.", "type": "multiple-choice", "answers": [{"text": "MySQL ist einfach zu installieren und zu administrieren.", "solution": "true"}, {"text": "MySQL ist eine etablierte und kostenfreie Alternative f\u00fcr \u201ekleinere\u201c Datenbankanwendungen.", "solution": "true"}, {"text": "MySQL f\u00fchrt den Markt im Enterprise-Segment an.", "solution": "false"}]}, {"id": 3524, "category": 9, "difficulty": 1, "text": "Welche Aussagen zu PHP sind richtig?", "explanation": "PHP ist eine weit verbreitete Scriptsprache bei gut 80% aller Websites und seit vielen Jahren im Web etabliert. PHP ist einfach zu erlernen, aber dennoch sehr m\u00e4chtig und performant. PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL m\u00f6glich macht. PHP hat sich zu einem Quasi-Standard f\u00fcr Server-seitige Programmiersprachen von Webanwendungen entwickelt.\n\n    \n\n    Erfunden wurde sie 1994 von Rasmus Lerdorf (urspr\u00fcnglich: Personal Home Page) und besteht aus einfachen Textdateien mit .php\u2013Endung. Mittlerweilse steht das Akronym PFP: Hypertext Preprocessor. Die Ausgabe erfolgt vielfach im HTML-Format.  \n\n    \n\n    Seit PHP Version 5 ist objektorientiertesProgrammieren m\u00f6glich. Somit ist eine Klassifizierung von Objekten der reelenWelt auf einen bestimmten Kontext umsetzbar.\n\n    \u2013Vereinfacht: Funktionen/Methoden k\u00f6nnen in Klassen zusammengefasst werden, um unendlich viele Objekte (mit verschiedenen Auspr\u00e4gungen) instanzierenzu k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "PHP ist eine weit verbreitete Datenbankprogrammiersprache f\u00fcr gespeicherte Routinen.", "solution": "false"}, {"text": "PHP ist einfach zu erlernen, aber dennoch sehr m\u00e4chtig und performant.", "solution": "true"}, {"text": "MySQL bringt Methoden mit, die eine schnelle Implementierung mit php m\u00f6glich macht.", "solution": "false"}, {"text": "Es wird mindestens die Verwendung von Version 5.3 empfohlen.", "solution": "true"}, {"text": "PHP erzeugt als Ausgabe i.d.R. HTML-Dateien.", "solution": "true"}, {"text": "PHP ist bislang immer noch eine rein prozedurale Programmiersprache.", "solution": "false"}]}, {"id": 3525, "category": 9, "difficulty": 1, "text": "Welche Aussagen zu PHP sind richtig?", "explanation": "PHP ist eine weit verbreitete Scriptsprache bei gut 80% aller Websites und seit vielen Jahren im Web etabliert. PHP ist einfach zu erlernen, aber dennoch sehr m\u00e4chtig und performant. PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL m\u00f6glich macht. PHP hat sich zu einem Quasi-Standard f\u00fcr Server-seitige Programmiersprachen von Webanwendungen entwickelt.\n\n    \n\n    Erfunden wurde sie 1994 von Rasmus Lerdorf (urspr\u00fcnglich: Personal Home Page) und besteht aus einfachen Textdateien mit .php\u2013Endung. Mittlerweilse steht das Akronym PFP: Hypertext Preprocessor. Die Ausgabe erfolgt vielfach im HTML-Format.  \n\n    \n\n    Seit PHP Version 5 ist objektorientiertesProgrammieren m\u00f6glich. Somit ist eine Klassifizierung von Objekten der reelenWelt auf einen bestimmten Kontext umsetzbar.  Vereinfacht: Funktionen/Methoden k\u00f6nnen in Klassen zusammengefasst werden, um unendlich viele Objekte (mit verschiedenen Auspr\u00e4gungen) instanzierenzu k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "Seit PHP Version 5 ist objektorientiertesProgrammieren m\u00f6glich.", "solution": "true"}, {"text": "PHP unterst\u00fctzt als Ausgabeformat leider kein HTML.", "solution": "false"}, {"text": "Die Idee und erste Realisierung stammt von Rasmus Lerdorf und bereits aus dem Jahr 1994.", "solution": "true"}, {"text": "PHP ist eine weit verbreitete Script-Sprache mit mehr als 80% bei Web-Anwendungen.", "solution": "true"}, {"text": "Es sind einfache Textdateien mit .phx-Endung.", "solution": "false"}, {"text": "PHP ist ein Quasi-Standard f\u00fcr Client-seitige Programmiersprachen von Webanwendungen.", "solution": "false"}]}, {"id": 3520, "category": 10, "difficulty": 1, "text": "INSTEAD OF-Trigger sind definierbar als", "explanation": "INSTEAD OF-Trigger sind nur als ROW-Trigger definierbar.", "type": "multiple-choice", "answers": [{"text": "beides", "solution": "false"}, {"text": "nur STATEMENT-Trigger", "solution": "false"}, {"text": "nur ROW-Trigger", "solution": "true"}]}, {"id": 3526, "category": 9, "difficulty": 1, "text": "Welche Aussagen zu PHP sind richtig?", "explanation": "PHP ist eine weit verbreitete Scriptsprache bei gut 80% aller Websites und seit vielen Jahren im Web etabliert. PHP ist einfach zu erlernen, aber dennoch sehr m\u00e4chtig und performant. PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL m\u00f6glich macht. PHP hat sich zu einem Quasi-Standard f\u00fcr Server-seitige Programmiersprachen von Webanwendungen entwickelt.\n\n    Erfunden wurde sie 1994 von Rasmus Lerdorf (urspr\u00fcnglich: Personal Home Page) und besteht aus einfachen Textdateien mit .php\u2013Endung. Mittlerweilse steht das Akronym PFP: Hypertext Preprocessor. Die Ausgabe erfolgt vielfach im HTML-Format.  \n\n    \n\n    Seit PHP Version 5 ist objektorientiertesProgrammieren m\u00f6glich. Somit ist eine Klassifizierung von Objekten der reelen Welt auf einen bestimmten Kontext umsetzbar.  Vereinfacht: Funktionen/Methoden k\u00f6nnen in Klassen zusammengefasst werden, um unendlich viele Objekte (mit verschiedenen Auspr\u00e4gungen) instanzierenzu k\u00f6nnen.", "type": "multiple-choice", "answers": [{"text": "PHP ist eine junge Sprache, die Rasmus Lerdorf und erst im Jahr 2010.", "solution": "false"}, {"text": "Es wird empfohlen f\u00fcr die Verwendung noch auf Version 1.0 zu warten.", "solution": "false"}, {"text": "PHP erzeugt als Ausgabe i.d.R. HTML-Dateien.", "solution": "true"}, {"text": "Es sind einfache Textdateien mit .php-Endung.", "solution": "true"}]}, {"id": 3545, "category": 9, "difficulty": 1, "text": "Bei welchen SQL-Lesezugriffen ist das Sortieren immer notwendig?", "explanation": "Au\u00dfer bei Unterabfragen muss immer sortiert werden, um Duplikate zu erkennen.Das kostet Zeit!", "type": "multiple-choice", "answers": [{"text": "SELECT mit Unterabfrage", "solution": "false"}, {"text": "SELECT mit GROUP BY", "solution": "true"}, {"text": "SELECT mit ORDER BY", "solution": "true"}, {"text": "SELECT mit DISTINCT", "solution": "true"}]}, {"id": 3589, "category": 9, "difficulty": 1, "text": "Mit welchen Konzepten k\u00f6nnen bei Oracle ab Version 12c Werte f\u00fcr k\u00fcnstliche Prim\u00e4rschl\u00fcssel generiert werden?", "explanation": "Neben den altbekanten Sequenzen ist bei Oracle 12c die Identity Column hinzu gekommen., siehe z.B.<a href=\"http://www.oracle.com/technetwork/database/database-technologies/rdb/0307-identity-columns-128126.pdf\">http://www.oracle.com/technetwork/database/database-technologies/rdb/0307-identity-columns-128126.pdf", "type": "multiple-choice", "answers": [{"text": "Sequenz", "solution": "true"}, {"text": "Identity Column", "solution": "true"}, {"text": "keine von beiden", "solution": "false"}]}, {"id": 3519, "category": 10, "difficulty": 2, "text": "In welchen Triggern sind die Transitionsvariablen :NEW gef\u00fcllt?", "explanation": ":NEW-Transitionsvariablen sind nur in ROW-Triggern f\u00fcr INSERT und UPDATE gef\u00fcllt und unabh\u00e4ngig von AFTER und BEFORE, ebenso wie in INSTEAD-OF-Triggern f\u00fcr diese Ereignisse.", "type": "multiple-choice", "answers": [{"text": "BEFORE UPDATE FOR EACH STATEMENT", "solution": "false"}, {"text": "AFTER INSERT ROW", "solution": "true"}, {"text": "INSTEAD-OF-Trigger", "solution": "true"}, {"text": "AFTER DELETE ROW", "solution": "false"}, {"text": "BEFORE UPDATE ROW", "solution": "true"}]}, {"id": 3536, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft die Methode, mit der mittels MySQLi eine SQL-Anfrage von PHP zu MySQL geschickt werden kann?", "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>", "type": "text", "answers": [{"text": "Geben Sie den Funktionsnamen kleingeschrieben und ohne Klammern an.", "solution": "\r\n    mysqli_query\r"}]}, {"id": 3539, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft die Methode, mit der mittels PDO eine SQL-Anfrage von PHP an MySQL geschickt werden kann?", "explanation": "<?php\n\n    function getConnection() {\n\n      $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n      $mysqluser=\"root\"; // MySQL-User angeben\n\n      $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n      $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n      $connection = new PDO(\"mysql:host=$mysqlhost;dbname=$mysqldb\", $mysqluser, $mysqldb); \n\n      $connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n      return $connection;\n\n    }\n\n    ?>\n\n     \n\n    function getApps() {\n\n      $sql = \"select * FROM apps ORDER BY name\";\n\n      try {\n\n      $db = getConnection();\n\n      $stmt = $db->query($sql); \n\n      $data = $stmt->fetchAll(PDO::FETCH_OBJ);\n\n      $db = null;\n\n      return $data;\n\n      } catch(PDOException $e) {\n\n      echo \"{\"error\":{\"text\":\". $e->getApps() .\"}}\";\n\n      }\n\n    }", "type": "text", "answers": [{"text": "Geben Sie den Funktionsnamen ohne Klammern an.", "solution": "\r\n    query\r"}]}, {"id": 3540, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft die Methode, mit der mittels PDO eine Verbindung von PHP zu MySQL aufgebaut werden kann?", "explanation": "<?php\n\n    function getConnection() {\n\n      $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n      $mysqluser=\"root\"; // MySQL-User angeben\n\n      $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n      $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n      $connection = new PDO(\"mysql:host=$mysqlhost;dbname=$mysqldb\", $mysqluser, $mysqldb); \n\n      $connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n      return $connection;\n\n    }\n\n    ?>\n\n     \n\n    function getApps() {\n\n      $sql = \"select * FROM apps ORDER BY name\";\n\n      try {\n\n      $db = getConnection();\n\n      $stmt = $db->query($sql); \n\n      $data = $stmt->fetchAll(PDO::FETCH_OBJ);\n\n      $db = null;\n\n      return $data;\n\n      } catch(PDOException $e) {\n\n      echo \"{\"error\":{\"text\":\". $e->getApps() .\"}}\";\n\n      }\n\n    }", "type": "text", "answers": [{"text": "Geben Sie den Funktionsnamen ohne Klammern an.", "solution": "\r\n    PDO\r"}]}, {"id": 3527, "category": 9, "difficulty": 2, "text": "Ordnen Sie die nachfolgenden Schritte in die richtige Ausf\u00fchrungsreihenfolge (1-6):", "explanation": "1. Der Client schickt eine Anfrage f\u00fcr die Ausf\u00fchrung einer .php-Datei \u00fcber das Internet an den Webserver.  \n\n    2. Der Webserver l\u00e4d die .php-Datei von der Festplatte.\n\n    3. Der Webserver \u00fcbergibt die .php-Datei an den PHP-Interpreter.  \n\n    4. Je nach php-Skript erzeugt der PHP-Interpreter eine Ausgabedatei des programmierten Formats, z.B. HTML, PDF, etc.\n\n    5. Der erzeugte Code wird an dem Webserver gegeben.\n\n    6. Der Webserver sendet den erzeugten Code an den Client.", "type": "text", "answers": [{"text": "Der Webserver \u00fcbergibt die .php-Datei an den PHP-Interpreter.", "solution": "\r\n    3\r"}, {"text": "Der Client schickt eine Anfrage f\u00fcr die Ausf\u00fchrung einer .php-Datei \u00fcber das Internet an den Webserver.", "solution": "\r\n    1\r"}, {"text": "Der Webserver sendet den erzeugten Code an den Client.", "solution": "\r\n    6\r"}, {"text": "Der erzeugte Code wird an dem Webserver gegeben.", "solution": "\r\n    5\r"}, {"text": "Der Webserver l\u00e4d die .php-Datei von der Festplatte.", "solution": "\r\n    2\r"}, {"text": "Je nach php-Skript erzeugt der PHP-Interpreter eine Ausgabedatei des programmierten Formats, z.B. HTML, PDF, etc.", "solution": "\r\n    4\r"}]}, {"id": 3528, "category": 9, "difficulty": 2, "text": "Ordnen Sie die nachfolgenden Schritte in die richtige Ausf\u00fchrungsreihenfolge (1-6):", "explanation": "1. Der Client schickt eine Anfrage f\u00fcr die Ausf\u00fchrung einer .php-Datei \u00fcber das Internet an den Webserver.  \n\n    2. Der Webserver l\u00e4d die .php-Datei von der Festplatte.\n\n    3. Der Webserver \u00fcbergibt die .php-Datei an den PHP-Interpreter.  \n\n    4. Je nach php-Skript erzeugt der PHP-Interpreter eine Ausgabedatei des programmierten Formats, z.B. HTML, PDF, etc.\n\n    5. Der erzeugte Code wird an dem Webserver gegeben.\n\n    6. Der Webserver sendet den erzeugten Code an den Client.", "type": "text", "answers": [{"text": "Der Webserver \u00fcbergibt die .php-Datei an den PHP-Interpreter.", "solution": "\r\n    3\r"}, {"text": "Der Client schickt eine Anfrage f\u00fcr die Ausf\u00fchrung einer .php-Datei \u00fcber das Internet an den Webserver.", "solution": "\r\n    1\r"}, {"text": "Der Webserver sendet den erzeugten Code an den Client.", "solution": "\r\n    6\r"}, {"text": "Der erzeugte Code wird an dem Webserver gegeben.", "solution": "\r\n    5\r"}, {"text": "Der Webserver l\u00e4d die .php-Datei von der Festplatte.", "solution": "\r\n    2\r"}, {"text": "Je nach php-Skript erzeugt der PHP-Interpreter eine Ausgabedatei des programmierten Formats, z.B. HTML, PDF, etc.", "solution": "\r\n    4\r"}]}, {"id": 3550, "category": 11, "difficulty": 1, "text": "Welches Problem kann beim Isolationsgrad SERIALIABLE auftreten?", "explanation": "Der Isolationsgrad SERIALIABLE unterbindet jedes der aufgelisteten Probleme.", "type": "multiple-choice", "answers": [{"text": "Keins von allen", "solution": "true"}, {"text": "PHANTOM", "solution": "false"}, {"text": "LOST UPDATE", "solution": "false"}, {"text": "DIRTY READ", "solution": "false"}, {"text": "NON REPEATABLE READ", "solution": "false"}]}, {"id": 3533, "category": 9, "difficulty": 1, "text": "Wie wird die R\u00fcckgabemenge (Datens\u00e4tze) einer php-Anfrage an eine MySQL-DB genannt?", "explanation": "in php: array\n\nin JDBC: result set\n\nin PL/SQL: cursor\n\nRelation werden Tabellen in der DB genannt.", "type": "multiple-choice", "answers": [{"text": "array", "solution": "true"}, {"text": "result set", "solution": "false"}, {"text": "cursor", "solution": "false"}, {"text": "relation", "solution": "false"}]}, {"id": 3548, "category": 8, "difficulty": 1, "text": "Welche Faktoren spielen bei der physischen Optimierung eine Rolle?", "explanation": "Die Anzahl der Relationen spielt f\u00fcr die physische Optimierung keine Rolle.", "type": "multiple-choice", "answers": [{"text": "Kardinalit\u00e4t, d.h. Gr\u00f6\u00dfe der Relationen", "solution": "true"}, {"text": "Selektivit\u00e4t, d.h. Verteilung der Dateien in den Spalten der Relationen", "solution": "true"}, {"text": "Anzahl der Relationen eines Datenbankschemas", "solution": "false"}]}, {"id": 3517, "category": 10, "difficulty": 2, "text": "INSTEAD OF-Trigger sind f\u00fcr welche der folgenden DB-Objekte definierbar", "explanation": "INSTEAD OF-Trigger sind nur f\u00fcr Sichten definiert. Ggf. sind dann Anwendern die DML-Rechte auf die Tabelle mit REVOKE zu entziehen und auf der Sicht mit GRANT einzur\u00e4umen. Trigger sind nie auf andere Trigger definierbar.", "type": "multiple-choice", "answers": [{"text": "Sichten (VIEW)", "solution": "true"}, {"text": "Tabellen (TABLE)", "solution": "false"}, {"text": "STATEMENT-Trigger", "solution": "false"}, {"text": "ROW-Trigger", "solution": "false"}]}, {"id": 3547, "category": 8, "difficulty": 1, "text": "Welche Optimierung ist eine Anwendung der relationalen Algebra?", "explanation": "Die logische Optimierung ber\u00fccksichtigt die Operatoren der relationalen Algebra, die physische Optinierung die Gr\u00f6\u00dfe der Relationen und  Statistiken.", "type": "multiple-choice", "answers": [{"text": "Logische Optimierung", "solution": "true"}, {"text": "Physische Optimierung", "solution": "false"}]}, {"id": 3521, "category": 9, "difficulty": 1, "text": "Welche Aussagen zu MySQL sind richtig?", "explanation": "W\u00e4hrend ORACLE den Markt im Enterprise-Segment anf\u00fchrt, f\u00fchrt MySQL im Web. MySQL ist eine etablierte und kostenfreie Alternative f\u00fcr \u201ekleinere\u201c Datenbankanwendungen. MySQL ist einfach zu installieren und zu administrieren. MySQL geh\u00f6rt seit dem Verkauf von SUN Microsystems auch zum Unternehmen ORACLE, ist aber weiterhin OpenSource.", "type": "multiple-choice", "answers": [{"text": "MySQL f\u00fchrt den Markt im Web-Segment an.", "solution": "true"}, {"text": "MySQL ist einfach zu installieren und zu administrieren.", "solution": "true"}, {"text": "Seid MySQL nun zu Oracle geh\u00f6rt ist die DB auch nur noch kostenpflichtig einsetzbar.", "solution": "false"}]}, {"id": 3532, "category": 9, "difficulty": 2, "text": "Mit welchen Schluesselwoertern wird bei mysqli die Feherbehandlung (error handling) programmiert?", "explanation": "<?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>", "type": "multiple-choice", "answers": [{"text": "on problem(...);", "solution": "false"}, {"text": "or die ( ... );", "solution": "true"}, {"text": "catch (...);", "solution": "false"}, {"text": "on dberror (...);", "solution": "false"}]}, {"id": 3687, "category": 11, "difficulty": 1, "text": "Bei welcher Art von Sperren k\u00f6nnen Deadlocks entstehen?", "explanation": "Siehe http://lwibs01.gm.fh-koeln.de/wikis/wiki_db/index.php?n=Datenbanken.DEADLOCK", "type": "multiple-choice", "answers": [{"text": "keine der anderen", "solution": "false"}, {"text": "Lesesperre", "solution": "false"}, {"text": "Schreibsperre", "solution": "true"}]}, {"id": 3551, "category": 11, "difficulty": 1, "text": "Welche Isolationsgrade unterst\u00fctzt Oracle?", "explanation": "Oracle unterst\u00fctzt nur die Isolationsgrade  SERIALIZABLE und READ COMITTED.", "type": "multiple-choice", "answers": [{"text": "Keins von allen", "solution": "false"}, {"text": "READ UNCOMMITTED", "solution": "false"}, {"text": "READ COMMITTED", "solution": "true"}, {"text": "REPEATABLE READ", "solution": "false"}, {"text": "SERIALIZABLE", "solution": "true"}]}, {"id": 3535, "category": 9, "difficulty": 2, "text": "Die MySQLi-Funktion zum Ausf\u00fchren von SQL-Befehlen \"mysqli_query\" wird mit welchen Parametern aufgerufen?", "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>", "type": "multiple-choice", "answers": [{"text": "<CONNECTION>  / Verbindung", "solution": "true"}, {"text": "<USER>  /  Benutzer", "solution": "false"}, {"text": "<DATABASE>  /  Datenbankname", "solution": "false"}, {"text": "<RELATION>  / Tabellenname", "solution": "false"}, {"text": "<QUERY>  / Anfrage", "solution": "true"}, {"text": "<HOST> / MySQL-Datenbankserver", "solution": "false"}, {"text": "/ Passwort", "solution": "false"}]}, {"id": 3546, "category": 9, "difficulty": 1, "text": "Bei welcher Join-Variante wird jedes Element mit jedem verglichen?", "explanation": "\n    Das ist die Definition des Nested Loop Joins!", "type": "multiple-choice", "answers": [{"text": "Merge Join", "solution": "false"}, {"text": "Hash Join", "solution": "false"}, {"text": "Nested Loop Join", "solution": "true"}]}, {"id": 3549, "category": 11, "difficulty": 1, "text": "Bei welchem Problem werden nicht freigegebene \u00c4nderungen (ohne commit) gelesen?", "explanation": "Beim  LOST UPDATE Problem handelt es sich um das \u00dcberschreiben von ge\u00e4nderten Daten. Bei allen anderen Problemen werden nicht freigegebene \u00c4nderungen in unterschiedlicher Weise verwendet.", "type": "multiple-choice", "answers": [{"text": "PHANTOM", "solution": "true"}, {"text": "LOST UPDATE", "solution": "false"}, {"text": "DIRTY READ", "solution": "true"}, {"text": "NON REPEATABLE READ", "solution": "true"}]}, {"id": 3530, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft die Methode, mit der mittels MySQLi eine Verbindung von PHP zu MySQL aufgebaut werden kann?", "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>", "type": "text", "answers": [{"text": "Geben Sie den Funktionsnamen kleingeschrieben und ohne Klammern an.", "solution": "\r\n    mysqli_connect\r"}]}, {"id": 3531, "category": 9, "difficulty": 3, "text": "Wie hei\u00dft die Methode und deren Parameter, mit der mittels MySQLi eine Verbindung von PHP zu MySQL aufgebaut werden kann?", "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>", "type": "text", "answers": [{"text": "Geben Sie den Funktionsnamen kleingeschrieben an. Die Parameter gro\u00dfgeschrieben in spitzen Klammern, alles ohne trennende Leerzeichen und abschlie\u00dfendem Semikolon", "solution": "\r\n    mysqli_connect(<HOST>,<USER>,,<DATABASE>)\r"}]}, {"id": 3534, "category": 9, "difficulty": 2, "text": "Die MySQLi-Funktion zum Verbindungsaufbau \"mysqli_connect\" wird mit welchen Parametern aufgerufen?", "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>", "type": "multiple-choice", "answers": [{"text": "<USER>  /  Benutzer", "solution": "true"}, {"text": "<DATABASE>  /  Datenbankname", "solution": "true"}, {"text": "<RELATION>  / Tabellenname", "solution": "false"}, {"text": "<QUERY>  / Anfrage", "solution": "false"}, {"text": "<HOST> / MySQL-Datenbankserver", "solution": "true"}, {"text": "/ Passwort", "solution": "true"}, {"text": "<CONNECTION>  / Verbindung", "solution": "false"}]}, {"id": 3768, "category": 7, "difficulty": 1, "text": "Gegeben sei eine Relation R(V, W, X, Y) mit funktionalen Abh\u00e4ngigkeiten V, Y -> W, X und W -> X.  Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 2NF?", "explanation": "V und Y sind schon der Prim\u00e4rschl\u00fcssel der Relation, da alle anderen Attribute von ihnen abh\u00e4ngen, und W -> X ist eine transitionale FD, womit sich ergibt, dass 1. NF = 2. NF.", "type": "multiple-choice", "answers": [{"text": "R={V,W,X,Y}", "solution": "true"}, {"text": "R1(V, Y) und R2(W,X)", "solution": "false"}, {"text": "R1(V, W,Y) und R2(W,X)", "solution": "false"}]}, {"id": 3537, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft die Methode, mit der mittels MySQLi eine Ergebnismenge mit Datens\u00e4tzen aus MySQL in PHP verarbeitet werden kann?", "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>", "type": "text", "answers": [{"text": "Geben Sie den Funktionsnamen kleingeschrieben und ohne Klammern an.", "solution": "\r\n    mysqli_fetch_array\r"}]}, {"id": 3538, "category": 9, "difficulty": 1, "text": "Wie hei\u00dft die Methode, mit der mittels PDO eine Ergebnismenge mit Datens\u00e4tzen aus MySQL in PHP verarbeitet werden kann?", "explanation": "<?php\n\n    function getConnection() {\n\n      $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n      $mysqluser=\"root\"; // MySQL-User angeben\n\n      $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n      $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n      $connection = new PDO(\"mysql:host=$mysqlhost;dbname=$mysqldb\", $mysqluser, $mysqldb); \n\n      $connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n      return $connection;\n\n    }\n\n    ?>\n\n     \n\n    function getApps() {\n\n      $sql = \"select * FROM apps ORDER BY name\";\n\n      try {\n\n      $db = getConnection();\n\n      $stmt = $db->query($sql); \n\n      $data = $stmt->fetchAll(PDO::FETCH_OBJ);\n\n      $db = null;\n\n      return $data;\n\n      } catch(PDOException $e) {\n\n      echo \"{\"error\":{\"text\":\". $e->getApps() .\"}}\";\n\n      }\n\n    }", "type": "text", "answers": [{"text": "Geben Sie den Funktionsnamen ohne Klammern an.", "solution": "\r\n    fetchAll\r"}]}, {"id": 3541, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber MySQL-Prozeduren und Trigger sind wahr?", "explanation": "<div style=\"margin-left:.38in;\">\n    MySQL 5.1 kennt auch gespeicherte Routinen (Prozeduren und Funktionen).\n<div style=\"margin-left:.38in;\">\n    MySQL verwendet die Syntax f\u00fcr gespeicherte Routinen gem\u00e4\u00df dem SQL:2003-Standard. Zwischen der prozeduralen Sprache in MySQL und PL/SQL von Oracle gibt es viele Analogiien, aber doch auch so einige Unterschiede.\n<div style=\"margin-left:.38in;\">\n    Wie bei ORACLE gibt es auch bei MySQL das Cursorkonzept, sogar die Syntax ist diesbez\u00fcglich weitestgehend gleich.\n<div style=\"margin-left:.38in;\">\n    Auch Trigger gibt es in MySQL. Nur das in MySQL die Trigger ausschlie\u00dflich f\u00fcr ein Ereignis definiert werden k\u00f6nnen, eine OR-Option bei den Events gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "Wie bei ORACLE gibt es auch bei MySQL das Cursorkonzept, sogar die Syntax ist diesbez\u00fcglich weitestgehend gleich.", "solution": "true"}, {"text": "MySQL-Trigger k\u00f6nnen nur f\u00fcr ein Ereignis definiert werden (keine OR-Option wie bei Oracle).", "solution": "true"}, {"text": "In MySQL k\u00f6nnen auch Trigger, Prozeduren und Funktionen als Datenbankobjekte programmiert werden.", "solution": "true"}, {"text": "Das Trigger-Konzept ist v\u00f6llig analog zwischen MySQL und Oracle.", "solution": "false"}]}, {"id": 3542, "category": 9, "difficulty": 1, "text": "Welche Aussagen \u00fcber MySQL-Prozeduren und Trigger sind wahr?", "explanation": "<div style=\"margin-left:.38in;\">\n    MySQL 5.1 kennt auch gespeicherte Routinen (Prozeduren und Funktionen).\n<div style=\"margin-left:.38in;\">\n    MySQL verwendet die Syntax f\u00fcr gespeicherte Routinen gem\u00e4\u00df dem SQL:2003-Standard. Zwischen der prozeduralen Sprache in MySQL und PL/SQL von Oracle gibt es viele Analogiien, aber doch auch so einige Unterschiede.\n<div style=\"margin-left:.38in;\">\n    Wie bei ORACLE gibt es auch bei MySQL das Cursorkonzept, sogar die Syntax ist diesbez\u00fcglich weitestgehend gleich.\n<div style=\"margin-left:.38in;\">\n    Auch Trigger gibt es in MySQL. Nur das in MySQL die Trigger ausschlie\u00dflich f\u00fcr ein Ereignis definiert werden k\u00f6nnen, eine OR-Option bei den Events gibt es nicht.", "type": "multiple-choice", "answers": [{"text": "Wie bei ORACLE gibt es auch bei MySQL das Cursorkonzept, sogar die Syntax ist diesbez\u00fcglich weitestgehend gleich.", "solution": "true"}, {"text": "Die prozedurale Datenbankprogrammiersprache von MySQL weist trotz aller \u00c4hnlichkeiten doch auch so einige Unterschiede auf.", "solution": "true"}, {"text": "In MySQL k\u00f6nnen auch Trigger, Prozeduren und Funktionen und Packages als Datenbankobjekte programmiert werden.", "solution": "false"}, {"text": "MySQL-Trigger k\u00f6nnen f\u00fcr mehrere Ereignisse definiert werden (OR-Option wie bei Oracle).", "solution": "false"}]}, {"id": 3543, "category": 9, "difficulty": 2, "text": "Nummerieren Sie die nachfolgenden Befehle einer Cursor-Verarbeitung in MySQL gem\u00e4\u00df ihrer Ausf\u00fchrungsreihenfolge von 1 - 4 durch.", "explanation": "CREATE PROCEDURE KundenUpgrade()\n\n    BEGIN\n\n        DECLARE val INT;\n\n        DECLARE finished INT DEFAULT 0;\n\n        DECLARE kundenCursor CURSOR FOR SELECT kunde_id FROM kunden; -- Cursordefinition\n\n        DECLARE CONTINUE HANDLER FOR SQLSTATE \"02000\" SET finished = 1;\n\n        OPEN kundenCursor; -- Cursor \u00f6ffnen\n\n            REPEAT\n\n               FETCH kundenCursor INTO val;\n\n               IF NOT finished THEN\n\n                   CALL KundenStatusByID(val); -- Ruft f\u00fcr jeden Kunden die Proz. auf\n\n      END IF;\n\n            UNTIL finished END REPEAT;   \n\n            CLOSE kundenCursor; -- Cursor schlie\u00dfen\n\n    END //\n\n    DELIMITER ;", "type": "text", "answers": [{"text": "CLOSE cursorname;", "solution": "\r\n    4\r"}, {"text": "DECLARE cursorname  CURSOR FOR SELECT ...  ;", "solution": "\r\n    1\r"}, {"text": "OPEN cursorname;", "solution": "\r\n    2\r"}, {"text": "FETCH cursorname INTO variable;", "solution": "\r\n    3\r"}]}, {"id": 3544, "category": 1, "difficulty": 1, "text": "Welcher Schnittstelle der 5-Schichten-Architektur eines DBMS werden SQL-Befehle \u00fcbergeben?", "explanation": "Das ist die Definition der mengenorientierten Schnittstelle.", "type": "multiple-choice", "answers": [{"text": "Interne Satzschnittstelle", "solution": "false"}, {"text": "Systempufferschnittstelle", "solution": "false"}, {"text": "Ger\u00e4teschnittstelle", "solution": "false"}, {"text": "Dateischnittstelle", "solution": "false"}, {"text": "Mengenorientierte Schnittstelle", "solution": "true"}, {"text": "Satzorientierte Schnittstelle", "solution": "false"}]}, {"id": 3569, "category": 9, "difficulty": 1, "text": "Ein ge\u00f6ffneter CURSOR l\u00f6st eine EXCEPTION aus, wenn eine FETCH-Anweisung keine Zeilen liefert.", "explanation": "Es wird nur die CURSOR%NOTFOUND Variable gesetzt. Eine Exception w\u00fcrde ja bedeuten, dass die Programmausf\u00fchrung abbricht und in die Exception springt", "type": "multiple-choice", "answers": [{"text": "stimmt nicht", "solution": "true"}, {"text": "stimmt", "solution": "false"}]}, {"id": 3645, "category": 5, "difficulty": 1, "text": "Was versteht man unter Spezialisierung im EERM?", "explanation": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.\n\n\n    Die abgeleiteten Typen haben dann neben den vom Supertyp ererbten Attributen eigene Attribute, die nur den Subtyp beschreiben.\n\n\n \n\nUnter Generalisierung versteht man den Prozess der Gewinnung eines Supertyps aus mehreren \u00e4hnlichen Subtypen.\n\n\n    Der neue Supertyp wird dann durch diejenigen Attribute beschrieben, die den \u00e4hnlichen Subtypen gemeinsam sind.", "type": "multiple-choice", "answers": [{"text": "Das ist der Prozess der Gewinnung eines Supertyps aus mehreren \u00e4hnlichen Subtypen.", "solution": "false"}, {"text": "Keine von beiden Antworten ist korrekt.", "solution": "false"}, {"text": "Das ist der Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.", "solution": "true"}]}, {"id": 3646, "category": 5, "difficulty": 1, "text": "Was versteht man unter Generalisierung im EERM?", "explanation": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.\n\n    \u2013Die abgeleiteten Typen haben dann neben den vom Supertyp ererbten Attributen eigene Attribute, die nur den Subtyp beschreiben.\n\n     \n\n    Unter Generalisierung versteht man den Prozess der Gewinnung eines Supertyps aus mehreren \u00e4hnlichen Subtypen.\n\n    \u2013Der neue Supertyp wird dann durch diejenigen Attribute beschrieben, die den \u00e4hnlichen Subtypen gemeinsam sind.", "type": "multiple-choice", "answers": [{"text": "Das ist der Prozess der Gewinnung eines Supertyps aus mehreren \u00e4hnlichen Subtypen.", "solution": "true"}, {"text": "Keine von beiden Antworten ist korrekt.", "solution": "false"}, {"text": "Das ist der Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.", "solution": "false"}]}, {"id": 3688, "category": 9, "difficulty": 1, "text": "Betrachten Sie eine Tabelle test (Nr number primary key, Beschreibung varchar(100)), die 100.000 Datensatze beinhaltet. Welche Abfrage ist schneller?", "explanation": "Durch den Primary Key wird ein Index angelegt, der durch die like-Abfrage nicht genutzt werden kann.", "type": "multiple-choice", "answers": [{"text": "SELECT * from Test where nr = 4711;", "solution": "true"}, {"text": "SELECT * from TEST where nr like \"4711%\";", "solution": "false"}]}, {"id": 3769, "category": 7, "difficulty": 1, "text": "Gegeben sei eine Relation R(V, W, X, Y) mit funktionalen Abh\u00e4ngigkeiten V, Y -> W, X und\n\nW -> X.   Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 3NF?", "explanation": "V und Y sind schon der Prim\u00e4rschl\u00fcssel der Relation, da alle anderen Attribute von ihnen abh\u00e4ngen. Au\u00dferdem gibt es eine transitive Abh\u00e4ngikeit W -> X.", "type": "multiple-choice", "answers": [{"text": "R={V,W,X,Y}", "solution": "false"}, {"text": "R12(V, Y) und R2(W,X)", "solution": "false"}, {"text": "R12(V, W,Y) und R2(W,X)", "solution": "true"}]}, {"id": 3758, "category": 7, "difficulty": 1, "text": "Es sei eine Relation R(X, Y, Z) gegeben mit einem zusammengesetzten Prim\u00e4rschl\u00fcssel auf X, Y und einem eindeutigen Zweitschl\u00fcssel auf Z sowie einem gespeicherten Datensatz : (2, \"a\", 9).\n\nWelche weiteren Datens\u00e4tze lassen sich zu diesem hinzuf\u00fcgen?", "explanation": "Bitte beachten Sie die Eindeutigkeit des Prim\u00e4rschl\u00fcssels und des Zweitschl\u00fcssels! (Unique Key)", "type": "multiple-choice", "answers": [{"text": "(5, \"d\", 3)", "solution": "true"}, {"text": "(2, \"a\", 5)", "solution": "false"}, {"text": "(2, \"a\", 9)", "solution": "false"}, {"text": "(2, \"s\", 4)", "solution": "true"}, {"text": "(9, \"a\", 2)", "solution": "true"}, {"text": "(4, \"s\", 9)", "solution": "false"}]}, {"id": 3770, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine Relation R(X, Y, Z, V, W, T) mit den funktionalen Abh\u00e4ngigkeiten\n\nX, V -> Z   und   Z, Y-> W   und   Y -> V, T.    Welche Attributkombination ist ein (minimaler) eindeutiger Schl\u00fcssel?\n\nBitte die Attribute in alphabetischer Reihenfolge durch Kommas getrennt und ohne Klammern aufschreiben!", "explanation": "Alle anderen Attribute lassen sich von X und Y ableiten!", "type": "text", "answers": [{"text": "Das sind die Attribute:", "solution": "X , Y\r"}]}, {"id": 3773, "category": 7, "difficulty": 2, "text": "Gegeben sei eine Relation R(V, W, X, Y, Z) mit funktionalen Abh\u00e4ngigkeiten V -> W und Y -> X und\n\nV, Y -> Z.   Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 3NF?", "explanation": "V und Y sind schon der Prim\u00e4rschl\u00fcssel der Relation, da alle anderen Attribute von ihnen abh\u00e4ngen und die ersten zwei FDs sind partielle bzw. die letzte eine volle Abh\u00e4ngikeit vom zusammengestzten Prim\u00e4rschl\u00fcssel. Da transitive Abh\u00e4ngigkeiten fehlen, gilt hier 2.NF = 3.NF.", "type": "multiple-choice", "answers": [{"text": "R={V,W,X,Y, Z}", "solution": "false"}, {"text": "R1(V, W),   R2(Y,X),   R3(V,Y,Z)", "solution": "true"}, {"text": "R1(V,Y,Z) und R2(V,W,Y,X)", "solution": "false"}]}, {"id": 3778, "category": 5, "difficulty": 1, "text": "Bei welcher/n Entity-Mengen sind bei m:n-Beziehungen die Fremdschl\u00fcssel einzutragen?", "explanation": "Bei einer m:n-Beziehung werden dei Fremdschl\u00fcssel sp\u00e4ter in einer Zwischentabelle ausgelagert.", "type": "multiple-choice", "answers": [{"text": "Nur m-Ende", "solution": "false"}, {"text": "nur n-Ende", "solution": "false"}, {"text": "Beide Enden", "solution": "false"}, {"text": "Keine Fremdschl\u00fcssel  in den Entity-Mengen", "solution": "true"}]}, {"id": 3779, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abh\u00e4ngigkeiten:  A-> B, C, E     C -> E  und   D -> F  \n\nWelche Attributkombination ist ein (minimaler) eindeutiger Schl\u00fcssel?", "explanation": "Von A h\u00e4ngen alle Attribute au\u00dfer F ab. Daher braucht man neben A noch D f\u00fcr den Prim\u00e4rschl\u00fcssel.", "type": "text", "answers": [{"text": "Der Prim\u00e4rschl\u00fcssel ist:", "solution": "AD\r"}]}, {"id": 3780, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abh\u00e4ngigkeiten (FD):  A-> B, C, E     C -> E  und   D -> F , sowie dem Prim\u00e4raschl\u00fcssel AD.  Welche davon sind bezogen auf den gefundenen Prim\u00e4rschl\u00fcssel transitive FDs?", "explanation": "C geh\u00f6rt nicht zum Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Es gibt keine", "solution": "false"}, {"text": "A -> B, C, E", "solution": "false"}, {"text": "C -> E", "solution": "true"}, {"text": "D-> F", "solution": "false"}]}, {"id": 3781, "category": 7, "difficulty": 1, "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abh\u00e4ngigkeiten (FD):  A-> B, C, E     C -> E  und   D -> F , sowie dem Prim\u00e4raschl\u00fcssel AD.  Welche davon sind bezogen auf den gefundenen Prim\u00e4rschl\u00fcssel partielle FDs?", "explanation": "A und D geh\u00f6ren zum Prim\u00e4rschl\u00fcssel.", "type": "multiple-choice", "answers": [{"text": "Es gibt keine", "solution": "false"}, {"text": "A -> B, C, E", "solution": "true"}, {"text": "C -> E", "solution": "false"}, {"text": "D-> F", "solution": "false"}]}, {"id": 3774, "category": 7, "difficulty": 2, "text": "Gegeben sei eine Relation R(V, W, X, Y, Z) mit funktionalen Abh\u00e4ngigkeiten V -> W und Y -> X und\n\nV, Y -> Z.   Welche Zerlegung entspricht einer verlustfreien und abh\u00e4ngigkeitstreuen Zerlegung in die 2NF?", "explanation": "V und Y sind schon der Prim\u00e4rschl\u00fcssel der Relation, da alle anderen Attribute von ihnen abh\u00e4ngen und die ersten zwei FDs sind partielle bzw. die letzte eine volle Abh\u00e4ngikeit vom zusammengesetztn Prim\u00e4rschl\u00fcssel. Da transitive Abh\u00e4ngigkeiten fehlen, gilt hier 2.NF = 3.NF.", "type": "multiple-choice", "answers": [{"text": "R={V,W,X,Y, Z}", "solution": "false"}, {"text": "R1(V, W),   R2(Y,X),   R3(V,Y,Z)", "solution": "true"}, {"text": "R1(V,Y,Z) und R2(V,W,Y,X)", "solution": "false"}]}]