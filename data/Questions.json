[
  {
    "id": 1930,
    "category": 6,
    "difficulty": 2,
    "text": "Jeder Column-Constraint (Spaltenbedingung) kann auch als Table-Constraint (Tabellenbedingung) geschrieben werden.",
    "explanation": "Ein Column-Constraint unterscheidet sich von einem Table-Constraint durch die Stellung im SQL-Befehl: \nDer Columns-Constraint wird durch ein Komma von der Spaltendefinition abgetrennt und kann sich nur auf einen Spalte beziehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1931,
    "category": 10,
    "difficulty": 3,
    "text": "Mit welchem Isolationsgrad (Konstante der Methode setTransactionIsolation des Interfaces connection in JDBC) werden bei lesenden Transaktionen keine Sperren ausgelöst?",
    "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgeführt.",
    "type": "text",
    "answers": [
      {
        "text": "Der Isolationsgrad heißt",
        "solution": "TRANSACTION_READ_UNCOMMITED"
      }
    ]
  },
  {
    "id": 1932,
    "category": 12,
    "difficulty": 1,
    "text": "Tabellenname%ROWTYPE definiert in PL/SQL einen RECORD.",
    "explanation": "Mit Tabellenname%ROWTYPE wird die Attributstruktur einer Tabelle komplett an einen PL/SQL-Rekord übertragen und dynamisch angepasst. wenn sich dien Tabellendefinition ändert. Mit Tabellenname.Spaltenname%TYPE kann man eine Variable entsprechend der Spalte einer Tabelle definieren.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1960,
    "category": 7,
    "difficulty": 2,
    "text": "Wenn zwei Relationen R und S in SQL mit einem Natural Join verbunden werden, dann",
    "explanation": "Ein Natural Join verknüpft nach Definition alle Tupel von zwei Tabellen über gleichnamige Attribute.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "muss Relation R mehr Tupel als Relation S beinhalten",
        "solution": "false"
      },
      {
        "text": "ermittelt man alle Tupel aus R und S, die übereinstimmen",
        "solution": "false"
      },
      {
        "text": "sollten die Relationen R und S mindestens ein gleich bezeichnetes Attribut haben.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1961,
    "category": 10,
    "difficulty": 2,
    "text": "Für die JDBC-Klasse Connection gilt:",
    "explanation": "Ein JAVA-Programm kann eine oder mehrere Verbindungen zu einer oder mehreren Datenbanken unterhalten. \nJede Verbindung wird durch ein Objekt realisiert, das das Interface Connection implementiert. \nDieses Interface definiert unter anderem folgende Methoden: \nMit der Methode createStatement() kann ein Objekt, welches das Interface Statement implementiert, erzeugt werden.  Analog dazu wird mit der Methode prepareStatement(String sql) eine Anweisung vorbereitet.  Durch den Aufruf von setAutoCommit(boolean) wird der Autocommit-Modus der Verbindung an- oder ausgeschaltet.  \n- Mit getAutoCommit() wird geprüft, welcher Modus vorliegt. \n- Mit close() wird die Verbindung explizit geschlossen, \n- mit isClosed() kann dies nachgeprüft werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie verwaltet die Datenbankverbindung.",
        "solution": "true"
      },
      {
        "text": "Mit ihrer Methode close wird die Datenbankverbindung geschlossen.",
        "solution": "true"
      },
      {
        "text": "Sie enthält eine Methode rollback, mit der laufende Transaktionen\nabgebrochen werden können.",
        "solution": "true"
      },
      {
        "text": "Mit ihrer Methode commit kann der Auto-Commit-Modus deaktiviert\nwerden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1962,
    "category": 10,
    "difficulty": 3,
    "text": "Für die JDBC-Schnittstelle (Interface) Statement gilt:",
    "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface. CallableStatement  und PreparedStatement können Parameter mit dem Platzhalter \"?\" aufnehmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie ist Oberklasse von PreparedStatement.",
        "solution": "true"
      },
      {
        "text": "Sie ist Unterklasse von CallableStatement.",
        "solution": "false"
      },
      {
        "text": "Sie kann nur SQL-Anweisungen verarbeiten, die keine Daten zurückliefern.",
        "solution": "false"
      },
      {
        "text": "Mit ihrer Methode executeUpdate können Relationen auf der\nDatenbank erstellt werden.",
        "solution": "true"
      },
      {
        "text": "Die Klasse liefert stets ein ResultSet zurück.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1979,
    "category": 7,
    "difficulty": 3,
    "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche Anfragen liefern das gleiche Ergebnis?",
    "explanation": "RICHTIG sind: \nDie Anfragen \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nund \n\"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\"\nhaben die gleiche Semantik: \"Welche Mitarbeiter sind Leiter einer Abteilung?\"\n\nOb Fremd-, Eíndeutigkeits- oder Primärschlüssel auf diesen Spalten definiert sind, ist unerheblich für die Ausführung des NATURAL JOINs, dessen Bedingung alle gleich lautenden Spalten auf Gleichheit prüft und mit AND verknüpft.\n\n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ort = Abteilungen.Standort AND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter wohnen am gleichen Ort, an dem sie auch arbeiten?\".\n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Standort\nAND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1929,
    "category": 6,
    "difficulty": 2,
    "text": "Jeder Table-Constraint (Tabellenbedingung) kann auch als Column-Constraint (Spaltenbedingung) geschrieben werden.",
    "explanation": "Ein COLUMN-Constraint kann sich nur auf eine Spalte beziehen, ein TABLE-Constraint auch auf mehrere Spalten. Der einzige Column-Constraint, der nicht als TABLE-Constraint geschrieben werden kann, ist der (NOT)-NULL-CONSTRAINT.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2017,
    "category": 3,
    "difficulty": 1,
    "text": "Welche Aussagen über Beziehungen in ER-Modellen sind wahr?",
    "explanation": "In ERM ist eine Beziehung als Teilmenge des kartesischen Produkts der beteiligten Entity-Mengen definiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Beziehung ist eine Obermenge des kartesischen Produkts von Entity-Mengen.",
        "solution": "false"
      },
      {
        "text": "Eine Beziehung ist eine Teilmenge des kartesischen Produkts von Entity-Mengen.",
        "solution": "true"
      },
      {
        "text": "Eine Beziehung ist das kartesischen Produkts von Entity-Mengen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2019,
    "category": 5,
    "difficulty": 2,
    "text": "Welche Aussagen über Normalformen sind wahr?",
    "explanation": "Wiederherstellbarkeit: Eine Zerlegung einer Relation ist verlustfrei, wenn sich alle Tupel der ursprünglichen Relation durch einen Join aus den abgeleiteten Relationen wiederherstellen lassen. Eine verlustfreie Zerlegung stellt damit die Wiederherstellbarkeit der ursprünglichen Relation sicher. \nAbhängigkeitswahrung: Die Zerlegung einer Relation ist abhängigkeitstreu, wenn jede funktionale Abhängigkeit der Ausgangsrelation in einer der resultierenden Relationen erhalten bleibt. Eine abhängigkeitstreue Zerlegung stellt damit die Wiederherstellbarkeit der ursprünglichen funktionalen Abhängigkeiten sicher. \nEine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Primärschlüssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Zerlegung einer Relation ist abhängigkeitstreu, wenn sich alle Tupel der ursprünglichen Relation durch einen Join aus den abgeleiteten Relationen wiederherstellen lassen.",
        "solution": "false"
      },
      {
        "text": "Eine Zerlegung einer Relation ist verlustfrei, wenn sich alle Tupel der ursprünglichen Relation durch einen Join aus den abgeleiteten Relationen wiederherstellen lassen.",
        "solution": "true"
      },
      {
        "text": "Die 2NF beseitigt alle partiellen Abhängigkeiten",
        "solution": "true"
      },
      {
        "text": "Die 3NF beseitigt alle partiellen Abhängigkeiten",
        "solution": "false"
      },
      {
        "text": "Die 2NF beseitigt alle transitiven Abhängigkeiten",
        "solution": "false"
      },
      {
        "text": "Die 3NF beseitigt alle transitiven Abhängigkeiten",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1927,
    "category": 3,
    "difficulty": 1,
    "text": "Rekursive Beziehungen sind immer unär.",
    "explanation": "Da rekursive Beziehungen von einer Entity-Menge auf sich selber definiert sind, sind sie unär, d.h. nur eine Entity-Menge ist beteiligt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2015,
    "category": 3,
    "difficulty": 1,
    "text": "Eine Aggregation ist ein Spezialfall einer 1:c-Beziehung",
    "explanation": "Die Aggregation beschreibt eine \"Ist Teil von-Beziehung\" und ist daher \nein Spezialfall einer 1:n-Modellierung mit eigener Semantik.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2016,
    "category": 3,
    "difficulty": 1,
    "text": "Eine Aggregation ist ein Spezialfall einer 1:n-Beziehung",
    "explanation": "Die Aggregation beschreibt eine \"Ist Teil von-Beziehung\" und ist daher \nein Spezialfall einer 1:n-Modellierung mit eigener Semantik.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1987,
    "category": 7,
    "difficulty": 1,
    "text": "In der relationalen Algebra gibt es wie unter SQL die Möglichkeit, Daten über eine dem ORDER-BY ähnlichem Konstrukt zu sortieren.",
    "explanation": "Neben dem zentralen Unterschied zwischen Relationaler Algebra und SQL\n\nRA: nur Mengen von Datensätzen mit automatischer Duplikatelimination\nSQL: Multimengen von Datensätzen mit Duplikaten\n\ngibt es einen weiteren: \n\nSQL: Sortierung möglich\nRA:  keine Sortierung möglich",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1908,
    "category": 14,
    "difficulty": 1,
    "text": "Bei welcher Sperrstrategie lösen lesende Zugriffe keine Sperren aus?",
    "explanation": "Optimistisches Sperrverfahren \n\nMan nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden.\nLesende Zugriffe (SELECT) lösen keine Sperren aus.\nJeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird.\nBei Änderungen wird zunächst geprüft, ob der Zeitstempel unverändert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unverändert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.\n\n\nPessimistisches Sperrverfahren\nMan nimmt an, dass viele schreibende Zugriffe auf der Datenbank stattfinden.\nAuch lesende Zugriffe (SELECT FOR UPDATE statt SELECT) lösen Sperren für andere Benutzer aus.\nDie Daten werden erst wieder freigegeben, wenn alle Änderungen abgespeichert sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Optimistische Sperrstrategie",
        "solution": "true"
      },
      {
        "text": "Pessimistische Sperrstrategie",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2108,
    "category": 7,
    "difficulty": 3,
    "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche SELECT-Abfrage entspricht dem natürlichen Join?",
    "explanation": "RICHTIG sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist ein Natural Join, weil über die einzige Spalte dieser Tabellen, die gleich heißt, Abt_Nr, auf Gleichheit verglichen wird. \n\nWie das Schlüsselwort es sagt, hier wird ein natürlicher JOIN ausgeführt: \"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\" \n\nDie Semantik dieses natürlichen Joins heißt: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\" \n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verknüpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN weil über zwei Spalten verknüpft wird, die nicht gleich heißen: \"Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM Angestellte, Abteilungen;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Leiter_Ang_Nr\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2344,
    "category": 15,
    "difficulty": 1,
    "text": "Ein innerer Knoten mit n Einträgen eines B-Baums vom Typ k hat wie viele Nachfolger?",
    "explanation": "Nach Definition des B-Baumes hat ein Knoten mit n Einträgen (n+1) Nachfolger.",
    "type": "text",
    "answers": [
      {
        "text": "Die Anzahl der Nachfolger ist:",
        "solution": "n+1"
      }
    ]
  },
  {
    "id": 2346,
    "category": 9,
    "difficulty": 3,
    "text": "Nach einer objektorientierten Analyse z.B. mit UML wird mittels einem objektorientiertem DBS implementiert.",
    "explanation": "Dieser Weg (OO-Analyse/Design -> OO-Implementierung) ist in der Tat in der Praxis recht selten. Meist nur dort, wo die OO-Anforderungen absolut zentral und zwingend sind, wie z.B. bei GIS (geo information system) und CAD (computer aidet design), ...\nDie Gründe sind vielfältig. Datenbanksysteme spielen eine sehr zentrale Rolle im unternehmerischen und behördlichen Alltag, die tauscht man nicht mal eben so aus - nur wegen eines Paradigmenwechsels. Die Hersteller relationer DBS erweitern ihre Systeme ja auch immer mehr in Richtung OR/OO, so dass die Diskrepanz zwischen Design und Implementierung nicht mehr so groß ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dieser Weg ist in der Praxis kaum zu finden.",
        "solution": "true"
      },
      {
        "text": "Dieser Weg ist relativ unproblematisch.",
        "solution": "true"
      },
      {
        "text": "Dieser Weg beinhaltet das Impendance Mismatch-Problem und erfordert OR-Mapping.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2347,
    "category": 9,
    "difficulty": 1,
    "text": "Für VARRAY-Datentypen wird bei der Definition eine maximale Anzahl an Einträgen vorgegeben.",
    "explanation": "Das ist die Definition eines Oracle-VARRAYS.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2348,
    "category": 9,
    "difficulty": 1,
    "text": "Für NESTED TABLE-Datentypen wird bei der Definition eine maximale Anzahl an Einträgen vorgegeben.",
    "explanation": "NESTED TABLE \nMit der STORE-Klausel können tabellenwertige Spalten beschrieben werden. Für jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher inneren Tabelle die tabellenwertigen Spalten abgelegt werden. Der Kollektionstyp kann dabei wieder auf einem benutzerdefinierten Datentyp aufsetzen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2357,
    "category": 10,
    "difficulty": 3,
    "text": "Mit welchem Methodenaufruf wird bei JDBC eine Verbindung zur Datenbank hergestellt? Bitte geben Sie den für den Aufruf notwendigen Klassennamen, Methodennamen, sowie die Parameter (in englisch) in der Aufrufreihenfolge.",
    "explanation": "import java.sql; \ntry{ \n//1. Oracle JDBC Treiber laden bzw. dem DriverManager bekannt machen \nClass.forName(\"oracle.jdbc.driver.OracleDriver\"); \n//2. Verbindung herstellen \nConnection v_connection =  \n  DriverManager.getConnection( \n         \"jdbc:oracle:thin:@localhost:1521:dbname\");",
    "type": "text",
    "answers": [
      {
        "text": "Das ist der Methodenaufruf:",
        "solution": "DriverManager.getConnection(url,user,password)"
      }
    ]
  },
  {
    "id": 2371,
    "category": 15,
    "difficulty": 1,
    "text": "Was passiert bei B-Bäumen, wenn neue Datensätze in einen vollen Knoten eingefügt werden?",
    "explanation": "Bei B-Bäumen entstehen keine Überlaufseiten (wie bei der ISAM- und der HASH-Speicherstruktur) und es gibt auch keine verketteten Listen wie bei der HEAP-Speicherstruktur.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenn der Knoten voll ist, wird eine zusätzliche Überlaufseite angelegt.",
        "solution": "false"
      },
      {
        "text": "Wenn der Knoten voll ist, wird der Knoten \"gesplittet\".",
        "solution": "true"
      },
      {
        "text": "Das ist kein Problem, da Datensätze als verkettete Liste immer hinten angefügt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2372,
    "category": 15,
    "difficulty": 1,
    "text": "Was passiert bei der Speicherart HEAP, wenn neue Datensätze eingefügt werden?",
    "explanation": "Bei der HEAP-Struktur gibt es keine Überlaufseiten und auch kein Splitten von Blöcken, da die Datensätze einfach in Form einer verketteten Liste angefügt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenn der Block voll ist, wird eine zusätzliche Überlaufseite angelegt.",
        "solution": "false"
      },
      {
        "text": "Wenn der Block voll ist, wird der Block \"gesplittet\".",
        "solution": "false"
      },
      {
        "text": "Das ist kein Problem, da Datensätze als verkettete Liste immer hinten angefügt werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2373,
    "category": 15,
    "difficulty": 1,
    "text": "Was passiert bei der Speicherstruktur ISAM, wenn neue Datensätze in einen vollen Block eingefügt werden?",
    "explanation": "Die Daten werden bei dwr ISAM-Speicherstruktur über die Indexspalte(n) aufsteigend sortiert. Aus jedem Block wird der größte Schlüsselwert als Repräsentant vermerkt und in einer gesonderten Struktur, dem Index abgelegt. Der Index ordnet also jedem Block ein Intervall der möglichen Schlüsselwerte zu. Wenn auf der Seite noch Platz ist, wird der Datensatz einfach einsortiert und gespeichert. Wenn die Seite schon gefüllt ist, wird ein noch freier Block aus einem Überlaufbereich als Überlaufseite angekettet. Weitere neue Datensätze, die zu diesem Schlüsselbereich gehören, werden dann unsortiert in die Überlaufseite geschrieben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es wird eine zusätzliche Überlaufseite angelegt.",
        "solution": "true"
      },
      {
        "text": "Es wird der Block \"gesplittet\".",
        "solution": "false"
      },
      {
        "text": "Das ist kein Problem, da Datensätze als verkettete Liste immer hinten angefügt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2374,
    "category": 15,
    "difficulty": 1,
    "text": "Was passiert bei der Speicherstruktur HASH, wenn neue Datensätze in einen vollen Block eingefügt werden?",
    "explanation": "Das Splitten von Blöcken geschieht in der B-Baum-Speicherstruktur, HEAP-Strukturen sind als lineare Liste angelegt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es wird eine zusätzliche Überlaufseite angelegt.",
        "solution": "true"
      },
      {
        "text": "Es wird der Block \"gesplittet\".",
        "solution": "false"
      },
      {
        "text": "Das ist kein Problem, da Datensätze als verkettete Liste immer hinten angefügt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2376,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei folgende Methodendefinition gegeben:\n  CREATE OR REPLACE TYPE BODY kdtm AS\n  STATIC FUNCTION get_plzort (p_plz IN NUMBER, p_ort IN VARCHAR2) \n  RETURN VARCHAR2 IS \n  BEGIN      RETURN (p_plz || p_ort);      END;\n  END;\nMit welchem/n Befehl/en kann man bei Oracle diese Methode aufrufen?",
    "explanation": "SELECT kdtm.get_plzort(k.plz,k.ort) FROM kunden k WHERE name = \"Meier\";   ist der korrekte Aufruf einer Static-Funktion.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT kdtm.get_plzort(k.plz,k.ort) FROM kunden k WHERE name = \"Meier\";",
        "solution": "true"
      },
      {
        "text": "SELECT k.get_plzort(k.plz, k.ort) FROM kunden k WHERE name = \"Meier\";",
        "solution": "false"
      },
      {
        "text": "SELECT k.get_plzort() FROM kunden k WHERE name = \"Meier\";",
        "solution": "false"
      },
      {
        "text": "SELECT k.get_plzort FROM kunden k WHERE name = \"Meier\";",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2377,
    "category": 9,
    "difficulty": 2,
    "text": "Welche Eigenschaften hat eine relationale Tabelle?",
    "explanation": "Welche Tabellenformen kann es in einem ORDBMS geben?\n\nDefinitionsart: untypisiert vs. typisiert \n- Untypisiert: die Struktur ergibt sich direkt aus den Attributstrukturen (RM)\n- Typisiert: Tabellendefinition basiert auf benutzerdefinierten Typ (OR)\n\nZeilentyp: tupelwertig vs. objektwertig \n- Tupelwertig: keine Methodenaufrufe für ein konkretes Tupel (RM)\n- Objektwertig: Methodenaufrufe des zugehörigen Objekttyps direkt über die Zeilenvariable (OR)\n\nReferenzierbarkeit: nicht referenzierbar vs. referenzierbar  \n- Nicht referenzierbar: Zeilen sind nicht referenzierbar (RM)\n- Referenzierbar: Zeilen sind mittels Referenzspalten (OIDs) referenzierbar; setzt OIDs voraus (OR)\n\n\nRelationale Tabellen sind: \n- tupelwertig, \n- untypisiert, \n- nicht referenzierbar\n\nObjektorientierte/objektrelationale Klassen/Tabellen sind: \n- objektwertig, \n- typisiert, \n- referenzierbar",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typisiert",
        "solution": "false"
      },
      {
        "text": "Untypisiert",
        "solution": "true"
      },
      {
        "text": "Tupelwertig",
        "solution": "true"
      },
      {
        "text": "Objektwertig",
        "solution": "false"
      },
      {
        "text": "Referenzierbar",
        "solution": "false"
      },
      {
        "text": "Nicht referenzierbar",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2392,
    "category": 9,
    "difficulty": 3,
    "text": "Die Definition objektrelationaler Sichten kann basieren auf:",
    "explanation": "RICHTIG sind: OR-Sichten lassen sich auf relationalen Tabellen und Sichten sowie auch auf objektrelationalen Tabellen und Sichten definieren. \n \nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht über beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nermöglicht logische Datenunabhängigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen möglich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Relationalen Tabellen",
        "solution": "true"
      },
      {
        "text": "Objektrelationalen Tabellen",
        "solution": "true"
      },
      {
        "text": "Relationalen Sichten",
        "solution": "true"
      },
      {
        "text": "Objektrelationalen Sichten",
        "solution": "true"
      },
      {
        "text": "Keine dieser Antworten ist richtig.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 418,
    "category": 3,
    "difficulty": 1,
    "text": "ER-Modell: Um welchen Beziehungstyp handelt es sich hier?\nEin Student kann keine oder nur eine Vorlesung hören und eine Vorlesung kann von keinem oder nur von einem Studenten besucht werden.",
    "explanation": "Das ist die Definition einer c:c-Beziehung, auch wenn dieser Beziehungstyp im Beispiel wenig Sinn als Abbild der Realität macht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1:1",
        "solution": "false"
      },
      {
        "text": "c:1",
        "solution": "false"
      },
      {
        "text": "1:c",
        "solution": "false"
      },
      {
        "text": "c:c",
        "solution": "true"
      }
    ]
  },
  {
    "id": 422,
    "category": 3,
    "difficulty": 1,
    "text": "Rekursive Beziehungen sind in ER-Diagrammen erlaubt.",
    "explanation": "Im ER-Modell sind auch rekursive Beziehungen erlaubt, d.h. Beziehungen einer Entity-Menge auf sich selbst. Rekursive Beziehungen sind also immer unär, da nur eine Entity-Menge beteiligt ist.  Mittels der Rekursion lassen sich z.B. Vorgesetzte, Stücklisten oder Stammbäume mit unbekannter Tiefe modellieren.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1119,
    "category": 3,
    "difficulty": 1,
    "text": "In obligatorischen Attributen (ER-Modell) sind NULL-Werte erlaubt.",
    "explanation": "Obligatorisch bedeutet, dass das Attribut einen Wert haben muss, also nicht NULL sein darf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1576,
    "category": 15,
    "difficulty": 2,
    "text": "Welche Speicherstruktur eignet sich gut für große Datenbestände, die häufig Änderungen unterworfen sind?",
    "explanation": "Die B-Bäume und B+-Bäume passen sich bei veränderlichen Daten optimal an den Datenbestand an, da die Indexbäume dynamisch nach oben wachen und keine Überlaufseiten entstehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "ISAM",
        "solution": "false"
      },
      {
        "text": "B+ -Baum",
        "solution": "true"
      },
      {
        "text": "HASH",
        "solution": "false"
      },
      {
        "text": "B-Baum",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1578,
    "category": 15,
    "difficulty": 2,
    "text": "Welche Speicherstruktur wird bei Oracle automatisch angelegt, wenn eine Tabelle ohne Primärschlüssel erzeugt wird?",
    "explanation": "Bei HEAP wird in der zeitlichen Reihenfolge gespeichert, mit der die Daten erfasst werden. Eine Ordnung gemäß einem Schlüssel ist nicht möglich. \nBei den drei anderen Speicherformen B-Baum, HASH, ISAM wird ein Schlüssel benötigt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ISAM",
        "solution": "false"
      },
      {
        "text": "HEAP",
        "solution": "true"
      },
      {
        "text": "HASH",
        "solution": "false"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1579,
    "category": 15,
    "difficulty": 3,
    "text": "Welche Speicherstruktur wird automatisch angelegt, wenn eine Tabelle mit Primärschlüssel unter ORACLE erzeugt wird?",
    "explanation": "Bei Oracle wird für eine Tabelle mit Primärschlüssel automatisch B+-Baum als Speicherstruktur angewendet. Hier wird vor allem Wert auf einen äußerst schnellen Zugriff für imens große Datenmengen gelegt. Da beim B+-Baum ja nur die Schlüsselinformationen im Baum gespeichert werden, ist das ein Vorteil gegenüber B-Bäumen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      },
      {
        "text": "B+-Baum",
        "solution": "true"
      },
      {
        "text": "ISAM",
        "solution": "false"
      },
      {
        "text": "HASH",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1581,
    "category": 15,
    "difficulty": 3,
    "text": "Wie nennt man ein Verzeichnis der Gestalt: (Wert, physikalische Adresse)?",
    "explanation": "Ein Index ist ein separates Verzeichnis der Gestalt \"Wert, Adresse\", wobei der Wert aus einem oder mehreren Spaltenwerten (ein oder mehrdimensionaler Index) bestehen kann. Die Adresse verweist auf den Platz, an dem die Daten auf der Platte gespeichert sind. In einem dichten Index sind alle Datensätze eingetragen, in einem dünnen Index dagegen nur einige ausgewählte Datensätze.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ein",
        "solution": "Index"
      }
    ]
  },
  {
    "id": 1582,
    "category": 6,
    "difficulty": 2,
    "text": "Es soll folgende Spieler-Tabelle angelegt werden:  spieler (spieler_id, name, handy) mit dem Primärschlüssel: spieler_id.\n\n    Mit welchem/n Befehl/en kann zusätzlich ein zusammengesetzter, eindeutiger Zweitschlüssel für die Tabelle \"spieler\" über die beiden Attribute \"name, handy\" definiert werden, der zum Transaktionsende geprüft werden soll?",
    "explanation": "Nur der Ausdruck\n\n    \n\n    CREATE TABLE spieler\n\n    (spieler_id NUMBER(9) PRIMARY KEY,\n\n    name VARCHAR2(50),\n\n    handy NUMBER(11),\n\n    UNIQUE (name, handy) INITIALLY DEFERRED);\n\n    \n\n    ist syntaktisch richtig und entspricht der Fragestellung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \nname VARCHAR2(50), \nhandy    NUMBER(11), \nUNIQUE (name, handy) INITIALLY DEFERRED);",
        "solution": "true"
      },
      {
        "text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \n name VARCHAR2(50) UNIQUE INITIALLY DEFERRED, \n handy NUMBER(11) UNIQUE INITIALLY DEFERRED);",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \nname VARCHAR2(50), \nhandy    NUMBER(11), \nUNIQUE (name, handy) INITIALLY IMMEDIATE);",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE spieler  \n(spieler_id NUMBER(9) PRIMARY KEY,     \n name VARCHAR2(50) UNIQUE INITIALLY IMMEDIATE, \n handy NUMBER(11) UNIQUE INITIALLY IMMEDIATE);",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1605,
    "category": 11,
    "difficulty": 2,
    "text": "Welcher Teil von SQLJ beinhaltet die Einbindung von statischen SQL Statements in ein Java-Programm?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Part 0",
        "solution": "true"
      },
      {
        "text": "Part 1",
        "solution": "false"
      },
      {
        "text": "Part 2",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1585,
    "category": 5,
    "difficulty": 1,
    "text": "Eine Relation in der zweiten Normalform mit zwei Attributen ist auch immer in der dritten Normalform.",
    "explanation": "Ja, denn für die Verletzung der 3. NF werden wenigstens drei Attribute benötigt, je eines für X,Y und Z. \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist. \nMit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ heißt transitiv abhängig von X, wenn Y voll funktional abhängig von X und Z voll funktional abhängig von Y ist, aber X nicht voll funktional abhängig von Y ist. \nAlso X →Y →Z, aber nicht Y →X.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1587,
    "category": 5,
    "difficulty": 2,
    "text": "Eine Relation in der zweiten Normalform mit nur zwei funktionalen\nAbhängigkeiten ist immer in der dritten Normalform.",
    "explanation": "Mit nur einer funktionalen Abhängigkeit, wäre keine Möglichkeit zur Transitivitiät gegeben. z.B. a->b,c. \nAber mit zwei funktionalen Abhängigkeiten ist als Mindestvoraussetzung grundsätzlich die Möglichkeit gegeben, dass es sich dabei um transitive Abhängigkeiten handeln könnte. z.B. a->b,c. und b->c.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dieser Sachverhalt spielt in diesem Zusammenhang keine Rolle.",
        "solution": "false"
      },
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1589,
    "category": 11,
    "difficulty": 1,
    "text": "SQL-Befehle in  SQLJ-Klauseln schließen mit einem Semikolon innerhalb der geschweiften Klammern ab.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1590,
    "category": 13,
    "difficulty": 3,
    "text": "Betrachten Sie die folgende Definition einer Sequence: CREATE SEQUENCE Kun_seq INCREMENT BY 1 START WITH 1 NOMAXVALUE NOCYCLE CACHE 10;",
    "explanation": "Der nächste Wert einer Sequenz wird mit <sequence_name>NEXTVAL abgerufen..\n\n    Ein solcher INSERT, der nur einen Datensatz einfügt, wird mit dem Schlüsselwort VALUES( ) fortgesetzt.\n\n    INSERT INTO Kunden (Kun_Nr, Nachname) VALUES (Kun_seq.NEXTVAL, \"Vogt\")",
    "type": "text",
    "answers": [
      {
        "text": "Mit welchem Befehl wird ein Datensatz (Kunden_Nr, Nachname: 'Vogt') zu dieser Sequenz in eine Tabelle 'Kunden' angelegt? Vervollständigen Sie den folgenden SQL-Befehl (ohne abschließendes Komma): \n\nINSERT INTO Kunden (Kun_Nr, Nachname)",
        "solution": "VALUES (Kun_seq.NEXTVAL, 'Vogt')"
      }
    ]
  },
  {
    "id": 1592,
    "category": 12,
    "difficulty": 2,
    "text": "Betrachten Sie den folgenden PL/SQL-Code\n\n    PACKAGE xyz\n    IS\n      PROCEDURE b (p1 VARCHAR2);\n    END;\n\n    CREATE PACKAGE BODY xyz\n    IS \n      PRODEDURE a (p1 NUMBER) IS ...\n        \n    END; \n\nWelche Methode ist privat?",
    "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder öffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind öffentlich und können damit von außerhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und können damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.\na ist daher privat, da die Prozedur a innerhalb des BODY-Teils, also im Paketrumpf definiert ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "a",
        "solution": "true"
      },
      {
        "text": "b",
        "solution": "false"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1595,
    "category": 14,
    "difficulty": 2,
    "text": "Welche Aussagen über \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?",
    "explanation": "Alle drei Antworten sind richtig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, können andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.",
        "solution": "true"
      },
      {
        "text": "Beim \"pessimistischen\" LOCK-Verfahren lösen auch lesende Zugriffe Sperren für andere Benutzer aus. Die Daten werden erst wieder freigegeben, wenn alle Änderungen gespeichert sind. Nachteil des pessimistischen Verfahrens ist, dass andere Transaktionen oft unnötig lange auf die Freigabe von Daten warten müssen. Das parallele Arbeiten vieler Benutzer kann dadurch sehr eingeschränkt sein.",
        "solution": "true"
      },
      {
        "text": "Beim \"optimistischen\" LOCK-Verfahren lösen lesende Zugriffe keine Sperren aus. Jede Tabelle verfügt über einen Zeitstempel, der den Zeitpunkt der letzten Änderung angibt. Bei Datenänderungen wird zunächst geprüft, der Zeitstempel der Tabelle noch der gleiche ist wie beim Lesen der Daten. Ist dies der Fall, dann sind die Daten der Tabelle seit dem Lesen unverändert und die Änderungen können gespeichert werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1599,
    "category": 10,
    "difficulty": 3,
    "text": "Welche der JDBC-Objekte sind Interfaces?",
    "explanation": "Alle diese  Objekte sind Interfaces  bzw. Schnittstellen unter Java, von denen keine Objekte gebildet werden können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Connection",
        "solution": "true"
      },
      {
        "text": "Statement",
        "solution": "true"
      },
      {
        "text": "Driver",
        "solution": "true"
      },
      {
        "text": "PreparedStatement",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1602,
    "category": 6,
    "difficulty": 2,
    "text": "Was versteht man unter",
    "explanation": "DAL ist der administrative Teil, wie z.B. GRANT, REVOKE für die Rechte,...\n\n    DML ist die Datenmanipulationssprache mit INSERT, UPDATE, DELETE.\n\n    DDL ist die Datendefinitionssprache, um \"Objekte\" wie z.B. Tabellen, Indexe, Sequenzen, Trigger, Constraints im DBS anlegen zu können und umfasst im Wesentlichen CREATE, ALTER, DROP.\n\n    DQL ist die Anfragesprache, die nur aus dem SELECT-Befehl besteht.",
    "type": "text",
    "answers": [
      {
        "text": "DAL=",
        "solution": "Data Administration Language"
      },
      {
        "text": "DML=",
        "solution": "Data Manipulation Language"
      },
      {
        "text": "DDL=",
        "solution": "Data Definition Language"
      }
    ]
  },
  {
    "id": 1603,
    "category": 10,
    "difficulty": 2,
    "text": "Wie können Sie den Java Datentyp \"float\" in den meisten relationalen Datenbanken ablegen?",
    "explanation": "INTEGER hat keine Nachkommastellen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "FLOAT",
        "solution": "true"
      },
      {
        "text": "DOUBLE",
        "solution": "true"
      },
      {
        "text": "INTEGER",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1604,
    "category": 5,
    "difficulty": 1,
    "text": "Eine Relation in der zweiten Normalform, in der keine transitiven Abhängigkeiten auftreten, ist immer in der dritten Normalform.",
    "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Primärschlüssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1606,
    "category": 13,
    "difficulty": 3,
    "text": "Wie fragt man in PL/SQL ab, ob ein Datenbanktrigger durch einen INSERT angestossen wurde?",
    "explanation": "Mit IF INSERTING THEN   \n     ELSIF DELETING THEN  \n     ELSIF UPDATING THEN  \nkann unter PL/SQL ein Trigger für mehrere DML-Ereignisse definiert werden und dann dieses Ereignis im Action-Teil des Triggers abgefragt werden.  \n\nDies ist eine PL/SQL-spezifische Syntax, die nicht zum SQL-Standard gehört.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "IF INSERTING THEN"
      }
    ]
  },
  {
    "id": 1619,
    "category": 15,
    "difficulty": 2,
    "text": "Wie viele Datensätze sind in einem B-Baum vom Typ 3 auf einem Blatt höchstens enthalten?",
    "explanation": "Die Anzahl der Datensätze, die auf einem Blatt bei einem B-Baum vom Typ k enthalten sein dürfen, ist 2 * k, also hier 6.",
    "type": "text",
    "answers": [
      {
        "text": "Die Zahl ist",
        "solution": "6"
      }
    ]
  },
  {
    "id": 1616,
    "category": 15,
    "difficulty": 2,
    "text": "Beim Löschen in einem B-Baum wird",
    "explanation": "Kleben, Schmieren und Vertuschen kommen nur im wirklichen Leben oder in der Bastelstunde vor. B-Bäume werden verschmolzen oder ausgeglichen, wenn das Löschen eine Unterbesetzung eines Blattes verursacht..",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "verklebt",
        "solution": "false"
      },
      {
        "text": "verschmiert",
        "solution": "false"
      },
      {
        "text": "verschmolzen",
        "solution": "true"
      },
      {
        "text": "vertuscht",
        "solution": "false"
      },
      {
        "text": "ausgeglichen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1614,
    "category": 15,
    "difficulty": 1,
    "text": "Betrachten Sie die folgende SELECT-Abfrage:\n\nSELECT *\nFROM Tabelle 1\nWHERE Schlüssel BETWEEN 1 AND 100;\n\nWelche Speicherstruktur liefert das Ergebnis schneller?",
    "explanation": "Bei einer Hash-Speicherstruktur kann sehr schnell der Datensatz gefunden werden, wenn man den Primärschlüssel, nicht einen Primärschlüsselbereich vorgibt. Für einen einzelnen Wert wird dann nur die Hash-Funktion ohne zusätzliche Lesezugriffe ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "B- Baum",
        "solution": "true"
      },
      {
        "text": "HASH",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1615,
    "category": 15,
    "difficulty": 1,
    "text": "Nach welchem Informatiker sind die B-Bäume benannt?",
    "explanation": "Ein B-Baum ist eine Indexstruktur, die häufig in Datenbanken und Dateisystemen eingesetzt wird. Ein B-Baum ist ein immer vollständig balancierter Baum, der Daten sortiert nach Schlüsseln speichert.B-Bäume wachsen und schrumpfen von den Blättern hin zur Wurzel. Der B-Baum wurde 1972 von Rudolf Bayer und Edward M. McCreight entwickelt.",
    "type": "text",
    "answers": [
      {
        "text": "Der Autor heißt",
        "solution": "Bayer"
      }
    ]
  },
  {
    "id": 547,
    "category": 4,
    "difficulty": 3,
    "text": "Wie nennt man die Anzahl der Attribute einer Relation in der relationalen Algebra? (englischer Ausdruck)",
    "explanation": "Man schreibt auch: R(A1,...,An). Eine Relation entspricht dabei einer Tabelle mit den Attributen als Spaltenüberschriften. Der Degree ist die Anzahl der Attribute der Relation.",
    "type": "text",
    "answers": [
      {
        "text": "Die Anzahl der Attribute heißt:",
        "solution": "Degree"
      }
    ]
  },
  {
    "id": 548,
    "category": 4,
    "difficulty": 1,
    "text": "In einer Relation ist die Tupelreihenfolge definiert.",
    "explanation": "Dies ist ein sehr zentraler Grundsatz des relationalen Modells: die Reihenfolgeunabhängigkeit. \nAngewendet auf relationale Datenbanksysteme heißt das u.a. dass das Ergebnis einer Datenverarbeitung unabhängig davon ist, in welcher Reihenfolge die Tupel/Datensätze auf der Platte gespeichert sind. Stellen Sie sich vor, dem wäre nicht so:  das System wäre überhaupt nicht beherrschbar, wenn der Entwickler wissen müsste, in welcher Reihenfolge Tupel/Datensätze gespeichert sind. Diese Annahme widerspricht auch dem ANSI-3-Ebenen Modell und der physischen Datenunabhängigkeit.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 550,
    "category": 4,
    "difficulty": 2,
    "text": "Bei einer Selektion wird eine n-stellige Relation auf eine n-stellige Relation abgebildet.",
    "explanation": "Mit Hilfe der Selektion werden einzelne Tupel ausgewählt, die Attributstruktur der Relation bleibt jedoch unverändert. Es ist die Projektion, die einzelne Attribute auswählt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1122,
    "category": 4,
    "difficulty": 1,
    "text": "Es wird ein algebraischer Ausdruck der relationalen Algebra auf einen äquivalenten Ausdruck transformiert, der weniger Laufzeit benötigt.",
    "explanation": "Grundlage der logischen Optimierung sind Äquivalenzen in der relationalen Algebra: \nDie Operationen der relationalen Algebra genügen bestimmten mathematischen Rechengesetzen. Unter Ausnutzung dieser Gesetze gelangt man zu einem optimierten algebraischen Ausdruck, der äquivalent zum ursprünglichen Ausdruck in dem Sinne ist, dass er das gleiche Anfrageergebnis liefert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist die logische Optimierung.",
        "solution": "true"
      },
      {
        "text": "Das ist die physische Optimierung.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 556,
    "category": 4,
    "difficulty": 3,
    "text": "Wie heißt ein Natural Join, bei dem alle Tupel am Verbund der beiden Relationen teilnehmen?",
    "explanation": "Eine Join-Operation (Theta-Join, Equi-Join oder Natural-Join) zwischen R und S heißt verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.",
    "type": "text",
    "answers": [
      {
        "text": "Solch ein Join heißt",
        "solution": "verlustfrei"
      }
    ]
  },
  {
    "id": 557,
    "category": 4,
    "difficulty": 2,
    "text": "Welche der folgenden Aussagen über Join-Operatoren sind wahr?",
    "explanation": "Die drei Grundoperatoren, die man für die Simulation von Join-Operatoren benötigt, sind:  Selektion, Projektion und kartesisches Produkt. \nJede Relation kann mit einer anderen Relation gejoint werden (auch mit sich selber). \nDie Restriktion: \"Alle Attribute der beiden betroffenen Relationen müssen über die gleichen Namen verfügen.\" gilt nur für die Mengenoperatoren Differenz, Durchschnitt, Vereinigung und ist eine Teilbedingung der \"Vereinigungskonformität\". \nEs kann in der Relationalen Algebra über jedes beliebige Attribut \"gejoint\" werden, es muss kein Schlüsselattribut sein. In relationalen Datenbanksystemen dienen Schlüssel lediglich zur Beschleunigung des Zugriffs, aber nicht zur Einschränkung der Verknüpfungsmöglichkeiten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der Join-Operationen lassen sich nicht aus Selektion, Projektion und kartesischem Produkt ableiten.",
        "solution": "false"
      },
      {
        "text": "Jede Relation kann mit einer anderen Relation gejoint werden (auch mit sich selber).",
        "solution": "true"
      },
      {
        "text": "Alle Attribute der beiden betroffenen Relationen müssen für eine Join-Operation über die gleichen Namen verfügen.",
        "solution": "false"
      },
      {
        "text": "Die Attribute, über die der Join ausgeführt wird müssen eine Schlüsselattribute sein.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 561,
    "category": 5,
    "difficulty": 2,
    "text": "Welche Integritätsarten gibt es in relationalen Datenbanksystemen/im relationalen Modell?",
    "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrität, wenn jeder Wert eines Fremdschlüssels einer Relation Ri Wert eines Primärschlüssels in einer anderen Relation Rj\nist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt. \nEine Menge von Relationen R1,...,Rk besitzt die Entity-Integrität, wenn jede Relation einen Primärschlüssel besitzt. \nEine Menge von Relationen R1,...,Rk besitzt die semantische Integrität, wenn die Korrektheit der Eingaben der Benutzer gewährleistet ist. \nDie ürbrigen Integritätsbegriffe gibt es nicht in diesem Zusammenhang.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Entity-Integrität",
        "solution": "true"
      },
      {
        "text": "referentielle Integrität",
        "solution": "true"
      },
      {
        "text": "semantische Integrität",
        "solution": "true"
      },
      {
        "text": "differenzielle Integrität",
        "solution": "false"
      },
      {
        "text": "divergente Integrität",
        "solution": "false"
      },
      {
        "text": "resorbierende Integrität",
        "solution": "false"
      }
    ]
  },
  {
    "id": 559,
    "category": 4,
    "difficulty": 3,
    "text": "Welche der folgenden Operationen aus der relationalen Algebra sind kommutativ?",
    "explanation": "Während die beiden Mengenoperationen Vereinigung und Durchschnitt kommutativ sind, ist es die Differenz nicht, weil das Ergebnis davon abhängt, welche Relation von der anderen abgezogen wird. \nKartesisches Produkt und Join-Operation sind kommutativ (vertauschbar), das einzige, was sich ändert ist die Attributreihenfolge und das spielt keine Rolle.  \nHingegen sind die Left und Right Outer-Joins nicht kommutativ, da geht es ja gerade um die Anforderung, entweder die Tupel der linken oder rechten Relation vollständig in die Ergebnismenge aufzunehmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Durchschnitt",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Union",
        "solution": "true"
      },
      {
        "text": "Division",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Join-Operationen (Theta, Natural, Equi)",
        "solution": "true"
      },
      {
        "text": "Outer Join-Operatoren (Left, Right)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 560,
    "category": 4,
    "difficulty": 1,
    "text": "Wie heißt eine Attributkombination, die Primärschlüssel einer anderen Relation ist?",
    "explanation": "Eine Attributkombination einer Relation heißt Fremdschlüssel (foreign key), wenn diese Kombination Primärschlüssel in einer anderen Relation ist. Ein Fremdschlüssel darf Null-Werte besitzen.",
    "type": "text",
    "answers": [
      {
        "text": "Sie heißt  (deutscher Begriff):",
        "solution": "Fremdschlüssel"
      }
    ]
  },
  {
    "id": 563,
    "category": 14,
    "difficulty": 3,
    "text": "Welcher Lock-Typ erlaubt anderen Benutzern nicht, weitere Sperren auf eine Tabelle zu setzen, die mit diesem Lock-Typ gesperrt wurden?",
    "explanation": "1. Typ: XLOCKS oder EXKLUSIVE LOCKS\nEin XLOCK bewirkt, dass keine andere Transaktion eine Sperrung auf ein Objekt, das schon einen XLOCK hat, absetzen kann. Der XLOCK wird bis zum Ende der Transaktion gehalten.\n\n2.Typ: SHARED LOCKS oder SLOCKS (geteilte LOCKS )\nFalls eine Transaktion T1 einen SLOCK auf eine Tabelle hält, heißt das, dass sie nur lesend zugreifen wird. Eine andere Transaktion T2 kann parallel auch einen SLOCK absetzen, wenn nur Lesezugriffe beabsichtigt sind. Allerdings kann eine Transaktion T3 keinen XLOCK auf die betroffene Tabelle absetzen, bis alle SLOCKS wieder gelöscht sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SLOCK",
        "solution": "false"
      },
      {
        "text": "XLOCK",
        "solution": "true"
      },
      {
        "text": "EXCLUSIVE LOCK",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1123,
    "category": 4,
    "difficulty": 3,
    "text": "Es wird zur Optimierung eines Ausdrucks auf unterschiedliche Implementierungen der relationale Algebra zurückgegriffen, um eine Laufzeitverbesserung zu erreichen.",
    "explanation": "Bei der physischen Optimierung wird dagegen auf unterschiedliche Implementierungen der relationalen Algebra zurückgegriffen, d.h., unter mehreren Übersetzungsmöglichkeiten wird die performanteste herausgesucht. Dabei gehen Wissen über das Datenbankschema, die Größe der einzelnen Relationen und Statistiken über die erfolgten Datenzugriffe ein.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist die ...",
        "solution": "physische Optimierung"
      }
    ]
  },
  {
    "id": 1124,
    "category": 4,
    "difficulty": 1,
    "text": "Alle Natural-Joins sind verlustfrei.",
    "explanation": "Eine Join-Operation zwischen R und S heißt verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 569,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Operationen der relationalen Algebra sind assoziativ?",
    "explanation": "Kartesisches Produkt, Union, Durchschnitt und Join-Operation sind assoziativ, d. h., Klammern können beliebig gesetzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Durchschnitt",
        "solution": "true"
      },
      {
        "text": "Union",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1112,
    "category": 14,
    "difficulty": 1,
    "text": "Welche Aussagen über Transaktionen und Integritätsprüfung in SQL sind richtig?",
    "explanation": "RICHTIG sind:\n\"IMMEDIATE bezeichnet die Integritätsprüfung unmittelbar im Anschluss an die Ausführung des DML-Befehls und DEFERRED erst zum Transaktionsende.\"\n\n\"In SQL gibt es 5 CONSTRAINTs mittels denen die Datenintegrität gesichert werden kann: [NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.\"\n\nFALSCH sind: \n\"Wird vom DBMS ein Fehler bei der IMMEDIATE-Integritätsprüfung erkannt, so wird die gesamte Transaktion zurückgerollt.\" Bei einem IMMEDIATE-Fehler wird nur die eine fehlerhafte DML-Anweisung rückgängig gemacht. \n\n\"Wird vom DBMS ein Fehler bei der DEFERRED-Integritätsprüfung erkannt, so wird nur der fehlerhafte DML-Befehl zurückgerollt.\" Bei einem DEFERRED-Fehler wird die gesamte Transaktion zurückgerollt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integritätsprüfung erkannt, so wird die gesamte Transaktion zurückgerollt.",
        "solution": "false"
      },
      {
        "text": "Wird vom DBMS ein Fehler bei der DEFERRED-Integritätsprüfung erkannt, so wird nur der fehlerhafte DML-Befehl zurückgerollt.",
        "solution": "false"
      },
      {
        "text": "IMMEDIATE bezeichnet die Integritätsprüfung unmittelbar im Anschluss an die Ausführung des DML-Befehls und DEFERRED erst zum Transaktionsende.",
        "solution": "true"
      },
      {
        "text": "In SQL gibt es 5 CONSTRAINTs mittels denen die Datenintegrität gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 414,
    "category": 1,
    "difficulty": 1,
    "text": "ANSI-3-Ebenen-Modell: Die Organisation der physischen Speicherung wird geändert.",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Änderung betrifft die externe Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft die interne Ebene.",
        "solution": "true"
      },
      {
        "text": "Diese Änderung betrifft die konzeptionelle Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft keine Ebene.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 415,
    "category": 1,
    "difficulty": 2,
    "text": "In welchem Teilsystem eines DBMS werden Daten über Tabellenstrukturen, Benutzerrechte, Beziehungen der Tabellen untereinander etc. gespeichert?\nDieses System heißt",
    "explanation": "Das Data Dictionary enthält Daten (sogenannte Metadaten), die die Datenbasis, z.B. Tabellenstrukturen, definieren. Es umfasst außerdem Daten über die Verwendung und Bedeutung des Datenmodells, die Beziehungen der Daten untereinander und Integritätsbedingungen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Datenbasis",
        "solution": "false"
      },
      {
        "text": "Metadatenbank",
        "solution": "true"
      },
      {
        "text": "Data Dictionary",
        "solution": "true"
      },
      {
        "text": "Transaktionsverwaltung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 417,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie die folgende Frage an eine Auftrags-/Kunden-Tabelle:\nWelche Kunden haben einen Auftrag aufgegeben?\nWelche der folgenden Abfragen liefert das gewünschte Ergebnis?",
    "explanation": "Eine Exists-Bedingung liefert den Wahrheitswert wahr, wenn der SELECT (hier SELECT * FROM auftraege) mindestens einen Datensatz ergibt. \nDas ist hier der Fall, falls die Auftraege-Relation nicht leer ist, beantwortet aber nicht die oben gestellte Frage.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE EXISTS\n(SELECT * FROM Auftraege\nWHERE  Kunden.Kun_Nr = Auftraege.Kun_Nr);",
        "solution": "true"
      },
      {
        "text": "SELECT    DISTINCT Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege\nWHERE    Auftraege.Kun_Nr=Kunden.Kun_Nr;",
        "solution": "true"
      },
      {
        "text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE EXISTS\n(SELECT * FROM Auftraege)",
        "solution": "false"
      },
      {
        "text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege\nWHERE    Auftraege.Kun_Nr=Kunden.Kun_Nr;",
        "solution": "true"
      },
      {
        "text": "SELECT    Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname \nFROM    Kunden\nWHERE Kunden_nr IN\n(SELECT DISTINCT Kun_Nr FROM Auftraege);",
        "solution": "true"
      },
      {
        "text": "SELECT    DISTINCT Kunden.Kun_Nr, \n    Kunden.Vorname, \n    Kunden.Nachname\nFROM    Kunden, Auftraege;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 419,
    "category": 3,
    "difficulty": 1,
    "text": "ER-Modell: Um welchen Beziehungstyp handelt es sich hier?\nEin Student kann keine/eine/mehrere Vorlesungen hören und eine Vorlesung kann von keinem/nur von einem Studenten besucht werden.",
    "explanation": "Das ist die Definition einer c:cm-Beziehung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1:n",
        "solution": "false"
      },
      {
        "text": "c:n",
        "solution": "false"
      },
      {
        "text": "c:cn",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1110,
    "category": 12,
    "difficulty": 1,
    "text": "Wie viele Datensätze darf eine SELECT-Anweisung ohne CURSOR mit der INTO-Klausel unter PL/SQL liefern, ohne dass eine Exception erzeugt wird?",
    "explanation": "SELECT INTO übergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datensätze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datensätze verarbeiten kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "mehrere Datensätze",
        "solution": "false"
      },
      {
        "text": "keinen Datensatz",
        "solution": "false"
      },
      {
        "text": "einen Datensatz",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1111,
    "category": 9,
    "difficulty": 3,
    "text": "Mit welcher PL/SQL-Prozedur initialisiert man einen BLOB-Wert?",
    "explanation": "Bevor man einen BLOB-Datentyp benutzen kann, muss er mit EMPTY_BLOB() initialisiert werden.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist (mit Klammern schreiben):",
        "solution": "EMPTY_BLOB()"
      }
    ]
  },
  {
    "id": 1114,
    "category": 12,
    "difficulty": 2,
    "text": "Mit welchem Cursor-Attribut fragt man ab, ob ein Cursor geöffnet ist?",
    "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR geöffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "%ISOPEN"
      }
    ]
  },
  {
    "id": 1115,
    "category": 12,
    "difficulty": 2,
    "text": "Mit welchem Cursor-Attribut fragt man ab, ob die letzte FETCH-Anweisung keine Zeile mehr liefert?",
    "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR geöffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "%NOTFOUND"
      }
    ]
  },
  {
    "id": 1116,
    "category": 12,
    "difficulty": 2,
    "text": "Mit welchem Cursor-Attribut fragt man die Gesamtanzahl der bisher gelesenen Zeilen ab?",
    "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR geöffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "%ROWCOUNT"
      }
    ]
  },
  {
    "id": 1117,
    "category": 12,
    "difficulty": 3,
    "text": "Welche Datentypen oder zusammengesetzte Datentypen sind unter PL/SQL erlaubt?",
    "explanation": "PL/SQL kennt neben den SQL-Datentypen die eigenen Typen BOOLEAN und sogenannte Collections, die über TYPE ... is VARRAY OF ..., TYPE ... is TABLE  OF ... oder TYPE ... is RECORD OF ... definiert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DATE",
        "solution": "true"
      },
      {
        "text": "BOOLEAN",
        "solution": "true"
      },
      {
        "text": "TIMESTAMP",
        "solution": "true"
      },
      {
        "text": "TYPE ... is RECORD OF ...",
        "solution": "true"
      },
      {
        "text": "TYPE ... is TABLE  OF ...",
        "solution": "true"
      },
      {
        "text": "TYPE ... is VARRAY OF ...",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1120,
    "category": 13,
    "difficulty": 1,
    "text": "Das Mutating Table-Problem tritt auf",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Im  ORACLE PL/SQL",
        "solution": "true"
      },
      {
        "text": "in SQL 1999",
        "solution": "false"
      },
      {
        "text": "in IBM-DB2",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1135,
    "category": 13,
    "difficulty": 1,
    "text": "ORACLE-Trigger mit einer WHEN-Bedingung sind immer zeilenorientiert.",
    "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugehörigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgeführt (bei FALSE und NULL nicht). Sie muss immer in Klammern stehen.  \n\nZu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung geprüft, ob der Aktionsteil ausgeführt wird. \n\nDa Oracle keine Transitionstabellen kennt und Transitionsvariablen zu zeilenorienterten Triggern mit einer WHEN -Bedingung gehören, sind ORACLE-Trigger mit einer WHEN-Bedingung immer zeilenorientiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 918,
    "category": 14,
    "difficulty": 1,
    "text": "Welcher Prüfungszeitpunkt (CONSTRAINT_CHARACTERISTICA) führt dazu, dass beim Erkennen eines Fehlers die gesamte Transaktion zurückgerollt wird (Fehlerreaktion entspricht der ROLLBACK-Anweisung)?",
    "explanation": "Werden Datenänderungen ausgeführt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integritätsbedingung geprüft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung rückgängig gemacht. Die übrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen.\n\n\nDer COMMIT-Befehl löst das Transaktionsende aus und damit die Prüfung aller CONSTRAINTs (Integritätsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden während einer Transaktion erst mal akzeptiert und erst zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs geprüft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, führt dies zur Anzeige einer Fehlermeldung und zum Zurückrollen der gesamten Transaktion.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INITIALLY DEFERRED",
        "solution": "true"
      },
      {
        "text": "INITIALLY IMMEDIATE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 970,
    "category": 15,
    "difficulty": 3,
    "text": "Überlaufseiten",
    "explanation": "Überlaufseiten verlangsamen den Lesezugriff, da die ursprüngliche Speicherstruktur (ISAM oder HASH) zu einer linearen Liste ausarten kann, die sequentiell beim Lesen durchsucht werden muss.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "verlangsamen den Lesezugriff",
        "solution": "true"
      },
      {
        "text": "beschleunigen den Lesezugriff",
        "solution": "false"
      },
      {
        "text": "verlangsamen den Schreibzugriff",
        "solution": "false"
      },
      {
        "text": "beschleunigen den Schreibzugriff",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1245,
    "category": 14,
    "difficulty": 3,
    "text": "Wie heißt ein Ausführungsplan, der zu einem seriellen Ausführungsplan äquivalent ist?",
    "explanation": "Ein Ausführungsplan definiert eine (partielle) Reihenfolge der Operationen von verschiedenen Transaktionen.\n\nZwei Ausführungspläne heißen äquivalent, wenn die Ergebnisse ihrer Operationen in der Datenbasis gleich sind.\n\nBei einem seriellen Ausführungsplan wird jede Transaktion vollständig hintereinander ausgeführt.\n\nEin serialisierbarer Ausführungsplan ist ein geschachtelter Ausführungsplan, der zu einem seriellen Ausführungsplan äquivalent ist.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ein _____ Ausführungsplan.",
        "solution": "serialisierbarer"
      }
    ]
  },
  {
    "id": 921,
    "category": 14,
    "difficulty": 3,
    "text": "Wie heißen die Regeln, deren Einhaltung durch die Transaktionen die Serialisierbarkeit der Ausführungspläne garantieren?",
    "explanation": "Um nun für eine Menge von Transaktionen einen serialisierbaren Ausführungsplan zu finden, ist eine rege wissenschaftliche Diskussion8 geführt worden. Als Ergebnis wurden eine Vielzahl von Methoden entwickelt, die einen Test auf Serialisierbarkeit ermöglichen. Diese Verfahren haben im Wesentlichen zwei Nachteile. Zum einen sind sie sehr aufwändig, da sie meist auf graphentheoretischen Beweisen basieren. Zum anderen können sie erst im Nachhinein feststellen, ob der bereits ausgeführte Plan überhaupt serialisierbar ist, weil ihre Grundidee die Entdeckung von Fehlern ist. \n\n\nAus diesen beiden Gründen werden in kommerziellen Datenbanksystemen Protokolle wie z.B. das Zwei-Phasen-Sperr-Protokoll, das Zeitstempelordnungsprotokoll und das Multiversionsprotokoll verwendet, deren Einhaltung Serialisierbarkeit garantieren. Es werden also nicht im Nachhinein Fehler gesucht, sondern im Vorfeld Regeln definiert, deren Einhaltung die Serialisierbarkeit gewährleistet.\n\n\nNebenläufigkeitsprotokolle sind Regeln, deren Einhaltung durch alle beteiligten Transaktionen die Serialisierbarkeit garantiert. Damit ist eine hinreichende Voraussetzung für eine \"korrekte\" nebenläufige Ausführung garantiert.",
    "type": "text",
    "answers": [
      {
        "text": "Das sind",
        "solution": "Nebenläufigkeitsprotokolle"
      }
    ]
  },
  {
    "id": 922,
    "category": 14,
    "difficulty": 3,
    "text": "Welche der aufgelisteten Verfahren sind Nebenläufigkeitsprotokolle?",
    "explanation": "Um nun für eine Menge von Transaktionen einen serialisierbaren Ausführungsplan zu finden, ist eine rege wissenschaftliche Diskussion geführt worden. Als Ergebnis wurden eine Vielzahl von Methoden entwickelt, die einen Test auf Serialisierbarkeit ermöglichen. Diese Verfahren haben im Wesentlichen zwei Nachteile. Zum einen sind sie sehr aufwändig, da sie meist auf graphentheoretischen Beweisen basieren. Zum anderen können sie erst im Nachhinein feststellen, ob der bereits ausgeführte Plan überhaupt serialisierbar ist, weil ihre Grundidee die Entdeckung von Fehlern ist.\n\n\nAus diesen beiden Gründen werden in kommerziellen Datenbanksystemen Protokolle wie z.B. das Zwei-Phasen-Sperr-Protokoll, das Zeitstempelordnungsprotokoll und das Multiversionsprotokoll verwendet, deren Einhaltung Serialisierbarkeit garantieren. Es werden also nicht im Nachhinein Fehler gesucht, sondern im Vorfeld Regeln definiert, deren Einhaltung die Serialisierbarkeit gewährleistet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "2-Phasen-Sperrprotokoll",
        "solution": "true"
      },
      {
        "text": "Zeitstempel-Verfahren",
        "solution": "true"
      },
      {
        "text": "Lost-Update-Verfahren",
        "solution": "false"
      },
      {
        "text": "Multiversionsprotokolle",
        "solution": "true"
      }
    ]
  },
  {
    "id": 925,
    "category": 14,
    "difficulty": 2,
    "text": "Welche der folgenden Aussagen über Lese/Schreibsperren ist wahr?",
    "explanation": "Grundidee des Zwei-Phasen-Sperr-Protokolls ist das Sperren von Daten, auf die von verschiedenen Transaktionen gleichzeitig zugegriffen wird. Das einfache \"binäre\" Sperren mit den beiden Zuständen \"gesperrt\" (lock) und \"entsperrt\" (unlock) ist dabei zu grob. Es lässt zu wenig paralleles Arbeiten zu. Da dabei nicht zwischen der Art des Zugriffs unterschieden wird, kann sogar nicht mehr als ein Anwender lesend zugreifen, obwohl gemäß obiger Konfliktdefinition paralleles Lesen ja ungefährlich ist. Stattdessen wird eine verfeinerte Sperrtechnik mit drei Sperrzuständen verwendet, die die\nArt des Zugriffs berücksichtigt: \n\n1. lesend gesperrt (read_lock)\n2. schreibend gesperrt (write_lock)\n3. entsperrt (unlock)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Objekt wird exklusiv von einer Schreib-Transaktion gesperrt.",
        "solution": "true"
      },
      {
        "text": "Ein Objekt kann von mehreren Lese-Transaktionen gleichzeitig gesperrt werden.",
        "solution": "true"
      },
      {
        "text": "Ein Objekt wird exklusiv von einer Lese-Transaktion gesperrt.",
        "solution": "false"
      },
      {
        "text": "Ein Objekt kann von mehreren Schreib-Transaktionen gleichzeitig gesperrt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 926,
    "category": 14,
    "difficulty": 2,
    "text": "Dirty-Read ist möglich",
    "explanation": "Die Unterschiede bei den Isolationsgraden zwischen SQL2003 und Oracle basieren im Wesentlichen darauf, dass Oracle unsauberes Lesen (DIRTY READ) grundsätzlich ausschließt, womit der Isolationsgrad READ UNCOMMITTED entfällt. Zudem wird von Oracle der Unterschied zwischen den beiden Problemen Phantome und nicht wiederholbares Lesen als eher akademischer Natur betrachtet, womit der Isolationsgrad REPEATABLE READ ebenfalls entfällt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "unter ORACLE-SQL",
        "solution": "false"
      },
      {
        "text": "im SQL-Standard",
        "solution": "true"
      }
    ]
  },
  {
    "id": 927,
    "category": 14,
    "difficulty": 3,
    "text": "Bei welchem Konsistenzgrad unter ORACLE hat jede Anfrage der Transaktion eine eigene SCN (System change number)?",
    "explanation": "Konsistenzgrade sind bei Oracle realisiert mittels Multiversionsprotokollen: \n\nEs wird eine system change number (SCN) für jede Transaktion (Startzeit) vergeben.\nDie Rollback-Segmente enthalten geänderte Datensätze einer Tabelle (noch nicht 'committed' oder erst kürzlich) mit SCN. \nBeim Lesen von Datensätzen wird auch in den Rollback-Segmenten\nnach 'passenden Versionen' nachgeschaut.'Passende Versionen' sind 'committede' Datensätze mit SCN kleiner als SCN der Anfrage.\nBeim Konsistenzgrad 'transaction level' wird für jede Anfrage der Transaktion die SCN der Transaktion verwendet. \nBeim Konsistenzgrad 'statement level' wird für jede Anfrage der Transaktion eine eigene SCN vergeben.\nDie Konsistenzgrade werden über die SET TRANSACTION-Anweisung gesetzt. \n",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "transaction level",
        "solution": "false"
      },
      {
        "text": "statement level",
        "solution": "true"
      }
    ]
  },
  {
    "id": 928,
    "category": 14,
    "difficulty": 2,
    "text": "Bei welchem Konsistenzgrad unter ORACLE verwendet jede Anfrage der Transaktion die SCN (System change number) der Transaktion, also die gleiche SCN?",
    "explanation": "Konsistenzgrade sind bei Oracle realisiert mittels Multiversionsprotokollen: \n\nEs wird eine system change number (SCN) für jede Transaktion (Startzeit) vergeben.\nDie Rollback-Segmente enthalten geänderte Datensätze einer Tabelle (noch nicht 'committed' oder erst kürzlich) mit SCN.\nBeim Lesen von Datensätzen wird auch in den Rollback-Segmenten\nnach 'passenden Versionen' nachgeschaut.'Passende Versionen' sind 'committede' Datensätze mit SCN kleiner als SCN der Anfrage.\nBeim Konsistenzgrad 'transaction level' wird für jede Anfrage der Transaktion die SCN der Transaktion verwendet.\nBeim Konsistenzgrad 'statement level' wird für jede Anfrage der Transaktion eine eigene SCN vergeben.\nDie Konsistenzgrade werden über die SET TRANSACTION-Anweisung gesetzt.\n",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "transaction level",
        "solution": "true"
      },
      {
        "text": "statement level",
        "solution": "false"
      }
    ]
  },
  {
    "id": 929,
    "category": 14,
    "difficulty": 1,
    "text": "Bei welchem UPDATE-Verfahren werden Änderungen auf der Festplatte erst nach der COMMIT-Anweisung durchgeführt?",
    "explanation": "Recovery Basis-Techniken (für 'Nicht-Katastrophen-Fehler'): \nDeferred Update: \n\n Änderungen während der Transaktion nur in System-Log protokolliert \nauf der Platte werden sie erst beim COMMIT physisch aktualisiert \nbeim Zurückrollen kein Rückgängigmachen nötig \nNO-UNDO/REDO-Algorithmus\n\n\nImmediate Update:\n\nÄnderungen werden in System-Log protokolliert und unmittelbar auf der Platte physisch aktualisiert \nbeim Zurückrollen ist Rückgängigmachen notwendig  \nUNDO/NO-REDO-Algorithmus\n\n",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Deferred Update",
        "solution": "true"
      },
      {
        "text": "Immediate Update",
        "solution": "false"
      }
    ]
  },
  {
    "id": 234,
    "category": 7,
    "difficulty": 2,
    "text": "Mit welchem SQL-Befehl werden Daten in Tabellen verändert?",
    "explanation": "Mit der UPDATE-Anweisung können Mengen von Daten oder einzelne Datensätze in Tabellen verändert werden. Die Suchbedingung ist wie in der SELECT-Anweisung definiert. Die Wertzuweisung lässt einen NULL-Wert zu, einen Ausdruck wie bei der Default-Option der CREATE TABLE-Anweisung, oder einen Anfrageausdruck. Der Anfrageausdruck darf hier keine Datensatzmenge als Ergebnis liefern, sondern nur einen Datensatz. Je nachdem, ob in der SET-Klausel nur eine einzelne oder mehrere Spalten geändert werden, können inden Anfrageausdruck eine oder entsprechend auch mehrere Spalten selektiert werden.",
    "type": "text",
    "answers": [
      {
        "text": "Der Befehl heißt:",
        "solution": "UPDATE"
      }
    ]
  },
  {
    "id": 241,
    "category": 7,
    "difficulty": 3,
    "text": "Welcher SQL-Befehl kann eine SELECT-Abfrage enthalten?",
    "explanation": "Es gibt einen Befehl zum Einfügen von mehreren Datensätzen aus anderen Tabellen oder Sichten: \nINSERT INTO tabellenname AS SELECT (spaltenwert_1, ..., spaltenwert_n) FROM ... WHERE ...; \nBei den DML-Befehlen UPDATE und DELETE kann die SELECT-Anweisung in der WHERE-Klausel auftreten, um nur bestimmte Datensätze zu ändern bzw. zu löschen. Beim UPDATE können zudem SELECT-Anweisungen auch in der SET-Klausel verwendet werden, um neue Werte für den zu ändernden Datensatz zu ermitteln. \nBeim CREATE TABLE kann eine neue Tabellenstruktur erstellt und gleichzeitig mit Daten aus anderen Tabellen oder Sichten gefüllt werden. \nBeim DROP TABLE gibt es keine Verwendungsmöglichkeit für einen SELECT und ist daher auch nicht möglich. Eine Tabellen wird als Ganzes gelöscht, inklusive dem Tabelleninhalt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TABLE",
        "solution": "true"
      },
      {
        "text": "INSERT",
        "solution": "true"
      },
      {
        "text": "UPDATE",
        "solution": "true"
      },
      {
        "text": "DELETE",
        "solution": "true"
      },
      {
        "text": "DROP TABLE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 240,
    "category": 7,
    "difficulty": 2,
    "text": "Die folgende UPDATE-Anweisung ist syntaktisch korrekt:\nUPDATE TABELLE1 SET SPALTE1 = (SELECT SPALTE2 FROM TABELLE2);",
    "explanation": "Ein UPDATE_Befehl kann auch eine SELECT-Anweisung enthalten, wenn die Spalten der SET-Zuweisung mit der Spaltenliste der SELECT-Anweisung übereinstimmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 238,
    "category": 7,
    "difficulty": 1,
    "text": "Ein UPDATE-Befehl kann eine SELECT-Anweisung enthalten.",
    "explanation": "Die Wert-Zuweisung \"SET Spalte = ...\"  kann auch mit dem Ergebnis einer SELECT-Anweisung gefüllt werden, wenn die Datentypen übereinstimmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 242,
    "category": 10,
    "difficulty": 2,
    "text": "Der Datentyp \"Boolean\" wurde mit dem folgenden JDBC-Standard eingeführt:",
    "explanation": "Mit JDBC 2.0 wurden folgende Datentypen eingeführt: \n\nBLOB    in java.sql.Blob\nCLOB    in java.sql.Clob \nSTRUCT    in java.sql.Struct \nARRAY    in java.sql.Array \nREF    in java.sql.Ref",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "JDBC 1.0",
        "solution": "false"
      },
      {
        "text": "JDBC 2.0",
        "solution": "true"
      },
      {
        "text": "JDBC 3.0",
        "solution": "false"
      }
    ]
  },
  {
    "id": 253,
    "category": 11,
    "difficulty": 2,
    "text": "Bei SQLJ wird die Überprüfung des eingebetteten SQL-Codes erst zur Laufzeit vorgenommen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 254,
    "category": 11,
    "difficulty": 3,
    "text": "Mit welchem Schlüsselwort werden SQLJ-Klauseln eingeleitet?",
    "type": "text",
    "answers": [
      {
        "text": "Das Schlüsselwort ist",
        "solution": "#sql"
      }
    ]
  },
  {
    "id": 255,
    "category": 11,
    "difficulty": 3,
    "text": "Welche Endung besitzen SQLJ-Quelltexte?",
    "type": "text",
    "answers": [
      {
        "text": "Die Endung ist",
        "solution": ".sqlj"
      }
    ]
  },
  {
    "id": 258,
    "category": 10,
    "difficulty": 2,
    "text": "Welcher Treibertyp ist komplett in JAVA geschrieben und erfordert keinen zusätzlichen Binärcode auf dem CLIENT?",
    "explanation": "Treiber vom Typ 1: \n\nJDBC-ODBC-Bridge Bei diesem Treibertyp greift der JDBC-Treiber über die ODBC-Schnittstelle auf die Datenbank zu. Natürlich muss dazu auf jedem Client ein ODBC-Treiber installiert sein. Dieser Treibertyp bietet sich daher hauptsächlich in lokalen Netzwerken an, bei denen auf dem einzelnen Client leicht ODBC installiert werden kann. Außerdem ist durch den Zwischenschritt ODBC der Zugriff verhältnismäßig langsam.\n\nDa in der Frage explizit nach Binärcode auf dem Client gefragt ist, muss hier der Typ3  Treiber ebenfalls eine richtige Antwort sein, da der benötigte Anwendungsserver nicht auf dem Client vorhanden sein muss.\n\n\n\nTreiber vom Typ 2: \nNative-API partly-Java-Treiber Bei diesem Ansatz werden die JDBC-Aufrufe in ein datenbankspezifisches API auf dem Client weitergeben. Daher sind auch bei diesem Typ zusätzliche Installationen auf dem Client notwendig.\n\nTreiber vom Typ 3: \nJDBC-Net pure Java-Treiber Treiber vom Typ 3 übersetzen die JDBC-Aufrufe in ein vom DBMS unabhängiges Netzprotokoll und benutzen einen Anwendungsserver. Der Server übersetzt die Aufrufe in das jeweilige DBMS-Protokoll und über die CLI-Schnittstelle wird auf die Datenbank zugegriffen. Bei Treibern vom Typ 3 ist keine zusätzliche Client-Installation notwendig, aber ein Anwendungsserver.\n\n\nTreiber vom Typ 4:\nNative-Protocol pure Java-Treiber Bei diesem Treibertyp werden die JDBC-Aufrufe in ein datenbankeigenes Protokoll übersetzt, welches über das Netzwerk direkt auf den Datenbankserver zugreift. Es ist auch keine zusätzliche Client- Installation notwendig.  \n\n\nTreiber von Typ 3 und 4 sind appletfähig, die anderen beiden Typen nicht, da sie nicht komplett in Java geschrieben sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist ein Treiber vom Typ 1",
        "solution": "false"
      },
      {
        "text": "Das ist ein Treiber vom Typ 2",
        "solution": "false"
      },
      {
        "text": "Das ist ein Treiber vom Typ 3",
        "solution": "true"
      },
      {
        "text": "Das ist ein Treiber vom Typ 4",
        "solution": "true"
      }
    ]
  },
  {
    "id": 259,
    "category": 10,
    "difficulty": 1,
    "text": "Mit welchem Interface unter JDBC kann man Stored Routines (Procedures, Functions) in einer Datenbank aufrufen?",
    "explanation": "Das CallableStatement-Interface  dient zum Aufruf von Stored Procedures und Functions in der Datenbank. Diese Prozeduren und Funktionen können in Java selbst oder in einer Erweiterung von SQL wie PL/SQL von Oracle geschrieben sein. Das CallableStatement-Interface erbt vom PrepareStatement-Interface.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PreparedStatement",
        "solution": "false"
      },
      {
        "text": "CallableStatement",
        "solution": "true"
      },
      {
        "text": "Statement",
        "solution": "false"
      }
    ]
  },
  {
    "id": 260,
    "category": 10,
    "difficulty": 2,
    "text": "Von welchem Typ ist der Rückgabewert der Methode executeUpdate() des Interfaces \"Statement\"?",
    "explanation": "Das ResultSet hat den Rückgabewert int, in den eingetragen wird, ob der Datenbankzugriff erfolgreich war (1)  oder nicht(0)  oder je nach SQL-Anweisung auch die Anzahl der geänderten Datensätze.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "boolesch",
        "solution": "false"
      },
      {
        "text": "ResultSet",
        "solution": "false"
      },
      {
        "text": "int",
        "solution": "true"
      }
    ]
  },
  {
    "id": 262,
    "category": 6,
    "difficulty": 2,
    "text": "Welcher der folgenden CHECK-Constraints ist korrekt?",
    "explanation": "RICHTIG ist: \ngeschlecht VARCHAR2(1) CHECK (geschlecht IN ('W', 'M'))\nDa die CHECK-Bedingung für Tabellen- und Spalten-Constraints die gleiche Syntax aufweist, startet die Bedingung nach der öffenenden Klammer immer mit einem Spaltennamen. Der IN-Operator erwartet als zweiten Operanden eine Komma getrennte Liste konstanter Werte (unterschiedliche Werte gleichen Datentyps ohne Wiederholungen) oder eine SELECT-Anfrage, daher sind die OR-Operatoren dort völlig fehl am Platze.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "geschlecht VARCHAR2(1) CHECK (IN ('W', 'M'))",
        "solution": "false"
      },
      {
        "text": "geschlecht VARCHAR2(1) CHECK (geschlecht IN ('W', 'M'))",
        "solution": "true"
      },
      {
        "text": "geschlecht VARCHAR2(1) CHECK (geschlecht IN ('W' OR 'M'))",
        "solution": "false"
      }
    ]
  },
  {
    "id": 265,
    "category": 7,
    "difficulty": 1,
    "text": "Welche SELECT-Komponenten sind obligatorisch?",
    "explanation": "Eine SELECT-Anweisung muss mindestens eine Spalte aus einer Tabelle selektieren, also eine SELECT-Klausel und eine FROM-Klausel enthalten.\n Alle anderen Klauseln sind optional.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "FROM",
        "solution": "true"
      },
      {
        "text": "WHERE",
        "solution": "false"
      },
      {
        "text": "GROUP BY",
        "solution": "false"
      },
      {
        "text": "HAVING",
        "solution": "false"
      },
      {
        "text": "ORDER BY",
        "solution": "false"
      },
      {
        "text": "SELECT",
        "solution": "true"
      }
    ]
  },
  {
    "id": 269,
    "category": 11,
    "difficulty": 1,
    "text": "Was versteht man unter SQLJ unter eine HOST-Variablen?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HOST-Variable sind alle JAVA-Variablen, die static definiert sind.",
        "solution": "false"
      },
      {
        "text": "HOST Variablen sind JAVA-Variablen, die in einer SQLJ-Klausel auftreten.",
        "solution": "true"
      },
      {
        "text": "HOST-Variable gibt es unter SQLJ nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 270,
    "category": 11,
    "difficulty": 1,
    "text": "Durch welches Zeichen wird eine HOST-Variable in einer SQLJ-Klausel gekennzeichnet?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "!",
        "solution": "false"
      },
      {
        "text": "*",
        "solution": "false"
      },
      {
        "text": ":",
        "solution": "true"
      }
    ]
  },
  {
    "id": 275,
    "category": 11,
    "difficulty": 3,
    "text": "Mit welchem Schlüsselwort werden in SQLJ gespeicherte Funktionen (aus der Datenbank) aufgerufen?",
    "type": "text",
    "answers": [
      {
        "text": "Das Schlüsselwort ist:",
        "solution": "VALUES"
      }
    ]
  },
  {
    "id": 272,
    "category": 11,
    "difficulty": 1,
    "text": "Eine SQLJ-Klausel kann auch Werte zurückliefern",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 276,
    "category": 11,
    "difficulty": 3,
    "text": "Welches Konstrukt ist unter SQLJ mit dem ResultSet aus JDBC bzw. dem CURSOR in PL/SQL vergleichbar?",
    "type": "text",
    "answers": [
      {
        "text": "Das Konstrukt heißt:",
        "solution": "Iterator"
      }
    ]
  },
  {
    "id": 634,
    "category": 2,
    "difficulty": 2,
    "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung wird ein ER-Modell erstellt?",
    "explanation": "In der Analysephase werden die Systemfunktionen und Daten in groben Zügen geplant und festgelegt. Es wird eine explizite Systemdefinition in Form eines Lastenhefts vorgenommen. Dies geschieht umgangssprachlich in einer auch für Laien lesbaren Form. Außerdem werden die Daten mit Mitteln der Softwaretechnik, hier mit dem Entity-Relationship-Modell (kurz: ERM oder ER-Modell), genau beschrieben. Das ERM entspricht dem konzeptionellen Modell aus dem ANSI-3-Ebenen-Modell.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Implementierungsphase",
        "solution": "false"
      },
      {
        "text": "Analysephase",
        "solution": "true"
      },
      {
        "text": "Entwurfsphase",
        "solution": "false"
      }
    ]
  },
  {
    "id": 277,
    "category": 11,
    "difficulty": 1,
    "text": "Es gibt folgende Iteratortypen unter SQLJ",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "benannte Iteratoren",
        "solution": "true"
      },
      {
        "text": "unbenannte Iteratoren",
        "solution": "true"
      },
      {
        "text": "Iteratoren gibt es in SQLJ nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 279,
    "category": 11,
    "difficulty": 3,
    "text": "Durch welche Klasse werden in SQLJ Default-Verbindungen zu einer  Datenbank aufgebaut?",
    "type": "text",
    "answers": [
      {
        "text": "Die Klasse heißt:",
        "solution": "DefaultContext"
      }
    ]
  },
  {
    "id": 280,
    "category": 11,
    "difficulty": 2,
    "text": "Bei welchem JAVA-Programmtyp sind SQL-Fehlererkennungen schon zur Übersetzungszeit möglich?",
    "explanation": "null",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "JDBC",
        "solution": "false"
      },
      {
        "text": "SQLJ",
        "solution": "true"
      }
    ]
  },
  {
    "id": 291,
    "category": 7,
    "difficulty": 3,
    "text": "Welche der folgenden DELETE-Anweisungen ist korrekt?",
    "explanation": "Eine DELETE-Anweisung kann nur komplette Zeilen einer Tabelle, keine einzelnen Spaltenwerte, löschen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DELETE FROM Abteilungen;",
        "solution": "true"
      },
      {
        "text": "DELETE Abt_nr, Bezeichnung\nFROM Abteilungen;",
        "solution": "false"
      },
      {
        "text": "DELETE FROM TABLE Abteilungen;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 284,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welcher SELECT-Abfrage stellt man fest, ob eine Spalte vom Typ VARCHAR einen NULL-Wert hat?",
    "explanation": "Die einzige Möglichkeit, abzufragen, ob eine Spalte keinen Wert hat, ist im SQL-Standard \"IS NULL\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM Tabelle\nWHERE Spalte <> '';\n",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM Tabelle\nWHERE Spalte IS NULL;",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM Tabelle\nWHERE Spalte > 0;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 292,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem SQL-Befehl löscht man Tabellendefinitionen und gleichzeitig die Daten einer Tabelle?",
    "explanation": "Mit DELETE werden nur (einige) Datensätze gelöscht, die Struktur der Tabelle bleibt erhalten. \nMit DROP werden die Datensätze gelöscht und die Tabeellenstruktur zerstört, d.h. die Tabellendefinition aus dem Dictionary entfernt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DROP",
        "solution": "true"
      },
      {
        "text": "DELETE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 293,
    "category": 7,
    "difficulty": 3,
    "text": "Welchem Operator aus der relationalen Algebra entspricht der SQL-Ausdruck \"SELECT * FROM Teile, Artikel\"?",
    "explanation": "Eine SELECT-Anweisung auf mehreren Tabellen ohne WHERE-Klausel entspricht einen kartesischen Produkt bzw. einem Cross-Join. \n\nRA    SQL\n---------------\nProjektion     SELECT\nSelektion      WHERE \nKart. Produkt  FROM\nTheta Join     FROM + WHERE\nNatural Join   FROM + WHERE + ELECT\nVereinigung    UNION\nDifferenz      EXCEPT / MINUS / NOT IN / NOT EXISTS\nDurchschnitt    INTERSECTION\nDivision        \"doppeltes NOT EXISTS\" / \"Zählen\"",
    "type": "text",
    "answers": [
      {
        "text": "Dieser Operator heißt:",
        "solution": "kartesisches Produkt"
      }
    ]
  },
  {
    "id": 290,
    "category": 7,
    "difficulty": 2,
    "text": "Welche der folgenden Abfragen ist in SQL syntaktisch korrekt?",
    "explanation": "Eine Spalte, die nicht in der GROUP-BY-Klausel vorkommt, muss in der SELECT-Klausel eine Gruppenfunktion (AVG, SUM , MIN, MAX oder COUNT) haben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT      Abt_Nr\nFROM       Angestellte\nGROUP BY  Abt_Nr\nWHERE     COUNT(*) > = 5;",
        "solution": "false"
      },
      {
        "text": "SELECT      Abt_Nr\nFROM       Angestellte\nGROUP BY  Abt_Nr\nHAVING COUNT(*) > = 5;",
        "solution": "true"
      },
      {
        "text": "SELECT      Abt_Nr\nFROM       Angestellte\nWHERE     COUNT(*) > = 5;\nGROUP BY  Abt_Nr;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 294,
    "category": 7,
    "difficulty": 1,
    "text": "In Unterabfragen ist die ORDER-BY-Komponente vorgesehen.",
    "explanation": "Unterabfragen mit ORDER-BY machen keinen Sinn, da sie als ungeordnete Ergebnismenge genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "true"
      },
      {
        "text": "stimmt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 295,
    "category": 7,
    "difficulty": 1,
    "text": "Womit wird in einer SQL-Abfrage der Existenzquantor umgesetzt?",
    "explanation": "Der Existenzquantor wird mit dem EXISTS-Operator umgesetzt. \nBeim Allquantor wird es etwas schwieriger. In der Relationalen Algebra gibt es die Division, In SQL gibt es dafür gibt es keinen eigenen Operator. Man kann den Allquantor simulieren, entweder mittels einem \"doppelten NOT EXISTS\" oder durch zählen.",
    "type": "text",
    "answers": [
      {
        "text": "Der Ausdruck ist",
        "solution": "EXISTS"
      }
    ]
  },
  {
    "id": 660,
    "category": 6,
    "difficulty": 1,
    "text": "CONSTRAINTS sind eigene Datenbankobjekte, die unabhängig von einer Tabelle existieren.",
    "explanation": "Constraints werden nicht mit einem eigenen CREATE-Table-Befehl, sondern über ein ALTER-Table oder CREATE-Table angelegt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 682,
    "category": 5,
    "difficulty": 1,
    "text": "Bei welchem Beziehungstyp eines ER-Diagramms entsteht bei der Abbildung auf ein relationales Datenbankschema immer eine neue Relation?",
    "explanation": "Für n:m, cn:m, n:cm, cn:cm-Beziehungen im ERD gilt: \nFür beide (bzw. drei bei einer ternären Beziehung) Entity-Mengen und die Beziehung werden je eine Relation mit entsprechenden verbindenden Beziehungen erzeugt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1:1-Beziehung",
        "solution": "false"
      },
      {
        "text": "1:n-Beziehung",
        "solution": "false"
      },
      {
        "text": "n:m-Beziehung",
        "solution": "true"
      }
    ]
  },
  {
    "id": 685,
    "category": 1,
    "difficulty": 1,
    "text": "Das konzeptionelles Schema ist",
    "explanation": "Das konzeptionelle Schema ist Bestandteil der konzeptionenn Ebene des ANSI-3-Ebenen-Modells und daher unabhängig vom eingesetzten konkreten Datenbanksystem.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "unabhängig vom eingesetzten Datenbanksystem",
        "solution": "true"
      },
      {
        "text": "abhängig vom eingesetzten Datenbanksystem",
        "solution": "false"
      }
    ]
  },
  {
    "id": 663,
    "category": 6,
    "difficulty": 2,
    "text": "Bei einer materialisierten View (MV) wird nur der SELECT-Ausdruck der Sichtdefinition gespeichert. Die Daten werden also nicht redundant gespeichert.",
    "explanation": "Das ist die Definition der virtuellen View (VV).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 664,
    "category": 6,
    "difficulty": 2,
    "text": "Durch welches Zeichen wird in SQL die Konkatenation von Zeichenketten dargestellt?",
    "explanation": "In SQL ist es das Pipe-Zeichen: || ",
    "type": "text",
    "answers": [
      {
        "text": "Das Zeichen ist:",
        "solution": "||"
      }
    ]
  },
  {
    "id": 665,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem Zeichen in der SELECT-Klausel werden alle Spalten einer Tabelle bei einer SELECT-Anfrage ausgegeben?",
    "explanation": "SELECT * FROM tabellen WHERE ...; \nMit * werden immer alle Spalten aller Tabellen der FROM-Klausel ausgegeben.",
    "type": "text",
    "answers": [
      {
        "text": "Das Zeichen ist:",
        "solution": "*"
      }
    ]
  },
  {
    "id": 671,
    "category": 14,
    "difficulty": 2,
    "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Scenario verletzt?\n\nEine Transaktion enthält drei Update-Anweisungen. Nach der zweiten Update-Anweisung stürzt der Rechner ab. Nach dem erneuten Hochfahren des Rechners sind die Änderungen der ersten beiden Update-Anweisungen sichtbar, nicht jedoch die der dritten Update-Anweisung.",
    "explanation": "Es ist die \"Atomicity\"-Eigenschaft verletzt. \nDie Atomarität besagt, dass entweder alle Manipulationen einer Transaktion persistent in der DB gespeichert werden - oder gar nicht. Hier wird nur eine Teilmenge der Aktionen in der DB ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das verletzt die Eigenschaft A Atomicity.",
        "solution": "true"
      },
      {
        "text": "Das verletzt die Eigenschaft I Isolation",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft C Conistency.",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft D Durability.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 672,
    "category": 14,
    "difficulty": 1,
    "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Scenario verletzt?\n\nEine Transaktion fügt einen Satz mit einem Fremdschlüssel-Wert in eine Relation ein, der nicht als Primärschlüsselwert in der referenzierten Relation auftaucht.",
    "explanation": "Es ist die \"Consistency\"-Eigenschaft verletzt. \nDie Datenintegrität ist verletzt, denn die Fremdschlüssel-Eigenschaft stellt sicher, dass Fremdschlüsselwerte der einen Tabelle als Primärschlüsselwerte einer anderen Tabelle bereits vorhanden sind. Ist dies nicht der Fall, so muss das DBS die Änderung mit dem ungültigen Fremdschlüsselwert als fehlerhaft melden und zurückweisen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das verletzt die Eigenschaft I Isolation.",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft C Consistency.",
        "solution": "true"
      },
      {
        "text": "Das verletzt die Eigenschaft A Atomicity.",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft D Durability.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 669,
    "category": 14,
    "difficulty": 2,
    "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Scenario verletzt?\n\nEine Transaktion A ändert zwei Sätze S1 und S2. Eine zweite Transaktion B liest den Satz S1, bevor die Transaktion A einen Commit durchgeführt hat, und erhält den von der Transaktion A geänderten Wert des Satzes S1.",
    "explanation": "Es ist die \"Isolation\"-Eigenschaft verletzt. \nDie zweite Transaktion liest geänderte Werte der ersten Transaktion, ohne das die diese Änderungen bereits dauerhaft in der DB gespeichert hat (\"commited\") hat. Beide Transaktionen laufen also nicht isoliert nebeneinander ab, sondern beeinflussen sich.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das verletzt die Eigenschaft A Atomicity.",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft I Isolation.",
        "solution": "true"
      },
      {
        "text": "Das verletzt die Eigenschaft C Consistency.",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft D Durability.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 670,
    "category": 14,
    "difficulty": 2,
    "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Scenario verletzt?\n\nEine Transaktion enthält zwei Insert-Anweisungen und wird mit Commit abgeschlossen. Anschließend passiert ein Plattenfehler. Nach den Recovery-Maßnahmen sind die eingefügten Sätze nicht mehr vorhanden.",
    "explanation": "Es ist die \"Durability\"-Eigenschaft verletzt. \nEs wurden Datensätze persistent gespeichert (\"commited\"), die nach dem Fehler nicht wieder rekonstruiert werden konnten, somit wurde die Anforderung der \"Dauerhaftigkeit\" verletzt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das verletzt die Eigenschaft C Consistency.",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft I Isolation.",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft A Atomicity.",
        "solution": "false"
      },
      {
        "text": "Das verletzt die Eigenschaft D Durability.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 102,
    "category": 13,
    "difficulty": 3,
    "text": "In welchen Data-Dictionary-Tabellen sind unter ORACLE Informationen zu CONSTRAINTS enthalten?",
    "explanation": "Das Dictionary von Oracle umfasst eine Vielzahl von Tabellen bzw. Sichten. Sie sind in verschiedene Gruppen aufgeteilt, die im Namen deutlich werden:\n\n    USER_...: Sichten für alle DB-Objekte, die ein Benutzer selbst angelegt hat.\n\n    ALL_...: Sichten für alle DB-Objekte, die ein Benutzer selbst angelegt hat bzw. für die er von anderen Anwendern Zugriffsrechte bekommen hat.\n\n    DBA_...: Sichten für alle DB-Objekte, die überhaupt in der Datenbank existieren. Auf diese Sichten hat nur ein Benutzer mit Administrationsrechten Zugriff.\n\n    V$-Views: Sichten mit statistischen Informationen.\n\n    \n\n    USER_CONSTRAINTS gibt Auskunft über die vom Anwender angelegten Constraints.\n\n    USER_CONS_COLUMNS gibt Auskunft über die von den Constraints betroffenen Spalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "USER_CONSTRAINTS",
        "solution": "true"
      },
      {
        "text": "CONSTRAINT_INFO",
        "solution": "false"
      },
      {
        "text": "USER_CONS_COLUMNS",
        "solution": "true"
      }
    ]
  },
  {
    "id": 108,
    "category": 10,
    "difficulty": 2,
    "text": "Was bedeutet die folgende Abkürzung (JDBC)?",
    "explanation": "Wer näheres Wissen will, sollte bei SUN selber nachschlagen: \n\n<a href= \"http://java.sun.com/j2se/1.4.2/docs/api/java/sql/package-summary.html\"> JDBC-Dokumentation bei Sun .",
    "type": "text",
    "answers": [
      {
        "text": "JDBC =",
        "solution": "Java Database Connectivity"
      }
    ]
  },
  {
    "id": 930,
    "category": 14,
    "difficulty": 1,
    "text": "Bei welchem UPDATE-Verfahren werden Änderungen auf der Festplatte unmittelbar physisch durchgeführt?",
    "explanation": "Recovery Basis-Techniken (für 'Nicht-Katastrophen-Fehler'): \nDeferred Update: \n\n Änderungen während der Transaktion nur in System-Log protokolliert\nauf der Platte werden sie erst beim COMMIT physisch aktualisiert \nbeim Zurückrollen kein Rückgängigmachen nötig\nNO-UNDO/REDO-Algorithmus\n\n\nImmediate Update:\n\nÄnderungen werden in System-Log protokolliert und unmittelbar auf der Platte physisch aktualisiert\nbeim Zurückrollen ist Rückgängigmachen notwendig \nUNDO/NO-REDO-Algorithmus\n",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Deferred Update",
        "solution": "false"
      },
      {
        "text": "Immediate Update",
        "solution": "true"
      }
    ]
  },
  {
    "id": 971,
    "category": 15,
    "difficulty": 1,
    "text": "Welche Aussage ist korrekt?",
    "explanation": "Die Daten werden über die Indexspalte(n) aufsteigend sortiert. Aus jedem Block wird der größte Schlüsselwert als Repräsentant vermerkt und in einer gesonderten Struktur, dem Index abgelegt. Der Index ordnet also jedem Block ein Intervall der möglichen Schlüsselwerte zu. Der ISAM-Index ist ein dünner Index mit logischen Adressen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der ISAM-Index ist ein dünner Index mit logischen Adressen.",
        "solution": "true"
      },
      {
        "text": "Der ISAM-Index ist ein dichter Index mit logischen Adressen.",
        "solution": "false"
      },
      {
        "text": "Der ISAM-Index ist ein dünner Index mit physischen Adressen.",
        "solution": "false"
      },
      {
        "text": "Der ISAM-Index ist ein dichter Index mit physischen Adressen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 932,
    "category": 14,
    "difficulty": 2,
    "text": "Die SET-Transaction-Anweisung unter ORACLE und SQL haben die gleiche Syntax.",
    "explanation": "SQL-Anweisung SET TRANSACTION (Oracle Auszug): \nSET TRANSACTION { { READ { ONLY | WRITE } \n                  | ISOLATION LEVEL {SERIALIZABLE | READ COMMITTED}};\n  \n\nSQL-Anweisung SET TRANSACTION (SQL-Standard Auszug): \nSET TRANSACTION { READ UNCOMMITTED \n                | READ COMMITTED \n                | REPEATABLE READ \n                | SERIALIZABLE } } ;",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 935,
    "category": 10,
    "difficulty": 2,
    "text": "Welches Interface bietet in JDBC die Möglichkeit, Parameter zu verarbeiten?",
    "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface. CallableStatement  und PreparedStatement  können Parameter mit dem Platzhalter \"?\" aufnehmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CallableStatement",
        "solution": "true"
      },
      {
        "text": "PreparedStatement",
        "solution": "true"
      },
      {
        "text": "Statement",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1240,
    "category": 12,
    "difficulty": 3,
    "text": "Welcher Parametertyp unter PL/SQL ermöglicht eine Wertzuweisung?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. Bei IN OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "false"
      },
      {
        "text": "OUT",
        "solution": "true"
      },
      {
        "text": "IN OUT",
        "solution": "true"
      }
    ]
  },
  {
    "id": 976,
    "category": 15,
    "difficulty": 1,
    "text": "Berechnen Sie die HASH-Funktion 28 modulo 9!",
    "explanation": "Die Modul-Funktion ist das Teilen mit Rest, also hier der Rest der beim Teilen von 28 durch 9 entsteht: Das ist 1.",
    "type": "text",
    "answers": [
      {
        "text": "Das Ergebnis ist",
        "solution": "1"
      }
    ]
  },
  {
    "id": 983,
    "category": 13,
    "difficulty": 1,
    "text": "Welche Transitionsvariablen gibt es unter PL/SQL?",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": ":BIG",
        "solution": "false"
      },
      {
        "text": ":SMALL",
        "solution": "false"
      },
      {
        "text": ":OLD",
        "solution": "true"
      },
      {
        "text": ":NEW",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1241,
    "category": 12,
    "difficulty": 1,
    "text": "Welche Parametertypen gibt es unter PL/SQL?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "TO",
        "solution": "false"
      },
      {
        "text": "OUT",
        "solution": "true"
      },
      {
        "text": "IN OUT",
        "solution": "true"
      },
      {
        "text": "OUT IN",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1242,
    "category": 10,
    "difficulty": 1,
    "text": "Was versteht man unter \"Impendence Mismatch\" ?",
    "explanation": "Das ist der grundsätzliche Widerspruch zwischen der mengenorientierten Verarbeitung in SQL und der Einzelverarbeitung von Datensätzen in einer prozeduralen Programmiersprache, der zwischen . JAVA oder PL/SQL und SQL auftritt. Während in SQL eine mengenorienterte Verarbeitung erfolgt, muss das in einer Progerammiersprache über Konstrukte wie einen Cursor oder ein RESULT-Set nachgebaut werden",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist der grundsätzliche Widerspruch zwischen der mengenorientierten Verarbeitung in SQL und der Einzelverarbeitung von Datensätzen in einer prozeduralen Programmiersprache.",
        "solution": "true"
      },
      {
        "text": "Das sind Erweiterungen von prozeduralen Programmiersprachen um datenbankspezifische Sprachkonstrukte.",
        "solution": "false"
      },
      {
        "text": "Diesen Begriff gibt es im Zusammenhang mit Datenbanken nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 985,
    "category": 13,
    "difficulty": 1,
    "text": "Rekursive Trigger sind unter ORACLE-PL/SQL nicht zugelassen.",
    "explanation": "Trigger können durch DML-Anweisungen oder eben auch durch Datenbanktrigger ausgelöst werden, wobei auch rekursive Trigger syntaktisch zugelassen sind. Für die Semantik ist dann der Programmierer selber zuständig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 984,
    "category": 13,
    "difficulty": 1,
    "text": "Ein Trigger kann sich selber oder einen anderen Trigger anstoßen.",
    "explanation": "Trigger können durch DML-Anweisungen oder eben auch durch Datenbanktrigger ausgelöst werden, wobei auch rekursive Trigger syntaktisch zugelassen sind. Für die Semantik ist dann der Programmierer selber zuständig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Stimmt",
        "solution": "true"
      },
      {
        "text": "Stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 993,
    "category": 9,
    "difficulty": 3,
    "text": "In welcher Sprache können die Methoden zu einem benutzerdefinierten Typ unter ORACLE programmiert werden?",
    "explanation": "PL/SQL ist hier Standardsprache, Java ist auch möglich, da in der Datenbankserver eine virtuelle JAVA-Maschine integriert ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PL/SQL",
        "solution": "true"
      },
      {
        "text": "JAVA",
        "solution": "true"
      },
      {
        "text": "PHP",
        "solution": "false"
      },
      {
        "text": "C",
        "solution": "true"
      },
      {
        "text": "C++",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1244,
    "category": 14,
    "difficulty": 1,
    "text": "Was versteht man beim Transaktionshandling unter einem Konflikt von Datenbankoperationen?",
    "explanation": "RICHTIG ist:\n\"Ein Konflikt liegt vor, wenn die Operationen unterschiedlichen Transaktionen T1, ..,Tn angehören, sie auf das gleiche Objekt zugreifen und mindestens eine Operation eine Schreiboperation ist.\"\n\nDie anderen beiden Definitionen sind insofern falsch, als die eine gar keine Schreiboperation vorgibt und die andere höchstens eine Schreiboperation. Die Schreiboperation ist die kritische Aktion bei einem Konflikt, Leseoperationen können beliebig paralell ausgeführt werden, und davon kann es beliebig viele geben, die koordiniert werden müssen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Konflikt liegt vor, wenn die Operationen unterschiedlichen Transaktionen T1,...,Tn angehören, sie auf das gleiche Objekt zugreifen und höchsten eine Operation eine Schreiboperation ist.",
        "solution": "false"
      },
      {
        "text": "Ein Konflikt liegt vor, wenn die Operationen unterschiedlichen Transaktionen T1,...,Tn angehören, sie auf das gleiche Objekt zugreifen und keine Operation eine Schreiboperation ist.",
        "solution": "false"
      },
      {
        "text": "Ein Konflikt liegt vor, wenn die Operationen unterschiedlichen Transaktionen T1, ..,Tn angehören, sie auf das gleiche Objekt zugreifen und mindestens eine Operation eine Schreiboperation ist.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 395,
    "category": 7,
    "difficulty": 1,
    "text": "Welche Prioritätsreihenfolge habe die logischen Operatorn unter SQL? \nTragen Sie bitte 1, 2, 3 oder 4 ein!",
    "explanation": "Prioritätenreihenfolge der Operatoren (es ist die gleiche wie bei der Relationalen Algebra)\nPriorität Operator\n1         Alle Vergleichsoperatoren\n2         NOT\n3         AND\n4         OR",
    "type": "text",
    "answers": [
      {
        "text": "OR",
        "solution": "4"
      },
      {
        "text": "Vergleichssoperatoren",
        "solution": "1"
      },
      {
        "text": "AND",
        "solution": "3"
      },
      {
        "text": "NOT",
        "solution": "2"
      }
    ]
  },
  {
    "id": 404,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie die folgende Abfrage an einen Angestellten / Abteilungs -Tabelle:\nMan finde die Abteilungsnummern von Abteilungen in Dortmund, in denen es Angestellten gibt, die weniger als 2000 verdienen. Welche Abfrage liefert das gewünschte Ergebnis?",
    "explanation": "Wenn die Tabellen der FROM-Klausel nicht mit einer Join-Bedingungen (hier AB.Abt_NR = a.Abt_Nr ) verknüft sind, liefert die SELECT-Anweisung das kartesische Produkt der beteiligten Tabellen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT A.Abt_NR \nFROM Angestellte A, Abteilungen AB\nWHERE AB.Ort = 'Dortmund' \nAND a.Gehalt < 2000;\n",
        "solution": "false"
      },
      {
        "text": "SELECT A.Abt_NR \nFROM Angestellte A, Abteilungen AB\nWHERE AB.Abt_NR = a.Abt_NR\nAND AB.Ort = 'Dortmund' \nAND a.Gehalt < 2000;\n",
        "solution": "true"
      }
    ]
  },
  {
    "id": 400,
    "category": 6,
    "difficulty": 1,
    "text": "Bei einem  COLUMN-CONSTRAINT",
    "explanation": "Ein COLUMN-Constraint kann sich nur auf eine Spalte beziehen, ein TABLE-Constraint auch auf mehrere Spalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "können mehrere Spalten betroffen sein",
        "solution": "false"
      },
      {
        "text": "sind immer mehrere Spalten betroffen",
        "solution": "false"
      },
      {
        "text": "kann nur eine Spalte betroffen sein",
        "solution": "true"
      },
      {
        "text": "ist überhaupt keine Spalte betroffen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 406,
    "category": 1,
    "difficulty": 2,
    "text": "In einer Datenbank sollen alle Daten widerspruchsfrei gespeichert werden.",
    "explanation": "Das ist die Definition von konsistenten Daten.",
    "type": "text",
    "answers": [
      {
        "text": "Diese Eigenschaft nennt man:",
        "solution": "Konsistenz"
      }
    ]
  },
  {
    "id": 407,
    "category": 1,
    "difficulty": 1,
    "text": "Bei welchem Datenmodell werden die Daten in einem Baum gespeichert?",
    "explanation": "Ein hierarchisches Datenbankmodell ist historisch gesehen das älteste Datenbankmodell, es bildet die reale Welt durch eine hierarchische Baumstruktur ab und wurde später Grundlage des Netzwerkdatenmodells. Es entstand schon in den 50er Jahren und wurde Grundlage des Systems IMS/DB der Firma IBM. \nHeutzutage erlebt die hierarchische Datenspeicherung eine Renaissance in Verbindung mit XML-Datenbanken.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Relationales Datenmodell",
        "solution": "false"
      },
      {
        "text": "Hierarchisches Datenmodell",
        "solution": "true"
      },
      {
        "text": "Netzwerkdatenmodell",
        "solution": "false"
      }
    ]
  },
  {
    "id": 473,
    "category": 14,
    "difficulty": 1,
    "text": "In einer Datenbank können Daten zeitweise auf verschiedenen Ebenen gesperrt werden, damit der einzelne Benutzer ungestört und vollständig seine Transaktionen abschließen kann.",
    "explanation": "Das LOGGING-System ist dafür zuständig, alle Informationen zu protokollieren, die für ein Zurückrollen von Transaktionen aber auch zur Rekonstruktion nach DBS-Abstürzen notwendig sind. \nDas LOCKING-System sorgt dafür, dass Datensätze für Änderungen exklusiv gesperrt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Aufgabe leistet das Locking-System.",
        "solution": "true"
      },
      {
        "text": "Diese Aufgabe leistet das Logging-System.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 481,
    "category": 7,
    "difficulty": 3,
    "text": "Folgende Aussagen treffen auf virtuelle VIEWS zu:",
    "explanation": "Nur auf einfachen Views, z.B. ohne GROUP-BY, können UPDATE-Operationen durchgeführt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Auf Views können Benutzerrechte vergeben werden.",
        "solution": "true"
      },
      {
        "text": "In VIEWS können die gleichen UPDATE-Operationen durchgeführt werden, wie auf Tabellen.",
        "solution": "false"
      },
      {
        "text": "Auf Views können Abfragen (SELECT) gestartet werden",
        "solution": "true"
      }
    ]
  },
  {
    "id": 496,
    "category": 4,
    "difficulty": 3,
    "text": "Bei welchen Operatoren der relationalen Algebra müssen alle Attribute der beteiligten Relationen übereinstimmen, d.h. die gleiche Anzahl an Attributen, die gleiche Reihenfolge der Attribute, gleicher Datentyp/vergleichbarer Inhalt sowie gleicher Attributname? (vereinigungskonform)",
    "explanation": "Die Bedingung der \"Vereinigungskonformität\" gilt für alle drei Mengenoperatoren, nicht aber für die Join-Operatoren, die ja auf dem Kartesischen Produkt basieren und auch nicht für die Division. Bei der Division gilt die syntaktische Restriktion, dass die Attribute der Relation, durch die geteilt wird, eine echte Teilmenge der Attribute der Relation sein müssen, die dividiert wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "UNION",
        "solution": "true"
      },
      {
        "text": "JOIN",
        "solution": "false"
      },
      {
        "text": "DIFFERENZ",
        "solution": "true"
      },
      {
        "text": "DURCHSCHNITT",
        "solution": "true"
      },
      {
        "text": "DIVISION",
        "solution": "false"
      }
    ]
  },
  {
    "id": 497,
    "category": 4,
    "difficulty": 1,
    "text": "Welcher Join-Operator unterdrückt doppelte Join-Attribute?",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit geprüft und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "EQUI-Join",
        "solution": "false"
      },
      {
        "text": "Natural-Join",
        "solution": "true"
      },
      {
        "text": "Outer-Join",
        "solution": "false"
      },
      {
        "text": "Theta-Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 499,
    "category": 4,
    "difficulty": 1,
    "text": "Welcher Join-Operator kommt in der relationalen Algebra nicht vor?",
    "explanation": "Den SuperJoin gibt es nicht. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft. \nEin Equi-Join ist ein Theta-Join, der im Selektionsprädikat nur den Vergleichsoperator \"=\" zulässt. \nDer Outer-Join (beidseitiger, vollständiger äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgefüllt\nwerden, die beim natürlichen Join herausfallen würden.   \nZudem gibt es noch die linken und rechten Outer Join-Operatoren. Der linke Outer-Join (linker äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdrückt werden, als Tupel mit aufgeführt und in den Attributen, die zu R2 gehören, mit NULL-Werten aufgefüllt werden. \nDer rechte Outer-Join (rechter äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdrückt werden, als Tupel mit aufgeführt und in den Attributen, die zu R1 gehören, mit NULL-Werten aufgefüllt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Natural Join",
        "solution": "false"
      },
      {
        "text": "Equi Join",
        "solution": "false"
      },
      {
        "text": "Super Join",
        "solution": "true"
      },
      {
        "text": "Outer Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 507,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie die folgende Frage an die beiden Tabellen Angestellten und Abteilungen: In welchen Abteilungen sind alle Berufe der Unternehmung vertreten? Welche der folgenden Abfragen liefert das gewünschte Ergebnis?",
    "explanation": "Da es hier darum geht, die Abteilungen mit \"ALLEN\" Berufen zu ermitteln, handelt es sich um eine sogennate  Allaussage (Allquantor) und der wird ja bekanntlich in der Relationalen Algebra mittels der Division realisiert. In SQL fehlt ein solcher Operator leider. Aber wie aus der Logik bekannt, kann ein Allquantor mittels einem \"doppelte negierten Existenzquantor\" simuliert werden. Diese Anfrage hat wörtlich genommen die Semantik: \"Zeigen Sie die Abteilungen, für die es KEINE Berufe gibt, die es NICHT in der Firma gibt\" (vgl. mit Originalanfrage: semantisch äquivalent)\n\n    \n\n    Ein alternativer Lösungsansatz zählt die verschiedenen Berufe und ermittelt dann die Abteilungen mit der gleichen Anzahl an verschiedenen Berufen.\n\n    \n\n    SELECT A.Abt_NR, MAX(COUNT(A.Beruf))\n\n    FROM Angestellte A , Abteilungen B\n\n    WHERE A.Abt_Nr = B.Abt_Nr\n\n    GROUP BY A.Abt_nr\n\n    Diese Anfrage ist syntaktisch nicht ausführbar, da bei der Verwendung der MAX-Funktion in der SELECT-Klausel keine weiteren Spalten zulässig sind. MAX liefert nur einen Datensatz, es könnten aber durchaus mehrere Abteilungen alle Berufe enthalten.\n\n    \n\n    SELECT Abt_NR, Beruf\n\n    FROM Angestellte\n\n    WHERE beruf = ALL\n\n    (SELECT DISTINCT Beruf FROM Angestellte)\n\n    Diese Anfrage liefert immer die leere Menge, sobald mehr als zwei verschiedene Berufe in der Angestellten-Tabelle vorkommen. Denn für jeden Angestellten wird sein eingetragener Beruf verglichen, ob er gleich allen Datensätzen der Unteranfrage ist. Ein Wert kann aber niemals GLEICH mit mehreren unterschiedlichen Werten sein.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT A1.Abt_Nr, A1.Name FROM Abteilungen A1\n\n      WHERE NOT EXISTS ( SELECT * FROM Angestellte A2\n\n          WHERE NOT EXISTS ( SELECT * FROM Angestellte A3 WHERE a2.Beruf = a3.Beruf AND a1.Abt_NR = a3.Abt_nr))",
        "solution": "true"
      },
      {
        "text": "SELECT Abt_NR, Beruf\nFROM Angestellte \nwhere beruf = ALL \n  (SELECT Beruf FROM Angestellte)",
        "solution": "false"
      },
      {
        "text": "SELECT Abt_NR, COUNT( DISTINCT Beruf) FROM Angestellte\n\n       GROUP By Abt_NR HAVING COUNT ( DISTINCT beruf) = (SELECT COUNT ( DISTINCT Beruf) FROM angestellte)",
        "solution": "true"
      },
      {
        "text": "SELECT A.Abt_NR, MAX(COUNT(A.Beruf))\nFROM Angestellte A , Abteilungen B\nWHERE A.Abt_Nr = B.Abt_Nr\nGROUP BY A.Abt_nr",
        "solution": "false"
      }
    ]
  },
  {
    "id": 501,
    "category": 7,
    "difficulty": 1,
    "text": "Welche der folgenden Aussagen ist wahr?",
    "explanation": "Die GROUP BY-Klausel sorgt für die Gruppierung entsprechend den Werten in den aufgeführten Spalten. Nachdem gruppiert wurde, kann - muss aber nicht - mittels der HAVING-Klausel eine Bedingung für diese Gruppen formuliert werden, die diese erfüllen müssen. Da die HAVING-Klausel eine Bedingung für die Gruppen formuliert, macht eine HAVING-Klausel ohne GROUP BY keinen Sinn.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nach jeder GROUP-BY-Klausel muss eine HAVING-Klausel folgen",
        "solution": "false"
      },
      {
        "text": "Nach einer GROUP-BY-Klausel kann eine HAVING-Klausel folgen",
        "solution": "true"
      },
      {
        "text": "Eine HAVING-Klausel kann auch ohne GROUP BY vorkommen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 505,
    "category": 7,
    "difficulty": 3,
    "text": "Welche SELECT-Anweisung beantwortet die folgende Frage an die beíden Tabellen \"Auto\" und \"Sonderausstattung\":\nWelche Autos haben keine Sonderausstattung?",
    "explanation": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr\nDieses SELECT hat eine so unsinnige Semantik, dass sie sich kaum in Worte fassen lässt: Formal ist es die \"Komplementmenge des Natural Joins zum kartesischen Produkt\". Wem dafür eine Semantik einfällt, darf sich gerne melden - wird honoriert :-) versprochen :-) \n\nSELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)\nDer NOT IN wäre ja gut, wenn da nicht vorher der Natural Join zwischen Auto und Sonderausstattung wäre. Mit dem Natural Join werden alle Autos mit Sonderausstattung ermittelt und anschließend geprüft, ob sie keine Sonderaustattung haben. Da wird wohl immer die leere Menge herauskommen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr",
        "solution": "false"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)",
        "solution": "false"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr = B.SerienNr \nAND   B.Sonderausstattung IS NULL",
        "solution": "false"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A\nWHERE A.SerienNr NOT IN (\n      SELECT SerienNr FROM Sonderausstattung)",
        "solution": "true"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr NOT EXISTS(\n      SELECT SerienNr FROM Sonderausstattung)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 553,
    "category": 4,
    "difficulty": 3,
    "text": "Wie heißt die Mengenoperation, die mit Einschränkungen die gleiche Ergebnismenge liefert wie der Natural Join?",
    "explanation": "Natural Join und Intersection (Durchschnitt) sind beides Operationen, die nur die Tupel zurückliefern, die in beiden Relationen vorhanden sind. \nZu den Unterschieden zwischen beiden Operationen gehört, dass beim Natural Join die Ergebnisdatenmenge aus den Attributen beider Relationen besteht, während beim Intersection die Attributstrukturen der beiden Relationen <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  sein müssen.",
    "type": "text",
    "answers": [
      {
        "text": "Die Operation heißt (englische Bezeichung)",
        "solution": "Intersection"
      }
    ]
  },
  {
    "id": 1105,
    "category": 12,
    "difficulty": 1,
    "text": "Unter PL/SQL gibt es öffentliche und private Prozeduren.",
    "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder öffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind öffentlich und können damit von außerhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und können damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 511,
    "category": 1,
    "difficulty": 2,
    "text": "Daten sollen in einer Datenbank nicht mehrfach gespeichert werden.",
    "explanation": "Unter Redundanz versteht man die Mehrfachspeicherung von Daten in unterschiedlichen Dateien. Werden an unterschiedlichen Stellen in einem Unternehmen entsprechende Daten dezentral erfasst und verarbeitet, lassen sich diese Ansprüche ohne zusätzliche Logistik kaum realisieren.",
    "type": "text",
    "answers": [
      {
        "text": "Diese Eigenschaft nennt man:",
        "solution": "redundanzfrei"
      }
    ]
  },
  {
    "id": 512,
    "category": 1,
    "difficulty": 3,
    "text": "Ein Datenbanksystem besteht aus",
    "explanation": "Ein Datenbanksystem (DBS) ist eine Ansammlung von Daten, die allen Benutzern bzw. Anwendungen zur Verfügung steht und in der die Daten nach einheitlichen Regeln abgespeichert werden. Ein Datenbanksystem besteht aus einer Datenbasis und einem Datenbankmanagementsystem. Der Begriff der Datenbank wird synonym verwendet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Datenbasis",
        "solution": "true"
      },
      {
        "text": "Datenmodell",
        "solution": "false"
      },
      {
        "text": "Anwendungsprogrammen",
        "solution": "false"
      },
      {
        "text": "Data Dictionary",
        "solution": "true"
      },
      {
        "text": "Verwaltungssoftware für die Datenbasis (DBMS)",
        "solution": "true"
      },
      {
        "text": "Metadaten",
        "solution": "true"
      }
    ]
  },
  {
    "id": 515,
    "category": 1,
    "difficulty": 1,
    "text": "Welches Datenmodell ist in einer Baumstruktur organisiert?",
    "explanation": "Das hierarchisches Datenbankmodell ist das älteste Datenbankmodell, es bildet die reale Welt durch eine hierarchische Baumstruktur ab und wurde später Grundlage des Netzwerkdatenmodells. Es entstand schon in den 60erJahren und wurde Grundlage des Systems IMS/DB der Firma IBM. Heutzutage erlebt die hierarchische Datenspeicherung eine Renaissance in Verbindung mit XML.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Relationales Modell",
        "solution": "false"
      },
      {
        "text": "Netzwerkdatenmodell",
        "solution": "false"
      },
      {
        "text": "Hierarchisches Datenmodell",
        "solution": "true"
      },
      {
        "text": "B-Baum-Modell",
        "solution": "false"
      }
    ]
  },
  {
    "id": 530,
    "category": 1,
    "difficulty": 2,
    "text": "Die Programme sind von der internen Organisation der Daten und den Zugriffsmöglichkeiten über Zugriffspfade unabhängig.",
    "explanation": "Das ist die Definition der physische Datenunabhängigkeit.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Eigenschaft nennt man vertikale, logische  Datenunabhängigkeit.",
        "solution": "false"
      },
      {
        "text": "Diese Eigenschaft nennt man horizontale, logische Datenunabhängigkeit.",
        "solution": "false"
      },
      {
        "text": "Diese Eigenschaft nennt man physische Datenunabhängigkeit.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 517,
    "category": 1,
    "difficulty": 2,
    "text": "Bei welchem Datenmodell werden Adressverweise in der Datenbank gespeichert?",
    "explanation": "Bis auf die relationalen Datenbanken war es bei älteren Systemen, also den Netzwerkdatenbanken und den hierachischen Datenbanken, üblich, neben den Daten selber auch phyikalische Adressverweise in der Datenbank zu speichern.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Hierarchisches Modell",
        "solution": "true"
      },
      {
        "text": "Objektorientiertes Modell",
        "solution": "false"
      },
      {
        "text": "Relationales Modell",
        "solution": "false"
      },
      {
        "text": "Netzwerk-Datenmodell",
        "solution": "true"
      }
    ]
  },
  {
    "id": 529,
    "category": 1,
    "difficulty": 1,
    "text": "Programme sind stabil gegenüber Änderungen in anderen Programmen, die Anwendungsprogramme sind untereinander unabhängig.",
    "explanation": "Diese Eigenschaft ist die Definition der horizontalen, logischen Datenunabhängigkeit.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Eigenschaft nennt man vertikale, logische  Datenunabhängigkeit.",
        "solution": "false"
      },
      {
        "text": "Diese Eigenschaft nennt man horizontale, logische  Datenunabhängigkeit.",
        "solution": "true"
      },
      {
        "text": "Diese Eigenschaft nennt man physische Datenunabhängigkeit.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 531,
    "category": 11,
    "difficulty": 3,
    "text": "In welche Richtung können HOST-Variable unter SQLJ Daten austauschen?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "von SQL nach JAVA",
        "solution": "true"
      },
      {
        "text": "in beiden Richtungen",
        "solution": "true"
      },
      {
        "text": "von JAVA nach SQL",
        "solution": "true"
      }
    ]
  },
  {
    "id": 521,
    "category": 1,
    "difficulty": 3,
    "text": "Welche Aufgaben hat ein Datenbankadministrator?",
    "explanation": "Die Hauptaufgaben des Datenbankadministrators sind:\n\nDatenbankdesign, Anlegen der Datenbank \nSoftwareinstallation und -wartung \nSpeicherplatzverwaltung \nImplementierung von Sicherheitsmechanismen \nLaden von Daten\nBackup und Recovery\nReorganisation von Datenbeständen\nSystembeobachtung und -Tuning",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Datenbankdesign",
        "solution": "true"
      },
      {
        "text": "Systemanalyse",
        "solution": "false"
      },
      {
        "text": "Anwendungsentwicklung",
        "solution": "false"
      },
      {
        "text": "Backup und Recovery",
        "solution": "true"
      },
      {
        "text": "Tuning",
        "solution": "true"
      },
      {
        "text": "Speicherplatzverwaltung",
        "solution": "true"
      },
      {
        "text": "Beantwortung von Ad-Hoc-Abfragen an die Datenbank",
        "solution": "false"
      }
    ]
  },
  {
    "id": 522,
    "category": 1,
    "difficulty": 2,
    "text": "Welche Aufgaben hat ein Datenbankentwickler?",
    "explanation": "SystemanalyseUnter Systemanalyse versteht man den Entwurf des konzeptionellen Datenbankmodells,\nz.B. die Erstellung eines ER-Modells, die Erstellung einer kompletten Aufgabenbeschreibung\nund die Abstimmung von Lasten- und Pflichtenheften, sowie die Abstimmung mit\nbestehenden Applikationen und die Einbindung in ein komplexes Datenmodell.\nAd-hoc-AbfragenSystementwickler haben die Aufgabe, den Datenbestand zu beobachten, zu analysieren\nund Benutzeranfragen, die nicht fest programmiert werden müssen, auszuwerten.\nDazu werden verschiedene SQL-Werkzeuge, die für den Endanwender nicht geeignet\nsind, eingesetzt.\nAnwendungsentwicklungHierzu gehören die Entwicklung von Masken und Reports und die Programmierung\nvon schriftlichen Dokumenten. Zum Einsatz kommen Programmiersprachen der\n4. Generation, wie PL/SQL von Oracle, Java oder C, auch um die Datenbank an das\nInternet anzubinden. Daneben ist eine Hauptaufgabe die Erstellung von Datenbankprozeduren\nund Datenbanktriggern, die in der Datenbank selbst abgespeichert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Softwareinstallation und Wartung",
        "solution": "false"
      },
      {
        "text": "Systemanalyse",
        "solution": "true"
      },
      {
        "text": "Backup und Recovery",
        "solution": "false"
      },
      {
        "text": "Anwendungsentwicklung",
        "solution": "true"
      },
      {
        "text": "Beantwortung von Benutzerfragen, die nicht fest programmiert werden sollen",
        "solution": "true"
      },
      {
        "text": "Speicherplatzverwaltung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 525,
    "category": 1,
    "difficulty": 2,
    "text": "Zu welcher Ebene einer Datenbankarchitektur gehört die Integritätsprüfung?",
    "explanation": "Die Integritätsprüfung ist Bestandteil der Anfrageverarbeitungsebene.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1. Ebene: Verarbeitung von Benutzereingaben",
        "solution": "false"
      },
      {
        "text": "2. Ebene: Anfrageverarbeitung",
        "solution": "true"
      },
      {
        "text": "3. Ebene: Zugriffsstrukturen und Codeerzeugung",
        "solution": "false"
      },
      {
        "text": "4. Ebene: Synchronisation paralleler Zugriffe",
        "solution": "false"
      },
      {
        "text": "5. Ebene: Speicherverwaltung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 526,
    "category": 1,
    "difficulty": 1,
    "text": "Zu welcher Ebene einer Datenbankarchitektur gehört der Parser?",
    "explanation": "Das ist die Ebene der Verarbeitung von Benutzereingaben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "3. Ebene: Zugriffsstrukturen und Codeerzeugung",
        "solution": "false"
      },
      {
        "text": "4. Ebene: Synchronisation paralleler Zugriffe",
        "solution": "false"
      },
      {
        "text": "5. Ebene: Speicherverwaltung",
        "solution": "false"
      },
      {
        "text": "1. Ebene: Verarbeitung von Benutzereingaben",
        "solution": "true"
      },
      {
        "text": "2. Ebene: Anfrageverarbeitung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1107,
    "category": 12,
    "difficulty": 1,
    "text": "Wo deklariert man eine öffentliche Prozedur unter PL/SQL?",
    "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder öffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind öffentlich und können damit von außerhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und können damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "im Package Header einer Paketdefinition",
        "solution": "true"
      },
      {
        "text": "im Package Body einer Paketdefinition",
        "solution": "false"
      },
      {
        "text": "solch einen Typ gibt es unter PL/SQL nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 420,
    "category": 3,
    "difficulty": 1,
    "text": "ER-Modell: Um welchen Beziehungstyp handelt es sich hier?\nEin Student kann eine, keine oder mehrere Vorlesungen hören und eine Vorlesung kann von keinem, einem oder mehreren Studenten besucht werden.",
    "explanation": "Das ist die Definition einer cn:cm-Beziehung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "m:n",
        "solution": "false"
      },
      {
        "text": "1:n",
        "solution": "false"
      },
      {
        "text": "cn:cm",
        "solution": "true"
      }
    ]
  },
  {
    "id": 425,
    "category": 6,
    "difficulty": 2,
    "text": "Der Datentyp \"Künstlicher Schlüssel / Surrogate-Key\" gehört zum SQL2003-Standard.",
    "explanation": "So einen Datentypen gibt es gar nicht. \"Surrogate Keys/Künstliche Primärschlüssel\" ist ein Konzept für kleine, effiziente Primärschlüssel, die die Vorteile haben, platzsparend beim Speichern und schnell beim Suchen und Lesen zu sein. Gemeint sind damit Primärschlüssel, die der Anwender gar nicht zu Gesicht bekommt, also rein anwendungsintern verwaltet werden, die aus nur einer Spalte bestehen, die einen numerischen Datentyp hat und, die mit einer fortlaufenden Nummer gefüllt wird. Diese fortlaufende Nummer kann in SQL mittels einer SEQUENCE generiert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 426,
    "category": 14,
    "difficulty": 3,
    "text": "Was versteht man unter den ACID-Eigenschaften einer Transaktion? (Begriffe bitte in Englisch eintragen)",
    "explanation": "A  Atomicity Transaktionen sind atomar, also als unteilbare Einheiten zu betrachten. Transaktionen werden ganz oder gar nicht ausgeführt.\nC  Consistency Eine Transaktion überführt eine Datenbank von einem konsistenten Zustand in einen anderen konsistenten Zustand. Ein Datenzustand heißt konsistent, wenn alle Daten semantisch richtig, also im Anwendungskontext korrekt sind.\nI  Isolation Transaktionen laufen isoliert ab. Obwohl im Mehrbenutzerbetrieb gleichzeitig mehrere Transaktionen abgearbeitet werden, läuft jede einzelne Transaktion wie in einem simulierten Einbenutzerbetrieb ab.\nD  Durability Die Ergebnisse einer Transaktion werden dauerhaft (persistent) in der Datenbank gespeichert.",
    "type": "text",
    "answers": [
      {
        "text": "A steht für",
        "solution": "Atomicity"
      },
      {
        "text": "C steht für",
        "solution": "Consistency"
      },
      {
        "text": "I steht für",
        "solution": "Isolation"
      },
      {
        "text": "D steht für",
        "solution": "Durability"
      }
    ]
  },
  {
    "id": 428,
    "category": 14,
    "difficulty": 2,
    "text": "Um Datensicherheit zu gewährleisten und ein Zurückfahren der Datenbank nach Datenbankfehlern zu ermöglichen, werden alle Transaktionen, die in der Datenbank ablaufen, mitprotokolliert.",
    "explanation": "Das LOGGING-System ist dafür zuständig, alle Informationen zu protokollieren, die für ein Zurückrollen von Transaktionen aber auch zur Rekonstruktion nach DBS-Abstürzen notwendig sind. \nDas LOCKING-System sorgt dafür, das Datensätze für Änderungen exclusiv gesperrt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Aufgabe leistet das Locking-System.",
        "solution": "false"
      },
      {
        "text": "Diese Aufgabe leistet das Logging-System.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 431,
    "category": 14,
    "difficulty": 2,
    "text": "Welcher Lock-Typ erlaubt anderen Benutzern lesende Zugriffe auf die Tabellen, die mit diesem Lock-Typ gesperrt wurden?",
    "explanation": "1. Typ: XLOCKS oder EXKLUSIVE LOCKS\nEin XLOCK bewirkt, dass keine andere Transaktion eine Sperrung auf ein Objekt, das schon einen XLOCK hat, absetzen kann. Der XLOCK wird bis zum Ende der Transaktion gehalten.\n\n2.Typ: SHARED LOCKS oder SLOCKS (geteilte LOCKS )\nFalls eine Transaktion T1 einen SLOCK auf eine Tabelle hält, heißt das, dass sie nur lesend zugreifen wird. Eine andere Transaktion T2 kann parallel auch einen SLOCK absetzen, wenn nur Lesezugriffe beabsichtigt sind. Allerdings kann eine Transaktion T3 keinen XLOCK auf die betroffene Tabelle absetzen, bis alle SLOCKS wieder gelöscht sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "XLOCK",
        "solution": "false"
      },
      {
        "text": "SLOCK",
        "solution": "true"
      },
      {
        "text": "EXCLUSIVE LOCK",
        "solution": "false"
      }
    ]
  },
  {
    "id": 433,
    "category": 14,
    "difficulty": 1,
    "text": "Wie nennt man das Verfahren, das nach folgender Methode verfährt:\n\n- Man nimmt an, dass viele schreibende Zugriffe auf die Datenbank stattfinden. \n- Auch lesende Zugriffe lösen Sperren für andere Benutzer aus. \n- Die Daten werden erst wieder freigegeben, wenn alle Änderungen abgespeichert sind.",
    "explanation": "Passive und dynamische Sperrverfahren gibt es nicht.\n\nOptimistisches Sperrverfahren \nMan nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden. Lesende Zugriffe (SELECT) lösen keine Sperren aus.\nJeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird. Bei Änderungen wird zunächst geprüft, ob der Zeitstempel unverändert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unverändert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.\n\nPessimistisches Sperrverfahren\nMan nimmt an, dass viele schreibende Zugriffe auf der Datenbank stattfinden.Auch lesende Zugriffe (SELECT FOR UPDATE statt SELECT) lösen Sperren für andere Benutzer aus.Die Daten werden erst wieder freigegeben, wenn alle Änderungen abgespeichert sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "optimistisch",
        "solution": "false"
      },
      {
        "text": "pessimistisch",
        "solution": "true"
      },
      {
        "text": "dynamisch",
        "solution": "false"
      },
      {
        "text": "passiv",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2488,
    "category": 4,
    "difficulty": 3,
    "text": "Bei der Ausführung welcher Operatoren können Duplikate (doppelte Tupel) auftreten, die aber in der RA automatisch unterdrückt werden (automatische Duplikatelimination)?",
    "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen können, diese automatisch eliminiert werden. Zu diesen Operatoren gehören Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: später bei SQL sind Duplikate zugelassen, aber nicht in der RA.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Projektion",
        "solution": "true"
      },
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "false"
      },
      {
        "text": "Join (NATURAL, THETA, EQUI, )",
        "solution": "false"
      },
      {
        "text": "OUTER JOIN (LEFT, RIGHT, FULL)",
        "solution": "false"
      },
      {
        "text": "Vereinigung",
        "solution": "true"
      },
      {
        "text": "Durchschnitt",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Division",
        "solution": "true"
      },
      {
        "text": "Es gibt keinen solchen Operator in der RA.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2489,
    "category": 4,
    "difficulty": 3,
    "text": "Welche der folgenden Operatoren der relationalen Algebra müssen der Anforderung genügen, \"vereinigungskonform\" zu sein?",
    "explanation": "Die Forderung in der Relationalen Algebra <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt für alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Relationen (Eingangsdatenmengen) müssen die gleichen Attributdefinitionen aufweisen: \nDie Anzahl der Attribute muss übereinstimmen. \nDie Attribute müssen gleich heißen.  \nDie Datentypen der der Attribute müssen gleich sein.  \nDie Reihenfolge der Attribute muss übereinstimmen. \nAchtung: In SQL wird diese Definition leicht variieren (keine gleichen Attributnamen).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "false"
      },
      {
        "text": "Join (NATURAL, THETA, EQUI, )",
        "solution": "false"
      },
      {
        "text": "OUTER JOIN (LEFT, RIGHT, FULL)",
        "solution": "false"
      },
      {
        "text": "Vereinigung",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "true"
      },
      {
        "text": "Durchschnitt",
        "solution": "true"
      },
      {
        "text": "Division",
        "solution": "false"
      },
      {
        "text": "Es gibt keine solche Anforderung in der RA.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2490,
    "category": 4,
    "difficulty": 3,
    "text": "Welche der folgende Aussagen über den Natural Join sind wahr?",
    "explanation": "Der Natural Join ist ableitbar aus dem kartesischen Produkt mit anschließender Selektion gemäss der implizit definierten Natural Join-Bedingung über alle Attribute, die gleichheißen, und abschließender Projektion, so dass die gleichheißenden Attribute nur einmal in der Ergebnismenge vorkommen. \nGrundoperatoren sind Operatoren, die nicht simuliert werden können und damit ist der Natural Join keiner.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Für die Verknüpfungsbedingung werden nur die Fremd- und Primärschlüsselattribute, die gleich heißen, auf Gleichheit mit einander verglichen.",
        "solution": "false"
      },
      {
        "text": "Die Attribute, die in beiden Relationen namensgleich vorkommen, treten in der Ergebnismenge nur einmal auf.",
        "solution": "true"
      },
      {
        "text": "Er kann simuliert werden durch die RA-Operatoren kartesisches Produkt, Selektion, Projektion.",
        "solution": "true"
      },
      {
        "text": "Er ist kein Grundoperator der relationalen Algebra.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 544,
    "category": 3,
    "difficulty": 1,
    "text": "Von welchem Grad sind binäre Beziehungen?",
    "explanation": "Das ist eine schwierige Frage :-), die an die  philosophische Fakultät weitergegeben wurde.",
    "type": "text",
    "answers": [
      {
        "text": "Sie sind vom Grad (als Zahl eintragen):",
        "solution": "2"
      }
    ]
  },
  {
    "id": 434,
    "category": 14,
    "difficulty": 2,
    "text": "Bei welchem LOCK-Verfahren wird ein Zeitstempel verwendet?",
    "explanation": "Passive und dynamische Sperrverfahren gibt es nicht.\n\nOptimistisches Sperrverfahren \nMan nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden. Lesende Zugriffe (SELECT) lösen keine Sperren aus.\nJeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird. Bei Änderungen wird zunächst geprüft, ob der Zeitstempel unverändert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unverändert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.\n\nPessimistisches Sperrverfahren\nMan nimmt an, dass viele schreibende Zugriffe auf der Datenbank stattfinden.Auch lesende Zugriffe (SELECT FOR UPDATE statt SELECT) lösen Sperren für andere Benutzer aus.Die Daten werden erst wieder freigegeben, wenn alle Änderungen abgespeichert sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "pessimistische Verfahren",
        "solution": "false"
      },
      {
        "text": "optimistische Verfahren",
        "solution": "true"
      },
      {
        "text": "dynamische Verfahren",
        "solution": "false"
      },
      {
        "text": "passive Verfahren",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1093,
    "category": 15,
    "difficulty": 1,
    "text": "Welche Speicherstruktur hat folgende Eigenschaften:\n\nDie Daten werden über die Indexspalte(n) aufsteigend sortiert. \nAus jedem Block wird der größte Schlüsselwert als Repräsentant vermerkt und in einer gesonderten Tabelle abgelegt.\nDer Index ordnet jedem Block ein Intervall der möglichen Schlüsselwerte zu.",
    "explanation": "Das ist die Definition des ISAM-Index, der z.B. bei Mysql mit MyISAM verwendet wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "ISAM",
        "solution": "true"
      },
      {
        "text": "B+ Baum",
        "solution": "false"
      },
      {
        "text": "HASH",
        "solution": "false"
      }
    ]
  },
  {
    "id": 444,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welcher Ergänzung zu DROP TABLE... löscht man alle Fremdschlüssel-CONSTRAINTS, die diese Tabelle referenzieren?",
    "explanation": "Specify CASCADE CONSTRAINTS to drop all referential integrity constraints that refer to primary and unique keys in the dropped table. If you omit this clause, and such referential integrity constraints exist, then the database returns an error and does not drop the table.",
    "type": "text",
    "answers": [
      {
        "text": "Der Befehl heißt:",
        "solution": "CASCADE CONSTRAINTS"
      }
    ]
  },
  {
    "id": 445,
    "category": 7,
    "difficulty": 1,
    "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN ORDER BY Nachname DESC\"",
    "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel-",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "bewirkt eine absteigende Sortierung über den Nachnamen",
        "solution": "true"
      },
      {
        "text": "bewirkt eine aufsteigende Sortierung über den Nachnamen",
        "solution": "false"
      },
      {
        "text": "bewirkt eine Gruppierung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 450,
    "category": 3,
    "difficulty": 1,
    "text": "In ER-Diagrammen können Beziehungen auch Attribute haben.",
    "explanation": "Beziehungen in ER-Modellen können Attribute haben, auch wenn das viele grafische ER-Zeichentools leider nicht unterstützen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 452,
    "category": 10,
    "difficulty": 2,
    "text": "Mit der Methode getString des ResultSets kann man",
    "explanation": "getXXX(), z.B. getString(...),  liefern im ResultSet den Wert einer Spalte zurück, wobei man über die Spaltennummer oder über den Spaltennamen zugreifen kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "über die Spaltennummer zugreifen",
        "solution": "true"
      },
      {
        "text": "über den Spaltenname zugreifen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 453,
    "category": 7,
    "difficulty": 2,
    "text": "Zur DML-Sprache gehören die folgenden Befehle:",
    "explanation": "DDL (Data Definition Language): CREATE, ALTER, DROP, RENAME, ... \nDML (Data Manipulation Language): INSERT, UPDATE, DELETE \nDQL (Data Query Language): SELECT",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE",
        "solution": "false"
      },
      {
        "text": "INSERT",
        "solution": "true"
      },
      {
        "text": "UPDATE",
        "solution": "true"
      },
      {
        "text": "ALTER",
        "solution": "false"
      },
      {
        "text": "RENAME",
        "solution": "false"
      }
    ]
  },
  {
    "id": 455,
    "category": 7,
    "difficulty": 3,
    "text": "In welcher SELECT-Klausel sind Gruppenfunktionen (COUNT, MIN, MAX, AVG, SUM) erlaubt, wenn der SELECT keinen SUBSELECT enthält?",
    "explanation": "In der WHERE-Klausel sind keine Gruppenfunktionen erlaubt, da sich die Where-Klausel auf einzelne Zeilen, nicht auf eine Menge von Zeilen bezieht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "In der FROM-Klausel",
        "solution": "false"
      },
      {
        "text": "In der WHERE-Klausel",
        "solution": "false"
      },
      {
        "text": "In der GROUP-BY-Klausel",
        "solution": "false"
      },
      {
        "text": "in der HAVING-Klausel",
        "solution": "true"
      },
      {
        "text": "In der ORDER-BY-Klausel",
        "solution": "true"
      },
      {
        "text": "In der SELECT-Klausel",
        "solution": "true"
      }
    ]
  },
  {
    "id": 458,
    "category": 4,
    "difficulty": 3,
    "text": "Mit welchen Operatoren der relationalen Algebra lässt sich der Natural-Join-Operator simulieren?",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft. \n \nDas erreicht man damit, dass zuerst ein Kartesisches Produkt ausgeführt wird (damit hat man alle Attribute beider Relationen nebeneinander stehen), dann werden nur die Tupel in die Ergebnismenge übernommen für die die Join-Bedingung zu \"wahr\" ausgewertet wird (die Inhalte aller gleichlautenden Attribute werden auf Gleichheit geprüft). Abschließend müssen noch die doppelten gleichlautenden Attribute entfernt werden aus der Ergebnismenge und das kann mit einer Projektion erreichen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Division",
        "solution": "false"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Selektion",
        "solution": "true"
      },
      {
        "text": "Projektion",
        "solution": "true"
      }
    ]
  },
  {
    "id": 462,
    "category": 4,
    "difficulty": 2,
    "text": "Jemand schlägt vor, als Primärschlüssel einer Auftragspositionen-Relation nicht die Kombination von AuftragsNr und und ArtikelNr (wie bisher) zu wählen, sondern nur die AuftragsNr. Was würde das bedeuten?",
    "explanation": "Ist nur die AuftragsNr Primärschlüsselattribut, so kann in der Auftragspositionen-Relation jede Auftragsnummer nur einmal vorkommen, mit der Konsequenz, dass es je Auftrag nur einen Artikel geben kann. \nGrund dafür ist die Eigenschaft der Eindeutigkeit bei (Primär-)Schlüsseln.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Auftrag besteht höchsten aus einem Artikel.",
        "solution": "true"
      },
      {
        "text": "Ein Artikel kann insgesamt nur einmal bestellt werden.",
        "solution": "false"
      },
      {
        "text": "Es macht keinen Unterschied zur anderen Lösung.",
        "solution": "false"
      },
      {
        "text": "Keine dieser Antworten ist korrekt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 465,
    "category": 11,
    "difficulty": 2,
    "text": "Mit welchem Aufruf werden in SQLJ in der Datenbank gespeicherte Prozeduren aufgerufen?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "execute",
        "solution": "false"
      },
      {
        "text": "call",
        "solution": "true"
      },
      {
        "text": "start",
        "solution": "false"
      }
    ]
  },
  {
    "id": 466,
    "category": 10,
    "difficulty": 3,
    "text": "Mit welchem Isolationsgrad (Konstante der Methode setTransactionIsolation des Interfaces connection) werden im Datenbanksystem unter JDBC keine Sperren mehr gesetzt?",
    "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgeführt.",
    "type": "text",
    "answers": [
      {
        "text": "Der Isolationsgrad heißt",
        "solution": "TRANSACTION_NONE"
      }
    ]
  },
  {
    "id": 468,
    "category": 4,
    "difficulty": 2,
    "text": "Welche der folgenden Aussagen über die relationale Algebra ist wahr?",
    "explanation": "Selektion ist die Auswahl von Tupeln und Projektion die Auswahl von Attributen. \nDie Ergebnismenge eines kartesischen Produkts angewendet auf zwei Relationen mit je n bzw. m Tupeln umfasst n x m Tupel. \nDie Division (Allaussage, Allquantor) könnte man zwar analog zu SQL mittels einer doppelten Differenz und vielen anderen Operatoren simulieren, aber als eine spezielle Form der Differenz kann sie wahrlich nicht bezeichnet werden. \nDie beiden Operatoren Selektion und der Projektion als Grundoperationen reichen nicht, um alle Operatoren der relationalen Algebra abzuleiten. Es fehlt u.a. ein so wichtiger Operator wie das Kartesische Produkt, dem einzigen Grundoperator, mit dem man die Tupel \"nebeneinander verknüpfen kann\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion ist die Auswahl von Attributen und Projektion die Auswahl von Tupeln.",
        "solution": "false"
      },
      {
        "text": "Die Ergebnismenge eines kartesischen Produkts angewendet auf zwei Relationen mit je n bzw. m Tupeln umfasst n x m Tupel.",
        "solution": "true"
      },
      {
        "text": "Die Division ist eine spezielle Form der Differenz.",
        "solution": "false"
      },
      {
        "text": "Alle Operatoren der relationalen Algebra lassen sich aus der Selektion und der Projektion als Grundoperationen ableiten.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 469,
    "category": 4,
    "difficulty": 2,
    "text": "Betrachten Sie zwei Relationen Artikel(ArtikelNr, Bezeichnung...)und Auftragspositionen (AuftragsNr, ArtikelNr, Menge...). Die Relation Auftragspositionen enthält einen Fremdschlüssel zu dem Attribut ArtikelNr in der Relation Artikel. Die Relation Artikel soll jetzt nur noch Einträge enthalten, die auch wenigstens einmal gekauft wurden. Kann man das Problem lösen, indem man ArtikelNr in ARTIKEL als zusätzlichen Fremdschlüssel deklariert, der auf das Attribut ArtikelNr in der Relation Auftragspositionen referenziert?",
    "explanation": "An dieser Stelle lösen Fremdschlüssel, die man in beiden Richtungen vereinbaren kann, nicht das Problem, da sie sich gegenseitig behindern und so das Einfügen von Daten generell verhindern würden. Denkbar sind allerdings Datenbanktrigger zur Lösung dieses Problems.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nein. Das wäre kein gültiger Fremdschlüssel.",
        "solution": "false"
      },
      {
        "text": "Man kann den Fremdschlüssel deklarieren, aber er würde das Problem nicht lösen.",
        "solution": "true"
      },
      {
        "text": "Ja",
        "solution": "false"
      }
    ]
  },
  {
    "id": 470,
    "category": 7,
    "difficulty": 1,
    "text": "Welche SQL-Abfragen liefern das gleiche Ergebnis?",
    "explanation": "Der BETWEEN-Vergleichsoperator schließt die Grenzwerte beim Vergleich mit ein, so dass die WHERE-Klausel \"Gehalt >= 3000  AND  Gehalt <= 3600\" die gleichen Datensätze in der Ergebnisdatenmenge liefert. \nIN vergleicht nur mit den beiden Werten 3000 und 3600, aber nicht die Zwischenwerte 3001 ... 3599.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt BETWEEN 3000 AND 3600;",
        "solution": "true"
      },
      {
        "text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt > 3000 \nAND     Gehalt < 3600",
        "solution": "false"
      },
      {
        "text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt >= 3000 \nAND     Gehalt <= 3600",
        "solution": "true"
      },
      {
        "text": "SELECT     Nachname, Vorname, Gehalt\nFROM     Angestellte\nWHERE     Gehalt IN (3000, 3600)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 472,
    "category": 7,
    "difficulty": 3,
    "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nDer Vertriebsleiter Dr. Guck der Firma Byce & Co. möchte herausfinden, für welche Artikel überhaupt Aufträge vorliegen. Er stellt diese Anfrage an die EDV-Abteilung. Welche der folgenden Anfragen liefert das gewünschte Ergebnis?",
    "explanation": "Man kann diese Anfrage mittels Natural Join, IN-, EXISTS-Operator lösen. Mann kann auch eine Anfrage in einer FROM-Klausel formulieren. \n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN (SELECT * FROM Auftraege b \n        WHERE a.TNr = b.TNr); \nDiese Anfrage ist falsch, weil sie syntaktisch nicht richtig ist. Wenn der linke Operand des IN-Operators die TNR ist, dann können beim rechten Operanden nicht alle Spalten für die Ergebnismenge selektiert werden. Statt SELECT * müsste hier SELECT TNR stehen. Und dann wäre die WHERE-Klausel beim Sub-SELECT überflüssig. \n\n\nSELECT      DISTINCT a.TNr,  a.Bezeichnung\nFROM         Artikel a, (SELECT * FROM Auftragspositionen) b;\nDiese Anfrage ist falsch, weil statt einem Natural Join nur ein kartesisches Produkt formuliert wurde. Es fehlt z.B. eine WHERE-Klausel mit  WHERE      a.Tnr = b.Tnr; \n\n\nSELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;\nDiese Anfrage ist falsch, weil sie syntaktisch nicht richtig ist. \nDie Spalte Bezeichnung gibt es nicht in der Auftragspositionen-Tabelle, sondern nur in der Artikel-Tabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;",
        "solution": "true"
      },
      {
        "text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN (SELECT * FROM Auftraege b \n        WHERE a.TNr = b.TNr);",
        "solution": "false"
      },
      {
        "text": "SELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS \n        (SELECT b.TNR FROM Auftragspositionen b \n                  WHERE a.TNR = b.TNR);",
        "solution": "true"
      },
      {
        "text": "SELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;",
        "solution": "true"
      },
      {
        "text": "SELECT      DISTINCT a.TNr,  a.Bezeichnung\nFROM         Artikel a, (SELECT * FROM Auftragspositionen) b;",
        "solution": "false"
      },
      {
        "text": "SELECT      a.TNr, a.Bezeichnung\nFROM         Artikel a\nWHERE       TNR IN (SELECT TNr FROM Auftragspositionen);",
        "solution": "true"
      },
      {
        "text": "SELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1098,
    "category": 15,
    "difficulty": 1,
    "text": "Welche Speicherstruktur ist bei einem direkten Zugriff über den Primärschlüssel schneller?",
    "explanation": "Da bei einer HASH-Struktur ist beim Zugriff über den Primärschlüsssel am schnellsten, da keine zusätzlichen Daten von der Festplatte gelesen werden müssen. Der HASH-Algorithmus liefert direkt die Adresse des zugeordneten Blocks.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "B+ Baum",
        "solution": "false"
      },
      {
        "text": "HASH",
        "solution": "true"
      }
    ]
  },
  {
    "id": 220,
    "category": 7,
    "difficulty": 3,
    "text": "Das \"IN\"-Prädikat hat unter der SELECT-Anweisung in SQL folgende Eigenschaften:",
    "explanation": "Die rechte Vergleichsmenge des IN-Operators kann entweder eine Menge konstanter Werte gleichen Typs aber ohne Duplikate sein oder es wird an dieser Stelle eine SELECT-Anfrage ausgeführt und mit deren Ergebnismenge verglichen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die rechte Vergleichsmenge darf Konstanten gleichen Typs enthalten.",
        "solution": "true"
      },
      {
        "text": "Die rechte Vergleichsmenge darf Operatoren wie \"+, - , *  und / \" enthalten.",
        "solution": "false"
      },
      {
        "text": "Die rechte Vergleichsmenge darf Konstanten unterschiedlichen Typs enthalten.",
        "solution": "false"
      },
      {
        "text": "Die rechte Vergleichsmenge darf eine SELECT-Anweisung enthalten.",
        "solution": "true"
      },
      {
        "text": "Die rechte Vergleichsmenge darf zwei gleiche Konstanten enthalten.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 221,
    "category": 7,
    "difficulty": 1,
    "text": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX)",
    "explanation": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX) gehören zum SQL-Standard.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "gehören zum SQL-Standard.",
        "solution": "true"
      },
      {
        "text": "sind ORACLE-spezifisch.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 223,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welcher SQL-Gruppenfunktion berechnet man den Mittelwert einer Spalte?",
    "explanation": "Die SQL-Gruppenfunktion AVG(spaltenname) berechnet den Mittelwert einer Spalte \"spaltenname\".",
    "type": "text",
    "answers": [
      {
        "text": "Die Funktion heißt:",
        "solution": "AVG"
      }
    ]
  },
  {
    "id": 224,
    "category": 7,
    "difficulty": 1,
    "text": "NULL-Werte werden bei den Gruppenfunktionen in SQL (z.B. COUNT) berücksichtigt.",
    "explanation": "NULL-Werte werden bei den Gruppenfunktionen in SQL (z.B. COUNT) nicht berücksichtigt. \nGehen Sie z.B. von folgenden Datensätzen aus: \nspalte1  spalte2\n   ab,       123,  \n   cd,       NULL, \n   df,       234, \nWird nun mit SELECT COUNT(spalte2) über Spalte2 gezählt, so lautet das Ergebnis: 2 Datensätze. \nWird aber mit SELECT COUNT(spalte1) über Spalte1 gezählt, so lautet das Ergebnis: 3 Datensätze. \nDie Semantik beider SELECTs ist sehr unterschiedlich. \nZählt man über Spalte2, so hat die Ergebnismenge die Semantik:  \"Wieviele Datensätze sind in Spalte2 nicht leer?\"\nZählt man über Spalte1, so hat die Ergebnismenge die Semantik:  \"Wieviele Datensätze hat die Tabelle?\"",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "true"
      },
      {
        "text": "stimmt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 227,
    "category": 7,
    "difficulty": 2,
    "text": "In der Ausgabe wird über die GROUP-BY-Spalten aufsteigend sortiert.\nDiese Aussage",
    "explanation": "In der Ausgabe wird über die GROUP BY-Spalten aufsteigend sortiert. \nAber eigentlich ist für die Sortierung die ORDER BY-Klausel zuständig mit den beiden Optionen ASC und DESC. Die Sortierung bei der Gruppierung ist nur ein Nebenprodukt der eigentlichen Aufgabe, der Guppenbildung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 264,
    "category": 6,
    "difficulty": 2,
    "text": "Der Vergleichsoperator \"ungleich\" heißt in SQL:",
    "explanation": "Die Vergleichsoperatoren für Ungleicheit sind: <> oder !=",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "=!",
        "solution": "false"
      },
      {
        "text": "<>",
        "solution": "true"
      },
      {
        "text": "!=",
        "solution": "true"
      },
      {
        "text": "UNLIKE",
        "solution": "false"
      },
      {
        "text": "UNEQUAL",
        "solution": "false"
      }
    ]
  },
  {
    "id": 233,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem SQL-Befehl werden Daten in Tabellen eingefügt? Bitte geben Sie nur einen Ausdruck, nicht den kompletten Befehl  ein!",
    "explanation": "Es gibt einen Befehl zum Einfügen von genau einem Datensatz:\n\n    INSERT INTO tabellenname VALUES (spaltenwert_1, ..., spaltenwert_n);\n\n    Und es  gibt einen Befehl zum Einfügen von mehreren Datensätzen aus anderen Tabellen oder Sichten:\n\n    INSERT INTO tabellenname AS SELECT (spaltenwert_1, ..., spaltenwert_n) FROM ... WHERE ...;",
    "type": "text",
    "answers": [
      {
        "text": "Der Befehl heißt:",
        "solution": "INSERT"
      }
    ]
  },
  {
    "id": 231,
    "category": 7,
    "difficulty": 2,
    "text": "Bei einer \"CREATE VIEW AS SELECT * FROM TABLE TEST\" - Anweisung",
    "explanation": "Mit \"CREATE VIEW AS SELECT..\" wird eine virtuelles View nach SQL-Standard, keine materialisierte View, angelegt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "werden auch die Daten der Tabelle Test kopiert",
        "solution": "false"
      },
      {
        "text": "wird nur die SELECT-Anweisung in der Datenbank gespeichert.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 101,
    "category": 6,
    "difficulty": 2,
    "text": "In CHECK-Constraints sind unter ORACLE-SQL auch Abfragen möglich.",
    "explanation": "Leider entspricht Oracle hier nicht dem SQL2-Standard, unter dem solche CHECK-Constraints mit SELECT-Anfragen schon 1992 vorgesehen waren.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ja",
        "solution": "false"
      },
      {
        "text": "nein",
        "solution": "true"
      }
    ]
  },
  {
    "id": 103,
    "category": 6,
    "difficulty": 2,
    "text": "Mit welchem Befehl löscht man einen CONSTRAINT?",
    "explanation": "Constraints sind keine eigenen Datenbankobjekte, sie der gehören zu einer Tabelle und werden daher auch nicht mit einem eigenen DROP-Befehl gelöscht, sondern mit einem ALTER TABLE-Befehl.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ALTER TABLE XYZ DELETE CONSTRAINT ...",
        "solution": "false"
      },
      {
        "text": "DELETE CONSTRAINT ...",
        "solution": "false"
      },
      {
        "text": "ALTER TABLE XYZ DROP CONSTRAINT ...",
        "solution": "true"
      },
      {
        "text": "DROP CONSTRAINT ...",
        "solution": "false"
      }
    ]
  },
  {
    "id": 107,
    "category": 7,
    "difficulty": 1,
    "text": "Was bedeutet die Abkürzung (DML)?",
    "explanation": "DML ist die Abkürzung für Data Manipulation Language und meint die SQL-Befehle INSERT, UPDATE, DELETE. Manche zählen auch noch SELECT dazu. Aber bei uns gehört SELECT zur DQL: Data Query Language.",
    "type": "text",
    "answers": [
      {
        "text": "DML =",
        "solution": "Data Manipulation Language"
      }
    ]
  },
  {
    "id": 112,
    "category": 9,
    "difficulty": 2,
    "text": "Objekttypen und benutzerdefinierte Datentypen wurden im folgenden SQL-Standard definiert:",
    "explanation": "Die objektrelationalen Erweiterungen kommen mit SQL3 auch SQL:1999/2003 genannt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SQL 1",
        "solution": "false"
      },
      {
        "text": "SQL 2",
        "solution": "false"
      },
      {
        "text": "SQL 3",
        "solution": "true"
      }
    ]
  },
  {
    "id": 113,
    "category": 6,
    "difficulty": 2,
    "text": "Welche Ausgabe erzeugt die Formatierung NUMBER(7,-2) der Zahl 7456123.89 ?",
    "explanation": "Die negative zweite Zahl, besagt, dass die entsprechenden letzten Vorkommastellen, durch numerische Nullen ersetzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Syntax ist nicht korrekt",
        "solution": "false"
      },
      {
        "text": "Die Ausgabe ist 7456100",
        "solution": "true"
      },
      {
        "text": "Die Ausgabe ist 7456200",
        "solution": "false"
      },
      {
        "text": "Die Ausgabe ist 7456123.89",
        "solution": "false"
      },
      {
        "text": "Die Ausgabe ist 7456123.8900",
        "solution": "false"
      }
    ]
  },
  {
    "id": 118,
    "category": 6,
    "difficulty": 1,
    "text": "Die Programmierung von SQL-Befehlen muss case-sensitive erfolgen.",
    "explanation": "Der SQL-Übersetzer arbeitet nicht case-sensitiv, so dass bei der Programmierung von SQL-Befehlen die Groß-/Kleinschreibung von reservierten Wörtern völlig irrelevant ist. \nLediglich bei Vergleichen z.B. in der WHERE-Klausel muss jedoch sehr wohl auf die passende Groß-/Kleinschreibung geachtet werden, da hier case-sensitiv die Inhalte von Datenspalten verglichen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 121,
    "category": 6,
    "difficulty": 1,
    "text": "Mit dem DROP TABLE - Befehl werden Tabellen-Definition und Daten der Tabelle gelöscht.",
    "explanation": "Mit dem DROP TABLE-Befehl werden die Daten, die Tabelle selbst und alle abhängigen Datenbankobjekte, wie z.B. Constraints und  Trigger gelöscht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "false"
      },
      {
        "text": "stimmt",
        "solution": "true"
      }
    ]
  },
  {
    "id": 124,
    "category": 6,
    "difficulty": 3,
    "text": "Der RENAME-Befehl gehört zum SQL2003-Standard",
    "explanation": "<RENAME Anweisung> ::= RENAME Alter Tabellenname TO Neuer Tabellenname;\n\nDiese Anweisung gehört nicht zum SQL2003-Sprachumfang und ist auch nicht in allen Systemen verfügbar, wohl aber bei Oracle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 125,
    "category": 6,
    "difficulty": 2,
    "text": "Mit welchem SQL-Befehl vergibt man Rechte auf einer Tabelle?",
    "explanation": "Mit dieser Anweisung lassen sich sehr differenziert auf einzelnen Tabellen Benutzerrechte vergeben. \n\n<GRANT Anweisung> ::= \nGRANT  [ ON { Tabellenname | Sichtname } ] TO ;\n ::= { PUBLIC | Benutzername }\n ::= \n{ ALL | SELECT | DELETE | INSERT \n  | UPDATE [Spaltenname [, Spaltenname ]...] }",
    "type": "text",
    "answers": [
      {
        "text": "Der Befehl heißt",
        "solution": "GRANT"
      }
    ]
  },
  {
    "id": 126,
    "category": 6,
    "difficulty": 2,
    "text": "Mit welchem SQL-Befehl löscht man Rechte auf einer Tabelle?",
    "explanation": "Mit der REVOKE-Anweisung werden Datenbankprivilegien wieder aus der Datenbank entfernt: \n<REVOKE Anweisung> ::= \nREVOKE  ON [ Tabellenname | Sichtname ] FROM ;",
    "type": "text",
    "answers": [
      {
        "text": "Der Befehl ist",
        "solution": "REVOKE"
      }
    ]
  },
  {
    "id": 133,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welchem Befehl löscht man alle Rechte auf einer Tabelle XYZ für den Benutzer Emil?",
    "explanation": "RICHTIG ist: \nREVOKE ALL ON XYZ FROM EMIL;  \nweil die Syntaxvorgabe folgende ist: <revoke anweisung=\"\">REVOKE  ON [ Tabellenname | Sichtname ] FROM tabellenname;  \nFALSCH ist: \nREVOKE ALL FROM XYZ OF Hugo; weil  FROM und OF falsche Schlüsselwörter sind.<revoke anweisung=\"\">\nGRANT ALL FROM XYZ OF HUGO; weil mit GRANT Rechtevergeben werden und die Schlüsselwörter FROM und OF falsch sind. \nDROP ALL ON XYZ; weil DROP ein Befehl zum Löschen von DB-Objekten wie Tabellen, Sichten, Sequenzen, Indexen etc. ist, aber nicht zum Löschen von Rechtezuordnungen zwischen Benutzern und DB-Objekten ist.\nDELETE ALL FROM XYZ; weil DELETE ein DML-Befehl zum Löschen von Datensätzen ist.",
    "type": "text",
    "answers": [
      {
        "text": "Der SQL-Ausdruck (ohne Semikolon, inGroßbuchstaben) lautet:",
        "solution": "\r\n    REVOKE ALL ON XYZ FROM EMIL\r"
      }
    ]
  },
  {
    "id": 168,
    "category": 10,
    "difficulty": 2,
    "text": "Mit welcher Ausnahme wird in JDBC ein SQL-Fehler geworfen?",
    "explanation": "Da in JDBC erst zur Laufzeit eine Übersetzung der SQL-Anweisungen erfolgt, ist mit\nLaufzeitfehlern zu rechnen, die eine SQLException verursachen. Die Ausführung\neines SQL-Befehls muss daher immer in einem try/catch-Block erfolgen. Der catch-\nBlock enthält die Fehlerbehandlung und das Auffangen einer SQLException.",
    "type": "text",
    "answers": [
      {
        "text": "Die Ausnahme heißt:",
        "solution": "SQLException"
      }
    ]
  },
  {
    "id": 177,
    "category": 10,
    "difficulty": 2,
    "text": "Mit welcher Methode des Interfaces Statement führt man in JDBC eine SELECT-Abfrage aus?",
    "explanation": "Die Methode executeQuery des Statement-Objekts führt Abfragen durch, die über einen SQL-String übergeben werden und zur Laufzeit ausgeführt werden.",
    "type": "text",
    "answers": [
      {
        "text": "Die Methode (ohne Klammern geschrieben) heißt",
        "solution": "executeQuery"
      }
    ]
  },
  {
    "id": 184,
    "category": 10,
    "difficulty": 1,
    "text": "Von welchem JDBC-Interfaces erben die anderen Interfaces?",
    "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PreparedStatement",
        "solution": "false"
      },
      {
        "text": "Statement",
        "solution": "true"
      },
      {
        "text": "CallableStatement",
        "solution": "false"
      }
    ]
  },
  {
    "id": 186,
    "category": 10,
    "difficulty": 2,
    "text": "Welches Konstrukt in PL/SQL bietet eine ähnliche Funktion wie das ResultSet in JDBC?",
    "explanation": "Der Cursor unter  PL/SQL  entspricht einem ResultSet, welches nur in einer Richtung durchlaufen werden kann.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ein",
        "solution": "Cursor"
      }
    ]
  },
  {
    "id": 192,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem SQL-Befehl werden temporäre Änderungen endgültig in die Datenbank geschrieben?",
    "explanation": "Die COMMIT-Anweisung macht Datenbankzugriffe erst dauerhaft wirksam, die ROLLBACK-Anweisung spielt temporäre Anweisungen wieder auf einen konsistenten Zustand zurück. Beide Anweisungen gehören zur DAL-Sprache.",
    "type": "text",
    "answers": [
      {
        "text": "Der SQL-Befehl heißt:",
        "solution": "commit"
      }
    ]
  },
  {
    "id": 196,
    "category": 10,
    "difficulty": 1,
    "text": "Unter JDBC wird der SQL-Code schon zur Übersetzungszeit auf Syntax und Semantikfehler geprüft.",
    "explanation": "Der SQL-Code zur Übersetzungszeit als String betrachtet, der erst zur Laufzeit gegen die Datenbank geschickt wird. Daher treten SQL-Fehler auch erst zur Laufzeit auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 198,
    "category": 10,
    "difficulty": 1,
    "text": "Der aktuelle, letzte JDBC-Standard ist:",
    "explanation": "\n    JDBC 4.0 wurde 2006 veröffentlicht",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "JDBC 1.0",
        "solution": "false"
      },
      {
        "text": "JDBC 2.0",
        "solution": "false"
      },
      {
        "text": "JDBC 3.0",
        "solution": "false"
      },
      {
        "text": "JDBC 4.0",
        "solution": "true"
      },
      {
        "text": "JDBC 5.0",
        "solution": "false"
      },
      {
        "text": "JDBC 6.0",
        "solution": "false"
      }
    ]
  },
  {
    "id": 199,
    "category": 10,
    "difficulty": 2,
    "text": "Welche Konstanten repräsentieren Isolationsgrade unter JDBC?",
    "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "TRANSACTION_READ_UNCOMMITTED",
        "solution": "true"
      },
      {
        "text": "TRANSACTION_READ_COMMITTED",
        "solution": "true"
      },
      {
        "text": "TRANSACTION_SERIALIZABLE",
        "solution": "true"
      },
      {
        "text": "TRANSACTION_NONE",
        "solution": "true"
      },
      {
        "text": "TRANACTION_ALL",
        "solution": "false"
      }
    ]
  },
  {
    "id": 203,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem Schlüsselwort werden in SQL doppelte Datensätze unterdrückt?",
    "explanation": "Anders als bei der Relationalen Algebra, in der Duplikate nicht zugelassen sind und daher automatisch eliminieren werden, sind in SQL Duplikate zugelassen. Um Duplikate in SQL zu unterdrücken, muss man in der SELECT-Anweisung explizit die Option DISTINCT verwenden: SELECT DISTINCT spaltenname, .... FROM ....;",
    "type": "text",
    "answers": [
      {
        "text": "Das Schlüsselwort heißt",
        "solution": "DISTINCT"
      }
    ]
  },
  {
    "id": 2382,
    "category": 9,
    "difficulty": 3,
    "text": "Wozu braucht man objektrelationale Sichten?",
    "explanation": "Alle Antworten sind richtig! ;-)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zu all den Verwendungszwecken, zu denen man auch die relationalen Sichten benötigt.",
        "solution": "true"
      },
      {
        "text": "Sie sind hilfreich, um objektrelationales Verhalten auszuprobieren bzw. zu simulieren, ohne, dass man die relationalen Tabellen transformieren muss.",
        "solution": "true"
      },
      {
        "text": "Sei können Performance-Vorteile mit sich bringen, wenn man nur ein Objekt statt mehrerer Datensätze über das Netz schicken muss.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2413,
    "category": 13,
    "difficulty": 2,
    "text": "Ein Oracle-Trigger kann ein COMMIT oder ROLLBACK enthalten",
    "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keine von beiden",
        "solution": "false"
      },
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt  nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2452,
    "category": 5,
    "difficulty": 1,
    "text": "Das relationale Modell kann wie folgt definiert werden: MULTISET ( ROW ( Basisdatentyp ) )",
    "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt  nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2454,
    "category": 3,
    "difficulty": 3,
    "text": "Bei welchen Beziehungen tauchen Fremdschlüsselattribute in den Entity-Mengen des ERDs auf, die an der Beziehung beteiligt sind?",
    "explanation": "Bei n-m-Beziehungen entstehen die Fremdschlüsselattribute beim Auflösen in einer neuen Entity-Menge, nicht in den ursprünglicheen Entity-Mengen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1:1-Beziehungen",
        "solution": "true"
      },
      {
        "text": "1:n-Beziehungen",
        "solution": "true"
      },
      {
        "text": "m:n-Beziehungen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2471,
    "category": 6,
    "difficulty": 3,
    "text": "Wie verhält sich ein DEFERRED-Constraint bei einem Integritätsfehler?",
    "explanation": "Bei einem Deferred-Constraint wird der Fehler erst angezeigt, wenn die Transaktion z.B. mit COMMIT oder ROLLBACk abgeschlossen wird. \nEs wird nicht nur die fehlerhafte Manipulation, sondern alle Manipulationen, die zur Transaktion gehören, zurückgerollt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Unmittelbar nach der Manipulation eines Datensatzes wird der Fehler angezeigt und der fehlerhafte Datensatz wird nicht angenommen.",
        "solution": "false"
      },
      {
        "text": "Zum Transaktionsende wird der Fehler angezeigt und die fehlerhafte Manipulation rückgängig gemacht.",
        "solution": "false"
      },
      {
        "text": "Keine von diesen Reaktionen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2472,
    "category": 6,
    "difficulty": 2,
    "text": "Um welchen Typ einer Integritätsbedingung handelt es sich hier?\n\nInnerhalb eines Jahres dürfen die Ausgaben der Abteilung nicht stärker steigen, als die vom Bundesministerium prognostizierte Preissteigerungsrate.",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingung",
        "solution": "true"
      },
      {
        "text": "statische, temporale Bedingung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 204,
    "category": 6,
    "difficulty": 1,
    "text": "Mit welchem Operator werden unter ORACLE-SQL Zeichenketten aneinandergehängt?",
    "explanation": "In SQL ist es das Pipe-Zeichen: || ",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "+",
        "solution": "false"
      },
      {
        "text": "||",
        "solution": "true"
      }
    ]
  },
  {
    "id": 206,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem WHERE-Ausdruck prüft man, ob eine Spalte NULL-Werte hat?",
    "explanation": "Der \"IS [NOT] NULL\"-Vergleichsoperator bietet als einziger Vergleichsoperator die Möglichkeit, leere Spaltenwerte in Bedingungen zu TRUE resp. FALSE zu transformieren. Wenn bei einem der übrigen Vergleichsoperatoren wie z.B. =, <>, >=, LIKE, BETWEEN, ... einer der Operanden leer (NULL) ist, dann ist das Ergebnis der Auswertung dieser Bedingung immer UNKNOWN.",
    "type": "text",
    "answers": [
      {
        "text": "Der WHERE - Ausdruck heißt:",
        "solution": "IS NULL"
      }
    ]
  },
  {
    "id": 208,
    "category": 7,
    "difficulty": 3,
    "text": "Welche SQL-Ausdrücke liefern das gleiche Ergebnis?",
    "explanation": "Bei einem IN-Operator wird nicht ein Intervall, sondern nur die Eckwerte abgefragt, bei einem BETWEEN-Operator gehören die Eckwerte (hier 1000 und 2000) mit zur Lösungsmenge.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT gehalt FROM Angestellte WHERE gehalt > 1000 AND gehalt < 2000",
        "solution": "false"
      },
      {
        "text": "SELECT gehalt FROM Angestellte WHERE gehalt in (1000, 2000)",
        "solution": "false"
      },
      {
        "text": "SELECT gehalt FROM Angestellte WHERE gehalt >= 1000 AND gehalt <= 2000",
        "solution": "true"
      },
      {
        "text": "SELECT gehalt FROM Angestellte WHERE gehalt between 1000 and 2000",
        "solution": "true"
      }
    ]
  },
  {
    "id": 212,
    "category": 7,
    "difficulty": 2,
    "text": "Sortieren Sie die Verlgleichs- und logischen Operatoren nach der Priorität unter SQL ( Zahlen 1-4 eintragen)!",
    "explanation": "Die Ausführungsreihenfolge bei den Verlgleichs- und logischen Operatoren ist folgende: \n1. Vergleichsoperatoren (=, <=, >=, ...) \n2. NOT \n3. AND \n4. OR  \n\nAm einfachsten ist es jedoch, man setzt Klammern, da kann man bei der Ausführungsreihenfolge nichts falsch machen ;-)",
    "type": "text",
    "answers": [
      {
        "text": "OR",
        "solution": "4"
      },
      {
        "text": "Vergleichoperatoren ( <, > , ...)",
        "solution": "1"
      },
      {
        "text": "AND",
        "solution": "3"
      },
      {
        "text": "NOT",
        "solution": "2"
      }
    ]
  },
  {
    "id": 211,
    "category": 7,
    "difficulty": 1,
    "text": "Welcher der folgenden logischen Operatoren hat in SQL die höchste Priorität?",
    "explanation": "Die Ausführungsreihenfolge bei den logischen Operatoren ist folgende: \n1. NOT \n2. AND \n3. OR  \n\nAm einfachsten ist es jedoch, man setzt Klammern, dann kann man bei der Ausführungsreihenfolge nichts falsch machen ;-)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "OR",
        "solution": "false"
      },
      {
        "text": "NOT",
        "solution": "true"
      },
      {
        "text": "AND",
        "solution": "false"
      }
    ]
  },
  {
    "id": 217,
    "category": 6,
    "difficulty": 2,
    "text": "Mit dem Wildcard \"%\" und LIKE selektiert man unter SQL:",
    "explanation": "Mit dem LIKE-Operator wird die Übereinstimmung mit einem Zeichenmuster gesucht. Zulässige Wildcards sind: \"%\" für kein, ein, oder mehrere Zeichen und \"_\" für genau ein Zeichen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "kein, ein oder mehrere Zeichen",
        "solution": "true"
      },
      {
        "text": "ein oder mehrere Zeichen",
        "solution": "false"
      },
      {
        "text": "genau ein Zeichen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 214,
    "category": 6,
    "difficulty": 2,
    "text": "Mit welchem Wildcard wird unter SQL mit LIKE genau ein Zeichen selektiert ?",
    "explanation": "Mit dem LIKE-Operator wird die Übereinstimmung mit einem Zeichenmuster gesucht. Zulässige Wildcards sind: \"%\" für kein, ein, oder mehrere Zeichen und \"_\" für genau ein Zeichen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "%",
        "solution": "false"
      },
      {
        "text": "_",
        "solution": "true"
      },
      {
        "text": "Solch einen Wildcard gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 218,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welchem Wildcard werden unter SQL mit LIKE ein oder mehrere  Zeichen selektiert ?",
    "explanation": "Mit dem LIKE-Operator wird die Übereinstimmung mit einem Zeichenmuster gesucht. Zulässige Wildcards sind: \"%\" für kein, ein, oder mehrere Zeichen und \"_\" für genau ein Zeichen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "%",
        "solution": "false"
      },
      {
        "text": "-",
        "solution": "false"
      },
      {
        "text": "solch einen Wildcard gibt es nicht.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 216,
    "category": 6,
    "difficulty": 1,
    "text": "Mit welchem Wildcard werden unter SQL mit LIKE kein, ein oder mehrere Zeichen selektiert ?",
    "explanation": "Mit dem LIKE-Operator wird die Übereinstimmung mit einem Zeichenmuster gesucht. Zulässige Wildcards sind: \"%\" für kein, ein, oder mehrere Zeichen und \"_\" für genau ein Zeichen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "%",
        "solution": "true"
      },
      {
        "text": "_",
        "solution": "false"
      },
      {
        "text": "solch einen Wildcard gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 996,
    "category": 9,
    "difficulty": 2,
    "text": "Was versteht man unter einer Objekttabelle (object table) bei Oracle?",
    "explanation": "Tabellen, bei den die benutzerdefinierten Typen als Datentypen eingetragen sind, heißen relationale Tabellen. Bei den Objekttabellen dagegen basieren die Tabellen komplett auf einem Typ: CREATE TABLE xyz of Typ_xyz;",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Objekttabelle ist eine Tabelle, in der jede Spaltendefinition ein benutzerdefinierter Typ ist.",
        "solution": "false"
      },
      {
        "text": "Eine Objekttabelle ist eine Tabelle, in der jeder Datensatz ein Objekt repräsentiert.",
        "solution": "true"
      },
      {
        "text": "Eine Objekttabelle ist eine Tabelle, in der eine Spaltendefinition ein benutzerdefinierter Typ ist.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 997,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Alternativen gibt es, um in einer Objekttabelle unter ORACLE ein Objekt eindeutig zu identifizieren?",
    "explanation": "Primary Key und eine weltweit eindeutige OID sind beide als Möglichkeiten vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die OID, eine weltweit eindeutige Kennung",
        "solution": "true"
      },
      {
        "text": "einen Primärschlüssel",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1271,
    "category": 12,
    "difficulty": 3,
    "text": "Welcher Code zum Aufruf einer PL/SQL-Funktion Gehaltssumme ist korrekt?",
    "explanation": "call   läßt sich nicht als Funktionsaufruf verwenden und Gehaltssumme(); ist falsch, da Gehaltssumme als Funktion, nicht als Prozedur, definiert ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "EXECUTE :Gehaltssumme:= Gehaltssumme();",
        "solution": "true"
      },
      {
        "text": "CALL :Gehaltssumme:= Gehaltssumme();",
        "solution": "false"
      },
      {
        "text": "Gehaltssumme();",
        "solution": "false"
      },
      {
        "text": "SELECT Gehaltssumme() FROM dual;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1008,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt eine Methode, die mit dem Objekttyp assoziiert ist? Der typischer Aufruf ist \"type_name.method()\".",
    "explanation": "Das ist die Definition einer Static-Methode. Der zweite Methodentyp sind Member-Methoden, die einem einzelnen Objekt zugeordnet sind.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist eine",
        "solution": "STATIC METHOD"
      }
    ]
  },
  {
    "id": 1028,
    "category": 9,
    "difficulty": 3,
    "text": "Mit welcher Inherritance-Klausel kann ein Typ unter ORACLE als Supertyp deklariert werden, der Methoden und Attribute vererben kann?",
    "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "NOT FINAL"
      }
    ]
  },
  {
    "id": 1001,
    "category": 9,
    "difficulty": 1,
    "text": "Mit ORACLE können Typhierarchien aufgebaut werden.",
    "explanation": "Von einem Supertyp kann ein Suptyp mit dem Schlüsselwort \"Under\" abgeleitet werden. Attribute und Methoden werden dabei vom Supertyp übernommen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1002,
    "category": 9,
    "difficulty": 1,
    "text": "Bei REF-Beziehungen müssen bei Foreign Keys die Join-Bedingungen selber programmiert werden.",
    "explanation": "Die Foreign-Key-Beziehungen werden automatisch erzeugt und müssen nicht selber programmiert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1003,
    "category": 9,
    "difficulty": 2,
    "text": "Wird bei einer bestehenden REF-Beziehung das referenzierte Objekt gelöscht, dann verweist die bestehende Referenz auf ein nicht mehr existierendes Objekt.",
    "explanation": "Die Beziehung bleibt bestehen, obwohl das Objekt gelöscht wird und kann mit   WHERE spaltenreferenz IS DANGLING; abgefragt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1738,
    "category": 9,
    "difficulty": 3,
    "text": "Welche CONSTRAINT-Typen können auf ORACLE-OBJECT-Tabellen definiert werden?",
    "explanation": "USER-CONSTRAINTS gibt es nicht, ansonsten können alle CONSTRAINTS wie im relationalen Modell auch definiert werden. MIT REF-CONSTRAINTS werden zusätzlich Zeiger auf anderen OIDS von Objekten realisiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "COLUMN-CONSTRAINTS",
        "solution": "true"
      },
      {
        "text": "TABLE-CONSTRAINTS",
        "solution": "true"
      },
      {
        "text": "DBS-CONSTRAINTS",
        "solution": "false"
      },
      {
        "text": "REF-CONSTRAINTS",
        "solution": "true"
      },
      {
        "text": "USER-CONSTRAINTS",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1015,
    "category": 9,
    "difficulty": 1,
    "text": "Unter ORACLE gilt: Für einen Subtypen sind mehrere Eltern möglich.",
    "explanation": "Mehrfachvererbung ist bei Typen hier nicht vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "true"
      },
      {
        "text": "stimmt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1013,
    "category": 9,
    "difficulty": 3,
    "text": "Mit welcher Anweisung wird in SQL 2003 ein benutzerdefinierter Datentyp festgelegt?",
    "explanation": "CREATE TYPE gehört zum SQL-Standard seit SQL:2003.",
    "type": "text",
    "answers": [
      {
        "text": "Die Anweisung heißt",
        "solution": "CREATE TYPE"
      }
    ]
  },
  {
    "id": 1011,
    "category": 9,
    "difficulty": 3,
    "text": "Wie nennt man den folgenden Zugriff in einer Objekt-Tabelle?",
    "explanation": "Das ist die Definition des Single Column-Zugriffs.Die Alternative ist der Zugriff auf eine mehrspaltige Tabelle, in der jedes Attribut des Objekttypes die Anwendung von relationalen Operationen erlaubt. Dieser Zugriff heißt Multi-Column_Zugriff.",
    "type": "text",
    "answers": [
      {
        "text": "Die Objekttabelle wird als einspaltige Tabelle betrachtet, bei der jeder Datensatz ein Objekt darstellt, das die Anwendung objektorientierter Operationen erlaubt. Für den Zugriff auf Instanzwerte eines Objekts muss die VALUE-Funktion verwendet werden, der als Parameter der Tabellenalias übergeben wird und die dann als Rückgabewert eine Objektinstanz liefert. \n\n(ohne Bindestrich schreiben)",
        "solution": "Single Column"
      }
    ]
  },
  {
    "id": 1031,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussage ist wahr?",
    "explanation": "Die Normalformen (1NF, 2NF und 3NF) spielen in objektrelationalem SQL keine Rolle, ihre Verletzung relationalen Tabellen sind solche, die nicht auf einem Typ basieren, CREATE TABLE OF typname.... Sie können aber sehr wohl einen selbstdefiniereten  Datentypen benutzen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Werden in relationalen Tabellen Collection-Types (varrays, nested tables) angewendet, dann wird automatisch die erste Normalform verletzt.",
        "solution": "true"
      },
      {
        "text": "Werden in relationalen Tabellen Collection-Types (varrays, nested tables) angewendet, dann wird automatisch die dritte Normalform verletzt.",
        "solution": "true"
      },
      {
        "text": "Werden in relationalen Tabellen Collection-Types (varrays, nested tables) angewendet, dann wird automatisch die zweite Normalform verletzt.",
        "solution": "true"
      },
      {
        "text": "Collectiions-Typen (varrays, nested tables) können in relationalen Tabellen gar nicht angewendet werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1029,
    "category": 9,
    "difficulty": 2,
    "text": "Wie kann man auf die Daten einer Objekttabelle zugreifen?",
    "explanation": "Eine mehrspaltige Tabelle,  bei der jedes Attribut des benutzerdefinierten Datentyps die Anwendung relationaler Operationen erlaubt, heißt Tupeltabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Objekttabelle wird als einspaltige Tabelle betrachtet, bei der jeder Datensatz ein Objekt darstellt, das die Anwendung objektorientierter Operationen erlaubt. Für den Zugriff auf Instanzwerte eines Objekts muss die VALUE-Funktion verwendet werden, der als Parameter der Tabellenalias übergeben wird und die dann als Rückgabewert eine Objektinstanz (Datensatz) liefert.",
        "solution": "true"
      },
      {
        "text": "Die Objekttabelle wird als mehrspaltige Tabelle betrachtet, bei der jedes Attribut des benutzerdefinierten Datentyps die Anwendung relationaler Operationen erlaubt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1016,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Parameter kann die Inheritance-Klausel zu Definition von Subtypen unter ORACLE haben?",
    "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt über die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "OVERRIDING",
        "solution": "true"
      },
      {
        "text": "OVERLOADING",
        "solution": "false"
      },
      {
        "text": "STATIC",
        "solution": "false"
      },
      {
        "text": "FINAL",
        "solution": "true"
      },
      {
        "text": "INSTANTIABLE",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1018,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißen die Beziehungen unter ORACLE, die Foreign Keys ersetzen können?",
    "explanation": "Die REF-Beziehung ersetzt einen Fremdschlüsselverweis wie im relationalenModell üblich. Es wird ein Zeiger auf das Referenzobjekt in der Master-Tabelle angelegt. Erstaunlicherweise wird hier zugelassen, dass Zeiger ins Leere verweisen, wenn das Master-Objekt gelöscht wird. Es können also sogenannte \"Dangling-Tupel\" entstehen, die sich auch mit IS [NOT] DANGLING abfragen lassen.",
    "type": "text",
    "answers": [
      {
        "text": "Das sind (mit Bindestrich schreiben):",
        "solution": "REF-Beziehungen"
      }
    ]
  },
  {
    "id": 1019,
    "category": 9,
    "difficulty": 3,
    "text": "Die unter ORACLE 9i aufgenommenen REF-Beziehungen (REF-Klausel) können verwendet werden",
    "explanation": "Die REF-Beziehung ersetzt einen Fremdschlüsselverweis wie im relationalenModell üblich und können zwischen Objekttabellen und Objekt-Views verwendet werden.  Es wird ein Zeiger auf das Referenzobjekt in der Master-Tabelle angelegt. Erstaunlicherweise wird hier zugelassen, dass Zeiger ins Leere verweisen, wenn das Master-Objekt gelöscht wird. Es können also sogenannte \"Dangling-Tupel\" entstehen, die sich auch mit IS [NOT] DANGLING abfragen lassen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "zwischen Objekttabellen",
        "solution": "true"
      },
      {
        "text": "zwischen allen mit CREATE TABLE definierten Tabellen",
        "solution": "false"
      },
      {
        "text": "zwischen Object Views",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1032,
    "category": 4,
    "difficulty": 3,
    "text": "Was versteht man unter \"Dangling Tuples\" in der relationalen Algebra?",
    "explanation": "Gibt es Tupel in einer Relation, deren Werte in den Fremdschlüssel-Attributen auf Werte in der anderen Relation verweisen, die dort nicht (mehr) existieren, so sind dies die sog. \"dangling tuples\", die Probleme hinsichtlich der referenziellen Integrität darstellen. \nEbenso werden auch Tupel, die bei Join-Operationen nicht mit entsprechenden Tupeln aus der anderen Relation verknüpft werden können, als \"dangling tuples\" bezeichnet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Tupel, die nicht gesichert werden.",
        "solution": "false"
      },
      {
        "text": "Tupel, denen bei Join-Operationen die entsprechenden Tupel in der anderen Relation fehlen, mit denen sie verknüpft werden könnten.",
        "solution": "true"
      },
      {
        "text": "Tupel, denen Attributwerte fehlen.",
        "solution": "false"
      },
      {
        "text": "Tupel in einer Relation, deren Werte in den Fremdschlüssel-Attributen auf Werte in der anderen Relation verweisen, die dort nicht (mehr) existieren.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1021,
    "category": 9,
    "difficulty": 1,
    "text": "Welche Aussage ist wahr?",
    "explanation": "Für eine geordnete Menge von Datenelementen unterschiedlichen Typs können unter Oracle strukturierte Datentypen (create type...) verwendet werden, die dann mit einem TABLE-Konstruktur als nested Table eingebettet werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "VARRAYS können eine geordnete Menge von Datenelementen, die alle den gleichen Datentyp haben, aufnehmen.",
        "solution": "true"
      },
      {
        "text": "VARRAYS können eine geordnete Menge von Datenelementen, die nicht den gleichen Datentyp besitzen müssen, aufnehmen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1022,
    "category": 9,
    "difficulty": 1,
    "text": "Unter Oracle muss eine maximale VARRAY-Größe definiert werden, unterhalb der die VARRAY-Größe variabel sein kann.",
    "explanation": "Ein VARRAY hat eine maximale Größe n, die über \nCREATE OR REPLACE TYPE varray_typ  AS VARRAY(n) OF Datentyp; \nfestgelegt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1023,
    "category": 9,
    "difficulty": 1,
    "text": "Bei welchem Modus werden die VARRAY/NESTED TABLE-Werte unter Oracle mittels der \"Konstruktor\"-Methode angezeigt?",
    "explanation": "Bei einer NESTED QUERY wird der Tabelleninhalt mit den eingebetteten Kollektionen und zugehörigen Konstruktoren komplett ausgegeben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NESTED QUERY",
        "solution": "true"
      },
      {
        "text": "UNNESTED QUERY",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1024,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Zugriffsarten gibt es bei einer UNNESTED QUERY auf einen Collection-Typ (VARRAY oder NESTED TABLE) unter Oracle?",
    "explanation": "Bei einer  \"unnested Query\" wird die enthaltene geschachtelte Tabelle mit dem Operator TABLE  flachgeklopft und auf eine relationale\nTabelle abgebildet wird. Die Benutzung eines Tabellenalias (k und a) ist bei geschachtelten Tabellen obligatorisch. \n\nDer  CURSOR-Zugriff  zählt die Anzahl der Zeilen eines SELECTs an eine eingebettete Tabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "USER",
        "solution": "false"
      },
      {
        "text": "TABLE",
        "solution": "true"
      },
      {
        "text": "FINAL",
        "solution": "false"
      },
      {
        "text": "CURSOR",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1026,
    "category": 9,
    "difficulty": 1,
    "text": "Die Änderung des Wertes einer einzelnen Spalte unter Oracle-SQL ist möglich bei",
    "explanation": "Bei VARRAYS kann unter Oracle leider kein einzelner Wert, sondern nur das komplette VARRAY geändert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "VARRAYS",
        "solution": "false"
      },
      {
        "text": "NESTED TABLES",
        "solution": "true"
      }
    ]
  },
  {
    "id": 876,
    "category": 12,
    "difficulty": 1,
    "text": "Welcher PL/SQL-Block ermittelt einen Wert und gibt ihn als RETURN-Wert zurück?",
    "explanation": "PL/SQL unterscheidet vier Typen von Blöcken: \n\nEin Anonymer Block ist ein unbenannter PL/SQL-Block, der in einer Anwendung (Prozedur, Funktion ) eingebettet ist oder interaktiv eingegeben wird. \nEine Stored ist ein benannter PL/SQL-Block, der Parameter haben kann und als Prozedur oder Funktion definiert ist. Er wird im Datenbanksystem gespeichert und auf dem Server von der PL/SQL-Engine ausgeführt. Stored Functions geben über RETURN einen Wert an das aufrufende Programm zurück\nEin PACKAGE ist ein benannter PL/SQL-Block, der logisch verwandte Prozeduren und Funktionen, Deklarationen etc. zu einer Bibliothek zusammenfasst. \nEin Datenbanktrigger ist ein PL/SQL-Block, der zu einem definierten Ereignis (INSERT, UPDATE oder DELETE) automatisch vom Datenbankmanagementsystem aktiviert und ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "eine Prozedur",
        "solution": "false"
      },
      {
        "text": "eine Funktion",
        "solution": "true"
      },
      {
        "text": "ein Paket",
        "solution": "false"
      },
      {
        "text": "ein Datenbanktrigger",
        "solution": "false"
      }
    ]
  },
  {
    "id": 845,
    "category": 12,
    "difficulty": 1,
    "text": "Welcher Parametertyp unter PL/SQL ermöglicht einen DEFAULT -Wert?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. bei IN OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten\nWerts an das aufrufende Objekt. \n\nEin Defaultwert ist nur  bei der IN-Parameterübergabe möglich, da bei den anderen Typen ein im Programm erzeugter Wert zurückgegeben wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "OUT",
        "solution": "false"
      },
      {
        "text": "IN OUT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 847,
    "category": 12,
    "difficulty": 3,
    "text": "Welcher Parametertyp verhält sich wie eine initialisierte Variable?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten.  \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann  \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "false"
      },
      {
        "text": "OUT",
        "solution": "false"
      },
      {
        "text": "IN OUT",
        "solution": "true"
      }
    ]
  },
  {
    "id": 848,
    "category": 12,
    "difficulty": 2,
    "text": "Welcher Parametertyp verhält sich wie eine nicht initialisierte Variable?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "false"
      },
      {
        "text": "OUT",
        "solution": "true"
      },
      {
        "text": "IN OUT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 850,
    "category": 12,
    "difficulty": 1,
    "text": "Welcher Parametertyp verhält sich wie eine Konstante in einer Prozedur?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "OUT",
        "solution": "false"
      },
      {
        "text": "IN OUT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 851,
    "category": 12,
    "difficulty": 1,
    "text": "Mit welcher PL/SQL-Prozedur schreibt man Text in das Ausgabefenster?",
    "explanation": "Die umfangreiche Oracle-Bibliothek besteht aus einer ganzen Reihe mitgelieferter Pakete, zu denen auch DBMS_OUTPUT gehört. Die Funktion DBMS_OUTPUT.PUT_LINE(Text) nutzen wir sehr häufig zur Ausgabe in SQL*PLUS oder anderen Client-Applikationen und DBMS_OUTPUT.ENABLE(Buffergröße) zum Einstellen der Größe des Bildschirmbuffers.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DBMS_OUTPUT.PUT_LINE(..)",
        "solution": "true"
      },
      {
        "text": "DBMS_OUTPUT.PUTLINE(..)",
        "solution": "false"
      },
      {
        "text": "DBMSOUTPUT.PUT_LINE(..)",
        "solution": "false"
      },
      {
        "text": "DBMSOUTPUT.PUTLINE(..)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 852,
    "category": 12,
    "difficulty": 3,
    "text": "Welche Aussagen über PL/SQL-Funktionen sind wahr?",
    "explanation": "Der Rückgabeparameter der Funktionen erfordert eine andere Aufrufart als die Prozeduren. Es gibt drei Möglichkeiten, Funktionen aufzurufen:\n\n1. Möglichkeit: in SQL-Anweisungen Funktionen können grundsätzlich in jedem SQL-Anfrage- und Manipulationsbefehl aufgerufen und ausgeführt werden. Sie können überall dort aufgerufen werden, wo SINGLE ROW-Funktionen aufrufbar sind, z.B. SELECT function(...) FROM dual; \n\n2. Möglichkeit: In PL/SQL-Anweisungen kann man iterativ die Funktion auch mittels eines geeigneten PL/SQL-Befehls ausführen. Geeignete Anweisungen sind z.B. Zuweisungen oder als Parameter eines Prozedur- oder Funktionsaufrufs. Eine andere Möglichkeit ist die Verwendung der Anzeigefunktion PUT_LINE aus dem Bibliothekspaket\nDBMS_OUTPUT. \n\n3. Möglichkeit (mit SQL*PLUS-Variabeln): Dieser Aufruf funktioniert nur unter SQL*PLUS. Eine Sessionvariable wird definiert, mit dem Funktionswert über die EXECUTE-Anweisung gefüllt und über den PRINT-Befehl auf dem Bildschirm ausgegeben \n\nVARIABLE Gehaltssumme NUMBER; \nEXECUTE :Gehaltssumme:= Func_Gehaltssumme(); \nPRINT Gehaltssumme;",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Im SQL-Developer  können PL/SQL-Funktionen direkt aufgerufen werden.",
        "solution": "false"
      },
      {
        "text": "PL/SQL-Funktionen können über Session-Variablen ausgeführt werden, deren Wert mit PRINT ausgegeben wird.",
        "solution": "true"
      },
      {
        "text": "PL/SQL-Funktionen können wie die Single-Row_Funktionen (SQRT, TO_Char, etc...), die zum Funktionsumfang von ORACLE-SQL-gehören, in SQL-Anweisungen eingebunden werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 878,
    "category": 12,
    "difficulty": 1,
    "text": "EXCEPTION-Handling unter PL/SQL ist",
    "explanation": "Die kleinste Einheit von PL/SQL ist ein sogenannter PL/SQL-Block, der aus bis zu drei PL/SQL-Abschnitten bestehen kann. \n\nDer Deklarationsabschnitt  enthält Deklarationen von benutzerdefinierten Datentypen, Variablen, Konstanten, CURSOR und\nbenutzerdefinierte EXCEPTIONS, Unterprozedurenund -funktionen und ist optional. \nDer Ausführungsabschnitt   enthält PL/SQL-Anweisungen und bestimmte SQL-Anweisungen\nwie INSERT, UPDATE, DELETE, SELECT,\nCOMMIT, ROLLBACK und ist obligatorisch. \n\nDer Fehlerbehandlungsabschnitt (EXCEPTION-Handling)   gibt an, welche Aktionen ausgeführt werden sollen, wenn im Ausführungsabschnitt  Fehler auftreten und ist optional.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "obligatorisch",
        "solution": "false"
      },
      {
        "text": "optional",
        "solution": "true"
      }
    ]
  },
  {
    "id": 861,
    "category": 12,
    "difficulty": 1,
    "text": "In PL/SQL-Blöcken können Sie",
    "explanation": "In PL/SQL-Blöcken sind aus Sicherheitsgründen keine DDL-Anweisungen zugelassen. Um diese Einschränkung zu umgehen, kann man allerdings dynamischen SQL mit EXECUTE IMMEDIATE '--DDL-ANWEISUNG--' nutzen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DML-Anweisungen wie INSERT, UPDATE und DELETE schreiben.",
        "solution": "true"
      },
      {
        "text": "COMMIT und ROLLBACK absetzen, falls es sich nicht um einen Trigger handelt.",
        "solution": "true"
      },
      {
        "text": "DDL-Anweisungen wie CREATE TABLE, DROP TABLE etc. schreiben.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 859,
    "category": 12,
    "difficulty": 1,
    "text": "Welche Schleifentypen gibt es in PL/SQL?",
    "explanation": "In PL/SQL gibt es bedingte Verzweigungen mit IF und CASE, Basisschleifen ohne Bedingung mit LOOP, FOR-, WHILE- und CURSOR-Schleifen sowie eine EXIT-Anweisung zum Verlassen von Schleifen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DO_NEXT-Schleifen",
        "solution": "false"
      },
      {
        "text": "LOOP-Schleifen",
        "solution": "true"
      },
      {
        "text": "FOR-Schleifen",
        "solution": "true"
      },
      {
        "text": "WHILE-Schleifen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 860,
    "category": 12,
    "difficulty": 1,
    "text": "Der Zuweisungsoperator unter PL/SQL",
    "explanation": "Das \":=\" stimmt leider nicht mit dem \"=\" aus anderen Programmiersprachen überein.",
    "type": "text",
    "answers": [
      {
        "text": "ist",
        "solution": ":="
      }
    ]
  },
  {
    "id": 862,
    "category": 12,
    "difficulty": 2,
    "text": "Welche PL/SQL-Anweisungen werden aus SQL unverändert übernommen?",
    "explanation": "DDL-Anweisungen wie GRANT und CREATE sind in PL/SQL aus Sicherheitsgründen nicht zugelassen. Die SELECT-Anweisung kann nicht direkt, sondern nur über einen Cursor ausgeführt werden, der das Ergebnis der SELECT-Anweisung zur Weiterverarbeitung aufnimmt oder besitzt zusätzlich zum interaktiven SQL eine INTO-Klausel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSERT",
        "solution": "true"
      },
      {
        "text": "DELETE",
        "solution": "true"
      },
      {
        "text": "SELECT",
        "solution": "false"
      },
      {
        "text": "UPDATE",
        "solution": "true"
      },
      {
        "text": "CREATE",
        "solution": "false"
      },
      {
        "text": "GRANT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 863,
    "category": 12,
    "difficulty": 1,
    "text": "Welche Komponente kommt bei SELECT-Anweisungen unter PL/SQL neu hinzu?",
    "explanation": "Das Ergebnis eines SELECTS wird mit SELECT ... INTO ... in eine PL/SQL-Variable übergeben, was bei interaktivem SQL nicht notwendig ist.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "INTO"
      }
    ]
  },
  {
    "id": 864,
    "category": 12,
    "difficulty": 1,
    "text": "In welcher Reihenfolge erscheinen die folgenden Komponenten eines PL/SQL-Cursors? Tragen Sie die Zahlen 1-4 ein!",
    "explanation": "DECLARE: Als erstes wird der CURSOR im Deklarationsteil des PL/SQL-Blocksdefiniert, das heißt, er bekommt einen Namen und eine SELECT-Anweisung, diebeliebig komplex sein kann. Eine INTO-Klausel ist weder erlaubt noch notwendig.Damit verbunden ist intern das Anlegen eines benannten Zwischenspeicherbereichsfür die Aufnahme der Ergebnismenge. Alle weiteren Schritte werden imAusführungsteil durchgeführt.  \nOPEN: Beim Öffnen eines CURSOR wird die zugehörige SELECT-Anfrage an das Datenbankmanagementsystem geschickt und dort ausgewertet. Von dort wird die Ergebnismenge in den benannten Speicherbereich geladen, was heißt, dass während der gesamten Zeit der CURSOR-Verarbeitung die Ergebnisdatenmenge unverändert bleibt. Nach der OPEN-Anweisung parallel von anderen Transaktionen durchgeführte Manipulationen haben keinen Einfluss mehr auf die Ergebnisdaten, die ja bereits als Kopie im Zwischenspeicherbereich vorliegen. \nFETCH: In PL/SQL ist ein Zeiger (CURSOR) nach dem Öffnen sofort auf den ersten Datensatz dieser Ergebnismenge positioniert, so dass mit einer FETCH-Anweisung dieser Satz aus dem benannten Speicherbereich in die lokalen PL/SQL-Variablen hinein ausgelesen werden kann. Als zusätzliche Funktion positioniert die FETCH-Anweisung den Zeiger auch noch auf den nächsten Datensatz im Zwischenspeicher. \nCLOSE: War der letzte FETCH nicht erfolgreich, d.h., sind die lokalen Variablen leer, dann heißt dass, dass alle Datensätze abgearbeitet sind und die Schleife verlassen werden kann. Beim Schließen des CURSOR wird der damit verbundene Zwischenspeicherbereich wieder freigegeben.",
    "type": "text",
    "answers": [
      {
        "text": "OPEN",
        "solution": "2"
      },
      {
        "text": "CLOSE",
        "solution": "4"
      },
      {
        "text": "FETCH",
        "solution": "3"
      },
      {
        "text": "DECLARE",
        "solution": "1"
      }
    ]
  },
  {
    "id": 865,
    "category": 12,
    "difficulty": 2,
    "text": "Welches Cursor-Attribut liefert die Gesamtanzahl der bisher gelesenen Zeilen?",
    "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR geöffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "%ROWCOUNT"
      }
    ]
  },
  {
    "id": 866,
    "category": 12,
    "difficulty": 2,
    "text": "Womit fragt man ab, ob ein CURSOR schon geöffnet ist?",
    "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR geöffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen",
    "type": "text",
    "answers": [
      {
        "text": "Mit dem CURSOR-Attribut",
        "solution": "%ISOPEN"
      }
    ]
  },
  {
    "id": 867,
    "category": 12,
    "difficulty": 2,
    "text": "Womit fragt man ab, ob die Fetch-Anweisung schon die letzte Zeile eines Cursors erreicht hat?",
    "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR geöffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen",
    "type": "text",
    "answers": [
      {
        "text": "Mit dem Cursor-Attribut",
        "solution": "%NOTFOUND"
      }
    ]
  },
  {
    "id": 869,
    "category": 12,
    "difficulty": 2,
    "text": "Welche EXCEPTION wird unter PL/SQL geworfen, wenn ein SELECT kein Ergebnis liefert?",
    "explanation": "IN PL/SQL verursacht eine SELECT-Anweisung, die nicht in einem Cursor definiert ist, die EXCEPTION NO_DATA_FOUND, wenn der SELECT keine Zeilen liefert. Ausweg ist die Verwendung eines Cursors.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "NO_DATA_FOUND"
      }
    ]
  },
  {
    "id": 870,
    "category": 12,
    "difficulty": 3,
    "text": "Welche EXCEPTION wird unter PL/SQL geworfen, wenn die Konvertierung eines Strings in eine Zahl fehlschlug?",
    "explanation": "INVALID NUMBER ist in PL/SQL die vordefinierte EXCEPTION für diesen Konvertierungsfehler.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "INVALID_NUMBER"
      }
    ]
  },
  {
    "id": 872,
    "category": 12,
    "difficulty": 3,
    "text": "Welche Exception wird in PL/SQL geworfen, wenn die Anmeldung an die Datenbank fehlschlug?",
    "explanation": "LOGIN_DENIED ist in PL/SQL die vordefinierte EXCEPTION für diesen Anmeldungsfehler.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "LOGIN_DENIED"
      }
    ]
  },
  {
    "id": 873,
    "category": 12,
    "difficulty": 3,
    "text": "Welche Exception wird geworfen, wenn der Fehler nicht explizit vom Exception-Handler aufgerufen wurde?",
    "explanation": "OTHERS steht in PL/SQL für alle EXCEPTIONS, die nicht explizit im\nEXECPTION-Handler aufgeführt wurden.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "OTHERS"
      }
    ]
  },
  {
    "id": 874,
    "category": 12,
    "difficulty": 1,
    "text": "Welche Parametertypen gibt es unter PL/SQL?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "OUT",
        "solution": "true"
      },
      {
        "text": "IN OUT",
        "solution": "true"
      },
      {
        "text": "OUT IN",
        "solution": "false"
      }
    ]
  },
  {
    "id": 875,
    "category": 7,
    "difficulty": 2,
    "text": "In welcher Reihenfolge müssen in einem SELECT-Befehl die folgenden Klauseln stehen? (Geben Zahlen von 1 bis 6 an)",
    "explanation": "Die Reihenfolge der Klauseln einer SELECT-Anfrage sind: \nSELECT ...\nFROM ...\n[ WHERE ... ]\n[ GROUP BY ... ]\n[ HAVING ... ]\n[ ORDER BY ... ]\nDie eckigen Klammern geben die Optionalität der Klauseln an.",
    "type": "text",
    "answers": [
      {
        "text": "WHERE",
        "solution": "3"
      },
      {
        "text": "FROM",
        "solution": "2"
      },
      {
        "text": "ORDER BY",
        "solution": "6"
      },
      {
        "text": "HAVING",
        "solution": "5"
      },
      {
        "text": "GROUP BY",
        "solution": "4"
      },
      {
        "text": "SELECT",
        "solution": "1"
      }
    ]
  },
  {
    "id": 881,
    "category": 12,
    "difficulty": 2,
    "text": "Womit kann man in PL/SQL eine Variable definieren, deren Datentyp einer Spalte einer Tabelle entspricht?",
    "explanation": "MitTabellenname.Spaltenname%TYPE;  wird eine PL/SQL-Variable entsprechend eines zuvor definierten Attributs (Spalte) einer Tabelle definiert. Alternativ kann man auch mit Tabellenname%ROWTYPE die Attributstruktur der Tabelle komplett an einen Variable in PL/SQL übertragen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "%TYPE"
      }
    ]
  },
  {
    "id": 882,
    "category": 12,
    "difficulty": 1,
    "text": "Unter PL/SQL gibt es den Datentyp BOOLEAN.",
    "explanation": "Während in PL/SQL und in Standard -SQL der Datentyp Boolean schon seit SQL2 existiert, ist dies in Oracle SQL bis zur Version 11g leider nicht der Fall.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 683,
    "category": 7,
    "difficulty": 1,
    "text": "Bei einer INSERT-Anweisung kann man die Spaltennamen hinter \"INSERT INTO Tabellenname (...)\" unter bestimmten Bedingungen weglassen.",
    "explanation": "In einer INSERT-Anweisung kann man die Spaltennamen nach INSERT weglassen, wenn alle Spalten der Tabelle mit Werten gefüllt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 684,
    "category": 6,
    "difficulty": 1,
    "text": "Die Pflichteingabebedingung kann mit der NOT-NULL-Klausel nur als COLUMN-Constraint definiert werden.",
    "explanation": "Die Funktionalität des NULL-Constraints ist als einziges Constraint ausschließlich als Spalten-Constraint zu haben. Die Funktionalität der anderen Constraints (Primär-, Eindeutigkeit-, Fremdschlüssel und CHECK) sind sowohl als Spalten- wie auch Tabellen-Constraint definierbar. Beim Fremdschlüssel muss auf eine unterschiedliche Syntax geachtet werden: Als Spalten-Constraint heißt es \"REFERENCES\" und als Tabellen-Constraint \"FOREIGN KEY\" \n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... )\n\n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 701,
    "category": 6,
    "difficulty": 1,
    "text": "Der Datentyp BOOLEAN gehört zum SQL2003-Standard.",
    "explanation": "Ja, endlich gibt es dort einen BOOLEAN-Datentyp mit den Zuständen: TRUE, FALSE, NULL/UNKNOWN. Denken Sie immer daran, SQL liegt eine dreiwertige Logik zugrunde mit \"wahr\", \"falsch\", \"unbekannt\"! \nLeider ist dieser Datentyp immer noch nicht bei Oracle und anderen Datenbankherstellern implementiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ja",
        "solution": "true"
      },
      {
        "text": "nein",
        "solution": "false"
      }
    ]
  },
  {
    "id": 911,
    "category": 13,
    "difficulty": 1,
    "text": "Transitionale Integritätsbedingungen können definiert werden",
    "explanation": "In CONSTRAINTS sind nur sehr einfache Integritätsbedingungen formulierbar, die Werte mit Konstanten oder Werten in anderen Spalten vergleichen. Transitionale Integritätsbedingungen  gehören nicht dazu und müsssen in Triggern formuliert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "In CONSTRAINTS",
        "solution": "false"
      },
      {
        "text": "In Datenbanktriggern",
        "solution": "true"
      }
    ]
  },
  {
    "id": 914,
    "category": 13,
    "difficulty": 2,
    "text": "Auf einer Tabelle sei ein AFTER-ROW-Trigger für eine UPDATE-Anweisung definiert. Es wird eine UPDATE - Anweisung ausgeführt, die keinen Datensatz verändert.",
    "explanation": "Da kein Datensatz verändert wird, wird der AFTER-ROW-Trigger auch nicht angestossen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der ROW-Trigger wird trotzdem ausgeführt.",
        "solution": "false"
      },
      {
        "text": "Der ROW-Trigger wird nicht ausgeführt.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 915,
    "category": 13,
    "difficulty": 1,
    "text": "Auf einer Tabelle sei ein STATEMENT-Trigger für eine UPDATE-Anweisung definiert. Es wird eine UPDATE - Anweisung ausgeführt, die keinen Datensatz verändert.",
    "explanation": "Bei einem Statement-Trigger wird der Trigger ausgeführt, auch wenn kein Datensatz verändert wurde. Bei AFTER-ROW-Triggern ist das nicht der Fall.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der Trigger wird ausgeführt.",
        "solution": "true"
      },
      {
        "text": "Der Trigger wird nicht ausgeführt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1764,
    "category": 12,
    "difficulty": 2,
    "text": "Wodurch ist eine dynamische SQL-Anweisung gekennzeichnet?",
    "explanation": "Dynamisch bedeutet gerade, dass ein Inhalt einer Textvariable erst zur Laufzeit dem Datenbanksystem übergeben und dann auch übersetzt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der Inhalt der SQL-Anweisung ist schon zur Übersetzungszeit bekannt.",
        "solution": "false"
      },
      {
        "text": "Der Inhalt der SQL-Anweisung wird zur Laufzeit erstellt.",
        "solution": "true"
      },
      {
        "text": "Der Inhalt der SQL-Anweisung ist zur Übersetzungszeit unbekannt.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 961,
    "category": 14,
    "difficulty": 3,
    "text": "Welches Problem taucht unter ORACLE-SQL nicht auf?",
    "explanation": "Die Unterschiede bei den Isolationsgraden zwischen SQL2003 und Oracle basieren im Wesentlichen darauf, dass Oracle unsauberes Lesen (DIRTY READ) grundsätzlich ausschließt, womit der Isolationsgrad READ UNCOMMITTED entfällt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DIRTY READ",
        "solution": "true"
      },
      {
        "text": "LOST UPDATE",
        "solution": "true"
      },
      {
        "text": "PHANTOM",
        "solution": "false"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "false"
      }
    ]
  },
  {
    "id": 964,
    "category": 7,
    "difficulty": 3,
    "text": "Autos mit ihren Sonderausstattungen werden in zwei Tabellen Auto und Sonderausstattung gespeichert. Welche SELECT-Anweisung befriedigt die folgende Anfrage: \nErstellen Sie eine Liste aller Autos, die keine Sonderausstattung haben!",
    "explanation": "Die Abfrage\n\nSELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr \n\ngibt aus dem kartesischen Produkt alle Autos mit allen Sonderausstattungen diejenigen aus, deren Seriennummer verschieden ist. \n\nSELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung) \n\nliefert alle Autos, da der NOT EXIST immer erfüllt ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A\nWHERE A.SerienNr NOT IN \n   (SELECT SerienNr FROM Sonderausstattung)",
        "solution": "true"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung B\n WHERE A.SerienNr = B.SerienNr)",
        "solution": "true"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A LEFT JOIN Sonderausstattung B ON (A.SerienNr = B.SerienNr) GROUP BY A.SerienNr, A.Modell\nHAVING count(B.Sonderausstattung) = 0",
        "solution": "true"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A \nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung)",
        "solution": "false"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE NOT EXISTS   \n(SELECT SerienNr FROM Sonderausstattung\n WHERE A.SerienNr = B.SerienNr)",
        "solution": "false"
      },
      {
        "text": "SELECT A.SerienNr, A.Modell\nFROM Auto A, Sonderausstattung B\nWHERE A.SerienNr <> B.SerienNr",
        "solution": "false"
      }
    ]
  },
  {
    "id": 967,
    "category": 15,
    "difficulty": 2,
    "text": "Es gibt",
    "explanation": "Ein Index ist ein separates Verzeichnis der Gestalt \"Wert, Adresse\",  wobei der Wert aus einem oder mehreren Spaltenwerten (ein oder mehrdimensionaler Index) bestehen kann. Die Adresse verweist auf den Platz, an dem die Daten auf der Platte gespeichert sind. In einem dichten Index sind alle Datensätze eingetragen, in einem dünnen Index dagegen nur einige ausgewählte Datensätze.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "dünne Indizes",
        "solution": "true"
      },
      {
        "text": "dicke Indizes",
        "solution": "false"
      },
      {
        "text": "dichte Indizes",
        "solution": "true"
      },
      {
        "text": "undichte Indizes",
        "solution": "false"
      },
      {
        "text": "lange Indizes",
        "solution": "false"
      },
      {
        "text": "kurze Indizes",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1320,
    "category": 14,
    "difficulty": 2,
    "text": "Welche Aussagen über \"Transaktionen und Lesekonsistenz in SQL\" sind richtig?",
    "explanation": "Richtig ist, dass bei Oracle zwei Konsistenzgrade unterschieden werden: \"statement level\" und \"transaction level\", richtig ist auch, das bei Oracle \"dirty reads\" grundsätzlich ausgeschlossen sind. \n\nBeim SQL-Standard hingegen ist es anders, dort sind \"dirty reads\" grundsätzlich möglich und müssen durch einen passenden Isolationsgrad ausgeschlossen werden (READ COMMITTED und höher).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Im SQL-Standard sind keine \"dirty reads\" möglich.",
        "solution": "false"
      },
      {
        "text": "Bei Oracle werden zwei Konsistenzgrade unterschieden: \"statement level\" und \"transaction level\".",
        "solution": "true"
      },
      {
        "text": "Im SQL-Standard sind \"dirty reads\" möglich. Bei Oracle wird die Grundannahme getroffen, dass keine \"dirty reads\" möglich sind.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1763,
    "category": 13,
    "difficulty": 1,
    "text": "Bei welchem Trigger-Ausführungsmodell richtet sich die Reihenfolge der Ausführung der Trigger, die für eine bestimmte Tabelle definiert sind, nach der \"creation time\"?",
    "explanation": "Im Ausführungsmodell von Oracle werden die ROW-Trigger um das DML-Ereignis gruppiert, so dass die creation-Time nicht notwendig ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ausführungsmodell von ORACLE",
        "solution": "false"
      },
      {
        "text": "Ausführungsmodell von SQL:1999 und DB2",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1319,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Aussagen über \"Transaktionen und Lesekonsistenz in SQL\" sind richtig?",
    "explanation": "Lesekonsistenz ist ein weiteres Problem, welches beim Mehrbenutzerbetrieb auftritt. Bei länger andauernden Transaktionen stellt sich die Frage, auf welchem Datenbankzustand die Anfragen eigentlich ausgewertet werden, wenn parallel andere Benutzer die zu lesenden Daten ändern.\n\nDaraus resultieren mehrere Probleme: \n\nBei innerhalb einer Transaktion wiederholten Anfragen können bei der Wiederholung Datensätze angezeigt werden, die vorher nicht da waren, also \"Phantome\", bzw. es werden Datensätze nicht mehr angezeigt oder mit geänderten Inhalt, also \"nicht wiederholbares Lesen\".  Grund dafür sind jeweils andere Transaktionen, die ihre Änderungen persistent gespeichert haben (COMMIT).\n\nEin anderes Problem stellt sich bei langandauernden Anfragen, was passiert mit den Änderungen parallel ausgeführter Transaktionen, die zwischenzeitlich ihre Änderungen persistent gespeichert haben. (COMMIT).\n\n\"Dirty Read\" ist ein Problem, das beiden Aufgabenstellungen, Nebenläufigkeitskontrolle wie auch Lesekonsistenz betrifft. \n\n\"Lost Update\" ist ein Problem der Nebenläufigkeitskontrolle weniger der Lesekonsistenz.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dauert eine Anfrage länger, so kann im Multi User-Betrieb u.a. das \"Lost Update-Problem\" auftreten.",
        "solution": "false"
      },
      {
        "text": "Dauert eine Anfrage länger, so kann im Multi User-Betrieb u.a. das \"Dirty Read-Problem\" auftreten.",
        "solution": "true"
      },
      {
        "text": "Führt eine Transaktion eine Anfrage mehrfach aus, so können u.a. \"non repeatable reads\" und \"phantome\" auftreten.",
        "solution": "true"
      },
      {
        "text": "Führt eine Transaktion eine Anfrage mehrfach aus, so können u.a. \"lost updates\", \"non repeatable reads\" und \"phantome\" auftreten.",
        "solution": "false"
      },
      {
        "text": "Bei der Lesekonsistenz geht es primär um das Problem: \"Auf welchem Datenbankzustand werden die Transaktionen ausgeführt, wenn z.B. eine Anfrage länger dauert oder aber während einer Transaktion eine Anfrage mehrfach ausgeführt wird.\"",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1765,
    "category": 12,
    "difficulty": 3,
    "text": "Welche EXCEPTIONS können speziell bei einem impliziten Cursor (SELECT  INTO ) geworfen werden? Bitte in alphabetischer Reihenfolge schreiben!",
    "explanation": "SELECT INTO übergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datensätze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datensätze verarbeiten kann.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "NO_DATA_FOUND"
      },
      {
        "text": "und",
        "solution": "TOO_MANY_ROWS"
      }
    ]
  },
  {
    "id": 1291,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem SQL-Operator wird der Für-Alle-Quantor umgesetzt?",
    "explanation": "Der Für-Alle-Quantor kann in SQL nicht direkt umgesetzt werden, sondern nur über zwei mögliche Umwege: Über ein doppeltes NOT EXISTS oder durch ein GROUP-BY/HAVING mit Zählen über COUNT(*).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mit einem NOT EXISTS",
        "solution": "false"
      },
      {
        "text": "Mit zwei NOT EXISTS",
        "solution": "true"
      },
      {
        "text": "Mit FORALL",
        "solution": "false"
      },
      {
        "text": "Mit keinem dieser Operatoren",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1293,
    "category": 7,
    "difficulty": 3,
    "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank:\n\n    Spieler (Spieler_id, Name, Adresse, Geburtsdatum) Vereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr )\n\n    Spiele (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\n\n    Spieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\n    Welche der angegeben SQL-Abfragen beantwortet/en die Frage: Welche Vereine (Kürzel, Name) haben wenigstens ein Auswärtsspiel, also wenigstens ein als Spiel als Gastmannschaft in der Rückrunde (Spieltag 18-34) absolviert?",
    "explanation": "SELECT v_kuerzel, vereinsname\n\n    FROM verein, spiele\n\n    WHERE spieltag BETWEEN 18 AND 34;\n\n    \n\n    ist semantisch falsch: Es wird hier das kartesische Produkt zwischen den beiden Tabellen ausgeführt und nicht der Natural Join.\n\n    \n\n    Die übrigen Anfragen sind alle richtig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND  spieltag BETWEEN 18 AND 34;",
        "solution": "true"
      },
      {
        "text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND spieltag >= 18 AND <= 34;",
        "solution": "true"
      },
      {
        "text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele  \nWHERE  spieltag BETWEEN 18 AND 34;",
        "solution": "false"
      },
      {
        "text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34);",
        "solution": "true"
      },
      {
        "text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34\n GROUP BY gast_v_kuerzel \n  HAVING COUNT (*) >=1);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1294,
    "category": 5,
    "difficulty": 3,
    "text": "Welche Aussagen über Normalformen sind wahr?",
    "explanation": "In der 3. NF sind partielle (2.NF) und transitive funktionale Abhängigkeiten (3. NF) aufgelöst, so dass jedes Nichtschlüsselattribut nur einmal auftritt in allen Relationen. Lediglich Schlüsselattribute der einen Relation können in anderen Relationen als Fremdschschlüssel-Attribute auftreten, somit liegen nur noch in diesen Fremdschlüsselattributen Redundanzen vor. \nFalsch ist \"Redundanzen vermeiden Einfüge-/Lösch- und Änderungsanomalien.\", weil Redundanzen Grundvoraussetzungen für diese Anomalien sind. \nFalsch ist \"Eine Relation R mit Primärschlüssel S befindet sich in der ersten Normalform, wenn jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.\", weil dies die Definition der 2. NF ist. Die 1. NF schließt mengenwertige (nicht atomare) Attribute aus. \nEine Relation ist in der dritten Normalform, wenn sie in der 1. und 2. NF ist und kein Nichtschlüsselattribut transitiv abhängig ist von einem Schlüsselattribut.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Datenmodell in 3. Normalform enthält keine Redundanzen außer Schlüsselredundanzen (Fremdschlüsselbeziehungen).",
        "solution": "true"
      },
      {
        "text": "Redundanzen vermeiden Einfüge-/Lösch- und Änderungsanomalien.",
        "solution": "false"
      },
      {
        "text": "Eine Relation R mit Primärschlüssel S befindet sich in der ersten Normalform, wenn jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.",
        "solution": "false"
      },
      {
        "text": "Eine Relation ist in der dritten Normalform, wenn sie in der 1. und 2. NF ist und kein Nichtschlüsselattribut transitiv abhängig ist von einem Schlüsselattribut.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1322,
    "category": 14,
    "difficulty": 2,
    "text": "Welche Aussagen über \"Transaktionen und Fehlererholung in SQL\" sind richtig?",
    "explanation": "FALSCH ist: \n\"Recovery\" meint das Einspielen eines physisch gesicherten Datenbestands.\" Diese Definition ist nicht umfassend genug. Das Einspielen gesicherter Daten ist nur ein Teil des RECOERY-Prozesses. \n \nEine umfassende Beschreibung liefert die Antwort: \n\"Recovery\" meint das Wiederherstellen eines möglichst aktuellen DB-Zustands vor Abbruch des DBS. Ein erster Schritt kann ggf. das Zurückspielen eines extern gesicherten Datenbestands sein. Ausgehend von diesem DB-Zustand wird dann anhand von System-Log-Datei-Einträgen ein möglichst aktueller DB-Zustand rekonstruiert.\"\n \nEbenfalls richtig ist:\n\"Zentrale Werkzeuge der Fehlererholung sind \"Backup-\" (physische Datensicherung) und \"Recovery\"-Strategien (Wiederherstellung eines möglichst aktuellen DB-Zustands vor Abbruch i.d.R. ausgehend von einem gesicherten Datenbestand).\"",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zentrale Werkzeuge der Fehlererholung sind \"Backup-\" (physische Datensicherung) und \"Recovery\"-Strategien (Wiederherstellung eines möglichst aktuellen DB-Zustands vor Abbruch i.d.R. ausgehend von einem gesicherten Datenbestand).",
        "solution": "true"
      },
      {
        "text": "\"Recovery\" meint das Einspielen eines physisch gesicherten Datenbestands.",
        "solution": "false"
      },
      {
        "text": "\"Recovery\" meint das Wiederherstellen eines möglichst aktuellen DB-Zustands vor Abbruch des DBS. Ein erster Schritt kann ggf. das Zurückspielen eines extern gesicherten Datenbestands sein. Ausgehend von diesem DB-Zustand wird dann anhand von System-Log-Datei-Einträgen ein möglichst aktueller DB-Zustand rekonstruiert.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1323,
    "category": 14,
    "difficulty": 1,
    "text": "Welche Aussagen über \"Transaktionen und Fehlererholung in SQL\" sind richtig?",
    "explanation": "RICHTIG ist: \n\"System-Log-Dateien sind Protokolle über alle durchgeführten Transaktionen und die Informationen werden ohne Pufferung direkt auf der Platte gespeichert.\" Wichtig ist, dass diese Informationen nicht im Hauptspeicher gehalten werden, denn es geht ja gerade darum, dass diese Informationen für etwaige Rekonstruktionen von Transaktionen zur Verfügung stehen - auch im Falle eines Systemabsturzes und Verlust der HSP-Daten, daher immer persistent auf Platte.  \n\nAus diesem Grunde ist die andere Aussage dann auch FALSCH.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "System-Log-Dateien sind Protokolle über alle durchgeführten Transaktionen und die Informationen werden für einen schnellen Zugriff möglichst lange im Hauptspeicher gepuffert.",
        "solution": "false"
      },
      {
        "text": "System-Log-Dateien sind Protokolle über alle durchgeführten Transaktionen und die Informationen werden ohne Pufferung direkt auf der Platte gespeichert.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1324,
    "category": 14,
    "difficulty": 2,
    "text": "Welche der folgenden Punkte sind Inhalte von System-Log-Dateien?",
    "explanation": "Es muss zwischen den beiden Systemen für das LOGGING und das LOCKING differenziert werden: \nDas LOCKING-System sorgt für ein exclusives Sperren von Datensätzen für Änderungen und daher werden dort Informationen wie z.B.\n\nArt des Locks (SLOCK, XLOCK)\nLOCK-Ebene.\n\n\nDas LOGGING-System sorgt dafür, dass Transaktionen zurückgerollt und ggf. auch wieder rekonstruiert werden können. Dafür werden u.a. folgende Informationen benötigt: \n\nTransaktions-ID\nArt der Änderung (Insert / Update / Delete)\nAlter/neuer Wert der Daten des Datensatzes (physikalische Adresse)\nStartzeitpunkt der Änderung\nArt der Beendigung (COMMIT, ROLLBACK, noch nicht beendet)\nBenutzerkennung bzw. verwendetes Programm",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Transaktions-ID",
        "solution": "true"
      },
      {
        "text": "LOCK-Ebene",
        "solution": "false"
      },
      {
        "text": "Art der Änderung (Insert / Update / Delete)",
        "solution": "true"
      },
      {
        "text": "Alter/neuer Wert der Daten des Datensatzes (physikalische Adresse)",
        "solution": "true"
      },
      {
        "text": "Startzeitpunkt der Änderung",
        "solution": "true"
      },
      {
        "text": "Art des Locks (SLOCK, XLOCK)",
        "solution": "false"
      },
      {
        "text": "Art der Beendigung (COMMIT, ROLLBACK, noch nicht beendet)",
        "solution": "true"
      },
      {
        "text": "Benutzerkennung bzw. verwendetes Programm",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1325,
    "category": 10,
    "difficulty": 2,
    "text": "In welchem JAVA-Package befinden sich die Klassen von JDBC?",
    "explanation": "Wer näheres Wissen will, sollte bei SUN selber nachschlagen: \n\n<a href= \"http://java.sun.com/j2se/1.4.2/docs/api/java/sql/package-summary.html\"> JDBC-Dokumentation bei Sun",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "java.sql"
      }
    ]
  },
  {
    "id": 1326,
    "category": 10,
    "difficulty": 1,
    "text": "Von der executeQuery() Methode wird ein ResultSet-Objekt erzeugt. Wo steht der Cursor zu Beginn?",
    "explanation": "Der Cursor steht vor dem ersten Datensatz und muss dann mit next() auf den ersten Datensatz bewegt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Vor dem ersten Datensatz",
        "solution": "true"
      },
      {
        "text": "Auf dem ersten Datensatz",
        "solution": "false"
      },
      {
        "text": "Auf dem zweiten Datensatz",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1327,
    "category": 10,
    "difficulty": 3,
    "text": "Wie können Sie den Java Datentyp \"boolean\" in den meisten relationalen Datenbanken ablegen?",
    "explanation": "Obwohl der Datentyp boolean im SQL-Standard seid SQL:2003 vorgesehen ist, wird er nur von wenigen Datenbankherstellern implementiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "\"boolean\" hat in dem meisten SQL-Dialekten keine Entsprechung.",
        "solution": "true"
      },
      {
        "text": "boolean entspricht dem SQL-Standard-Datentyp \"boolean\" seid SQL:2003.",
        "solution": "true"
      },
      {
        "text": "Oracle besitzt einen Datentyp boolean gemäß dem SQL-Standard SQL:2003.",
        "solution": "false"
      },
      {
        "text": "Postgres besitzt einen Datentyp boolean gemäß dem SQL-Standard SQL:2003.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1328,
    "category": 10,
    "difficulty": 2,
    "text": "Wie können Sie den Java Datentyp \"String\" in den meisten relationalen Datenbanken ablegen?",
    "explanation": "Standardmäßig wird der Datentyp varchar benutzt, char kann auch angegeben werden, ist aber nicht der default.",
    "type": "text",
    "answers": [
      {
        "text": "Das entspricht im SQL-Standard",
        "solution": "varchar"
      }
    ]
  },
  {
    "id": 1373,
    "category": 11,
    "difficulty": 3,
    "text": "Wie heißt die Default-Verbindung, mit der man unter SQLJ und JDBC eine Verbindung in einer ORACLE-Datenbank selber als gespeicherte Prozedur aufbauen kann?",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "jdbc:default:connection"
      }
    ]
  },
  {
    "id": 1376,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über CONSTRAINTS sind wahr?",
    "explanation": "Die zwei richtigen Aussagen erklären sich selbst. \nFALSCH ist: \nDie Sache mit dem \"MANDATORY-CONSTRAINT\". Ein Constraint dieses Namens gibt es nicht. Das Constraint mit der gewünschten Funktion heißt: NOT NULL bei SQL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Für im ER-Modell als \"obligatorisch\" (Pflichteingabe) deklarierte Attribute werden im Datenmodell MANDATORY-CONSTRAINTS definiert.",
        "solution": "false"
      },
      {
        "text": "Die Standardreaktion auf einen Integritätsfehler beim \"integrity checking\" mittels Constraints ist das Zurückrollen des fehlerhaften DML-Befehls (Prüfungsmodus IMMEDIATE) bzw. der gesamten Transaktion beim Prüfungsmodus DEFERRED.",
        "solution": "true"
      },
      {
        "text": "Transitionale Integritätsbedingungen können in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Referenzvariablen (:OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1392,
    "category": 6,
    "difficulty": 1,
    "text": "Wenn ein CONSTRAINT existiert, kann der Anwender sicher sein, dass alle in der Datenbank gespeicherten Daten die Bedingung erfüllen, die durch den CONSTRAINT definiert ist.",
    "explanation": "Genau das ist der 100% Schutz, den Datenbanksysteme bei Constraints bieten. Wenn man in der USER_CONSTRAINTS des Dictionary sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabhängig vom Zeitpunkt der Speicherung korrekt sind. \nDas ist einer der Punkte, bei dem sich Integritätsprüfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden dort nur für alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung überprüft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1461,
    "category": 12,
    "difficulty": 1,
    "text": "Betrachten Sie die folgende Package-Definition in PL/SQL:\n\nCREATE OR REPLACE PACKAGE Math_Pack AS\n      PROCEDURE Mitteln (x IN NUMBER, y IN NUMBER);\n      PROCEDURE Root    (x IN NUMBER, y IN NUMBER);\n      Ergebnis NUMBER;\nEND Math_Pack;",
    "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder öffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind öffentlich und können damit von außerhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und können damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.  \n\nDaher ist die Variable \"Ergebnis\" ist öffentlich.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Variable \"Ergebnis\" ist privat.",
        "solution": "false"
      },
      {
        "text": "Die Variable \"Ergebnis\" ist öffentlich.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1397,
    "category": 15,
    "difficulty": 3,
    "text": "Bei welchen Speicherstrukturen sind die Nutzdaten von den Schlüsseldaten getrennt?",
    "explanation": "Die Hash-Speicherstruktur beinhaltet keinen Index und ISAM und B+-Baum haben einen Index, der getrennt von den Nutzdaten gespeichert wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "ISAM",
        "solution": "true"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      },
      {
        "text": "B+-Baum",
        "solution": "true"
      },
      {
        "text": "HASH",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1411,
    "category": 1,
    "difficulty": 1,
    "text": "Was versteht man unter der Abkürzung QBE?",
    "explanation": "QBE steht für Query By Example und ist eine Anfragesprache, die schon in den 70er Jahren parallel zu SQL und System R bei der IBM entwickelt wurde.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "Query By Example"
      }
    ]
  },
  {
    "id": 1446,
    "category": 11,
    "difficulty": 2,
    "text": "Mit welchem Zeichen werden Paramater an eine SQLJ Prozedur von außen übergeben?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist \":\"",
        "solution": "false"
      },
      {
        "text": "Das ist \"?\"",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1448,
    "category": 7,
    "difficulty": 3,
    "text": "Wo sind SQL-Aggregatfunktionen (SUM, MIN, MAX, COUNT, AVG) erlaubt?",
    "explanation": "Die SQL-Gruppenfunktionen SUM,MIN, MAX, AVG und COUNT machen in der WHERE-Klausel keinen Sinn, da sie sich auf Gruppen von Werten, nicht auf einzelne Werte, beziehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT-Klausel ohne SUBSELECT",
        "solution": "true"
      },
      {
        "text": "FROM-Klausel ohne SUBSELECT",
        "solution": "false"
      },
      {
        "text": "WHERE-Klausel ohne SUBSELECT",
        "solution": "false"
      },
      {
        "text": "GROUP BY-Klausel",
        "solution": "false"
      },
      {
        "text": "HAVING-Klausel ohne SUBSELECT",
        "solution": "true"
      },
      {
        "text": "ORDER BY-Komponente",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1456,
    "category": 12,
    "difficulty": 1,
    "text": "Welche PL/SQL-Syntax ist korrekt?",
    "explanation": "OPEN Cursorname; reicht hier aus.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "OPEN CURSOR Cursorname;",
        "solution": "false"
      },
      {
        "text": "OPEN Cursorname;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1742,
    "category": 14,
    "difficulty": 2,
    "text": "Welche Aussagen über \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?",
    "explanation": "RICHTIG ist: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, können  andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.\"\n\nFALSCH ist: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, können  andere Transaktion keine SLOCKs auf das gesperrte Objekt absetzen.\"\nEs ist ja gerade Sinn und Zweck der SLOCKs parallleles Lesen zuzulassen und daher sind mehrere SLOCKs auf einer Tabelle möglich. \nXLOCKS hingegen können erst wieder gesetzt werden, wenn keine SLOCKs mehr vorliegen und auch keine anderen XLOCKs.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, können  andere Transaktion keine XLOCKs auf das gesperrte Objekt absetzen.",
        "solution": "true"
      },
      {
        "text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, können  andere Transaktion keine SLOCKs auf das gesperrte Objekt absetzen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1741,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welchem CONSTRAINT_CHARACTERISTICA  kann man den Prüfungszeitpunkt bis zum Ende der Transaktion verzögern?",
    "explanation": "<CONSTRAINT Characteristika> ::= \n{ INITIALLY DEFERRED | INITIALLY IMMEDIATE } [ [ NOT ] DEFERRABLE ]\n\nMit DEFERRED (verzögert) wird die Prüfung der Integritätsbedingung zum Ende der Transaktion (COMMIT) bezeichnet. IMMEDIATE (unmittelbar) beschreibt die Prüfung unmittelbar im Anschluss an die Ausführung einer einzelnen Änderungsanweisung. \nIMMEDIATE hat den Vorteil, dass Integritätsfehler so früh wie möglich erkannt werden, und DEFERRED, dass während der laufenden Transaktion durch nachfolgende Anweisungen ein zwischenzeitlich inkonsistenter Zustand wieder korrigiert werden kann.",
    "type": "text",
    "answers": [
      {
        "text": "CONSTRAINT_CHARACTERISTICA  =",
        "solution": "INITIALLY DEFERRED"
      }
    ]
  },
  {
    "id": 2465,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über Sichten sind wahr?",
    "explanation": "Sichten können auf Tabellen oder anderen Sichten definiert sein, das snd die sogenannten Sichthierarchien. \nAufrund der redundanten Datenspeicherung in den materialisierten Sichten sind diese schneller bei Anfragen, haben jedoch das Problem, dass sich Tabellendaten ändern und die Sichtdaten dann veraltet sind. \nEs ist der Nachteil der virtuellen Sichten, dass sie längere Antwortzeiten haben, da die Anfrage erst über allen Tabellen ausgewertet werden muss. \n\nDML-Befehle (INSERT, UPDATE,DELETE) können auf Sichten ausgeführt werden. Und daraus resultiert das \"view updating\"-Problem, bei dem es darum geht, das das DBMS in der Lage ist, eine Manipulation des View-Datensatzes nur mit Hilfe der Sichtdefinition vollautomatisch auf die Datensätze in den zugrunde liegenden Tabellen zu transformieren. Dieses \"view updating\"-Problem ist in der Wissenschaft bislang nur für einige Fälle gelöst und für einen kleinen Teil davon haben die DBMS-Hersteller die Lösungen auch implementiert. Wenn es nicht mehr \"automatisch\" geht, dann muss der Entwickler einen INSTEAD OF-Trigger programmieren.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sichten können auf Tabellen oder anderen Sichten definiert sein.",
        "solution": "true"
      },
      {
        "text": "Bei virtuellen Sichten tritt das Problem großer Antwortzeiten auf.",
        "solution": "true"
      },
      {
        "text": "Bei materialisierten Sichten tritt das Problem der Datenaktualität auf.",
        "solution": "true"
      },
      {
        "text": "Bei Sichten tritt das Problem des \"View Updatings\" auf.",
        "solution": "true"
      },
      {
        "text": "DML-Befehle (INSERT, UPDATE,DELETE) können auf Sichten ausgeführt werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2467,
    "category": 5,
    "difficulty": 1,
    "text": "Welche der folgenden Aussagen über Normalformen sind wahr?",
    "explanation": "FALSCH ist:\n\n    Die 1NF ist immer verschieden von der 2NF.\n\n    Wenn es keine partiellen funktionalen Abhängigkeiten gibt vom Primärschlüssel in der 1.NF, dann gilt: 1.NF = 2.NF.\n\n    FALSCH ist:\n\n    Die 2NF ist immer verschieden von der 3NF.\n\n    Wenn es keine transitiven funktionalen Abhängigkeiten gibt, dann gilt: 2.NF = 3.NF.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die 1NF ist immer verschieden von der 2NF.",
        "solution": "false"
      },
      {
        "text": "keine von beiden",
        "solution": "true"
      },
      {
        "text": "Die 2NF ist immer verschieden von der 3NF.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 954,
    "category": 14,
    "difficulty": 3,
    "text": "Mit welcher Oracle-SQL-Anweisung kann man Isolationsgrade \"transaction level\" und \"statement level\" setzen?",
    "explanation": "Unterschiede zwischen SQL2003 und Oracle \nDie Unterschiede bei den Isolationsgraden zwischen SQL2003 und Oracle basieren im Wesentlichen darauf, dass Oracle unsauberes Lesen grundsätzlich ausschließt, womit der Isolationsgrad READ UNCOMMITTED entfällt. Zudem wird von Oracle der Unterschied zwischen den beiden Problemen Phantome und nicht wiederholbares Lesen als eher akademischer Natur betrachtet, womit der Isolationsgrad REPEATABLE READ ebenfalls entfällt.\n\nStatement Level \nDie Daten, die eine Anfrage ermittelt, sind alle vom gleichen Zeitpunkt und zwar vom Start der Anfrageauswertung. Es werden keine \"unsauberen\" Daten gelesen und keine Änderungen, die während der Anfrageauswertung von anderen Transaktionen mit COMMIT persistent gespeichert wurden. Dieser Lesekonsistenzgrad wird durch die Option READ COMMITTED spezifiziert und ist die Voreinstellung. \n\nTransaction Level \nDie Daten aller Anfragen einer Transaktion stammen vom gleichen Zeitpunkt und zwar vom Start der Transaktion. Es können weder das nicht wiederholbare Lesen noch Phantome auftreten. Dieser Zustand wird durch die Option SERIALIZABLE eingestellt.\n\n<SET TRANSACTION Anweisung (Oracle)> ::=\n  SET TRANSACTION { READ { ONLY | WRITE }  } ;\n\n ::= ISOLATION LEVEL { READ COMMITTED | SERIALIZABLE }",
    "type": "text",
    "answers": [
      {
        "text": "Das ist die Anweisung (ohne Parameter)",
        "solution": "SET TRANSACTION"
      }
    ]
  },
  {
    "id": 586,
    "category": 5,
    "difficulty": 2,
    "text": "Attribute in der ersten Normalform dürfen Wiederholungsgruppen von Attributen haben.",
    "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 571,
    "category": 5,
    "difficulty": 2,
    "text": "Jedes Nicht-Schlüssel-Attribut ist in einer Relation R voll funktional abhängig vom Primärschlüssel S.",
    "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Primärschlüssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist die erste Normalform.",
        "solution": "false"
      },
      {
        "text": "Das ist die zweite Normalform.",
        "solution": "true"
      },
      {
        "text": "Das ist die dritte Normalform.",
        "solution": "false"
      },
      {
        "text": "Das entspricht keiner Normalform.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 959,
    "category": 14,
    "difficulty": 2,
    "text": "Wie nennt man das folgende Problem:\nEine Verklemmung entsteht, wenn eine Transaktion A ein Objekt X gesperrt hält und im weiteren Verlauf ein Objekt Y sperren möchte. Zudem hält eine Transaktion B das Objekt Y gesperrt und will später noch Objekt X sperren. Somit warten beide Transaktionen jeweils auf das Objekt, das die andere Transaktion gesperrt hält. Eine Freigabe durch eine der beiden Transaktionen ist ohne Eingriff von Außen nicht möglich.",
    "explanation": "Da bei Transaktionen die beteiligten Relationen im Vorfeld nicht bekannt sind, tritt das Problem der Verklemmung (Deadlock) durchaus schon mal auf und ist wie oben definiert.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ein",
        "solution": "DEADLOCK"
      }
    ]
  },
  {
    "id": 580,
    "category": 5,
    "difficulty": 2,
    "text": "Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation bezeichnet. Y sei funktional abhängig von X und Z funktional abhängig von Y, und X sei funktional abhängig von Y.",
    "explanation": "Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ heißt transitiv abhängig von X, wenn Y voll funktional abhängig von X und Z voll funktional abhängig von Y ist, aber X nicht voll funktional abhängig von Y ist. \nAlso X ->Y ->Z, aber nicht Y ->X.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist die transitive Abhängigkeit.",
        "solution": "false"
      },
      {
        "text": "Das ist nicht die transitive Abhängigkeit.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 581,
    "category": 5,
    "difficulty": 3,
    "text": "Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation bezeichnet. Y sei funktional abhängig von X und Z funktional abhängig von Y, aber X sei nicht funktional abhängig von Y.",
    "explanation": "Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ heißt transitiv abhängig von X, wenn Y voll funktional abhängig von X und Z voll funktional abhängig von Y ist, aber X nicht voll funktional abhängig von Y ist. \nAlso X ->Y ->Z, aber nicht Y ->X.",
    "type": "text",
    "answers": [
      {
        "text": "Diese Eigenschaft nennt man:",
        "solution": "Transitive Abhängigkeit"
      }
    ]
  },
  {
    "id": 588,
    "category": 5,
    "difficulty": 3,
    "text": "Welche Aktion gehört nicht in die Transformation eines konzeptionellen Schemas auf ein Datenbankschema?",
    "explanation": "Bei der Transformation vom konzeptionellen Schema zum Datenbankschema gibt es zwei Hauptregeln: \nRegel 1: Die Entity-Mengen des ER-Modells werden auf Relationen abgebildet. \nRegel 2: Beziehungen werden auf Fremdschlüsselattribute oder Relationen abgebildet. \n\nAnschließend wird noch eine Überführung des Datenbankschemas in die dritte Normalform durchgeführt und das entstandene Datenbankschema verfeinert. Dazu gehören: \n1. Primärschlüssel + Fremdschlüssel: Jede Relation muss einen Primärschlüssel haben. Fremdschlüssel werden verwendet, um die referentielle Integrität zu sichern, und müssen daher nicht in jeder Relation existieren. \n2. Wertebereiche der Attribute: Neben den Basisdatentypen sind endliche Wertebereiche und Domänen (z.B. weiblich, männlich) festzulegen. \n3. Semantische Integritätsbedingungen (vgl. Abschnitt 4.1) werden in Textform beschrieben. \n4. Views stellen Daten aus einer oder auch verschiedenen Relationen für bestimmte Benutzersichten, die für spezielle Funktionen verwendet werden, zur Verfügung. \n5. Indizes beschreiben Zweitschlüssel. \n6. Zugriffsrechte werden auf den Relationen oder Sichten für einzelne Benutzer oder Gruppen von Benutzern erklärt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Auflösung der Entitäten und Beziehungen auf Relationen",
        "solution": "false"
      },
      {
        "text": "Überführung in die dritte Normalform",
        "solution": "false"
      },
      {
        "text": "Festlegung der Wertebereiche der Attribute",
        "solution": "false"
      },
      {
        "text": "Festlegung der Benutzersichten",
        "solution": "false"
      },
      {
        "text": "Festlegung der Benutzerschnittstellen",
        "solution": "true"
      },
      {
        "text": "Festlegung der Speicherstrukturen",
        "solution": "false"
      },
      {
        "text": "Festlegung der Benutzerrechte",
        "solution": "false"
      }
    ]
  },
  {
    "id": 579,
    "category": 5,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation, deren Primärschlüssel aus drei Attributen besteht. Wie viele Relationen können bei der Überführung in die zweite Normalform höchstens entstehen? Zwei Relationen, die sich nur in der Spaltenreihenfolge unterscheiden, sollen als gleich betrachtet werden",
    "explanation": "Die Anzahl der Relationen ist 7, da man die Potenzmenge, das ist die Anzahl der Teilmengen einer elementigen Menge betrachten muss. In unserem Beispiel ist das  2 hoch 3, also 8. Da die leere Menge mit zur Potenzmenge gehört, bleiben 7 Relationen übrig, die maximal entstehen können, wenn von der jeweiligen Teilmenge der Primärschlüsselattribute weitere Nichtschlüsselattribute abhängen. Nähere Einzelheiten findet man in <a href=\"http://de.wikipedia.org/wiki/Potenzmenge\">Wikipedia: Potenzmenge",
    "type": "text",
    "answers": [
      {
        "text": "Die Anzahl ist:",
        "solution": "7"
      }
    ]
  },
  {
    "id": 584,
    "category": 5,
    "difficulty": 1,
    "text": "In einer Relation sei kein Sekundärattribut (Nicht-Schlüsselattribut) transitiv abhängig von einem Schlüsselattribut.",
    "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Primärschlüssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist die dritte Normalform.",
        "solution": "true"
      },
      {
        "text": "Das ist die erste Normalform.",
        "solution": "false"
      },
      {
        "text": "Das ist die zweite Normalform.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 957,
    "category": 14,
    "difficulty": 2,
    "text": "Wie nennt man das folgende Problem:\nA liest und ändert Objekt X und ändert dann noch weitere Objekte. B liest nach der Änderung von A den neuen Wert von Objekt X und ändert diesen wiederum. Anschließend wird die Transaktion A zurückgerollt, womit auch die Änderungen an Objekt X rückgängig gemacht werden. Aber B hat bereits den geänderten Wert weiter verarbeitet, obwohl er noch nicht dauerhaft gültig war.",
    "explanation": "LOST UPDATE (verlorene Änderungen) ist das Problem, das auf dem Überschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgeführter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn Änderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zuückgerollt werden (ROLLBACK, Integritätsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgeführte Transaktionen die Daten zwischenzeitlich geändert bzw. gelöscht haben (NON REPEATABLE READ) oder neue Datensätze eingefügt wurden (PHANTOME).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LOST UPDATE",
        "solution": "false"
      },
      {
        "text": "DIRTY READ",
        "solution": "true"
      },
      {
        "text": "PHANTOM",
        "solution": "false"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "false"
      }
    ]
  },
  {
    "id": 632,
    "category": 2,
    "difficulty": 1,
    "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung werden Pflichtenhefte erstellt?",
    "explanation": "In der Analysephase werden die Systemfunktionen und Daten in groben Zügen geplant und festgelegt. Es wird eine explizite Systemdefinition in Form eines Lastenhefts vorgenommen. Dies geschieht umgangssprachlich in einer auch für Laien lesbaren Form. Außerdem werden die Daten mit Mitteln der Softwaretechnik, hier mit dem Entity-Relationship-Modell (kurz: ERM oder ER-Modell), genau beschrieben. Das ERM entspricht dem konzeptionellen Modell aus dem ANSI-3-Ebenen-Modell.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Analysephase",
        "solution": "true"
      },
      {
        "text": "Entwurfsphase",
        "solution": "false"
      },
      {
        "text": "Implementierungsphase",
        "solution": "false"
      }
    ]
  },
  {
    "id": 636,
    "category": 2,
    "difficulty": 1,
    "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung wird eine Normalisierung durchgeführt?",
    "explanation": "In der Entwurfsphase wird das konzeptionelle Schema auf ein relationales Datenbankschema abgebildet und eine Normalisierung durchgeführt. Außerdem wird bei einer geplanten Anwendungsentwicklung ein objektorientiertes Klassenmodell erstellt, das die für die Datensicht erforderlichen Methoden und Funktionen enthält.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Analysephase",
        "solution": "false"
      },
      {
        "text": "Entwurfsphase",
        "solution": "true"
      },
      {
        "text": "Implementierungsphase",
        "solution": "false"
      }
    ]
  },
  {
    "id": 635,
    "category": 2,
    "difficulty": 1,
    "text": "In welcher Phase des Vorgehensmodells der Datenbankentwicklung wird das ER-Modell auf ein relationales Datenbankschema abgebildet?",
    "explanation": "In der Entwurfsphase wird das konzeptionelle Schema auf ein relationales Datenbankschema abgebildet und eine Normalisierung durchgeführt. Außerdem wird bei einer geplanten Anwendungsentwicklung \nein objektorientiertes Klassenmodell erstellt, das die für die Datensicht erforderlichen Methoden und Funktionen enthält.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Analysephase",
        "solution": "false"
      },
      {
        "text": "Entwurfsphase",
        "solution": "true"
      },
      {
        "text": "Implementierungsphase",
        "solution": "false"
      }
    ]
  },
  {
    "id": 639,
    "category": 4,
    "difficulty": 1,
    "text": "In der relationalen Algebra sind Null-Werte für Attribute nicht zulässig.",
    "explanation": "In der relationalen Algebra sind Null-Werte für Attribute zugelassen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 958,
    "category": 14,
    "difficulty": 2,
    "text": "Wie nennt man das folgende Problem:\nZuerst liest A das Objekt X, dann B. Anschließend schreibt erst A seinen neuen Wert für zurück, anschließend B. In der Datenbasis wurde mit dem neuen Wert von B der neue Wert von A überschrieben, ohne dass B diesen Wert gesehen hat.",
    "explanation": "LOST UPDATE (verlorene Änderungen) ist das Problem, das auf dem Überschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgeführter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn Änderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zuückgerollt werden (ROLLBACK, Integritätsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgeführte Transaktionen die Daten zwischenzeitlich geändert bzw. gelöscht haben (NON REPEATABLE READ) oder neue Datensätze eingefügt wurden (PHANTOME).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LOST UPDATE",
        "solution": "true"
      },
      {
        "text": "DIRTY READ",
        "solution": "false"
      },
      {
        "text": "PHANTOM",
        "solution": "false"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "false"
      }
    ]
  },
  {
    "id": 644,
    "category": 5,
    "difficulty": 3,
    "text": "Jeder Wert eines Fremdschlüssels einer Relation A ist Wert eines Primärschlüssel in einer anderen Relation. Diese Eigenschaft heißt",
    "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrität, wenn jeder Wert eines Fremdschlüssels einer Relation Ri Wert eines Primärschlüssels in einer anderen Relation Rj ist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt.",
    "type": "text",
    "answers": [
      {
        "text": "Diese Integrität heißt:",
        "solution": "referentielle Integrität"
      }
    ]
  },
  {
    "id": 647,
    "category": 4,
    "difficulty": 2,
    "text": "Welche der folgenden Aussagen über Zweitschlüssel treffen zu?",
    "explanation": "Zweitschlüssel werden als separate Speicherstrukturen (Index) gespeichert, um das Auffinden von Informationen und damit das Lesen zu beschleunigen. Beim Einfügen von Tupeln bzw. Ändern von Schlüsselwerten dauert es dann natürlich länger, weil die Werte im Tupel und in der separaten Speicherstruktur eingefügt bzw. gepflegt werden muss.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zweitschlüssel erzeugen Zeitgewinn beim Schreiben.",
        "solution": "false"
      },
      {
        "text": "Zweitschlüssel erzeugen Zeitverlust beim Schreiben.",
        "solution": "true"
      },
      {
        "text": "Zweitschlüssel erzeugen Zeitgewinn beim Lesen.",
        "solution": "true"
      },
      {
        "text": "Zweitschlüssel erzeugen Zeitverlust beim Lesen.",
        "solution": "false"
      },
      {
        "text": "Zweitschlüssel haben gar keinen Einfluss auf die Zugriffszeiten beim Lesen/Schreiben.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 649,
    "category": 5,
    "difficulty": 1,
    "text": "Bei der Abbildung eines ER-Diagramms auf ein relationales Datenbankschema werden generell alle Entitäten auf Relationen abgebildet.",
    "explanation": "Bei der Transformation, die auch maschinell erfolgen kann, gibt es zwei Hauptregeln: \nRegel 1: Die Entity-Mengen des ER-Modells werden auf Relationen abgebildet. \nRegel 2: Beziehungen werden auf Fremdschlüsselattribute oder Relationen abgebildet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 654,
    "category": 3,
    "difficulty": 1,
    "text": "Wann heißt eine 1:n-Beziehung identifizierend?",
    "explanation": "Bei identifizierenden Beziehungen wird in der Detail-Entitymenge der Fremdschlüssel zum Primärschlüssel hinzugenommen, bei nicht identifizierenden Beziehungen wird der Fremdschlüssel nur als Attribut eingetragen, welches nicht zum Primärschlüssel der Relation gehört.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Primärschlüsselattribute der Detail-Entity-Menge treten als Bestandteile des Primärschlüssels bei der Master-Entity-Menge auf.",
        "solution": "false"
      },
      {
        "text": "Die Primärschlüsselattribute der Master-Entity-Menge treten als Bestandteile des Primärschlüssels bei der Detail-Entity-Menge auf.",
        "solution": "true"
      },
      {
        "text": "Die Primärschlüsselattribute der Master-Entity-Menge treten als Fremdschlüssel-Attribute bei der Detail-Entity-Menge auf und sind aber kein Bestandteil des Primärschlüssels.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 626,
    "category": 7,
    "difficulty": 1,
    "text": "Welche SELECT-Ausdrücke liefern das gleiche Ergebnis?",
    "explanation": "Der logische Operator OR ist assoziativ und daher liefert er die gleichen Ergebnisse, unabhängig davon, ob ein Operator rechts oder links steht. \nDie Semantik dieser beiden Anfragen ist: \"Welche Kunden wohnen nicht in Gummersbach oder in Köln?\". \nDie Anfrage ohne \"Gummersbach\" hat die Semantik: \"Welche Kunden wohnen in Köln?\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'Köln'\nOR    NOT (Ort = 'Gummersbach')\n",
        "solution": "true"
      },
      {
        "text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'Köln'\n",
        "solution": "false"
      },
      {
        "text": "SELECT  Nachname, Ort \nFROM    Kunden\nWHERE     NOT (Ort = 'Gummersbach')\nOR      Ort = 'Köln'",
        "solution": "true"
      }
    ]
  },
  {
    "id": 627,
    "category": 7,
    "difficulty": 3,
    "text": "Mit welcher SELECT-Komponente kann man die Reihenfolge der Datensätze der Ergebnismenge einer SELECT-Abfrage festlegen?",
    "explanation": "Mit der ORDER BY-Klausel kann auf- (ASC) oder absteigend (DESC) sortiert werden. Die GROUP BY-Klausel sortiert als \"Nebenergebnis\" der Gruppierung die Gruppen auch, aber nur aufsteigend. \nMit den WHERE- und HAVING-Klauseln können einzelne Datensätze bzw. Gruppen selektiert werden, aber nicht sortiert. \nDie FROM-Klausel verknüpft die angegebenen Tabellen mittels kartesischem Produkt bzw. Join, sortiert aber nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "WHERE",
        "solution": "false"
      },
      {
        "text": "HAVING",
        "solution": "false"
      },
      {
        "text": "FROM",
        "solution": "false"
      },
      {
        "text": "ORDER BY",
        "solution": "true"
      },
      {
        "text": "GROUP BY",
        "solution": "true"
      },
      {
        "text": "solch eine Komponente gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 629,
    "category": 1,
    "difficulty": 3,
    "text": "Welche Datenbanksysteme sind auf das Suchen in unformatierten Datenbeständen spezialisiert?",
    "explanation": "Information Retrieval ist ein Fachgebiet, das sich mit computergestütztem inhaltsorientiertem Suchen in unfomatierten Daten beschäftigt. \nEs ist ein Teilgebiet der Informationswissenschaft, der Computerlinguistik wie auch der Informatik.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ein (englischer Begriff)",
        "solution": "Information Retrieval System"
      }
    ]
  },
  {
    "id": 630,
    "category": 4,
    "difficulty": 1,
    "text": "Welche der folgenden Operationen gehört nicht zur relationalen Algebra?",
    "explanation": "Projektion (attributweise Auswahl), Division (Allquantor) und Differenz (Anfragen mit \"Keine\"/\"Ohne-Aussagen\") gehören zur Relationalen Algebra, die Addition aber nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Division",
        "solution": "false"
      },
      {
        "text": "Addition",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Projektion",
        "solution": "false"
      }
    ]
  },
  {
    "id": 759,
    "category": 4,
    "difficulty": 3,
    "text": "Wie viele Tupel hat die Ergebnismenge des kartesischen Produkts von zwei Relationen, die 18 bzw. 20 Tupel beinhalten, wobei es für 14 Tupel der einen Relation Tupel der anderen Relation gibt, die in einem gleichheißenden Attribut die gleichen Werte aufweisen?",
    "explanation": "Das Kartesische Produkt \"verbindet jedes Tupel der einen Relation mit jedem Tupel aus der anderen Relation unabhängig von irgendwelchen passenden oder nichtpassenden Werten\" und somit ergeben sich 18*20 = 360 Tupel in der Ergebnismenge. \nDas nur bei 14 Tupeln übereinstimmende Werte gegeben sind, spielt für das kartesische Produkt keine Rolle, sondern nur für den Natural Join.",
    "type": "text",
    "answers": [
      {
        "text": "Das kartesische Produkt hat ... Tupel.",
        "solution": "360"
      }
    ]
  },
  {
    "id": 760,
    "category": 4,
    "difficulty": 1,
    "text": "Jede n-stellige Relation R ist eine Teilmenge des kartesischen Produkts der Wertebereiche der Attribute.",
    "explanation": "Sei (A1,..., An) eine Menge von Attributen mit den Wertebereichen Mi. Die Elemente der Mi sind Basisdatentypen und beschreiben die Werte, die die Attribute annehmen können. Eine n-stellige Relation R ist eine Teilmenge des kartesischen Produkts M1×...×Mn. Rn bezeichne die Menge aller n-stelligen Relationen. Man schreibt auch: R(A1,...,An).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 783,
    "category": 4,
    "difficulty": 3,
    "text": "Aus welchen Operatoren lässt sich der Theta-Join ableiten?",
    "explanation": "Der Theta-Join ist gemäß seiner Definition eine Operation, die sich aus Selektion und kartesischem Produkt ableiten lässt. Wird zuerst das kartesische Produkt R1 × R2 ausgeführt und auf dieser Zwischenergebnismenge die Selektion der Bedingung B, dann erhält man das gleiche Ergebnis wie beim Theta-Join(R1, R2, B).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Selektion",
        "solution": "true"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Vereinigung",
        "solution": "false"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Division",
        "solution": "false"
      }
    ]
  },
  {
    "id": 763,
    "category": 4,
    "difficulty": 2,
    "text": "Relationale Operatoren sind immer Abbildungen, die zwei Relationen eine Ergebnis-Relation zuordnen.",
    "explanation": "Unär:  F1 : Rn → Rm      mit n , m ∈ N \nBinär: F2 : Rn × Rm → Rk mit n , m , k ∈ N\nUnäre Operatoren: Selektion, Projektion\nBinäre Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 781,
    "category": 4,
    "difficulty": 3,
    "text": "Selektionsprädikate können in der relationalen Algebra enthalten:",
    "explanation": "Bestandteile eines Selektionsprädikats sind: \n1. Attribute einer Relation und Konstanten als Operanden, \n2. Vergleichsoperatoren = <, ≤, >, ≥ , <> und != (ungleich), \n3. die logischen Operatoren UND, ODER und NICHT und \n4. Berechnungen mit Konstanten und Spaltenwerten (z.B. Gehalt*1,.045)  \n5. eine beliebige Kombination aus den oben genannten Möglichkeiten, die durch Klammerung (..) erzeugt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Konstante Werte",
        "solution": "true"
      },
      {
        "text": "Klammern ()",
        "solution": "true"
      },
      {
        "text": "Attributnamen einer Relation",
        "solution": "true"
      },
      {
        "text": "Vergleichsoperatoren",
        "solution": "true"
      },
      {
        "text": "logische Operatoren",
        "solution": "true"
      },
      {
        "text": "Berechnungen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 767,
    "category": 4,
    "difficulty": 1,
    "text": "Welcher Operator der relationalen Algebra wählt Tupel aus einer Relation aus?",
    "explanation": "Die Selektion erzeugt eine n-stellige Relation mit der gleichen Attributanzahl, aber mit weniger oder gleich viel Tupeln als die ursprüngliche Relation. Sie extrahiert aufgrund des Selektionsprädikats Tupel aus einer vorgegebenen Relation.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "true"
      },
      {
        "text": "Projektion",
        "solution": "false"
      }
    ]
  },
  {
    "id": 782,
    "category": 4,
    "difficulty": 2,
    "text": "Welche Eigenschaften haben Relationen in der relationalen Algebra resp. dem relationalen Modell? Kreuzen Sie die korrekten Antworten an!",
    "explanation": "Eine zentrale Eigenschaft der RA ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen können (Projektion, Vereinigung, Durchschnitt und Division), diese Duplikate automatisch eliminiert werden. \nAchtung: später bei SQL sind Duplikate zugelassen, aber nicht in der RA. \n \nEine zweite zentrale Eigenschaft des relationalen Modells ist die Reihenfolgeunabhängigkeit. Sie bedeutet, dass das Ergebnis der\ndeklarativ formulierten Anweisungen (RA: Anfrageausdrücke / SQL: SELECT, INSERT, UPDATE, DELETE), immer gleich sein muss, unabhängig davon, in welcher Reihenfolge die Tupel gelesen oder verarbeitet wurden. \n,   \nDie Wertebereiche Mi heißen Domänen. Domänen sind atomar, d.h. keine zusammengesetzten Datentypen. Bei der Definition von Domänen muss angegeben werden, ob NULL-Werte, also einzelne Attribute ohne Werteintrag, zugelassen sind.\n \nDie zusammengesetzten Datentypen sind nicht Bestandteil des relationalen Modells. Sie werden erst mit den objektrelationalen Erweiterungen eingeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Für die Attribute sind NULL-Werte erlaubt.",
        "solution": "true"
      },
      {
        "text": "Eine Relation hat keine doppelten Tupel, d.h. Zeilen mit komplett den gleichen Werten werden unterdrückt.",
        "solution": "true"
      },
      {
        "text": "Die Tupelreihenfolge ist fest definiert.",
        "solution": "false"
      },
      {
        "text": "Neben atomaren Attributen sind auch selbstdefinierte zusammengesetzte Datentypen zugelassen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 769,
    "category": 4,
    "difficulty": 2,
    "text": "Bei der Projektion werden identische Tupel automatisch eliminiert.",
    "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen können, diese Duplikate automatisch eliminiert werden. Zu diesen Operatoren gehören Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: später bei SQL sind Duplikate zugelassen, aber nicht in der RA.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 784,
    "category": 4,
    "difficulty": 2,
    "text": "Wie heißt ein Theta-Join, bei dem nur der Gleichheitsoperator als Vergleichsoperator zugelassen ist?",
    "explanation": "Ein Equi-Join ist ein Theta-Join, der im Selektionsprädikat nur den Vergleichsoperator \"=\"\nzulässt.\nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ein",
        "solution": "Equi-Join"
      }
    ]
  },
  {
    "id": 786,
    "category": 4,
    "difficulty": 2,
    "text": "Mit welchem Operator der relationalen Algebra wird der Für-Alle-Quantor (die Allaussage) umgesetzt?",
    "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.",
    "type": "text",
    "answers": [
      {
        "text": "Der Operator heißt",
        "solution": "Division"
      }
    ]
  },
  {
    "id": 773,
    "category": 4,
    "difficulty": 1,
    "text": "Ein Outer-Join ist immer verlustfrei.",
    "explanation": "Eine Join-Operation zwischen R und S heißt verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 789,
    "category": 5,
    "difficulty": 3,
    "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass jede Relation einen Primärschlüssel besitzt.",
    "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrität, wenn jede Relation einen Primärschlüssel besitzt.",
    "type": "text",
    "answers": [
      {
        "text": "Diese Eigenschaft heißt",
        "solution": "Entity-Integrität"
      }
    ]
  },
  {
    "id": 826,
    "category": 7,
    "difficulty": 1,
    "text": "Welches Prädikat in einer SELECT-WHERE-Bedingung mit Unterabfrage wird als wahr erkannt, wenn die Unterabfrage mindestens einen Datensatz selektiert?",
    "explanation": "Das EXISTS-Prädikat liefert TRUE, wenn die Ergebnismenge der Unterabfrage wenigstens einen Datensatz enthält. \nDas IN-Prädikat liefert TRUE, wenn der Wert des linken Operators in der Ergebnismenge des rechten Operators der Unteranfrage enthalten ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "EXISTS",
        "solution": "true"
      },
      {
        "text": "solche ein Prädikat gibt es nicht",
        "solution": "false"
      },
      {
        "text": "IN",
        "solution": "false"
      }
    ]
  },
  {
    "id": 888,
    "category": 13,
    "difficulty": 1,
    "text": "Der DEFAULT-Typ eines Datenbanktriggers ist",
    "explanation": "Ein Befehlstrigger  (STATEMENT TRIGGER, befehlsorientiert, default) wird genau einmal vor oder nach der Ausführung des feuernden Ereignisses ausgeführt, auch dann, wenn kein Datensatz von der feuernden Anweisung manipuliert wird.  \nEin Zeilentrigger (ROW TRIGGER, zeilenorientiert) wird dagegen für jeden von der feuernden Datenmanipulation betroffenen Datensatz je einmal ausgeführt. Wird kein Datensatz\nvon der Anweisung geändert, dann wird auch kein Zeilentrigger ausgeführt. Nur bei den Zeilentriggern sind die Transitionsvariablen zugreifbar, die Transitionstabellen hingegen sind es bei beiden Triggertypen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "befehlsorientiert",
        "solution": "true"
      },
      {
        "text": "zeilenorientiert",
        "solution": "false"
      }
    ]
  },
  {
    "id": 758,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welcher Komponente kann man in einer SELECT-Anweisung Spalten absteigend sortieren?",
    "explanation": "Mit der ORDER BY-Klausel kann auf- (ASC) oder absteigend (DESC) sortiert werden. Die GROUP BY-Klausel sortiert als \"Nebenergebnis\" der Gruppierung die Gruppen auch, aber nur aufsteigend. \nMit den WHERE- und HAVING-Klauseln können einzelne Datensätze bzw. Gruppen selektiert werden, aber nicht sortiert. \nDie FROM-Klausel verknüpft die angegebenen Tabellen mittels kartesischem Produkt bzw. Join, sortiert aber nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ORDER BY",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      },
      {
        "text": "GROUP BY",
        "solution": "false"
      }
    ]
  },
  {
    "id": 884,
    "category": 12,
    "difficulty": 1,
    "text": "Womit wird in PL/SQL ein Vektor fester Länge definiert?",
    "explanation": "VARRAY und TABLE gehören zu den Kollektionstypen, wobei varray definiert ist über:  \n\n<CREATE TYPE Anweisung VARRAY> ::=\nCREATE OR REPLACE TYPE Typname AS VARRAY () OF ;  \n \nIm Unterschied zum TABLE-Kollektionstypen hat VARRAY eine fest definierte Länge.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "TYPE ... is TABLE OF ...",
        "solution": "false"
      },
      {
        "text": "TYPE ... is VARRAY OF ...",
        "solution": "true"
      },
      {
        "text": "TYPE ... is RECORD OF ...",
        "solution": "false"
      }
    ]
  },
  {
    "id": 903,
    "category": 13,
    "difficulty": 2,
    "text": "Welche der ECMA-Bestandteile eines Datenbanktriggers sind unverzichtbar?",
    "explanation": "Jeder Trigger muss mindestens auf einen Event reagieren (E) und eine Action-Teil (A) haben, alle anderen Bestandteile sind optional.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "E",
        "solution": "true"
      },
      {
        "text": "C",
        "solution": "false"
      },
      {
        "text": "M",
        "solution": "false"
      },
      {
        "text": "A",
        "solution": "true"
      }
    ]
  },
  {
    "id": 906,
    "category": 14,
    "difficulty": 1,
    "text": "Bei welchem Prüfungszeitpunkt (= CONSTRAINT_CHARACTERISTICA ) wird die Datenprüfung zum Transaktionsende durchgeführt?",
    "explanation": "Werden Datenänderungen ausgeführt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integritätsbedingung geprüft.  \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung rückgängig gemacht. Die übrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl löst das Transaktionsende aus und damit die Prüfung aller CONSTRAINTs (Integritätsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden.  \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden während für eine Transaktion erst mal akzeptiert und erst zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs geprüft und die Fehler erkannt.  \nWenn ein DEFERRED-Fehler auftritt, führt dies zur Anzeige einer Fehlermeldung und zum Zurückrollen der gesamten Transaktion.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INITIALLY IMMEDIATE",
        "solution": "false"
      },
      {
        "text": "INITIALLY DEFERRED",
        "solution": "true"
      }
    ]
  },
  {
    "id": 890,
    "category": 13,
    "difficulty": 1,
    "text": "Triggerereignisse können sich beziehen auf",
    "explanation": "Bei SQL sind drei Ereignisse zugelassen, und zwar die Manipulationsanweisungen INSERT, UPDATE, DELETE. Ein Trigger kann nur zu einem einzigen Ereignis bzw, für eine einzigen Tabelle programmiert werden. Die Ereignisse gelten nur für die in der ON Klausel mit \"Tabellenname\" spezifizierten Tabelle. Das UPDATE-Ereignis lässt sich für die Änderung ganz bestimmter Spalten weiter eingrenzen, wobei die Spalten natürlich Spalten der Tabelle aus der ON-Klausel sein müssen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "mehrere Tabellen",
        "solution": "false"
      },
      {
        "text": "genau eine Tabelle",
        "solution": "true"
      }
    ]
  },
  {
    "id": 894,
    "category": 13,
    "difficulty": 1,
    "text": "Bei einem INSERT-Ereignis eines Datenbanktriggers sind belegt",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Transitionsvariable :NEW",
        "solution": "true"
      },
      {
        "text": "Die Transitionsvariable :OLD",
        "solution": "false"
      }
    ]
  },
  {
    "id": 892,
    "category": 13,
    "difficulty": 3,
    "text": "Ein PL/SQL-DML-Datenbanktrigger hat drei Ausführungszeitpunkte. Bitte in alphabetischer Reihenfolge angeben:",
    "explanation": "Der Ausführungszeitpunkt (AFTER oder BEFORE) legt fest, ob ein DML-Trigger vor oder nach dem feuernden (aktivierenden) Ereignis ausgeführt werden soll. Je nach Aufgabenstellung kann der BEFORE- oder der AFTER-Zeitpunkt sinnvoll oder gar notwendig sein. Sind Folgeverarbeitungen durchzuführen, so bieten sich AFTER TRIGGER an, da bei deren Ausführung die Integritätsbedingungen bereits\ngeprüft wurden. Sollen die Werte des neuen Datensatzes geändert oder ergänzt werden, so bietet es sich hingegen an, in den BEFORE TRIGGER die NEW-Variablen mit entsprechenden Werten zu belegen.\n\nDie INSTEAD OF-DML-Trigger werden anstelle des feuernden Befehls (INSERT, UPDATE, DELETE) ausgeführt. Diese werden vor allem angewendet, wenn DML-Operationen auf nicht änderbaren Sichten ausgeführt werden sollen. Dann übernimmt der Entwickler im INSTEAD OF-Trigger die Aufgabe, die Manipulation der Sichtdaten in die zugehörigen Manipulationen von zugrundeliegenden Tabellendaten zu transformieren.",
    "type": "text",
    "answers": [
      {
        "text": "Das sind",
        "solution": "AFTER"
      },
      {
        "text": "und",
        "solution": "BEFORE"
      },
      {
        "text": "und",
        "solution": "INSTEAD OF"
      }
    ]
  },
  {
    "id": 893,
    "category": 13,
    "difficulty": 1,
    "text": "Bei einem UPDATE -Ereignis eines Datenbanktriggers sind belegt",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "die Transitionsvariable :OLD",
        "solution": "true"
      },
      {
        "text": "die Transitionsvariable :NEW",
        "solution": "true"
      }
    ]
  },
  {
    "id": 895,
    "category": 13,
    "difficulty": 1,
    "text": "Bei einem DELETE-Ereignis eines Datenbanktriggers sind belegt",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "die Transitionsvariable :NEW",
        "solution": "false"
      },
      {
        "text": "die Transitionsvariable :OLD",
        "solution": "true"
      }
    ]
  },
  {
    "id": 896,
    "category": 13,
    "difficulty": 3,
    "text": "Transitionstabellen gehören zum Funktionsumfang von",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ORACLE-PL/SQL",
        "solution": "false"
      },
      {
        "text": "SQL 1999",
        "solution": "true"
      },
      {
        "text": "IBM-DB2",
        "solution": "true"
      }
    ]
  },
  {
    "id": 897,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem SQL-Ausdruck werden in einer Gruppenfunktion ( z.B. COUNT)  auch Werte, die mehrfach vorkommen, berücksichtigt?",
    "explanation": "Bei \"ALL\"  werden alle Werte berücksichtigt, bei \"DISTINCT\" nur unterschiedliche Werte.",
    "type": "text",
    "answers": [
      {
        "text": "Der SQL-Ausdruck, der vor der Gruppenfunktion steht, heißt:",
        "solution": "ALL"
      }
    ]
  },
  {
    "id": 898,
    "category": 5,
    "difficulty": 1,
    "text": "Eine Relation, deren Primärschlüssel nur aus einem Attribut besteht, ist immer in der dritten Normalform.",
    "explanation": "Der Sachverhalt aus der Fragestellung hat nichts mit der 3. NF zu tun.\n\nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist. \nMit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ heißt transitiv abhängig von X, wenn Y voll funktional abhängig von X und Z voll funktional abhängig von Y ist, aber X nicht voll funktional abhängig von Y ist. \nAlso X ->Y →Z, aber nicht Y →X.  \n\nDamit eine Relation überhaupt die 3. NF verletzen kann, muss sie über wenigstens 3 Attribute verfügen, von denen ein Attribut zum Primärschlüssel gehört.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 899,
    "category": 5,
    "difficulty": 1,
    "text": "Eine Relation, deren Primärschlüssel nur aus einem Attribut besteht, ist immer in der ersten Normalform.",
    "explanation": "Wenn das Atrribut nicht atomar ist, ist die 1. NF trotzdem verletzt. \nEine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 900,
    "category": 5,
    "difficulty": 3,
    "text": "In einer Menge von Relationen besitzt jede Relation einen Primärschlüssel.",
    "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrität, wenn jede Relation einen Primärschlüssel besitzt.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist die ...",
        "solution": "Entity-Integrität"
      }
    ]
  },
  {
    "id": 901,
    "category": 12,
    "difficulty": 2,
    "text": "Unter PL/SQL (ab ORACLE 9) gibt es einen REF-Datentypen",
    "explanation": "REF ist kein eigener PL/SQL-Datentyp, sondern wird in PL/SQL in Cursor-Variablen benutzt bzw. in den objektrelationalen Erweiterungen von Oracle/SQL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "true"
      },
      {
        "text": "stimmt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 908,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Phasen hat das 2-Phasen-Sperrprotokoll?",
    "explanation": "Die zentrale Anforderung, damit das Zwei-Phasen-Sperr-Protokoll die Serialisierbarkeit gewährleisten kann, lautet, dass bei Transaktionen alle Sperroperationen vor der ersten Entsperroperation ausgeführt werden. Somit entstehen bei der Ausführung der Transaktion zwei Phasen: \n\n\neine Anforderungsphase oder Wachstumsphase, in der alle Schreiblesesperren (read_lock, write_lock) gesetzt werden, und \n\neine Schrumpfungsphase, in der alle Objekte wieder freigegeben werden (unlock).  \nAus diesen zwei Phasen ergibt sich der Name des Protokolls.",
    "type": "text",
    "answers": [
      {
        "text": "Das sind die",
        "solution": "Wachstumsphase"
      },
      {
        "text": "und die",
        "solution": "Schrumpfungsphase"
      }
    ]
  },
  {
    "id": 989,
    "category": 9,
    "difficulty": 1,
    "text": "Normalisierung im Sinne der ersten, zweiten und dritten Normalform wird auch in der objektorientierten Analyse angewendet.",
    "explanation": "Normalformen spielen in der objektorientierten Analyse keine Rolle, da die Modellierung sich danach richtet, wie Objekte als Abbild der Realität modelliert werden sollen. Logisch zusammenhängende Attribute verbleiben dann in der gleichen Klasse.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1006,
    "category": 9,
    "difficulty": 1,
    "text": "Für den Zugriff auf einzelne ausgewählte Spalten des benutzerdefinierten Datentyps muss in der FROM-Klausel ein Tabellenalias als eine Art Instanzvariable vergeben werden.",
    "explanation": "Ohne Tabellenalias ist hier kein Zugriff möglich.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 992,
    "category": 9,
    "difficulty": 1,
    "text": "In objektorientierten Datenbanken gibt es",
    "explanation": "Wertidentität bedeutet, dass Objekte über einen Wert in einem Primärschlüssel identifiziert werden. Dies ist in einem relationalen Datenbanksystem der Fall.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wertindentität",
        "solution": "false"
      },
      {
        "text": "Objektidentität",
        "solution": "true"
      }
    ]
  },
  {
    "id": 994,
    "category": 9,
    "difficulty": 1,
    "text": "Für jeden bei Oracle definierten instantiierbaren benutzerdefinierten Typ wird automatisch ein Konstruktor definiert.",
    "explanation": "Der Konstruktor heißt wie der Typ und wird automatisch angelegt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1007,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt eine Methode unter ORACLE-SQL, die als Attribut referenziert wird? Der typische Aufruf erfolgt im sogennanten \"selfish\" Stil: \"object_expression.method()\".",
    "explanation": "Das ist die Definition einer Oracle-Member-Methode. Der zweite Methodentyp sind STATIC-Methoden, die einer Klasse zugeordnet sind.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist eine",
        "solution": "Member Method"
      }
    ]
  },
  {
    "id": 1701,
    "category": 6,
    "difficulty": 2,
    "text": "Mit dem RENAME-Befehl kann man unter ORACLE-SQL",
    "explanation": "Die RENAME-Anweisung ändert den Namen einer Tabelle.  \n<RENAME Anweisung> ::= RENAME Alter Tabellenname TO Neuer Tabellenname;",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keins von beiden",
        "solution": "false"
      },
      {
        "text": "eine Tabelle umbenennen",
        "solution": "true"
      },
      {
        "text": "eine Spalte umbenennen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1705,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie die Tabelle Test(NR1 number, NR2 number), wobei nur ein Tupel existiert. NR1 hat den Wert 1, NR2 hat einen NULL-Wert, also keinen Eintrag.\n\nWelches Ergebnis hat die folgende SQL-Abfrage?\n\nSELECT NR1 + NR2 FROM Test;",
    "explanation": "Die Summe aus einer Zahl und einem NULL-Wert ist unter SQL wieder NULL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1",
        "solution": "false"
      },
      {
        "text": "2",
        "solution": "false"
      },
      {
        "text": "NULL",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1703,
    "category": 6,
    "difficulty": 2,
    "text": "Welche Änderungen kann man mit ALTER TABLE auf den Spalten einer Tabelle durchführen, wenn die Spalten leer sind (NULL)?",
    "explanation": "Weil die Spalten leer sind, ist vieles möglich. All diese Dinge sind bei Spalten mit Daten nicht durchführbar, weil sie u.U. zu Konfikten mit den gespeicherten Daten führen können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "die Nachkomma-Stellen einer NUMBER-Spalte erhöhen",
        "solution": "true"
      },
      {
        "text": "den Datentyp der Spalte ändern",
        "solution": "true"
      },
      {
        "text": "die Breite einer Text-Spalte im CHARACTER-oder VARCHAR-Format reduzieren",
        "solution": "true"
      },
      {
        "text": "Anzahl-Ziffern in einer NUMBER-Spalte reduzieren",
        "solution": "true"
      },
      {
        "text": "Text-Spalten im CHARACTER-oder VARCHAR-Format vergrößern",
        "solution": "true"
      },
      {
        "text": "Anzahl-Ziffern in einer NUMBER-Spalte erhöhen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1704,
    "category": 13,
    "difficulty": 1,
    "text": "Betrachten Sie einen zeilenorientierten Trigger auf der Tabelle \nText (nr1 number, nr2  number) der Gestalt:\n\nCREATE OR REPLACE TRIGGER test_update\nAFTER UPDATE ON text\nFOR EACH ROW\nBEGIN       \n   ......END;\n\nWelche Aussagen über diesen Trigger unter ORACLE-PL/SQL sind wahr?",
    "explanation": "Es werden alle Transitionsvariablen gefüllt, wenn der Trigger als Row-Trigger definiert ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "die Transaktionsvariabale :NEW.nr2 ist auch gefüllt, wenn sich nur die Spalte nr1 mittels UPDATE ändert",
        "solution": "true"
      },
      {
        "text": "die Transaktionsvariabale :NEW.nr2 ist nicht gefüllt, wenn sich nur die Spalte nr1 mittels UPDATE ändert",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1709,
    "category": 7,
    "difficulty": 2,
    "text": "Es sei folgende Kunden-Tabelle gegeben:\n            Kunden( Kunden_id, Name, Handy ) \nMit welchem/n Befehl/en kann ein Primärschlüssel für die Kunden_Id sowie ein zusammengesetzter, eindeutiger Zweitschlüssel für die Tabelle \"Kunden\" über die beiden Attribute \"Name\" und \"Handy\" definiert werden?",
    "explanation": "Eine Tabelle kann nur einen Primary Key haben und CONSTRAINT-Namen sind eindeutig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TABLE Kunden  \n(Kunden_Id    NUMBER(9) PRIMARY KEY,     \n Name              VARCHAR2(50),    \n Handy        NUMBER(11), \nCONSTRAINT Kunden_uk  UNIQUE (Name, Handy));",
        "solution": "true"
      },
      {
        "text": "CREATE TABLE Kunden  \n(Kunden_I NUMBER(9) PRIMARY KEY,     \nName VARCHAR2(50)  CONSTRAINT Kunden_uk  UNIQUE, \nHandy      NUMBER(11) CONSTRAINT Kunden_uk  UNIQUE);",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE Kunden  \n(Kunden_Id NUMBER(9) PRIMARY KEY,     \n Name  VARCHAR2(50), \n Handy NUMBER(11), \n CONSTRAINT Kunden_pk2  PRIMARY KEY (Name, Handy));",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE Kunden  \n(Kunden_Id NUMBER(9) PRIMARY KEY,     \nName  VARCHAR2(50) CONSTRAINT Kunden_pk2 PRIMARY KEY), \nHandy  NUMBER(11)CONSTRAINT Kunden_pk2 PRIMARY KEY));",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1707,
    "category": 6,
    "difficulty": 2,
    "text": "Mit welcher ORACLE -Funktion kann man einen NULL-Wert durch einen beliebigen anderen Wert in einer SELECT-Abfrage ersetzen?",
    "explanation": "Z.B: \nNVL(spalte1, 7)  \nliefert den Wert von spalte1 zurück, wenn dieser ungleich NULL ist, also wenn spalte1 gefüllt ist. Ist spalte1 leer/NULL, dann liefert NVL den Wert 7 zurück. Das funktioniert mit Spalten/Ausdrücken beliebigen Datentyps.",
    "type": "text",
    "answers": [
      {
        "text": "Die Funktion heißt (ohne Klammern)",
        "solution": "NVL"
      }
    ]
  },
  {
    "id": 1708,
    "category": 6,
    "difficulty": 2,
    "text": "FOREIGN-KEY-Constraints können unter ORACLE-SQL mit einer ON UPDATE CASCADE-Option versehen werden.",
    "explanation": "Nein, das ist leider nur beim SQL-Standard vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1710,
    "category": 7,
    "difficulty": 3,
    "text": "Wie können Sie reagieren, wenn Sie beim Löschen eines Datensatzes (DELETE-Befehl) die Fehlermeldung bekommen, dass noch abhängige Datensätze existieren?",
    "explanation": "Daten in Tabellen mit Primary-Key können nur gelöscht werden, wenn der Primary Key nicht mehr als Foreign-Key in einer anderen Tabelle verwendet wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zuerst den Master-Datensatz löschen und dann die Detail-Datensätze.",
        "solution": "false"
      },
      {
        "text": "Zuerst die Detail-Datensätze löschen und dann den Master-Datensatz.",
        "solution": "true"
      },
      {
        "text": "Zuerst die Werte der Fremdschlüsselspalten der betroffenen Detail-Datensätze mittels eines UPDATE-Befehls auf die Schlüsselwerte eines noch existierenden Master-Datensatzes ändern.",
        "solution": "true"
      },
      {
        "text": "Wenn für die Fremdschlüsselspalten der betroffenen Detail-Datensätze NULL-Constraints definiert sind, dann können, die bestehenden Werte aus den Fremdschlüsselspalten gelöscht werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1711,
    "category": 6,
    "difficulty": 1,
    "text": "Welcher SQL-Ausdruck zum Einfügen eines Datensatzes mit einem Sequenz-Wert ist korrekt ?",
    "explanation": "Der nächste Wert einer Sequenz wird mit <sequence_name>.NEXTVAL abgerufen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSERT INTO Kunden (Kun_Nr, Nachname)\nVALUES (Kun_seq.NEXTVAL, 'Vogt');",
        "solution": "true"
      },
      {
        "text": "INSERT INTO Kunden (Kun_Nr, Nachname)\nVALUES (Kun_seq.NEXTVALUE, 'Vogt');",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1712,
    "category": 12,
    "difficulty": 2,
    "text": "Welche der folgenden Aussagen ist korrekt?",
    "explanation": "Die PL/SQL-Einheit steht in der Hierarchie über den Blöcken, d.h., kann aus mehreren untergeordneten Blöcken bestehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein PL/SQL-Block besteht aus mehreren PL/SQL-Einheiten.",
        "solution": "false"
      },
      {
        "text": "Eine PL/SQL-Einheit besteht aus mehreren PL/SQL-Blöcken.",
        "solution": "true"
      },
      {
        "text": "keine der Antworten ist korrekt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1779,
    "category": 7,
    "difficulty": 2,
    "text": "Wie heißt die Operation der relationalen Algebra, die in SQL nicht direkt, sondern mit einer doppelten Verneinung und EXISTS abbildbar ist (doppeltes NOT EXISTS)?",
    "explanation": "Die Anfrage: \"Zeige die Kunden an, die ALLE Artikel gekauft haben\", wird in der relationalen Algebra mittels Division gelöst. \nDiese Anfrage kann man doppelt negiert umformulieren: \n\"Zeige die Kunden, für die gilt, das es KEINE Artikel gibt, die sie NICHT gekauft haben\". \nWenn es KEINE Artikel gibt, die sie NICHT gekauft haben, dann haben die Kunden doch ALLE Artikel gekauft. Ergo, die Allaussage kann in SQL mittels \"doppeltem NOT EXISTS\" programmiert werden. \nOder mit einem SELECT COUNT(..). \nBeispiele finden Sie im <a href =\"http:://edb.g,.fh-koeln.de\" edb-SQL-Trainer",
    "type": "text",
    "answers": [
      {
        "text": "Die Operation heißt",
        "solution": "Division"
      }
    ]
  },
  {
    "id": 1780,
    "category": 4,
    "difficulty": 3,
    "text": "Mit welchen Operatoren der relationalen Algebra lässt sich der Vereinigungsoperator (UNION) simulieren?",
    "explanation": "Die Vereinigung (UNION) gehört zu den Grund-/Basisoperatoren, die sich nicht ableiten lassen, wie auch Selektion, Projektion, Kartesisches Produkt und Differenz.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "false"
      },
      {
        "text": "Mit keinen anderen Operator der relationalen Algebra.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1781,
    "category": 4,
    "difficulty": 3,
    "text": "Welche der nachfolgenden Regeln sind Heuristiken der logischen Optimierung?",
    "explanation": "Heuristiken der logischen Optimierung: \n1. Konjunktionen in Selektionen werden gemäß Regel 4 in einzelne Selektionen aufgebrochen.\n2. Selektionen werden im Operatorbaum so weit wie möglich nach unten verschoben, um sie möglichst frühzeitig auszuführen (Anwendung von Regel 6).\n3. Selektionen und kartesische Produkte werden zu Join-Operationen zusammengefasst (Regel 8).\n4. Die Reihenfolge der Join-Operationen wird so festgelegt, dass möglichst kleine Zwischenergebnisse entstehen.\n5. Die Projektionen werden möglichst weit nach unten im Operatorbaum verschoben. Dazu kann das Einfügen weiterer Projektionen notwendig sein (Regel 7). \n6. Bei Mengenoperationen werden immer zuerst die kleinsten Relationen berücksichtigt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Projektionen werden im Operatorbaum so weit wie möglich nach unten verschoben.",
        "solution": "true"
      },
      {
        "text": "Mengenoperationen werden immer zuerst auf kleinen Relationen angewendet.",
        "solution": "true"
      },
      {
        "text": "Konjunktionen in Selektionsbedingungen werden in einzelne Selektionen aufgebrochen und im Operatorbaum so weit wie möglich nach unten verschoben.",
        "solution": "true"
      },
      {
        "text": "Die Bedingungen einzelner Selektionen werden nach Möglichkeit zusammengefasst in Konjunktionen dieser Selektionsbedingungen.",
        "solution": "false"
      },
      {
        "text": "Selektionen werden im Operatorbaum so weit wie möglich nach oben verschoben, um sie möglichst spät ausführen zu können.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1782,
    "category": 6,
    "difficulty": 3,
    "text": "Ein Spalten-Constraint (COLUMN CONSTRAINT) kann folgende Klauseln haben:",
    "explanation": "FALSCH ist: \nDie FOREIGN KEY-Klausel gibt es nur bei den Tabellen-Constraints, als Spalten-Constraint heißt diese Funktion REFERENCES. \n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NULL",
        "solution": "true"
      },
      {
        "text": "CHECK",
        "solution": "true"
      },
      {
        "text": "UNIQUE",
        "solution": "true"
      },
      {
        "text": "PRIMARY KEY",
        "solution": "true"
      },
      {
        "text": "FOREIGN KEY",
        "solution": "false"
      },
      {
        "text": "REFERENCES",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1783,
    "category": 7,
    "difficulty": 3,
    "text": "Mit welchem Befehl vergibt man für jeden in der Datenbank angelegten Benutzer alle Rechte (z.B. Lesen, Schreiben, Löschen und Ändern) auf der Tabelle XYZ?",
    "explanation": "RICHTIG ist:\nGRANT ALL ON XYZ TO PUBLIC; \n\n<GRANT Anweisung> ::= \nGRANT  [ ON { Tabellenname | Sichtname } ] TO ;\n ::= { PUBLIC | Benutzername }\n ::= \n{ ALL | SELECT | DELETE | INSERT \n  | UPDATE [Spaltenname [, Spaltenname ]...] }",
    "type": "text",
    "answers": [
      {
        "text": "Der Befehl (ohne Semikolon) lautet :",
        "solution": "GRANT ALL ON XYZ TO PUBLIC"
      }
    ]
  },
  {
    "id": 1784,
    "category": 7,
    "difficulty": 2,
    "text": "In einer SQL-Anweisung an eine Tabelle \"Auto\" sollen alle Opel Corsa ausgegeben werden und alle VW Polo, wobei die letzteren weniger als 6000 Euro kosten sollen. Welche SELECT-Anweisung befriedigt diese Anfrage?",
    "explanation": "Die Abfrage \nSELECT Modell, Preis\nFROM Auto\nWHERE (Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO')\nAND Preis < 6000 \n\nist von der SQL-Syntax her richtig, gibt aber nur die Opel Corsa-Fahrzeuge mit einem Preis kleiner als 6000  aus.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT Modell, Preis\nFROM Auto\nWHERE Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO'\nAND Preis < 6000",
        "solution": "true"
      },
      {
        "text": "SELECT Modell, Preis\nFROM Auto\nWHERE (Modell = 'OPEL CORSA'\nOR Modell = 'VW POLO')\nAND Preis < 6000",
        "solution": "false"
      },
      {
        "text": "SELECT Modell, Preis\nFROM Auto\nWHERE Modell = 'OPEL CORSA'\nOR (Modell = 'VW POLO'\nAND Preis < 6000)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1785,
    "category": 15,
    "difficulty": 2,
    "text": "Betrachten Sie einen B-Baum vom Typ k mit der Höhe h. Wie viele Lesezugriffe sind maximal notwendig, um einen Datensatz zu finden?",
    "explanation": "Nach h Zugriffen ist man bei einem Blatt des B-Baums.",
    "type": "text",
    "answers": [
      {
        "text": "Die Anzahl ist",
        "solution": "h"
      }
    ]
  },
  {
    "id": 1786,
    "category": 9,
    "difficulty": 2,
    "text": "Welche Datentypen werden unter ORACLE ab Version 8 für große Dokumenten im nationalen Zeichensatz verwendet?",
    "explanation": "BLOB: Mit diesem Datentyp können entsprechend dem SQL-Standard binäre Objekte (Oracle bis zu 4 Gbyte) für Grafiken oder Tonaufzeichnungen in der Datenbank gespeichert werden. Außerdem stehen einige Methoden zur Verfügung, mit denen diese Objekte auf dem Server manipuliert werden können.\n\nCLOB und NCLOB:  Oracle CLOB ist eine Modifikation des Typs BLOB, er wird für große Textobjekte mit den entsprechenden Methoden zur Verfügung gestellt. NCLOB entspricht dem CLOB mit nationalem Zeichensatz. \n\nBFILE:ist ein Oracle-Datentyp für Binärobjekte, der nur einen Zeiger (LOB-Locator) auf ein Verzeichnis im Dateisystem enthält, das die Binärdateien beihaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BLOB",
        "solution": "false"
      },
      {
        "text": "LOB",
        "solution": "false"
      },
      {
        "text": "CLOB",
        "solution": "false"
      },
      {
        "text": "NCLOB",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1270,
    "category": 4,
    "difficulty": 2,
    "text": "Relationale Operatoren sind immer Abbildungen, die aus einer Relation eine Ergebnis-Relation erzeugen.",
    "explanation": "Neben den unären (Selektion, Projektion) gibt es aber auch noch die binären Operatoren (kartesisches Produkt, Joins, Mengenoperatoren, Division). \nDurch Anwendung einer dieser Operationen entsteht aus einer oder zwei Relationen wieder eine neue Relation. \nF1 : Rn -> Rm mit n , m ∈ N \nF2 : Rn × Rm -> Rk mit n , m , k ∈ N",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1341,
    "category": 10,
    "difficulty": 2,
    "text": "Treiber von welchem Typ sind immer appletfähig?",
    "explanation": "Treiber vom Typ 1: \n\nJDBC-ODBC-Bridge Bei diesem Treibertyp greift der JDBC-Treiber über die ODBC-Schnittstelle auf die Datenbank zu. Natürlich muss dazu auf jedem Client ein ODBC-Treiber installiert sein. Dieser Treibertyp bietet sich daher hauptsächlich in lokalen Netzwerken an, bei denen auf dem einzelnen Client leicht ODBC installiert werden kann. Außerdem ist durch den Zwischenschritt ODBC der Zugriff verhältnismäßig langsam.\n\n\nTreiber vom Typ 2: \nNative-API partly-Java-Treiber Bei diesem Ansatz werden die JDBC-Aufrufe in ein datenbankspezifisches API auf dem Client weitergeben. Daher sind auch bei diesem Typ zusätzliche Installationen auf dem Client notwendig.\n\nTreiber vom Typ 3: \nJDBC-Net pure Java-Treiber Treiber vom Typ 3 übersetzen die JDBC-Aufrufe in ein vom DBMS unabhängiges Netzprotokoll und benutzen einen Anwendungsserver. Der Server übersetzt die Aufrufe in das jeweilige DBMS-Protokoll und über die CLI-Schnittstelle wird auf die Datenbank zugegriffen. Bei Treibern vom Typ 3 ist keine zusätzliche Client-Installation notwendig, aber ein Anwendungsserver.\n\n\nTreiber vom Typ 4:\nNative-Protocol pure Java-Treiber Bei diesem Treibertyp werden die JDBC-Aufrufe in ein datenbankeigenes Protokoll übersetzt, welches über das Netzwerk direkt auf den Datenbankserver zugreift. Es ist auch keine zusätzliche Client- Installation notwendig.  \n\n\nTreiber von Typ 3 und 4 sind appletfähig, die anderen beiden Typen nicht, da sie nicht komplett in Java geschrieben sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typ 1",
        "solution": "false"
      },
      {
        "text": "Typ 2",
        "solution": "false"
      },
      {
        "text": "Typ 3",
        "solution": "true"
      },
      {
        "text": "Typ 4",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1351,
    "category": 4,
    "difficulty": 2,
    "text": "Bei welcher Operation der relationalen Algebra wird die Anzahl der Attribute nicht verändert?",
    "explanation": "Eine n-stellige Relation wird mittels der Selektion auf eine n-stellige Relation abgebildet, denn damit werden nur die Tupel einer Relation ausgewählt und alle Attribute beibehalten. \nDie Projektion schränkt die Attribute der Ergebnisrelation auf eine Teilmenge der ursprünglichen Attribute ein. \nDie Attributsstruktur der Ergebnismenge des Natural Joins besteht aus der Summe der Attribute beider Relationen abzüglich der Attribute, die mehrfach in den beiden Relationen auftreten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Natural Join",
        "solution": "false"
      },
      {
        "text": "Selektion",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1343,
    "category": 10,
    "difficulty": 2,
    "text": "Welcher JDBC-Treibertyp ist auf einer Middlewarekomponente aufgebaut?",
    "explanation": "Treiber vom Typ 1: \n\nJDBC-ODBC-Bridge Bei diesem Treibertyp greift der JDBC-Treiber über die ODBC-Schnittstelle auf die Datenbank zu. Natürlich muss dazu auf jedem Client ein ODBC-Treiber installiert sein. Dieser Treibertyp bietet sich daher hauptsächlich in lokalen Netzwerken an, bei denen auf dem einzelnen Client leicht ODBC installiert werden kann. Außerdem ist durch den Zwischenschritt ODBC der Zugriff verhältnismäßig langsam.\n\n\nTreiber vom Typ 2: \nNative-API partly-Java-Treiber Bei diesem Ansatz werden die JDBC-Aufrufe in ein datenbankspezifisches API auf dem Client weitergeben. Daher sind auch bei diesem Typ zusätzliche Installationen auf dem Client notwendig.\n\nTreiber vom Typ 3: \nJDBC-Net pure Java-Treiber Treiber vom Typ 3 übersetzen die JDBC-Aufrufe in ein vom DBMS unabhängiges Netzprotokoll und benutzen einen Anwendungsserver. Der Server übersetzt die Aufrufe in das jeweilige DBMS-Protokoll und über die CLI-Schnittstelle wird auf die Datenbank zugegriffen. Bei Treibern vom Typ 3 ist keine zusätzliche Client-Installation notwendig, aber ein Anwendungsserver.\n\n\nTreiber vom Typ 4:\nNative-Protocol pure Java-Treiber Bei diesem Treibertyp werden die JDBC-Aufrufe in ein datenbankeigenes Protokoll übersetzt, welches über das Netzwerk direkt auf den Datenbankserver zugreift. Es ist auch keine zusätzliche Client- Installation notwendig.  \n\n\nTreiber von Typ 3 und 4 sind appletfähig, die anderen beiden Typen nicht, da sie nicht komplett in Java geschrieben sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typ 1",
        "solution": "false"
      },
      {
        "text": "Typ 2",
        "solution": "false"
      },
      {
        "text": "Typ 3",
        "solution": "true"
      },
      {
        "text": "Typ 4",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1344,
    "category": 10,
    "difficulty": 1,
    "text": "Mit welchem Platzhalter werden unter JDBC einem PreparedStatement-Objekt Werte übergeben?",
    "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface. CallableStatement  und PreparedStatement  können Parameter mit dem Platzhalter \"?\" aufnehmen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "?"
      }
    ]
  },
  {
    "id": 1345,
    "category": 10,
    "difficulty": 1,
    "text": "Welche Parametertypen gibt es unter JDBC und einem PreparedStatement- Objekt ?",
    "explanation": "Das CallableStatement erbt vom Interface PreparedStatement Attribute und Methoden, und dieses wiederum vom Statement-Interface. CallableStatement  und PreparedStatement  können Parameter mit dem Platzhalter \"?\" aufnehmen. Man unterscheidet bei\nden Parametern folgende Typen:\n\n\nIN-Parameter: nehmen Werte auf, die weiterverarbeitet werden\nOUT-Parameter: enthalten Rückgabewerte; Beim Arbeiten mit OUT-Parametern bitte beachten, dass sie explizit mit  registriert werden müssen, damit der Datentyp des OUT-Parameters im Programm bekannt ist.   \nIN OUT-Parameter: nehmen Übergabeparameter auf, deren Wert verändert und an das aufrufende Programm zurückgegeben werden kann",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "OUT",
        "solution": "true"
      },
      {
        "text": "IN OUT",
        "solution": "true"
      },
      {
        "text": "OUT IN",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1346,
    "category": 10,
    "difficulty": 2,
    "text": "Welcher JDBC-Treibertyp verwendet ODBC?",
    "explanation": "Treiber vom Typ 1: \n\nJDBC-ODBC-Bridge Bei diesem Treibertyp greift der JDBC-Treiber über die ODBC-Schnittstelle auf die Datenbank zu. Natürlich muss dazu auf jedem Client ein ODBC-Treiber installiert sein. Dieser Treibertyp bietet sich daher hauptsächlich in lokalen Netzwerken an, bei denen auf dem einzelnen Client leicht ODBC installiert werden kann. Außerdem ist durch den Zwischenschritt ODBC der Zugriff verhältnismäßig langsam.\n\n\nTreiber vom Typ 2: \nNative-API partly-Java-Treiber Bei diesem Ansatz werden die JDBC-Aufrufe in ein datenbankspezifisches API auf dem Client weitergeben. Daher sind auch bei diesem Typ zusätzliche Installationen auf dem Client notwendig.\n\nTreiber vom Typ 3: \nJDBC-Net pure Java-Treiber Treiber vom Typ 3 übersetzen die JDBC-Aufrufe in ein vom DBMS unabhängiges Netzprotokoll und benutzen einen Anwendungsserver. Der Server übersetzt die Aufrufe in das jeweilige DBMS-Protokoll und über die CLI-Schnittstelle wird auf die Datenbank zugegriffen. Bei Treibern vom Typ 3 ist keine zusätzliche Client-Installation notwendig, aber ein Anwendungsserver.\n\n\nTreiber vom Typ 4:\nNative-Protocol pure Java-Treiber Bei diesem Treibertyp werden die JDBC-Aufrufe in ein datenbankeigenes Protokoll übersetzt, welches über das Netzwerk direkt auf den Datenbankserver zugreift. Es ist auch keine zusätzliche Client- Installation notwendig.  \n\n\nTreiber von Typ 3 und 4 sind appletfähig, die anderen beiden Typen nicht, da sie nicht komplett in Java geschrieben sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typ 2",
        "solution": "false"
      },
      {
        "text": "Typ 3",
        "solution": "false"
      },
      {
        "text": "Typ 4",
        "solution": "false"
      },
      {
        "text": "Typ 1",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2116,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Spalten hat der Durchschnitt der Tabelle Test mit sich selber?",
    "explanation": "Der Durchschnitt einer Tabelle mit sich selber ist die Ursprungstabelle selber.",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "3"
      }
    ]
  },
  {
    "id": 2117,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Tupel hat der Durchschnitt der Tabelle Test mit sich selber?",
    "explanation": "Der Durchschnitt einer Tabelle mit sich selber ist die Ursprungstabelle selber.",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "5"
      }
    ]
  },
  {
    "id": 2118,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Tupel hat die Differenz der Tabelle Test mit sich selber?",
    "explanation": "x-x = 0 :-), das gilt sogar für Relationen.",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "0"
      }
    ]
  },
  {
    "id": 2119,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Tupel hat die Vereinigungsmenge der Tabelle Test mit sich selber?",
    "explanation": "Die Vereinigungsmenge der Tabelle Test mit sich selber ist wieder die Tabelle Test.",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "5"
      }
    ]
  },
  {
    "id": 2120,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Tupel hat die Projektion der Tabelle Test auf die Spalten Spalte_1, Spalte_2, wenn Spalte 2 der Primärschlüssel ist?",
    "explanation": "Primärschlüssel sind eindeutig.",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "5"
      }
    ]
  },
  {
    "id": 2121,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Spalten hat die Projektion der Tabelle Test auf die Spalten Spalte_2, Spalte_3?",
    "explanation": "2 = 2.",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "2"
      }
    ]
  },
  {
    "id": 2122,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind, die sich alle im Wert für Spalte_3 unterscheiden.\n\nWie viele Spalten hat die Selektion der Tabelle Test auf einen Wert der Spalte_3?\nBitte numerischen Wert azfschrieben!",
    "explanation": "Da in der Selektion keine Spalten ausgeschlossen werden, bleibt es bei ursprünglichen Spalten Spalte_1, Spalte_2, Spalte_3, also 3.",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "3"
      }
    ]
  },
  {
    "id": 2123,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind, die sich alle im Wert für Spalte_3 unterscheiden.\n\nWie viele Tupel hat die Selektion der Tabelle Test auf einen Wert der Spalte_3?\nBitte  numerischen Wert aufschreiben!",
    "explanation": "1 = 1 :-).",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "1"
      }
    ]
  },
  {
    "id": 1381,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welcher SELECT-Komponente kann man die Reihenfolge der Ergebnisdatensätze einer SELECT-Abfrage festlegen?",
    "explanation": "Neben ORDER BY sortiert auch GROUP By in der Reihenfolge der angegebenen Spalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ORDER BY",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      },
      {
        "text": "GROUP BY",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1386,
    "category": 14,
    "difficulty": 2,
    "text": "Welche ACID-Eigenschaft einer Transaktion wird bei dem folgenden Szenarium verletzt?\n\nEine Transaktion A ändert zwei Sätze S1 und S2. Beim Systemabsturz wird die Aktion S2 zurückgerollt, während S1 weiterhin in geänderter Form vorliegt.",
    "explanation": "Es ist die \"Atomarität\" verletzt. \nDie Atomarität besagt, dass entweder alle Manipulationen einer Transaktion persistent in der DB gespeichert werden - oder gar nicht. Hier wird nur eine Teilmenge der Aktionen in der DB ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Atomarität",
        "solution": "true"
      },
      {
        "text": "Isolation",
        "solution": "false"
      },
      {
        "text": "Konsistenz",
        "solution": "false"
      },
      {
        "text": "Dauerhaftigkeit",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1391,
    "category": 6,
    "difficulty": 1,
    "text": "Welcher CONSTRAINT-Typ kann sich auch auf mehrere Spalten beziehen?",
    "explanation": "Je nach Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung)\ndifferenziert. Die Spaltenbedingungen werden direkt bei der Spaltendefinition des CREATE TABLE-Befehls programmiert und können sich nur auf eine, die gerade definierte Spalte beziehen. Tabellenbedingungen werden auch beim CREATE TALBE-Befehl definiert, sind aber nicht Teil einer Spaltenspezifikation und können sich somit auf mehrere Spalten beziehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ein COLUMN-CONSTRAINT",
        "solution": "false"
      },
      {
        "text": "ein TABLE-CONSTRAINT",
        "solution": "true"
      },
      {
        "text": "keiner von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1441,
    "category": 7,
    "difficulty": 3,
    "text": "Mit welchem SQL-Befehl löscht man die Daten einer Tabelle, ohne die Tabellendefinition zu löschen?",
    "explanation": "Der DROP-Befehl löscht auch die Tabellendefinitionen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DROP table...",
        "solution": "false"
      },
      {
        "text": "DELETE FROM table ...",
        "solution": "true"
      },
      {
        "text": "CANCEL table ..",
        "solution": "false"
      },
      {
        "text": "truncate table ...",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1431,
    "category": 15,
    "difficulty": 3,
    "text": "Welche Speicherstruktur eignet sich in erster Linie für große Datenbestände, die sich wenig ändern?",
    "explanation": "Die ISAM- und die  HASH-Speichersruktur sind für statische Daten die sich selten ändern, sehr gut geeignet, da keine Überlaufseiten entstehen, die den Lesezugriff verlangsamen könnten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "B+ Baum",
        "solution": "false"
      },
      {
        "text": "HASH",
        "solution": "true"
      },
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "ISAM",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1432,
    "category": 6,
    "difficulty": 1,
    "text": "Der CREATE SEQUENCE-Befehl gehört zum SQL:2003-Standard.",
    "explanation": "CREATE SEQUENCE gehört schon länger :-)  zum Standard.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ja",
        "solution": "true"
      },
      {
        "text": "nein",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1433,
    "category": 7,
    "difficulty": 3,
    "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank:\n\nSpieler (Spieler_id, Name, Adresse, Geburtsdatum)\nVereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr)\nSpiele (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\nSpieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\nWelche der angegeben SQL-Abfragen beantwortet/en die Frage: \nWelche Spieler (Name, Adresse) haben noch nie in einem Spiel mit mehr als 30000 Zuschauern mitgespielt?",
    "explanation": "SELECT name, adresse FROM spieler se \nWHERE NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                  WHERE anzahl_zuschauer > 30000); \nist semantisch falsch: Der Unteranfrage fehlt die Korrelation zur oberen Anfragen (unkorrelierter EXISTS). So liefert die obere Anfrage immer die leere Menge als Ergebnis, sobald es wenigstens ein Spiel mit mehr als 3000 Zuschauern gibt, also wenn der untere SELECT wenigstens einen Datensatz liefert. \n\nSELECT name, adresse FROM spieler se \nWHERE  NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                   WHERE   anzahl_zuschauer > 30000) \nAND    se.spieler_id = sp.spieler_id;\nist semantisch und syntaktisch falsch: Die schließende Klammer steht falsch. Richtig wäre die Anfrage, wenn die AND-Bedingung zur Unteranfrage gehören würde. Aber so, gehört sie zur oberen Anfrage und damit ist das Ganze nicht ausführbar, denn z.B. der Tabellenalias se ist im oberen SELECT nicht bekannt, nur im unteren. \n\nSELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nHAVING COUNT(s.spieler_id ) = 0; \nist semantisch falsch: Mit dem Natural Join werden nur die Spiele mit mehr als 3000 Zuschauern ermittelt. Anschließend wird mit der HAVING-Bedingung versucht, die Spieler zu ermitteln, die kein solches Spiel haben. Ergebnis: aufgrund dieses Widerspruchs immer die leere Menge.  \n\nSELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nAND    COUNT(s.spieler_id ) IS NULL;   \nist syntaktisch falsch: Aggregatfunktionen können nicht in der WHERE-Klausel verwendet werden, nur in der SELECT-, GROUP BY, HAVING-Klausel.\n \n\n\nrichtig isz :\nSELECT name, adresse FROM spieler \nWHERE spieler_id NOT IN \n   (SELECT spieler_id \n    FROM   spieleinsatz, spiele \n    WHERE  anzahl_zuschauer > 30000\n    AND    spiele.spiel_id = spieleinsatz.spiel_id );",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT name, adresse FROM spieler se \nWHERE NOT EXISTS (SELECT spieler_id \n                  FROM   spieleinsatz se \n                  WHERE  anzahl_zuschauer > 30000);",
        "solution": "false"
      },
      {
        "text": "SELECT name, adresse FROM spieler \nWHERE spieler_id NOT IN \n   (SELECT spieler_id \n    FROM   spieleinsatz, spiele \n    WHERE  anzahl_zuschauer > 30000\n    AND    spiele.spiel_id = spieleinsatz.spiel_id );",
        "solution": "true"
      },
      {
        "text": "SELECT name, adresse FROM spieler se \nWHERE  NOT EXISTS (SELECT spieler_id FROM spieleinsatz se \n                   WHERE   anzahl_zuschauer > 30000) \nAND    se.spieler_id = sp.spieler_id;",
        "solution": "false"
      },
      {
        "text": "SELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nHAVING COUNT(s.spieler_id ) = 0;",
        "solution": "false"
      },
      {
        "text": "SELECT name, adresse \nFROM   spieler s, spieleinsatz e \nWHERE  s.spieler_id = e.spieler_id \nAND    anzahl_zuschauer > 30000\nAND    COUNT(s.spieler_id ) IS NULL;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1443,
    "category": 7,
    "difficulty": 2,
    "text": "Welcher der folgenden SQL-Ausdrücke ist korrekt?",
    "explanation": "In der SELECT-Klausel dürfen nur zwei Arten von Spalten vorkommen:\n\ndie, die mit einer Gruppenfunktion versehen sind (hier Gehalt) \ndie anderen Spalten müssen in der GROUP-BY-Klausel enthalten sein.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "SELECT\n    Abt_Nr,\n    AVG(Gehalt)\nFROM     Angestellte\nGROUP BY Abt_Nr;",
        "solution": "true"
      },
      {
        "text": "SELECT\n    Abt_Nr,\n    Nachname,\n    AVG(Gehalt)\nFROM     Angestellte\nGROUP BY Abt_Nr;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1445,
    "category": 10,
    "difficulty": 3,
    "text": "Mit welchem Interface kann man in JDBC auf Metadaten des Datenbanksystems zugreifen?",
    "explanation": "Die Informationen über die Datenbank, welche Benutzer es gibt, welche Tabellen angelegt sind, die Datenbankversion etc., sind in relationalen Datenbanksystemen in der Datenbank selbst gespeichert. Diese Informationen können über die Klasse DatabaseMetaData aus der Datenbank abgerufen werden. Insgesamt enthält diese Klasse seit JDBC 2.0 ca. 150 verschiedene Methoden, um Informationen abzurufen. Instanziert wird ein Objekt der Klasse DatabaseMetaData über die Methode getMetaData der connection-Schnittstelle.",
    "type": "text",
    "answers": [
      {
        "text": "Die Klasse heißt",
        "solution": "DataBaseMetaData"
      }
    ]
  },
  {
    "id": 1299,
    "category": 14,
    "difficulty": 2,
    "text": "Wie viele Sperrzustände kennt das 2-Phasen-Sperrprotokoll?",
    "explanation": "Nur die beiden Zustände LOCK und UNLOCK sind sehr \"grob\" und lassen wenig parallelen Zugriff zu, da nicht zwischen \"schreiben\" und \"lesen\" differenziert wird. \nDaher wird mit drei Sperrzuständen gearbeitet: \nUNLOCK - entsperrt\nWRITELOCK - exklusiv sperren für einen Schreibzugriff\nREADLOCK - sperren für parallele Lesezugriffe",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "einen Zustand",
        "solution": "false"
      },
      {
        "text": "zwei Zustände",
        "solution": "false"
      },
      {
        "text": "drei Zustände",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1144,
    "category": 12,
    "difficulty": 2,
    "text": "PL/SQL-Packages können enthalten",
    "explanation": "Pakete (PACKAGES) sind Oracle-Datenbankobjekte, mit denen logisch in Verbindung stehende Programmkonstrukte, wie\n\nProzeduren,\nFunktionen,\nCURSOR,\nVariablen und Konstanten sowie\nEXCEPTIONS \n\n\nzu einer Einheit zusammengefasst werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Prozeduren",
        "solution": "true"
      },
      {
        "text": "Funktionen",
        "solution": "true"
      },
      {
        "text": "CURSOR",
        "solution": "true"
      },
      {
        "text": "EXCEPTIONS",
        "solution": "true"
      },
      {
        "text": "Variable",
        "solution": "true"
      },
      {
        "text": "Konstanten",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1145,
    "category": 10,
    "difficulty": 3,
    "text": "Wie laden Sie in JDBC eine Klasse des Datenbanktreibers ohne eine Instanz zu erzeugen?",
    "explanation": "Der JDBC-Treiber entstammt einer Klassenbibliothek, die die Verbindung mit dem aktuellen Datenbankserver herstellt. Um die Klasse zu laden und beim DriverManager zu registrieren, wird die Methode Class.forName verwendet. Damit kann man eine Klasse laden, ohne eine Instanz zu erzeugen, und eine Klasse referenzieren, deren Name noch nicht bekannt ist.",
    "type": "text",
    "answers": [
      {
        "text": "Die Methode (mit Angabe der Klasse) heißt",
        "solution": "Class.forName"
      }
    ]
  },
  {
    "id": 1301,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Aussagen über \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?",
    "explanation": "FALSCH ist:  \n\"Non repeatable read\" und \"phantome\" sind zwei eng verwandte Probleme. Bei beiden geht es darum, dass die eine Anwendung die gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausführt und dann ggf. auf unterschiedlichen Datenbankzuständen ausführt, weil eine andere Transaktion Datensätze eingefügt oder geändert hat.\"  \nDie Aussage ist richtig bis auf den Teil: \"...gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausführt...\" Ganz:-) richtig wird die Aussage, wenn man das \"zwei verschiedene Transaktionen\" durch \"eine Transaktion\" ersetzt.\n  \n\nRICHTIG sind die anderen beiden Aussagen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "\"Non repeatable read\" und \"phantome\" sind zwei eng verwandte Probleme. Bei beiden geht es darum, dass die eine Anwendung die gleiche Anfrage in mindestens zwei verschiedenen Transaktionen ausführt und dann ggf. auf unterschiedlichen Datenbankzuständen ausführt, weil eine andere Transaktion Datensätze eingefügt oder geändert hat.",
        "solution": "false"
      },
      {
        "text": "\"Dirty reads\" treten auf, wenn eine z.B. Transaktion T1 Datensätze liest und verarbeitet, die eine andere Transaktion T2 zwar geändert aber nicht \"committet\" hat und T2 später mit einem Rollback abgeschlossen wird.",
        "solution": "true"
      },
      {
        "text": "Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und überschreibt somit die Änderungen von T2 ungesehen.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1311,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Aussagen über \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?",
    "explanation": "RICHTIG sind: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"XLOCK\" gesperrt hat, kann keine andere Transaktion irgendeinen anderen LOCK absetzen auf diesen Datensatz bzw. diese Tabelle.\"\n\n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, können  andere Transaktion ebenfalls SLOCKs absetzen und lesen auf das gesperrte Objekt zugreifen.\"\n\nFALSCH ist: \n\"Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, kann keine andere Transaktion irgendeinen anderen LOCK absetzen auf diesen Datensatz bzw. diese Tabelle.\"",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"XLOCK\" gesperrt hat, kann keine andere Transaktion irgendeinen anderen LOCK absetzen auf diesen Datensatz bzw. diese Tabelle.",
        "solution": "true"
      },
      {
        "text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, kann keine andere Transaktion irgendeinen anderen LOCK absetzen auf diesen Datensatz bzw. diese Tabelle.",
        "solution": "false"
      },
      {
        "text": "Solange eine Transaktion einen Datensatz oder eine Tabelle mit \"SLOCK\" gesperrt hat, können  andere Transaktion ebenfalls SLOCKs absetzen und lesen auf das gesperrte Objekt zugreifen.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1310,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Aussagen über \"Transaktionen und Mehrbenutzerbetrieb in SQL\" sind richtig?",
    "explanation": "Beide Aussagen sind richtig:   \nBeim 2-Phasen-Sperrprotokoll werden eine Wachstumsphase, in der alle erforderlichen Sperren angefordert werden, und eine Schrumpfungsphase, in der alle gesperrten Datensätze wieder freigegeben werden, unterschieden.   \nDamit beim 2-Phasen-Sperrprotokoll die Datensätze nicht unnötig lange gesperrt bleiben, werden drei Sperrzustände unterschieden: read_lock, write_lock, unlock.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Beim 2-Phasen-Sperrprotokoll werden eine Wachstumsphase, in der alle erforderlichen Sperren angefordert werden, und eine Schrumpfungsphase, in der alle gesperrten Datensätze wieder freigegeben werden, unterschieden.",
        "solution": "true"
      },
      {
        "text": "Damit beim 2-Phasen-Sperrprotokoll die Datensätze nicht unnötig lange gesperrt bleiben, werden drei Sperrzustände unterschieden: read_lock, write_lock, unlock.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1150,
    "category": 15,
    "difficulty": 1,
    "text": "Bei welcher Speicherstruktur enthalten die Blätter ausschließlich Nutzdaten?",
    "explanation": "Beim B-Baum werden die Nutzdaten gemeinsam mit dem Index gespeichert, beim B+-Baum getrennt von den Nutzdaten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "B+ Baum",
        "solution": "true"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1159,
    "category": 11,
    "difficulty": 2,
    "text": "Welches Java-Paket realisiert unter SQLJ den Zugriff auf eine relationale Datenbank?",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "sqlj.runtime"
      }
    ]
  },
  {
    "id": 1160,
    "category": 11,
    "difficulty": 2,
    "text": "SQLJ-Code muss durch einen Translator vorübersetzt werden",
    "explanation": "Der SQLJ-Translator überprüft schon zur Compilezeit, ob die SQL-Syntax korrekt ist,\ndie Datentypen übereinstimmen und die Tabellendefinitionen der Schemadefinition\nentsprechen. Der Translator wird über die Kommandozeilenprozedur ¿sqlj¿ aufgerufen\nund auf eine Datei mit der Endung *.sqlj , z.B. test.sqlj, angewandt. Ergebnis ist\neine *.java-Datei mit JDBC-Aufrufen. Diese Datei, z.B. test.java, wird wie jede andere\nJava-Datei mit dem Java-Compiler (z.B. javac test.java) in eine Class-Datei übersetzt,\ndie mittels der Laufzeitumgebung ¿java¿ gestartet werden kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1162,
    "category": 11,
    "difficulty": 1,
    "text": "Eine SQLJ-Klausel benutzt immer den voreingestellten Default-Kontext, um eine Verbindung zur Datenbank herzustellen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1163,
    "category": 11,
    "difficulty": 2,
    "text": "Bei welchem Kontext-Typ unter SQLJ können auch Verbindungen zu unterschiedlichen Datenbanken aufgebaut werden?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Impliziter Kontext",
        "solution": "false"
      },
      {
        "text": "Expliziter Kontext",
        "solution": "true"
      },
      {
        "text": "Solch einen Kontext-Typ gibt es nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1165,
    "category": 11,
    "difficulty": 3,
    "text": "Wo werden unter ORACLE SQLJ die jar-Archive von Java-Klassen abgelegt?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "In einem Betriebssystemverzeichnis, das bei der Installation der Datenbank festgelegt wird",
        "solution": "false"
      },
      {
        "text": "Als BFile-Datentyp in einer speziellen Tabelle",
        "solution": "false"
      },
      {
        "text": "Als BLOB-Datentyp in einer speziellen Tabelle",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1306,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über virtuelle SQL-Sichten sind richtig?",
    "explanation": "Mit dem SQL-Befehl \"CREATE VIEW  ...\" werden virtuelle Sichten erstellt. \nVirtuelle Sichten können sowohl auf der Basis von Tabellen als auch aufgrund von anderen Sichten definiert werden, so können Sicht-Hierarchien aufgebaut werden. \nAktualitätsprobleme (veraltete Daten in der Sicht gegenüber neuen Daten in den Tabellen oder auch umgekehrt) gibt es nur bei den materialisierten Sichten, weil dort die Daten in Tabellen und Sichten redundant gespeichert sind. Bei virtuellen Sichten wird der Datenbestand bei jeder Anfrage auf den Tabellen ausgewertet und ist damit absolut aktuell, auch wenn es (etwas) länger dauert. \nDas Problem des \"View Updating\", was die automatische Weiterleitung/Transformation der Änderung von Sichtdaten auf die gespeicherten Tabellen-Daten meint, ist auch noch ein in der Wissenschaft ungelöstes Problem. Für einige Fälle kann man die Daten automatisch transformieren (einige wenige davon sich auch bei Oracle implementiert), um viele andere Fälle wird semantisches Hintergrundwissen bei der Transformation benötigt, über das nur der Entwickler verfügt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mit dem SQL-Befehl \"CREATE VIEW <viewname> ...\" werden virtuelle Sichten erstellt.",
        "solution": "true"
      },
      {
        "text": "Virtuelle Sichten können nur auf der Basis von Tabellen und nicht aufgrund von anderen Sichten definiert werden.",
        "solution": "false"
      },
      {
        "text": "Virtuelle Sichten können auch auf der Basis von anderen Sichten definiert werden.",
        "solution": "true"
      },
      {
        "text": "Da die auf virtuellen Sichten ausgeführten Änderungsoperationen (INSERT, UPDATE, DELETE) ja sowieso auf den zugrunde liegenden Tabellen ausgeführt werden, können die Änderungsoperationen auf Sichten mit beliebig komplizierten Definitionen ohne jede Einschränkung ausgeführt werden.",
        "solution": "false"
      },
      {
        "text": "Bei virtuellen Sichten treten Aktualitätsprobleme bei Änderungen der zugrunde liegenden Daten in den Tabellen auf.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1307,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über materialisierte SQL-Sichten sind richtig?",
    "explanation": "Mit dem SQL-Befehl \"CREATE MATERIALIZED VIEW  ...\" werden virtuelle Sichten erstellt. \nMaterialisierte Sichten können sowohl auf der Basis von Tabellen als auch aufgrund von anderen Sichten definiert werden, so können Sicht-Hierarchien aufgebaut werden. \nAktualitätsprobleme (veraltete Daten in der Sicht gegenüber neuen Daten in den Tabellen oder auch umgekehrt) gibt es nur bei den materialisierten Sichten, weil dort die Daten aus den Tabellen und anderen Sichten beim Erstellen der matieralisierten Sicht einmal ermittelt und dann redundant gespeichert werden. Bei virtuellen Sichten wird der Datenbestand bei jeder Anfrage auf den Tabellen ausgewertet und ist damit absolut aktuell, auch wenn es (etwas) länger dauert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mit dem SQL-Befehl \"CREATE MATERIALIZED VIEW <viewname>...\" werden materialisierte Sichten erstellt.",
        "solution": "true"
      },
      {
        "text": "Materialisierte Sichten können nur auf der Basis von Tabellen und nicht aufgrund von anderen Sichten definiert werden.",
        "solution": "false"
      },
      {
        "text": "Die Daten materialisierte Sichten werden bei jeder Anfrage an eine Sicht neu auf der Basis der zugrunde liegenden Tabellen abgeleitet.",
        "solution": "false"
      },
      {
        "text": "Die Daten materialisierter Sichten werden nicht bei jeder Anfrage an eine Sicht vollständig neu auf der Basis der Daten der zugrunde liegenden Tabellen abgeleitet, sondern einmal beim Erstellen der Sicht und liegen dann gespeichert in der Sicht selbst vor.",
        "solution": "true"
      },
      {
        "text": "Bei materialisierten Sichten treten Aktualitätsprobleme bei Änderungen der zugrunde liegenden Daten in den Tabellen auf.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1308,
    "category": 6,
    "difficulty": 1,
    "text": "Mit welcher Oracle-/SQL2003-Funktion können Sie eine Zeichenkette in ein Datum konvertieren?",
    "explanation": "Richtig ist der Befehl: TO_DATE ('15.06.2004', 'DD.MM.RRRR') \nDie Formatmaske gibt an, wie die Zeichenkette zu interpretieren ist. DD für den Tag, MM für den Monat, RRRR für ein 4-stelliges Jahr. Trennzeichen ist hier der Punkt \".\". Es können aber auch beliebige andere Trennzeichen verwendet werden. Für andere Formatierungen gibt auch noch weitere Formatmasken.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "KONVERT_DATE ('15.06.2004', 'DD.MM.RRRR') ",
        "solution": "false"
      },
      {
        "text": "TRANSFORM_DATE ('15.06.2004', 'DD.MM.RRRR') ",
        "solution": "false"
      },
      {
        "text": "TO_DATE ('15.06.2004', 'DD.MM.RRRR') ",
        "solution": "true"
      },
      {
        "text": "MAKE_DATE ('15.06.2004', 'DD.MM.RRRR') ",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1309,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über CONSTRAINTS sind wahr?",
    "explanation": "Die drei richtigen Aussagen erklären sich selbst. \nFALSCH ist: \nDie Sache mit dem \"MANDATORY-CONSTRAINT\". Ein Constraint dieses Namens gibt es nicht. Das Constraint mit der gewünschten Funktion heißt: NOT NULL bei SQL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Standardreaktion auf einen Integritätsfehler beim \"integrity checking\" mittels Constraints ist das Zurückrollen des fehlerhaften DML-Befehls (Prüfungsmodus IMMEDIATE) bzw. der gesamten Transaktion beim Prüfungsmodus DEFERRED. Nur das FOREIGN KEY-Constraint bietet mit der Action-Klausel eine Möglichkeit zur Fehlerkorrektur wie z.B. das kaskadierendes Löschen bei \"dangling tuples\".",
        "solution": "true"
      },
      {
        "text": "Transitionale Integritätsbedingungen können in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Referenzvariablen (:OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.",
        "solution": "true"
      },
      {
        "text": "Oracle-Trigger erweitern das Oracle-Integritätskonzept im Wesentlichen in 2 Punkten. \n- Die Bedingungen die mit Triggern abgeprüft werden können, sind wesentlich komplexer als mit CHECK-CONSTRAINTS (Zugriff auf andere Tabellen, transitionale Integritätsbedingungen).\n- Neben dem Zurückrollen des fehlerauslösenden DML-Befehls, kann mittels der Triggeraktion der Fehler auch korrigiert werden.",
        "solution": "true"
      },
      {
        "text": "Für im ER-Modell als \"obligatorisch\" (Pflichteingabe) deklarierte Attribute werden im Datenmodell MANDATORY-CONSTRAINTS definiert.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1753,
    "category": 7,
    "difficulty": 1,
    "text": "Welche der beiden folgenden SELECT-Anweisungen ist korrekt, wenn Spalte_1 und Spalte_2 den gleichen Datentyp haben?",
    "explanation": "Eine ORDER-BY-Klausel kann in zwei SELECTs, die mit UNION verknüpft werden, nicht verwendet werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT Spalte_1 FROM TEST1 ORDER BY Spalte_1\nUNION\nSELECT Spalte_2 FROM TEST2 ORDER BY Spalte_2",
        "solution": "false"
      },
      {
        "text": "SELECT Spalte_1 FROM TEST1\nUNION\nSELECT Spalte_2 FROM TEST2",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1754,
    "category": 12,
    "difficulty": 2,
    "text": "Welche CURSOR-Attribute sind korrekt?",
    "explanation": "Ein Cursor hat folgende Attribute:\n%ISOPEN Boolesches Attribut, das TRUE ist, wenn der CURSOR geöffnet ist \n%NOTFOUND Boolesches Attribut, das TRUE ist, wenn die letzte FETCH-Anweisung keine Zeile mehr liefert \n%FOUND Gegenteil von %NOTFOUND \n%ROWCOUNT Gesamtanzahl der bisher gelesenen Zeilen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "%FOUND",
        "solution": "true"
      },
      {
        "text": "%ROWTYPE",
        "solution": "false"
      },
      {
        "text": "%ISSTARTED",
        "solution": "false"
      },
      {
        "text": "%NOTFOUND",
        "solution": "true"
      },
      {
        "text": "%ISROW",
        "solution": "false"
      },
      {
        "text": "%ISOPEN",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1755,
    "category": 12,
    "difficulty": 1,
    "text": "Packages bestehen aus verschiedenen Komponenten. Geben Sie an, welche Komponenten es gibt und ob sie für die private bzw. öffentliche Deklaration von Package-Objekten zuständig sind!",
    "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur,\nFunktion, Variable, Konstante, Cursor etc., ist es entweder öffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind öffentlich und können damit von außerhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und können damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Body",
        "solution": "true"
      },
      {
        "text": "Header",
        "solution": "true"
      },
      {
        "text": "Soul",
        "solution": "false"
      },
      {
        "text": "Declare",
        "solution": "false"
      },
      {
        "text": "Action",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1756,
    "category": 12,
    "difficulty": 3,
    "text": "Welche Aussagen über PL/SQL-Programmierkonstrukte sind wahr?",
    "explanation": "Prozeduren können über die Parametertypen IN OUT und OUT Werte an das aufrufende Programm zurückgeben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Anonyme Blöcke können beliebig geschachtelt werden.",
        "solution": "true"
      },
      {
        "text": "Für eine Funktion wird, anders als bei Prozeduren, der Datentyp eines Rückgabewertes definiert.",
        "solution": "true"
      },
      {
        "text": "Eine Funktion muss immer mit einer RETURN-Anweisung beendet werden, die den Rückgabewert zurück liefert",
        "solution": "true"
      },
      {
        "text": "Bei Prozeduren gibt es keine Möglichkeit, Werte zurückzugeben an die aufrufende Umgebung.",
        "solution": "false"
      },
      {
        "text": "Selbstprogrammierte Funktionen können in einer SELECT-Anweisung aufgerufen werden.",
        "solution": "true"
      },
      {
        "text": "In PL/SQL-Blöcken ist immer die direkte Verwendung von SQL-DML- und -DDL-Anweisungen wie SELECT, INSERT, UPDATE, DELETE bzw. CREATE, DROP, ALTER erlaubt.",
        "solution": "false"
      },
      {
        "text": "Transaktionen können innerhalb von PL/SQL-Blöcken nicht mittels Befehlen wie COMMIT und ROLLBACK gesteuert werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1767,
    "category": 1,
    "difficulty": 1,
    "text": "In einer Datenbank sollen die Daten auch nach Beendigung aller Programme dauerhaft gespeichert werden. Diese Eigenschaft einer Datenbank nennt man:",
    "explanation": "Das ist die Definition der Datenbankpersistenz.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Persistenz",
        "solution": "true"
      },
      {
        "text": "Konsistenz",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1758,
    "category": 13,
    "difficulty": 3,
    "text": "Welche Aussagen über Trigger sind wahr?",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das Mutating-Table-Problem tritt unter ORACLE-SQL auf, wenn ein ROW-Trigger bezüglich einer Tabelle X definiert ist und im Aktionsteil auf diese Tabelle X zugegriffen wird, sei es mit SELECT, INSERT, UPDATE, DELETE",
        "solution": "true"
      },
      {
        "text": "In einem Trigger dürfen neben SQL-DML-Befehlen (SELECT, INSERT, UPDATE, DELETE) auch die Anweisungen COMMIT und ROLLBACK zur Kontrolle der Transaktion verwendet werden.",
        "solution": "false"
      },
      {
        "text": "Bricht ein Trigger fehlerhaft ab, so werden nur die Aktionen des Trigger-Aktionsteils rückgängig gemacht. Das feuernde Ereignis wird ordentlich zu Ende ausgeführt",
        "solution": "false"
      },
      {
        "text": "Wird der Befehl DBMS_OUTPUT.PUT_LINE in einem Trigger ausgeführt, so wird eine Fehlermeldung angezeigt und die Ausführung des Triggers unterbrochen.",
        "solution": "false"
      },
      {
        "text": "Zulässige Ereignisse, die Trigger feuern können, sind bei Oracle u.a. alle SQL-DML-Befehle: SELECT, INSERT, UPDATE, DELETE.",
        "solution": "false"
      },
      {
        "text": "Das Mutating-Table-Problem tritt bei den ROW-Triggern des SQL-Standards auf",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1759,
    "category": 13,
    "difficulty": 2,
    "text": "Es wird eine UPDATE-Anweisung auf der Tabelle X ausgeführt, von der 5 Datensätze betroffen sind. Für diese Tabelle X ist je ein BEFORE- und AFTER-UPDATE-STATEMENT-Trigger definiert. Wie oft werden diese Trigger jeweils ausgeführt?",
    "explanation": "Die Statement-Trigger werden nach Definition nur einmal angestoßen.",
    "type": "text",
    "answers": [
      {
        "text": "BEFORE-UPDATE-STATEMENT-Trigger",
        "solution": "1"
      },
      {
        "text": "AFTER-UPDATE-STATEMENT-Trigger",
        "solution": "1"
      }
    ]
  },
  {
    "id": 1760,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussagen über LOBs bei Oracle sind wahr?",
    "explanation": "Für strukturierte Datentypen verwendet man keine LOBS, sondern benutzerdefinierte Typen, die mit CREATE TYPE ... angelegt werden.\n\nEine SELECT-Anweisung an LOBS selektiert nur den LOB-Locator, nicht die eigentlichen LOB-Werte.\n\nLOBS können als BFILE auch im Dateisystem gespeichert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LOB-Datentypen werden zur Speicherung von umfangreichen, strukturierten Daten benötigt.",
        "solution": "false"
      },
      {
        "text": "LOBs können nur in der Datenbank gespeichert werden. Eine Speicherung im Dateisystem ist nicht möglich.",
        "solution": "false"
      },
      {
        "text": "Die maximale Größenbeschränkung für LOBs liegt bei 4 GB pro Datensatz.",
        "solution": "true"
      },
      {
        "text": "Mittels der SELECT-Anweisung können die Inhalte von LOB-Daten ausgelesen und angezeigt werden.",
        "solution": "false"
      },
      {
        "text": "LOBs, die in der Datenbank gespeichert werden, unterliegen dem Transaktionskonzept sowie dem Recovery.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1761,
    "category": 9,
    "difficulty": 2,
    "text": "Welche internen LOB-Arten gibt es bei Oracle?",
    "explanation": "BLOB: Mit diesem Datentyp können entsprechend dem SQL-Standard binäre Objekte (Oracle bis zu 4 Gbyte) für Grafiken oder Tonaufzeichnungen in der Datenbank gespeichert werden. Außerdem stehen einige Methoden zur Verfügung, mit denen diese Objekte auf dem Server manipuliert werden können.\n\nCLOB und NCLOB:  Oracle CLOB ist eine Modifikation des Typs BLOB, er wird für große Textobjekte mit den entsprechenden Methoden zur Verfügung gestellt. NCLOB entspricht dem CLOB mit nationalem Zeichensatz. \n\nBFILE:ist ein Oracle-Datentyp für Binärobjekte, der nur einen Zeiger (LOB-Locator) auf ein Verzeichnis im Dateisystem enthält, das die Binärdateien beihaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ALOB",
        "solution": "false"
      },
      {
        "text": "BLOB",
        "solution": "true"
      },
      {
        "text": "CLOB",
        "solution": "true"
      },
      {
        "text": "BFILE",
        "solution": "false"
      },
      {
        "text": "NCLOB",
        "solution": "true"
      },
      {
        "text": "VIDEOLOB",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1772,
    "category": 7,
    "difficulty": 3,
    "text": "Welche der folgenden INSERT-Anweisungen in eine Tabelle test\n   \nCREATE TABLE test( Nr NUMBER(9), \nBezeichnung VARCHAR2(20), Wert NUMBER(9))  \n\nist korrekt? \n\nTabelle 2 soll die gleichen Spalten wie Tabelle test haben.",
    "explanation": "Bei einer INSERT-Anweisung müssen die Werte in der Reihenfolge der Spaltenliste hinter dem Tabellennamen, oder wenn dieser fehlt, in der Reihenfolge der Spaltendefinition vorkommen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSERT INTO TEST\nVALUES (1, 'Bier')",
        "solution": "false"
      },
      {
        "text": "INSERT INTO TEST\nVALUES (1, 'Bier', 20)",
        "solution": "true"
      },
      {
        "text": "INSERT INTO TEST (Nr, Bezeichnung, Wert)\nVALUES (1, 'Bier', 20)",
        "solution": "true"
      },
      {
        "text": "INSERT INTO TEST (Nr, Wert, Bezeichnung)\nVALUES (1, 'Bier', '20')",
        "solution": "false"
      },
      {
        "text": "INSERT INTO TEST SELECT Nr, Bezeichnung, Wert FROM Tabelle2",
        "solution": "true"
      },
      {
        "text": "INSERT INTO TEST\n(1, 20, 'Bier')",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1770,
    "category": 6,
    "difficulty": 2,
    "text": "Welche STRING-Funktionen gibt es unter ORACLE-SQL?",
    "explanation": "INSTR sucht eine gegebene Zeichenfolge in einem String und gibt dessen Position zurück.\nSELECT INSTR(bemerkung, 'zahlungsfreudig') FROM kunden;\nGibt für jeden Kundendatensatz die Position der Wortes 'zahlungsfreudig' an.  \n\nSUBSTR schneidet aus einem Datenwert (1. Parameter) ab einer übergebenen Position (2. Parameter) eine Zeichenkette bestimmter Länge (3. Parameter) ab und gibt sie zurück.\nSUBSTR(spalteA, 1, 7) liefert die ersten 7 Zeichen des Inhalts von spalteA zurück.\nSUBSTR(spalteA, LENTGH(spalteA, 3) liefert die letzten 3 Zeichen des Inhalts von spalteA zurück.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SUBSTR",
        "solution": "true"
      },
      {
        "text": "INSTR",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "LEFT",
        "solution": "false"
      },
      {
        "text": "RIGHT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1170,
    "category": 15,
    "difficulty": 3,
    "text": "Welche Speicherstruktur beinhaltet einen dünnen Index?",
    "explanation": "Bei der ISAM-Specherstruktur werden die Daten über die Indexspalte(n) aufsteigend sortiert. Aus jedem Block wird der größte Schlüsselwert als Repräsentant vermerkt und in einer gesonderten Struktur, dem Index abgelegt. Der Index ordnet also jedem Block ein Intervall der möglichen Schlüsselwerte zu. Der ISAM-Index ist daher ein dünner Index mit logischen Adressen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "gibt es nicht.",
        "solution": "false"
      },
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "ISAM",
        "solution": "true"
      },
      {
        "text": "B+ -Baum",
        "solution": "true"
      },
      {
        "text": "HASH",
        "solution": "false"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1171,
    "category": 15,
    "difficulty": 2,
    "text": "Bei welcher Speicherstruktur können Überlaufseiten entstehen?",
    "explanation": "Der B-Baum und der B+-Baum wurden entwickelt, um Überlaufseiten zu vermeiden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "B+-Baum",
        "solution": "false"
      },
      {
        "text": "HASH",
        "solution": "true"
      },
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "ISAM",
        "solution": "true"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1177,
    "category": 15,
    "difficulty": 2,
    "text": "Wie heißt ein Baum mit der Eigenschaft, dass der Weg von der Wurzel bis zu einem Blatt immer gleich lang ist?",
    "explanation": "Der B-Baum und der B+-Baum sind vollständig balancierte Bäume, bei den der Weg von der Wurzel bis zu  Blatt immer gleich lang sind und der Höhe H des Baums entsprechen.",
    "type": "text",
    "answers": [
      {
        "text": "Er heißt",
        "solution": "vollständig balanciert"
      }
    ]
  },
  {
    "id": 1219,
    "category": 9,
    "difficulty": 3,
    "text": "Benutzerdefinierten Datentypen unter ORACLE verwenden Konstruktormethoden bei",
    "explanation": "Konstruktormethoden dienen zum Einfügen und Ändern von Daten, nicht zum Selektieren bzw. Anlegen von Tabellen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DELETE",
        "solution": "false"
      },
      {
        "text": "INSERT",
        "solution": "true"
      },
      {
        "text": "UPDATE",
        "solution": "true"
      },
      {
        "text": "SELECT",
        "solution": "false"
      },
      {
        "text": "CREATE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1220,
    "category": 9,
    "difficulty": 3,
    "text": "Wie nennt man den folgenden Zugriff in einer Oracle-Objekttabelle?",
    "explanation": "Der Zugriff erfolgt im Multi-Column-Modus, falls die Objekttabelle als mehrspaltige Tabelle betrachtet wird, bei der jedes Attribut des benutzerdefinierten Datentyps die Anwendung relationaler Operationen erlaubt. \n\nDer Zugriff erfolgt im Single-Column-Modus, falls die Objekttabelle als einspaltige Tabelle betrachtet wird, in der jeder Datensatz ein Objekt darstellt, die die Anwendung von OO-Operationen erlaubt.",
    "type": "text",
    "answers": [
      {
        "text": "Die Objekttabelle wird als mehrspaltige Tabelle betrachtet, bei der jedes Attribut des benutzerdefinierten Datentyps die Anwendung relationaler Operationen erlaubt.\n\n(mit Bindestrich schreiben)",
        "solution": "Multi-Column"
      }
    ]
  },
  {
    "id": 1222,
    "category": 9,
    "difficulty": 1,
    "text": "In welchem Methoden-Typ ist unter ORACLE das Objekt selber mit SELF referenzierbar?",
    "explanation": "Eine MEMBER-Routine bezieht sich auf eine Instanz, das heißt eine Tabelle, die auf diesem Typ basiert. Eine STATIC-Routine bezieht\nsich auf den Typ selbst. Eine MEMBER-Methode wird aufgerufen über Instanzname.method(), eine STATIC-Routine über Typname.method(). In der MEMBER-Routine existiert immer ein implizites Argument SELF im Methoden-Body, das die Instanz repräsentiert, für die die Methode aufgerufen wurde. SELF existiert bei STATIC-Routinen\nnatürlich nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "MEMBER-Typ",
        "solution": "true"
      },
      {
        "text": "STATIC-Typ",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1457,
    "category": 12,
    "difficulty": 1,
    "text": "Welche PL/SQL-Deklaration ist korrekt?",
    "explanation": "Das ist leider umgekehrt wir man das z.B. von JAVA gewöhnt ist :-(.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "zahl number;",
        "solution": "true"
      },
      {
        "text": "number zahl;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1458,
    "category": 12,
    "difficulty": 3,
    "text": "Mit welcher Funktion gibt man unter ORACLE PL/SQL den Fehlermeldungstext aus?",
    "explanation": "SQLEERM gibt in einem EXCEPTION-Abschnitt den Oracle-Fehlermeldungstext, aus und SQLCODE die Oracle-Fehlernummer. Hier steht 0 für kein Fehler, 1 für einen benutzerdefinierten Fehler und 100 für NO_DATA_FOUND.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "SQLERRM"
      }
    ]
  },
  {
    "id": 1459,
    "category": 12,
    "difficulty": 3,
    "text": "Mit welcher Funktion gibt man unter PL/SQL die ORACLE -Fehlernummer aus?",
    "explanation": "SQLEERM gibt in einem EXCEPTION-Abschnitt den Oracle-Fehlermeldungstext, aus und SQLCODE die Oracle-Fehlernummer. Hier steht 0 für kein Fehler, 1 für einen benutzerdefinierten Fehler und 100 für NO_DATA_FOUND.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "SQLCODE"
      }
    ]
  },
  {
    "id": 1460,
    "category": 13,
    "difficulty": 1,
    "text": "Wenn ein Trigger existiert, kann der Anwender sicher sein, dass alle in der Datenbank gespeicherten Daten die Bedingung erfüllen, die durch den Trigger definiert ist.",
    "explanation": "Die Eigenschaft, dass rückwirkend die Daten kontrolliert werden, haben nur Constraints. Das führt dazu, dass man keinen Constraint anlegen kann, wenn die bestehenden Daten nicht der in dem Constraint enthaltenen Bedingung genügen. Für Trigger ist das nicht der Fall. Um die Kontrolle, die im Trigger enthalten ist, auszuführen, muss der Trigger angestoßen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1462,
    "category": 12,
    "difficulty": 1,
    "text": "Wie überlädt man Prozeduren unter PL/SQL?",
    "explanation": "Ein expliziter OVELOADING-Befehl ist unter PL/SQL nicht notwendig. Gleichnamige Prozeduren werden durch eine unterschiedliche Anzahl von Parametern oder durch unterschiedliche Datentypen der Parameter unterschieden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Durch das zusätzliche Schlüsselwort \"OVERLOADING\" hinter  \"CREATE PROZEDURE\" platziert.",
        "solution": "false"
      },
      {
        "text": "Gleichnamige Prozeduren werden durch eine unterschiedliche Anzahl von Parametern oder durch unterschiedliche Datentypen der Parameter unterschieden.",
        "solution": "true"
      },
      {
        "text": "Überladen von Prozeduren ist unter PL/SQL nicht möglich.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1463,
    "category": 12,
    "difficulty": 2,
    "text": "Welcher Programmiersprache ist PL/SQL nachempfunden?",
    "explanation": "PL/SQL ist eine Oracle-spezifische prozedurale Erweiterung von SQL, die auf ADA basiert. Sie stellt somit eine Möglichkeit dar, die mengenorientierten SQL-DML-Anweisungen Datensatz für Datensatz zu verarbeiten. PL/SQL kann sowohl beim Server als auch beim Client ausgeführt werden. Findet die Ausführung auf dem Server statt, dann handelt es sich um in der Datenbank gespeicherte Prozeduren und Funktionen, die durch externe Aufrufe (RPC Remote Procedure\nCall) angestoßen werden oder über Datenbanktrigger. PL/SQL-Aufrufe können alternativ auch beim Client verarbeitet werden. In diesem Fall wird der PL/SQL-Programmcode auf der Client-Seite bearbeitet und das Ergebnis dem Oracle-Datenbank-Server übergeben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BASIC",
        "solution": "false"
      },
      {
        "text": "JAVA",
        "solution": "false"
      },
      {
        "text": "C++",
        "solution": "false"
      },
      {
        "text": "ADA",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1466,
    "category": 6,
    "difficulty": 1,
    "text": "Mit welcher Funktion ersetzt man unter ORACLE-SQL einen Nullwert in der Ausgabe durch einen anderen, vordefinierten Wert?",
    "explanation": "Z.B: \nNVL(spalte1, 7)  \nliefert den Wert von spalte1 zurück, wenn dieser ungleich NULL ist, also wenn spalte1 gefüllt ist. Ist spalte1 leer/NULL, dann liefert NVL den Wert 7 zurück. Das funktioniert mit Spalten/Ausdrücken beliebigen Datentyps. \nDie Funktion IFNULL gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IFNULL(...)",
        "solution": "false"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      },
      {
        "text": "NVL(...)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1468,
    "category": 13,
    "difficulty": 1,
    "text": "Welcher Trigger-Typ ist unter PL/SQL als DEFAULT eingestellt?",
    "explanation": "Ein Befehlstrigger  (STATEMENT TRIGGER, befehlsorientiert, default) wird genau einmal vor oder nach der Ausführung des feuernden Ereignisses ausgeführt, auch dann, wenn kein Datensatz von der feuernden Anweisung manipuliert wird.  \nEin Zeilentrigger (ROW TRIGGER, zeilenorientiert) wird dagegen für jeden von der feuernden Datenmanipulation betroffenen Datensatz je einmal ausgeführt. Wird kein Datensatz\nvon der Anweisung geändert, dann wird auch kein Zeilentrigger ausgeführt. Nur bei den Zeilentriggern sind die Transitionsvariablen zugreifbar, die Transitionstabellen hingegen sind es bei beiden Triggertypen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "zeilenorientierte Trigger",
        "solution": "false"
      },
      {
        "text": "befehlsorientierte Trigger",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1469,
    "category": 13,
    "difficulty": 2,
    "text": "Bei einem Trigger unter PL/SQL muss eine WHEN-Bedingung immer in Klammern stehen.",
    "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugehörigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgeführt (bei FALSE und NULL nicht). Sie muss immer in Klammern  stehen.  \n\nZu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung geprüft, ob der Aktionsteil ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1471,
    "category": 13,
    "difficulty": 1,
    "text": "Das Mutating Table-Problem tritt auf:",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "in zeilenorientierten ORACLE-Triggern",
        "solution": "true"
      },
      {
        "text": "in befehlsorientierten orientierten ORACLE-Triggern",
        "solution": "false"
      },
      {
        "text": "in keinem Triggertyp, der unter ORACLE PL/SQL definiert Trigger wurde",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1472,
    "category": 13,
    "difficulty": 1,
    "text": "In PL/SQL kann man Trigger definieren",
    "explanation": "Der SQL-Standard und ORACLE-SQL sehen DML-Trigger vor, die nach INSERT, UPDATE oder DELETE gefeuert werden, SELECT-Anweisungen leider nicht. ORACLE kennt zusätzlich noch DDL-Trigger, die sich jedoch nicht auf CREATE TABLE (einer einzelnen Tabelle) sondern auf CREATE ON SCHEMA beziehen, sowie INSTEAD-OF-Trigger auf views.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "nach INSERT-Anweisungen",
        "solution": "true"
      },
      {
        "text": "nach SELECT-Anweisungen",
        "solution": "false"
      },
      {
        "text": "nach CREATE-TABLE-Anweisungen",
        "solution": "false"
      },
      {
        "text": "nach UPDATE-Anweisungen",
        "solution": "true"
      },
      {
        "text": "nach DELETE-Anweisungen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1473,
    "category": 12,
    "difficulty": 1,
    "text": "Wie kann man unter PL/SQL dynamisches SQL erzeugen?",
    "explanation": "In PL/SQL kann nur SQL-Manipulationsanweisungen, aber keine DDL-Anweisungen wie CREATE, ALTER, DROP etc.,keine DCL wie GRANT, REVOKE etc. und keine SESSION CONTROL-Anweisungen wie ALTER SESSION\nverarbeiten. Einen Ausweg aus dieser Situation bietet dynamisches SQL unter PL/SQL mit NDS, dem Native Dynamic SQL. Die auszuführende SQL-Anweisung wird ohne abschließendes Semikolon als Zeichenkette oder in einer Textvariablen dem Befehl EXECUTE IMMEDIATE übergeben, der diesen Text ungeprüft zur Ausführung an das Datenbankmanagementsystem sendet. Der Befehl EXECUTE IMMEDIATE selbst wird aber mit einem Semikolon abgeschlossen.Eine andere ältere und etwas aufwändigere  Möglichkeit ist die Verwendung des Pakets DBMS_SQL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mit dem Package DBMS_SQL",
        "solution": "false"
      },
      {
        "text": "Mit EXECUTE IMMEDIATE",
        "solution": "true"
      },
      {
        "text": "Solch eine Möglichkeit gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1475,
    "category": 12,
    "difficulty": 3,
    "text": "In welchen Data-Dictionary-Views sind unter ORACLE Informationen über PL/SQL-Prozeduren gespeichert?",
    "explanation": "USER_OBJECTS enthält Informationen über alle in der DB gespeicherten Objekte, also auch über Prozeduren. USER_FUNCTIONS existiert nicht und USER_SOURCE enthält den SOURCE-Code der Funktion. USER_PROCEDURES listet alle in der DB gespeicherten Prozeduren auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "USER_SOURCE",
        "solution": "true"
      },
      {
        "text": "USER_OBJECTS",
        "solution": "true"
      },
      {
        "text": "USER_SOURCE_TABLES",
        "solution": "true"
      },
      {
        "text": "USER_PROCEDURES",
        "solution": "true"
      },
      {
        "text": "USER_FUNCTIONS",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1476,
    "category": 12,
    "difficulty": 3,
    "text": "PL/SQL-CURSOR können",
    "explanation": "Dynamisches SQL wird über NDS mit EXECUTE IMMEDIATE ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Parameter aufnehmen",
        "solution": "true"
      },
      {
        "text": "als CURSOR-Variable deklariert werden",
        "solution": "true"
      },
      {
        "text": "dynamisches SQL enthalten",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1477,
    "category": 12,
    "difficulty": 2,
    "text": "Womit kann man in PL/SQL einen Record definieren, der den Datentypen einer kompletten Tabelle entspricht?",
    "explanation": "Mit Tabellenname%ROWTYPE wird die Attributstruktur einer Tabelle komplett an einen PL/SQL-Rekord übertragen und dynamisch angepasst. wenn sich dien Tabellendefinition ändert. Mit Tabellenname.Spaltenname%TYPE kann man eine Variable entsprechend der Spalte einer Tabelle definieren.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "%ROWTYPE"
      }
    ]
  },
  {
    "id": 1478,
    "category": 13,
    "difficulty": 3,
    "text": "Auf die Transitionsvariablen :OLD... und :NEW... kann man unter PL/SQL zugreifen in",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "befehlsorientierten Datenbanktriggern",
        "solution": "false"
      },
      {
        "text": "zeilenorientierten Datenbanktriggern",
        "solution": "true"
      },
      {
        "text": "einer WHEN-Klausel",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1479,
    "category": 12,
    "difficulty": 2,
    "text": "Welche Typen von CURSORN gibt es in PL/SQL?",
    "explanation": "Implizite Cursor werden bei jedem DML oder DQL -Befehl im Hintergrund benutzt und könnten z.B. mit SQL%ROWCOUNT abgefragt werden. CURSOR-Variable werden mit \"TYPE name_cur_type IS REF CURSOR; definiert. Explizite Cursor werden im  DECLARE-Abschnitts eines PL/SQL-Blocks  festgelegt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Implizite Cursor",
        "solution": "true"
      },
      {
        "text": "Ausnahmecursor",
        "solution": "false"
      },
      {
        "text": "Explizite Cursor",
        "solution": "true"
      },
      {
        "text": "Instanzcursor",
        "solution": "false"
      },
      {
        "text": "CURSOR Variable",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1480,
    "category": 12,
    "difficulty": 3,
    "text": "Mit welchen Schlüsselworten leitet man unter PL/SQL dynamisches SQL (NDS, Native Dynamic SQL) ein?",
    "explanation": "In PL/SQL kann nur SQL-Manipulationsanweisungen, aber keine DDL-Anweisungen wie CREATE, ALTER, DROP etc.,keine DCL wie GRANT, REVOKE etc. und keine SESSION CONTROL-Anweisungen wie ALTER SESSION\nverarbeiten. Einen Ausweg aus dieser Situation bietet dynamisches SQL unter PL/SQL mit NDS, dem Native Dynamic SQL. Die auszuführende SQL-Anweisung wird ohne abschließendes Semikolon als Zeichenkette oder in einer Textvariablen dem Befehl EXECUTE IMMEDIATE übergeben, der diesen Text ungeprüft zur Ausführung an das Datenbankmanagementsystem sendet. Der Befehl EXECUTE IMMEDIATE selbst wird aber mit einem Semikolon abgeschlossen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "EXECUTE IMMEDIATE"
      }
    ]
  },
  {
    "id": 1620,
    "category": 7,
    "difficulty": 3,
    "text": "Ein B-Baum hat folgende Eigenschaften:",
    "explanation": "Der B-Baum und der B+-Baum sind vollständig balancierte Bäume, bei denen der Weg von der Wurzel bis zu Blatt immer gleich lang sind und der Höhe H des Baums entsprechen. Die Daten werden, anders als beim B+-Baum, gemeinsam mit dem Index gespeichert. Alle inneren Knoten mit n Einträgen haben n+1 Nachfolger. Und jeder Knoten, außer der Wurzel, hat zwischen k und 2k Einträge, wobei k der Typ des Baums ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der B-Baum speichert die Daten ausschließlich in den Blättern.",
        "solution": "false"
      },
      {
        "text": "Innere Knoten enthalten nur Schlüsselinformationen und Verweise auf die nachfolgenden Knoten.",
        "solution": "false"
      },
      {
        "text": "Der Baum ist vollständig balanciert, d.h. jeder Weg von der Wurzel zum Blatt hat die gleiche Länge, die Höhe h.",
        "solution": "true"
      },
      {
        "text": "Der Weg von der Wurzel zum Blatt hat die Länge h, h+1 oder h+2, wobei h die Höhe des Baumes ist.",
        "solution": "false"
      },
      {
        "text": "Alle inneren Knoten haben zwei Nachfolger.",
        "solution": "false"
      },
      {
        "text": "Alle inneren Knoten mit n Einträgen haben n+1 Nachfolger.",
        "solution": "true"
      },
      {
        "text": "Jeder Knoten eines B- Baumes vom Typ k hat zwischen k und 2k Einträge.",
        "solution": "false"
      },
      {
        "text": "Jeder Knoten außer der Wurzel eines B- Baumes vom Typ k hat zwischen k und 2k Einträge.",
        "solution": "true"
      },
      {
        "text": "Die Wurzel hat mindestens einen und höchstens 2k Einträge.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1621,
    "category": 15,
    "difficulty": 3,
    "text": "Bei welcher Speicherstruktur sind die Verwaltungsdaten von der Größe her zu vernachlässigen?",
    "explanation": "Die Hash-Speicherstruktur und die Heap-Speicherstruktur beinhalten keinen gesonderten Index und daher sehr wenig Speicherplatz.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HASH",
        "solution": "true"
      },
      {
        "text": "ISAM",
        "solution": "false"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      },
      {
        "text": "HEAP",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1613,
    "category": 15,
    "difficulty": 3,
    "text": "Bei welcher Speicherstruktur kann beim Anlegen und Löschen von Daten ein relativ hoher Verwaltungsaufwand entstehen?",
    "explanation": "Beim Anlegen und Löschen von Daten in B-Bäumen und B+-Bäumen kann es vorkommen, dass eine Knoten überbelegt oder unterbelegt ist. Ist der Knoten überbelegt, wird er gesplittet und das mittlere Element wandert nach oben. Dieser Vorgang kann sich  im ungünstigsten Fall bis zur Wurzel fortsetzen. Ist der Knoten unterbelegt, kann er mit den Nachbarknoten zusammengelegt oder ausgeglichen werden, um die B-Baum-Struktur zu erhalten. Beide Verfahren sind verhältnismäßig aufwendig, vor allem das Löschen.\n\nWenn man die Überlaufseiten bei der ISAM-Struktur berücksichtigt, ist auch diese Antwort korrekt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "ISAM",
        "solution": "true"
      },
      {
        "text": "B- Baum",
        "solution": "true"
      },
      {
        "text": "HASH",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1575,
    "category": 15,
    "difficulty": 1,
    "text": "Ein B-Baum wächst",
    "explanation": "Ein B-Baum wächst über die Wurzel nach oben, da beim Einfügen in einen vollen Knoten dieser gesplittet wird und das mittlere Element nach oben weitergegeben wird. Ist dieser Knoten auch voll, kann das bis zur Wurzel weitergereicht werden, so dass ein neues Wurzelelement entsteht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "über die Blätter nach unten",
        "solution": "false"
      },
      {
        "text": "über die Wurzel nach oben",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2109,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Spalten hat die Vereinigungsmenge der Tabelle Test mit sich selber?",
    "explanation": "Es wird nach den Spalten,  nicht nach die Zeilen der Tabelle gefragt :-).",
    "type": "text",
    "answers": [
      {
        "text": "",
        "solution": "3"
      }
    ]
  },
  {
    "id": 2111,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Spalten hat die Differenz der Tabelle Test mit sich selber?",
    "explanation": "Die Differenz einer Tabelle mit sich selber ist die leere Menge.",
    "type": "text",
    "answers": [
      {
        "text": "Bitte schreiben Sie die Zahl als numerischen Wert auf!",
        "solution": "3"
      }
    ]
  },
  {
    "id": 1487,
    "category": 4,
    "difficulty": 1,
    "text": "Wie viele Relationen gehen in eine Selektion ein?",
    "explanation": "Eine n-stellige Relation wird mittels der Selektion R → SelektionB(R) auf eine n-stellige Relation abgebildet: Rn → Rn. \nEs ist also neben der Projektion der zweite unäre Operator.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1",
        "solution": "true"
      },
      {
        "text": "2",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "false"
      },
      {
        "text": "0",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1488,
    "category": 4,
    "difficulty": 1,
    "text": "Welche Aussagen über die Join-Operation sind richtig?",
    "explanation": "In eine Join-Operation gehen nach Definition immer nur genau zwei Operatoren ein.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es ist eine unäre Operation.",
        "solution": "false"
      },
      {
        "text": "Es ist eine binäre Operation.",
        "solution": "true"
      },
      {
        "text": "Es ist eine ternäre Operation.",
        "solution": "false"
      },
      {
        "text": "Es können beliebig viele Relationen in einer Join-Operation miteinander verknüpft werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1489,
    "category": 13,
    "difficulty": 3,
    "text": "Was kann in einer WHEN-Bedingung eines ORACLE-Datenbanktriggers verwendet werden?",
    "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugehörigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgeführt (bei FALSE und NULL nicht). Sie muss immer in Klammern stehen.  \n\nZu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung geprüft, ob der Aktionsteil ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine SELECT-Anweisung",
        "solution": "false"
      },
      {
        "text": "Vergleichsoperatoren",
        "solution": "true"
      },
      {
        "text": "Systemvariablen",
        "solution": "true"
      },
      {
        "text": "Transitionsvariablen",
        "solution": "true"
      },
      {
        "text": "ORACLE BUILD-IN-Funktionen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1490,
    "category": 7,
    "difficulty": 2,
    "text": "In einer WHEN-Bedingung eines zeilenorientierten Triggers haben die Transitionsvariable einen Doppelpunkt.",
    "explanation": "Der Doppelpunkt steht zur Stärkung des Gedächtnisses bei den Transitionsvariablen nur im PL/SQL-Ausführungsteil eines Triggers, nicht in der WHEN-Bedingung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1491,
    "category": 12,
    "difficulty": 1,
    "text": "Wie viele Datensätze darf unter PL/SQL ein expliziter CURSOR mit \"SELECT ...INTO ..\" liefern, ohne dass ein Fehler ausgelöst wird?",
    "explanation": "SELECT INTO übergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datensätze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datensätze verarbeiten kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keinen Datensatz",
        "solution": "false"
      },
      {
        "text": "einen Datensatz",
        "solution": "true"
      },
      {
        "text": "viele Datensätze",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1492,
    "category": 12,
    "difficulty": 2,
    "text": "Eine PL/SQL-Funktion a liefert einen booleschen Wert b zurück. Wie können Sie diesen Wert b in SQL*PLUS bzw de, SQL-Developer ausgeben?",
    "explanation": "DBMS_OUPUT.PUTLINE(a); kann nicht in dieser Form verwendet werden, da SQL keinen BOOLESCHEN Datentyp kennt. Daher muss der Umweg über eine IF-Abfrage benutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Direkt über DBMS_OUPUT.PUTLINE(a);",
        "solution": "false"
      },
      {
        "text": "Indirekt über eine IF-Abfrage und Umwandlung in eine  Variable vom Typ VARCHAR",
        "solution": "true"
      },
      {
        "text": "keine von beiden Möglichkeiten",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1496,
    "category": 13,
    "difficulty": 1,
    "text": "Trigger mit einer WHEN-Bedingung können sein:",
    "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugehörigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgeführt (bei FALSE und NULL nicht). Sie muss immer in Klammern  stehen.  \n\nZu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung geprüft, ob der Aktionsteil ausgeführt wird. \n\nDa Oracle keine Transitionstabellen kennt und Transitionsvariablen zu zeilenorienterten Triggern mit einer WHEN -Bedingung gehören, sind ORACLE-Trigger mit einer WHEN-Bedingung immer zeilenorientiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "zeilenorientiert",
        "solution": "true"
      },
      {
        "text": "befehlsorientiert",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1497,
    "category": 13,
    "difficulty": 2,
    "text": "Wofür steht ECMA bei Datenbanktrigger?",
    "explanation": "Für jede aktive Regel muss das Ereignis (E) spezifiziert werden, zu dem sie von der aktiven Regelkomponente gefeuert wird. Ereignisse köönen DML-Anweisungen z.B oder  Zeitereignisse sein.  \n\n(C) steht für die Formulierung einer optionalen Bedingung (condition), die vor der Aktivierung  oder Ausführung der aktiven Regel geprüft wird.  Ist eine Bedingung definiert, so wird der Aktionsteil der gefeuerten Regel nur ausgeführt, wenn die Bedingung erfüllt ist.  \n\n(M) steht für den optionalen Mode oder Ausführungszeitpunkt.  \n\n(A) steht für den Aktionsteil, der in jedem Trigger enthalten sein muss.",
    "type": "text",
    "answers": [
      {
        "text": "E steht für",
        "solution": "Event"
      },
      {
        "text": "C steht für",
        "solution": "Condition"
      },
      {
        "text": "M steht für",
        "solution": "Mode"
      },
      {
        "text": "A steht für",
        "solution": "Action"
      }
    ]
  },
  {
    "id": 1498,
    "category": 13,
    "difficulty": 2,
    "text": "Welche Ausführungszeitpunkte sind bei Datenbanktriggern unter SQL:1999 zugelassen? \nBitte in alphabetischer Reihenfolge eintragen!",
    "explanation": "Der Ausführungszeitpunkt (AFTER oder BEFORE) legt fest, ob ein Trigger vor oder nach dem feuernden (aktivierenden) Ereignis ausgeführt werden soll. Je nach Aufgabenstellung kann der BEFORE- oder der AFTER-Zeitpunkt sinnvoll oder gar notwendig sein. Sind Folgeverarbeitungen durchzuführen, so bieten sich AFTER TRIGGER an, da bei deren Ausführung die Integritätsbedingungen bereits\ngeprüft wurden. Sollen die Werte des neuen Datensatzes geändert oder ergänzt werden, so bietet es sich hingegen an, in den BEFORE TRIGGER die NEW-Variablen mit entsprechenden Werten zu belegen.",
    "type": "text",
    "answers": [
      {
        "text": "Das sind",
        "solution": "AFTER"
      },
      {
        "text": "und",
        "solution": "BEFORE"
      }
    ]
  },
  {
    "id": 1506,
    "category": 9,
    "difficulty": 3,
    "text": "BLOB, CLOB und BFILE Datentypen sind erlaubt",
    "explanation": "Die Datentypen können als Datentypen für große Binärobjekte nur als Datentyp einer Spalte und in einer PL-SQL-Variablen benutzt werden. Alle anderen Operationen machen keinen Sinn.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "als Datentyp einer Spalte",
        "solution": "true"
      },
      {
        "text": "als Teil eines Schlüssels",
        "solution": "false"
      },
      {
        "text": "als Datentyp einer PL/SQL-Variablen",
        "solution": "true"
      },
      {
        "text": "in booleschen oder arithmetischen Ausdrücken",
        "solution": "false"
      },
      {
        "text": "in der GROUP-BY-Klausel",
        "solution": "false"
      },
      {
        "text": "in der ORDER-BY-Klausel",
        "solution": "false"
      },
      {
        "text": "in einer SELECT DISTINCT - Anweisung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1331,
    "category": 4,
    "difficulty": 1,
    "text": "Wodurch wird in der relationalen Algebra der \"Für-Alle-Quantor\" (Allaussage) umgesetzt?",
    "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Division",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Durchschnitt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1333,
    "category": 11,
    "difficulty": 3,
    "text": "Womit beginnen SQLJ-Klauseln ?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "!",
        "solution": "false"
      },
      {
        "text": "#",
        "solution": "true"
      },
      {
        "text": "<!--",
        "solution": "false"
      },
      {
        "text": "&",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1361,
    "category": 12,
    "difficulty": 3,
    "text": "Mit welchem Befehl erteilen Sie dem Benutzer \"Hugo\" das Recht, die PL/SQL-Prozedur \"Test\" auszuführen, die ihm nicht selber gehört?",
    "explanation": "Mit dem Befehl \nGRANT EXECUTE ON Prozedurname TO Benutzername; \nkönnen Sie unter PL/SQL Ausführungsrechte an einzelne\nBenutzer vergeben, mit dem Befehl \nGRANT EXECUTE ON Prozedurname TO PUBLIC;  \nräumen Sie diese Ausführungsrechte allen Benutzern ein.",
    "type": "text",
    "answers": [
      {
        "text": "Der SQL-Befehl lautet ( ohne Semikolon am Schluss)",
        "solution": "GRANT EXECUTE ON Test TO Hugo"
      }
    ]
  },
  {
    "id": 1362,
    "category": 12,
    "difficulty": 1,
    "text": "Eine öffentliche Prozedur wird von einer privaten unterschieden:",
    "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur, Funktion, Variable, Konstante, Cursor etc., ist es entweder öffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind öffentlich und können damit von außerhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und können damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "durch den Zusatz public bzw. private",
        "solution": "false"
      },
      {
        "text": "durch die Platzierung im Package",
        "solution": "true"
      },
      {
        "text": "diese Unterscheidung gibt in PL/SQL nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1363,
    "category": 12,
    "difficulty": 1,
    "text": "In PL/SQL -Packages werden private Methoden definiert:",
    "explanation": "Je nach Platzierung eines Paketobjekts, wie Prozedur, Funktion, Variable, Konstante, Cursor etc., ist es entweder öffentlich oder privat.  \nAlle Objekte, die in der Paketspezifikation deklariert sind, sind öffentlich und können damit von außerhalb des Pakets mit Paketname.Objektname aufgerufen werden.  \nAlle Objekte, die nur im Paketrumpf definiert sind, sind privat und können damit nur innerhalb des Pakets von den Paketroutinen aufgerufen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "im Package-Header",
        "solution": "false"
      },
      {
        "text": "im Package-Body",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1365,
    "category": 12,
    "difficulty": 2,
    "text": "Overloading von Routinen bedeutet, dass Prozeduren und Funktionen gleich heißen können und dieses Konzept gibt es nur für Package-Prozeduren und -Funktionen.",
    "explanation": "Beim Overloading in PL/SQL können Paketroutinen gleich heißen:   Gleichnamige Prozeduren oder Funktionen werden durch eine unterschiedliche Anzahl, eine unterschiedliche Reihenfolge von Parametern oder durch unterschiedliche Datentypen der Parameter unterschieden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1366,
    "category": 12,
    "difficulty": 2,
    "text": "Mit welchem PL/SQL-Paket kann man unmittelbar HTML-Seiten aus der Datenbank generieren?",
    "explanation": "Eine vollständige Referenz dieses Pakets finden Sie unter \n<a href= \"http://download.oracle.com/docs/cd/B14099_19/web.1012/b15896/toc.htm\"> http://download.oracle.com/docs/cd/B14099_19/web.1012/b15896/toc.htm",
    "type": "text",
    "answers": [
      {
        "text": "Das Paket heißt:",
        "solution": "HTP"
      }
    ]
  },
  {
    "id": 1372,
    "category": 6,
    "difficulty": 2,
    "text": "Wie heißt die ORACLE-Funktion, die einen beliebigen, angegebenen Wert liefert, wenn ein Ausdruck (z.B. Spaltenwert) NULL ist?",
    "explanation": "Z.B: \nNVL(spalte1, 7)  \nliefert den Wert von spalte1 zurück, wenn dieser ungleich NULL ist, also wenn spalte1 gefüllt ist. Ist spalte1 leer/NULL, dann liefert NVL den Wert 7 zurück. Das funktioniert mit Spalten/Ausdrücken beliebigen Datentyps.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist: (Nur der Funktionsname ohne Parameter)",
        "solution": "NVL"
      }
    ]
  },
  {
    "id": 1526,
    "category": 10,
    "difficulty": 2,
    "text": "Wie heißt das JDBC Interface, das implementiert werden muss, um eine Datenbankverbindung aufzubauen?",
    "explanation": "Ein JAVA-Programm kann eine oder mehrere Verbindungen zu einer oder mehreren Datenbanken unterhalten. Jede Verbindung wird durch ein Objekt realisiert, das das Interface Connection implementiert.\nDieses Interface definiert unter anderem folgende Methoden:\nMit der Methode createStatement() kann ein Objekt, welches das Interface Statement implementiert, erzeugt werden.  Analog dazu wird mit der Methode prepareStatement(String sql) eine Anweisung vorbereitet.  Durch den Aufruf von setAutoCommit(boolean) wird der Autocommit-Modus der Verbindung an- oder ausgeschaltet.  \n- Mit getAutoCommit() wird geprüft, welcher Modus vorliegt.\n- Mit close() wird die Verbindung explizit geschlossen,\n- mit isClosed() kann dies nachgeprüft werden.",
    "type": "text",
    "answers": [
      {
        "text": "Das Interface heißt:",
        "solution": "Connection"
      }
    ]
  },
  {
    "id": 1527,
    "category": 10,
    "difficulty": 3,
    "text": "Mit welchem Isolationsgrad (Konstante der Methode setTransactionIsolation() des Interfaces Connection) werden unter JDBC Transaktionen nacheinander ausgeführt?",
    "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgeführt.",
    "type": "text",
    "answers": [
      {
        "text": "Der Isolationsgrad heißt",
        "solution": "TRANSACTION_SERIALIZABLE"
      }
    ]
  },
  {
    "id": 1529,
    "category": 10,
    "difficulty": 2,
    "text": "Welche Klassen bzw.Interfaces besitzen unter JDBC eine Methode close()?",
    "explanation": "Wer näheres Wissen will, sollte bei SUN selber nachschlagen: \n\n<a href= \"http://java.sun.com/j2se/1.4.2/docs/api/java/sql/package-summary.html\"> JDBC-Dokumentation bei Sun .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Statement",
        "solution": "true"
      },
      {
        "text": "ResultSet",
        "solution": "true"
      },
      {
        "text": "DriverManager",
        "solution": "false"
      },
      {
        "text": "Connection",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1555,
    "category": 11,
    "difficulty": 3,
    "text": "Zu welchem Part von SQLJ gehört die Einbindung von statischen SQL-Statements in ein JAVA-Programm?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Part 0",
        "solution": "true"
      },
      {
        "text": "Part 1",
        "solution": "false"
      },
      {
        "text": "Part 3",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1548,
    "category": 10,
    "difficulty": 3,
    "text": "Welches Interface enthält die Metadaten eines ResultSets unter JDBC?",
    "explanation": "Wer näheres Wissen will, sollte bei SUN selber nachschlagen: \n\n<a href= \"http://java.sun.com/j2se/1.4.2/docs/api/java/sql/package-summary.html\"> JDBC-Dokumentation bei Sun .",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "ResultSetMetaData"
      }
    ]
  },
  {
    "id": 1549,
    "category": 10,
    "difficulty": 3,
    "text": "Welche JAVA-SWING-Klassen können zur Ausgabe von Tabellen nach dem Model-View-Controler-Prinzip genutzt werden?",
    "explanation": "Wer näheres Wissen will, sollte bei SUN selber nachschlagen:\n\n    <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/javax/swing/table/AbstractTableModel.html\">JDBC-Dokumentation bei Sun .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "AbstractTableModel",
        "solution": "true"
      },
      {
        "text": "JTable",
        "solution": "true"
      },
      {
        "text": "SQLTable",
        "solution": "false"
      },
      {
        "text": "TableModel",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1550,
    "category": 10,
    "difficulty": 1,
    "text": "Die Funktionalität zum Umgang mit LOBs ist im Standard-JDBC enthalten.",
    "explanation": "Seit JDBC 2.0 gibt es ein Interface CLOB, das dazu dienst den Datentyp CLOB aus SQL abzubilden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1551,
    "category": 10,
    "difficulty": 1,
    "text": "Welche Aussage über SELECT-Abfragen unter ORACLE-JDBC ist wahr?",
    "explanation": "Wie in anderen SQL-Schnittstellen auch, wird unter JDBC/SQL nur der LOB-Locator selektiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Durch SELECT-Statements werden nicht die eigentlichen LOB-Daten, sondern nur die LOB-Locator selektiert.",
        "solution": "true"
      },
      {
        "text": "Durch SELECT-Statements werden die LOB-Daten selber selektiert.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1552,
    "category": 10,
    "difficulty": 1,
    "text": "Welche Aussage über BFiles unter ORACLE-JDBC ist wahr?",
    "explanation": "BFILEs können nur gelesen werden. Es können weder Daten hinzugefügt noch ein neues BFILE erzeugt werden.\nDer entsprechende JDBC-Datentyp ist BFILE Mit BFILE. getBFILE() kann ein BFILE-Locator aus einem OracleResultSet extrahiert werden.\nUm ein BFILE zu lesen, kann mit der Methode getBinaryStream() ein InputStream auf das BFILE geöffnet werden.\nGelesen werden die Daten mit den verschiedenen read()-Methoden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BFILEs können nur gelesen werden. Es können weder Daten hinzugefügt noch ein neues BFILE erzeugt werden.",
        "solution": "true"
      },
      {
        "text": "BFiles könnnen auch mit Methoden der Stream-KLasssen, wie getBinaryOutputStream(); verändert werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1553,
    "category": 11,
    "difficulty": 3,
    "text": "Mit Java Stored Procedures kann man",
    "explanation": "null",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PL/SQL-Prozeduren aufrufen, die in der Datenbank gespeichert sind",
        "solution": "true"
      },
      {
        "text": "Zugriffe auf das lokale Dateisystem realisieren",
        "solution": "false"
      },
      {
        "text": "Prozeduren und Funktionen mit Klassenmethoden schreiben",
        "solution": "true"
      },
      {
        "text": "JAVA-Objekte in der Datenbank anlegen",
        "solution": "false"
      },
      {
        "text": "SQL DML-Statements (INSERT, UPDATE, DELETE und SELECT) absetzen",
        "solution": "true"
      },
      {
        "text": "Grafische Benutzeroberflächen realisieren",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1554,
    "category": 11,
    "difficulty": 2,
    "text": "Methoden und Variable in SQLJ-Prozeduren, die in der Datenbank gespeichert werden, müssen public static (Klassenmethoden) sein.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1556,
    "category": 11,
    "difficulty": 2,
    "text": "Zu welchem Part von SQLJ gehört die Nutzung von statischen JAVA-Methoden als Stored Procedures?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Part 0",
        "solution": "false"
      },
      {
        "text": "Part 1",
        "solution": "true"
      },
      {
        "text": "Part 2",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1558,
    "category": 13,
    "difficulty": 2,
    "text": "Welche Aussagen über Oracle/SQL-Trigger und sind wahr?",
    "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten. Daher wird das Ereignis selber zurückgerollt, welches den Fehler ausgelöst hat.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Bricht die Ausführung eines Oracle-Triggers fehlerhaft mit einem RAISE_APPLICATION_ERROR-Befehl ab, so terminiert nur der Trigger fehlerhaft und es passiert nichts weiter.",
        "solution": "false"
      },
      {
        "text": "Bricht die Ausführung eines Oracle-Triggers fehlerhaft mit einem RAISE_APPLICATION_ERROR-Befehl ab, so wird die gesamte Transaktion zurückgerollt.",
        "solution": "false"
      },
      {
        "text": "Bricht die Ausführung eines Oracle-Triggers fehlerhaft mit einem RAISE_APPLICATION_ERROR-Befehl ab, so wird das Ereignis zurückgerollt, welches den Fehler ausgelöst hat.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1559,
    "category": 4,
    "difficulty": 2,
    "text": "Welche Operation aus der relationalen Algebra hat die folgende Eigenschaft: Sie extrahiert bestimmte Attribute aus einer Relation und vertauscht eventuell die Reihenfolge der Attribute.",
    "explanation": "Die Projektion extrahiert bestimmte Attribute aus einer Relation und vertauscht eventuell die Reihenfolge:\n\n    Sei R(A1,...,An) eine Relation und L = (B1,...,Bj) mit 1 ≤ j ≤ n eine Attributkombination, d.h. eine geordnete Teilmenge von (A1,...,An).\n\n    B1 entspricht hier dem Attribut Ai1 und Bj entspricht dem Attribut Aij.\n\n    Die Projektion ist definiert durch: Projektion L (R) Projektion B1...Bj (R) := {(ai1,...,aij)|(a1,...,an)∈R}.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist die Selektion.",
        "solution": "false"
      },
      {
        "text": "Das ist die Projektion.",
        "solution": "true"
      },
      {
        "text": "Das ist die Division.",
        "solution": "false"
      },
      {
        "text": "Das sind die Mengenoperatoren.",
        "solution": "false"
      },
      {
        "text": "Das sind das kartesische Produkt und die Join-Operatoren.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1560,
    "category": 7,
    "difficulty": 1,
    "text": "Welche der folgenden SELECT-Abfragen ist korreliert?",
    "explanation": "Korreliert bedeutet, dass die Spalten der äußeren Anweisung mit der innneren SELECT-Anweisung durch eine WHERE-Klausel verknüpft werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT AuftragsNr\nFROM  Auftraege\nWHERE EXISTS\n    (SELECT * FROM Kunden\n    WHERE  Kunden.Kun_Nr = Auftraege.Kun_Nr);",
        "solution": "true"
      },
      {
        "text": "SELECT AuftragsNr\nFROM  Auftraege\nWHERE EXISTS\n    (SELECT * FROM Kunden);",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1500,
    "category": 6,
    "difficulty": 2,
    "text": "Welche ORACLE-Build-in-Funktion ersetzt einen Nullwert durch einen selbstdefinierten Wert?",
    "explanation": "Z.B: \nNVL(spalte1, 7)  \nliefert den Wert von spalte1 zurück, wenn dieser ungleich NULL ist, also wenn spalte1 gefüllt ist. Ist spalte1 leer/NULL, dann liefert NVL den Wert 7 zurück. Das funktioniert mit Spalten/Ausdrücken beliebigen Datentyps.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "NVL"
      }
    ]
  },
  {
    "id": 1740,
    "category": 12,
    "difficulty": 2,
    "text": "Betrachten Sie die folgende Package-Definition:\n\nCREATE PACKAGE xyz\nIS\n    PROCEDURE a (p1 NUMBER); --- Nr 1\n    PROCEDURE a (p1 NUMBER, p2 NUMBER); --- Nr 2\n    PROCEDURE a (p1 DATE); --- Nr 3\n    PROCEDURE a (p3 NUMBER); --- Nr 4\nEND;\n\nWelche Prozedur-Definition ist nicht zulässig?",
    "explanation": "Eine Prozedur kann den gleichen Name und unterschiedliche Parametertypen und -anzahlen, aber nicht den gleichen Namen und sowohl gleiche Parameteranzahlen wie auch Parametertypen haben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nr. 3",
        "solution": "false"
      },
      {
        "text": "Nr. 4",
        "solution": "true"
      },
      {
        "text": "Nr 1",
        "solution": "false"
      },
      {
        "text": "Nr. 2",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1036,
    "category": 9,
    "difficulty": 2,
    "text": "Bei welchen ORACLE-Datentypen können bis zu 4 GB gespeichert werden?",
    "explanation": "BLOB: Mit diesem Datentyp können entsprechend dem SQL-Standard binäre Objekte (Oracle bis zu 4 Gbyte) für Grafiken oder Tonaufzeichnungen in der Datenbank gespeichert werden. Außerdem stehen einige Methoden zur Verfügung, mit denen diese Objekte auf dem Server manipuliert werden können.\n\nCLOB und NCLOB:  Oracle CLOB ist eine Modifikation des Typs BLOB, er wird für große Textobjekte mit den entsprechenden Methoden zur Verfügung gestellt. NCLOB entspricht dem CLOB mit nationalem Zeichensatz. \n\nBFILE:ist ein Oracle-Datentyp für Binärobjekte, der nur einen Zeiger (LOB-Locator) auf ein Verzeichnis im Dateisystem enthält, das die Binärdateien beihaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LONG",
        "solution": "false"
      },
      {
        "text": "LONG RAW",
        "solution": "false"
      },
      {
        "text": "BLOB",
        "solution": "true"
      },
      {
        "text": "CLOB",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1034,
    "category": 12,
    "difficulty": 3,
    "text": "Welche Exception wird geworfen, wenn Spalte eine Tabelle und Variable nicht den gleichen Datentyp haben, obwohl sie aufeinander abgebildet sind?",
    "explanation": "ROWTYPE_MISMATCH wird in PL/SQL geworfen, wenn Spalte und Variable nicht den gleichen Datentyp haben.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "ROWTYPE_MISMATCH"
      }
    ]
  },
  {
    "id": 1035,
    "category": 9,
    "difficulty": 3,
    "text": "Bei welchen Datentypen für große Objekte ist nur eine Spalte dieses Types je Tabelle erlaubt?",
    "explanation": "LONG und RAW sind Oracle-Datentypen seit Version 8, die große Binärdateien aufnehmen können. Sie bringen allerdings einige Probleme mit. So kann nur ein LONG-RAW-Spalte  und eine RAW-Spalte je Tabelle angelegt werden und die Daten können weder mit CREATE Table AS SELECT ... noch mit INSERT AS SELECT ... kopiert werden. Daher sollten diese Datentypen nicht mehr verwendet werden: BLOB und CLOB sind die empfohlenen Typen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LONG RAW",
        "solution": "true"
      },
      {
        "text": "LONG",
        "solution": "true"
      },
      {
        "text": "BLOB",
        "solution": "false"
      },
      {
        "text": "CLOB",
        "solution": "false"
      },
      {
        "text": "BFILE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1048,
    "category": 4,
    "difficulty": 3,
    "text": "Welcher Optimierungsvorgang berücksichtigt die Größe der beteiligten Relationen und das Vorhandensein von Schlüsseln etc.?",
    "explanation": "Bei der physischen Optimierung wird auf unterschiedliche Implementierungen der relationalen Algebra zurückgegriffen. Dabei gehen Wissen über das Datenbankschema, die Größe der einzelnen Relationen und Statistiken über die erfolgten Datenzugriffe etc. ein.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist die ...",
        "solution": "physische Optimierung"
      }
    ]
  },
  {
    "id": 1038,
    "category": 9,
    "difficulty": 3,
    "text": "Welcher Datentyp für große Objekte speichert alphanumerische Daten in der Datenbank im nationalen Zeichensatz ?",
    "explanation": "CLOB und NCLOB:  Oracle CLOB ist eine Modifikation des Typs BLOB, er wird für große Textobjekte mit den entsprechenden Methoden zur Verfügung gestellt. NCLOB entspricht dem CLOB mit nationalem Zeichensatz.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "NCLOB"
      }
    ]
  },
  {
    "id": 1045,
    "category": 9,
    "difficulty": 2,
    "text": "LOB-Werte können direkt in SQL bearbeitet werden.",
    "explanation": "LOB-Werte können nicht in SQL direkt bearbeitet werde. Man braucht dazu Schnittstellen, wie JDBC oder Pakete, wie DBMS_LOB aus Oracle/PL-SQL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1044,
    "category": 9,
    "difficulty": 3,
    "text": "Mit welcher SQL-Anweisung legt man ein Verzeichnis an, in dem BFILES abgelegt werden können?",
    "explanation": "CREATE DIRECTORY erzeugt einen Zeiger auf ein Verzeichnis auf dem Datenbankserver.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "CREATE DIRECTORY"
      }
    ]
  },
  {
    "id": 1046,
    "category": 9,
    "difficulty": 3,
    "text": "Mit welchem PL/SQL-Paket können LOB-Werte bearbeitet werden?",
    "explanation": "DBMS_LOB bietet Funktionen zum Bearveiten von großen Binärdatentypen, die als BLOB, CLOB und NCLOB in der Oracle-Datenbank abgespeichert sind. Dazu gehören APPEND, CLOSE, COPY ERASE, GETLENGTH , FILEOPEN und andere. Eine ausführliche Beschreibung ist in <a href = \"http://www.dba-oracle.com/t_dbms_lob.htm\"> Oracle  Dokumentation  zu finden.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "DBMS_LOB"
      }
    ]
  },
  {
    "id": 1047,
    "category": 9,
    "difficulty": 3,
    "text": "Welchen der folgenden Datentypen bezeichnet man als externen Datentypen für große Objekte?",
    "explanation": "BFILE:ist ein Oracle-Datentyp für Binärobjekte, der nur einen Zeiger (LOB-Locator) auf ein Verzeichnis im Dateisystem enthält, das die Binärdateien beihaltet.\nBFIles können mit der Funktion BFILENAME mit Dateien verbunden und gefüllt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LONG RAW",
        "solution": "false"
      },
      {
        "text": "BFILE",
        "solution": "true"
      },
      {
        "text": "BLOB",
        "solution": "false"
      },
      {
        "text": "CLOB",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1049,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Operatoren der relationalen Algebra sind assoziativ?",
    "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind assoziativ, d. h., Klammern können beliebig gesetzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Natural Join",
        "solution": "true"
      },
      {
        "text": "kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Durchschnitt",
        "solution": "true"
      },
      {
        "text": "Division",
        "solution": "false"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Vereinigung",
        "solution": "true"
      },
      {
        "text": "Join-Operatoren (Theta, Natural, Equi)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1054,
    "category": 4,
    "difficulty": 1,
    "text": "Welcher Join-Operator ist der allgemeinste Operator, von dem sich die anderen Join-Operatoren ableiten lassen?",
    "explanation": "Den Super-Join gibt es nicht. \nDer Theta_Join ist der Join, dessen Selektionsprädikat (Bedingung) keinen Restriktionen unterliegt. \nBeim Equi-Join sind nur Gleichheitsvergleiche (Vergleichsoperator \"=\") im Selektionsprädikat zugelassen. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Equi-Join",
        "solution": "false"
      },
      {
        "text": "Natural-Join",
        "solution": "false"
      },
      {
        "text": "Theta-Join",
        "solution": "true"
      },
      {
        "text": "Super-Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1055,
    "category": 4,
    "difficulty": 3,
    "text": "Mit welchen Operatoren aus der relationalen Algebra lässt sich der Differenz-Operator simulieren?",
    "explanation": "Die Differenz gehört zu den Grund-/Basisoperatoren und kann somit nicht simuliert werden mittels anderer RA-Operatoren. Mit ihrer Hilfe kann jedoch z.B. die Division abgeleitet werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Theta-Join",
        "solution": "false"
      },
      {
        "text": "Natural Join",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "false"
      },
      {
        "text": "Outer Join (Left, Right, Full)",
        "solution": "false"
      },
      {
        "text": "Vereinigung",
        "solution": "false"
      },
      {
        "text": "Durchschnitt",
        "solution": "false"
      },
      {
        "text": "Division",
        "solution": "false"
      },
      {
        "text": "keine der aufgeführten Antworten",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1056,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Aussagen über \"Transaktionen in SQL\" sind richtig?",
    "explanation": "FALSCH sind:  \n\"Im SQL-Standard sind keine \"dirty reads\" möglich.\" Dirty reads sind bei Oracle grundsätzlich ausgeschlossen, so dass es dort, anders als beim SQL-Standard, den Isolationsgrad READ UNCOMMITTED nicht gibt.\n\n\"Führt eine Transaktion eine Anfrage mehrfach aus, so können u.a. \"lost updates\", \"non repeatable reads\" und \"phantome\" auftreten.\" Diese Aussage ist hinsichtlich \"non repeatable reads\" und \"phantome\" richtig, nur für \"lost updates\" falsch. \"lost updates\" sind keine Probleme der Lesekonsistenz wie die anderen beiden, sie sind Probleme der Nebenläufigkeitskontrolle. \n\nRICHTIG sind: \n\"Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und überschreibt somit die Änderungen von T2 ungesehen.\"\n\n\"Ein Ausführungsplan ist serialisierbar, wenn er zu einem seriellen Ausführungsplan äquivalent ist.\"",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Beim \"lost update\"-Problem lesen zwei Transaktionen T1 und T2 die gleichen Daten. Dann verarbeitet und speichert z.B. T2 die gelesenen Daten. T1 verarbeitet und speichert die Daten erst nach T2 ab und überschreibt somit die Änderungen von T2 ungesehen.",
        "solution": "true"
      },
      {
        "text": "Ein Ausführungsplan ist serialisierbar, wenn er zu einem seriellen Ausführungsplan äquivalent ist.",
        "solution": "true"
      },
      {
        "text": "Im SQL-Standard sind keine \"dirty reads\" möglich.",
        "solution": "false"
      },
      {
        "text": "Führt eine Transaktion eine Anfrage mehrfach aus, so können u.a. \"lost updates\", \"non repeatable reads\" und \"phantome\" auftreten.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1057,
    "category": 13,
    "difficulty": 3,
    "text": "Welche Aussagen sind über CONSTRAINTS und Trigger in SQL sind wahr?",
    "explanation": "MANDATORY-CONSTRAINTS gibt es gar nicht. \n\nDie Fehlerkorrektur beschränkt sich bei Oracle auf die ON DELETE/UPDATE-Klausel bei den Fremdschlüsseln, wo man Masterdatensätze löschen bzw. ändern kann. Weitergehende Fehlerkorrektur ist dann nur mittels Triggern möglich. \n\nAlle IMMEDIATE-Constraints lassen sich mittels Trigger simulieren, aber nicht die DEFERRED-Constraints. Was fehlt ist ein Trigger zum COMMIT-Ereignis. \n\nRICHTIG sind: \n\"Transitionale Integritätsbedingungen können in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Referenzvariablen (:OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.\"",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Für im ER-Modell als \"obligatorisch\" (Pflichteingabe) deklarierte Attribute werden im Datenmodell MANDATORY-CONSTRAINTS definiert.",
        "solution": "false"
      },
      {
        "text": "Transitionale Integritätsbedingungen können in SQL nicht als CONSTRAINT definiert werden, wohl aber mittels der Transitionsvariablen (Referenzvariablen, :OLD.spaltenname, :NEW.spaltenname) in ROW-Triggern.",
        "solution": "true"
      },
      {
        "text": "MIT ORACLE-CONSTRAINTS können alle Fehler korrigiert werden, die beim Einfügen von Daten entstehen.",
        "solution": "false"
      },
      {
        "text": "MIT ORACLE-CONSTRAINTS können alle Fehler korrigiert werden, die beim Löschen von Daten entstehen.",
        "solution": "false"
      },
      {
        "text": "Alles, was sich mit CONSTRAINTs prüfen läßt, läßt sich auch mittels Oracle-Triggern programmieren.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1058,
    "category": 14,
    "difficulty": 2,
    "text": "Mit welchem Befehl kann man in SQL eine Transaktion beenden?",
    "explanation": "RICHTIG sind:\nCOMMIT für das persistente Abspeichern der Datenmanipulationen der Transaktion nach erfolgreicher DEFERRED-Integritätsprüfung. \n\nROLLBACK für das Zurückrollen der Datenmanipulationen der Transaktion (Rückgängigmachen). \n\nFALSCH sind: \nEOT und END_OF_TRANSACTION: Es gibt zwar einen Begin of Transaktion-Befehl (START TRANSACTION) und es gibt ein implizites Begin of Transaktion-Ereignis, wenn dieser Befehl nicht abgesetzt wird: das letzte ausgeführte COMMIT, aber ein EOT etc. gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "COMMIT",
        "solution": "true"
      },
      {
        "text": "EOT",
        "solution": "false"
      },
      {
        "text": "END_OF_TRANSACTION",
        "solution": "false"
      },
      {
        "text": "ROLLBACK",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1127,
    "category": 4,
    "difficulty": 3,
    "text": "Woraus können Selektionsprädikate bestehen?",
    "explanation": "Bestandteile eines Selektionsprädikats sind: \n1. Attribute einer Relation und Konstanten als Operanden, \n2. Vergleichsoperatoren = <, ≤, >, ≥ , <> und != (ungleich), \n3. die logischen Operatoren UND, ODER und NICHT und \n4. Berechnungen mit Konstanten und Spaltenwerten (z.B. Gehalt*1,.045)  \n5. eine beliebige Kombination aus den oben genannten Möglichkeiten, die durch Klammerung (..) erzeugt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Konstanten",
        "solution": "true"
      },
      {
        "text": "Join-Operatoren",
        "solution": "false"
      },
      {
        "text": "Attributen",
        "solution": "true"
      },
      {
        "text": "Vergleichsoperatoren",
        "solution": "true"
      },
      {
        "text": "Domänen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1066,
    "category": 9,
    "difficulty": 3,
    "text": "Mit welcher PL/SQL-Prozedur liest man einen BFILE-Datentyp ein?",
    "explanation": "BFILENAME(\"VERZEICHNIS\", \"DATEI\") liest eine Datei aus einem Verzeichnis auf dem Datenbankserver in eine Variable vom Typ BFILE ein.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist (Name der Prozedur ohne Klammern)",
        "solution": "BFILENAME"
      }
    ]
  },
  {
    "id": 1074,
    "category": 1,
    "difficulty": 1,
    "text": "Wie nennt man ein Softwaresystem zur Verwaltung einer Datenbasis?",
    "explanation": "Ein DBS (Datenbanksystem) besteht aus zwei Teilen: dem Datenbankmanagementsystem (DBMS) und der Menge der zu verwaltenden Daten, der eigentlichen Datenbank. \nDas DBMS organisiert intern die strukturierte Speicherung der Daten und kontrolliert alle lesenden und schreibenden Zugriffe auf die Datenbank. \nZur Abfrage und Verwaltung der Daten bietet ein Datenbanksystem eine Datenbanksprache an.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ein (Abkürzung)",
        "solution": "DBMS"
      }
    ]
  },
  {
    "id": 1068,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Datentypen können mit ROLLBACK zurückgerollt werden?",
    "explanation": "Alle Datentypen, die in der Datenbank selber gespeichert werden, d.h. alle außer BFILE, der nur einen Zeiger auf ein Verzeichnis beinhaltet, haben diese Eigenschaft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BLOB",
        "solution": "true"
      },
      {
        "text": "keine dieser Typen",
        "solution": "false"
      },
      {
        "text": "LONG RAW",
        "solution": "true"
      },
      {
        "text": "BFILE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1075,
    "category": 1,
    "difficulty": 1,
    "text": "Welche Typen von Datenbanken gibt es?",
    "explanation": "Eine mögliche Einteilung der Datenbanken basiert auf der Art der Anwendung. Datenbanken werden in kommerzielle, betriebswirtschaftlich/administrativ ausgerichtete Standardsysteme und neuartige Systeme unterschieden. Kommerzielle Datenbanken sind durch gut formatierte Datenbestände und die Verwendung von Standardsystemen gekennzeichnet. Neben diesen Datenverwaltungssystemen gehören auch noch Recherchesysteme zur Suche in großen, unformatierten Datenbeständen zu den kommerziellen Datenbanksystemen.\n\nNeuartige Anwendungen sind durch komplexe Datentypen, Multimediadatentypen und die Anforderungen, die sich aus einer objektorientierten Analyse ergeben (z.B. Vererbung, Kapselung von Methoden), gekennzeichnet. Typische Anwendungsfelder\nsind Geoinformationssysteme, Multimediadatenbanken oder die Unterstützung technischer\nAnwendungen. \n\nEine andere Einteilung ist die Typisierung von Datenbanksystemen über das Datenmodell. Ein Datenmodell ist eine festgelegte Struktur mit eigenen Begriffen, nach der Daten und ihre Beziehungen untereinander gespeichert werden. Man unterscheidet historisch gesehen zwischen hierarchischen Datenmodellen, Netzwerkdatenmodellen, relationalen Datenmodellen und objektorientierten Datenmodellen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Hierarchische Datenbanken",
        "solution": "true"
      },
      {
        "text": "Grafische Datenbanken",
        "solution": "false"
      },
      {
        "text": "Relationale Datenbanken",
        "solution": "true"
      },
      {
        "text": "Objektorientierte Datenbanken",
        "solution": "true"
      },
      {
        "text": "Parse-Datenbanken",
        "solution": "false"
      },
      {
        "text": "Netzwerkdatenbanken",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1078,
    "category": 4,
    "difficulty": 3,
    "text": "Mit welchem Operator der relationalen Algebra läßt sich der Theta-Join simulieren?",
    "explanation": "Alle Join-Operationen sind aus kartesischem Produkt, Selektion und ggf. Projektion ableitbar. \nWobei für den Theta-Join das kartesische Produkt mit einer anschließenden Selektion ausreichend ist. \nEine zusätzliche Projektion wird nur noch beim Natural Join benötigt. \nDer Theta-Join ist der Join mit der allgemeinsten Bedingung, so dass er durch andere Joins (Equi, Natural, Left, Right, Full Outer) nicht simuliert werden kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "mit keinem anderen Operator der relationalen Algebra",
        "solution": "false"
      },
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Selektion",
        "solution": "true"
      },
      {
        "text": "Natural Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1084,
    "category": 6,
    "difficulty": 3,
    "text": "Welche CREATE-Anweisungen gibt es unter ORACLE-SQL und SQL2003?",
    "explanation": "TABLE (Tabelle), INDEX (Index), SEQUENCE (Nummerngenerator), VIEW (Sicht) und Benutzer (USER) sind eigenständige DB-Objekte mit eigenen DDL-Befehlen wie CREATE, ALTER, DROP. \nEin ADMIN kann auch nicht explizit mit CREATE erzeugt werden. Man kann einem beliebigen USER Administrator-Rechte geben, dann hat dieses die Funktionalität eines Admins. \nCONSTRAINTs sind keine eigenständigen DB-Objekte, es gibt keinen eigenen CREATE-Befehl für sie. Sie gehören zu genau einer Tabelle und können bei einem CREATE/ALTER/DROP TABLE angelegt oder gelöscht werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INDEX",
        "solution": "true"
      },
      {
        "text": "CONSTRAINTS",
        "solution": "false"
      },
      {
        "text": "TABLE",
        "solution": "true"
      },
      {
        "text": "VIEW",
        "solution": "true"
      },
      {
        "text": "USER",
        "solution": "true"
      },
      {
        "text": "ADMIN",
        "solution": "false"
      },
      {
        "text": "SEQUENCE",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1085,
    "category": 12,
    "difficulty": 3,
    "text": "Welcher PL/SQL-Blocktyp wird ausschließlich auf dem Datenbankserver eingesetzt?",
    "explanation": "PL/SQL unterscheidet fünf Typen von Blöcken: Ein anonymer Block ist ein unbenannter PL/SQL-Block, der in einer Anwendung (Prozedur, Funktion ) eingebettet ist oder interaktiv eingegeben wird. Eine Stored Procedure ist ein benannter PL/SQL-Block, der Parameter haben kann und als Prozedur oder Funktion definiert ist. Er wird im Datenbanksystem gespeichert und auf dem Server von der PL/SQL-Engine ausgeführt. Stored Functions geben über RETURN einen Wert an das aufrufende Programm zurückEin PACKAGE ist ein benannter PL/SQL-Block, der logisch verwandte Prozeduren und Funktionen, Deklarationen etc. zu einer Bibliothek zusammenfasst. Ein Datenbanktrigger ist ein PL/SQL-Block, der zu einem definierten Ereignis (INSERT, UPDATE oder DELETE) automatisch vom Datenbankmanagementsystem aktiviert und ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ein Datenbanktrigger",
        "solution": "true"
      },
      {
        "text": "eine \"stored Procedure\"",
        "solution": "true"
      },
      {
        "text": "ein anonymer Block",
        "solution": "false"
      },
      {
        "text": "ein Package",
        "solution": "true"
      },
      {
        "text": "ein Funktion",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1089,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt die Klausel unter ORACLE, die eine eingebettete Tabelle erzeugt?",
    "explanation": "Mit NESTED TABLE <Tabellenwertige Spalte> STORE AS Tabellenname können tabellenwertige Spalten beschrieben werden. Für jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher innerenTabelle die tabellenwertigen Spalten abgelegt werden.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "NESTED TABLE"
      }
    ]
  },
  {
    "id": 1126,
    "category": 4,
    "difficulty": 2,
    "text": "Wie heißt der Wertebereich eines Attributs?",
    "explanation": "Sei (A1,..., An) eine Menge von Attributen mit den Wertebereichen Mi. Die Elemente der Mi sind Basisdatentypen und beschreiben die Werte, die die Attribute annehmen können. \nDie Wertebereiche Mi heißen Domänen. Domänen sind atomar, d.h. keine zusammengesetzten Datentypen. Bei der Definition von Domänen muss angegeben werden, ob NULL-Werte, also einzelne Attribute ohne Werteintrag, zugelassen sind. Eine Domäne kann auch eine festgelegte\nMenge von Werten aus den obigen Basisdatentypen sein.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist eine",
        "solution": "Domäne"
      }
    ]
  },
  {
    "id": 1128,
    "category": 4,
    "difficulty": 1,
    "text": "Bei der Division R % S müssen die Attribute von S in den Attributen von R enthalten sein.",
    "explanation": "Wir betrachten zwei Relationen R und S. Die Attribute von S sollen in den Attributen von R enthalten sein. Die Attribute der Ergebnismenge der Division entsprechen der Differenzmenge X der Attribute von R und S: \nDie Division R ÷ S besteht aus allen Tupeln x aus X, so dass die folgenden beiden Bedingungen für jedes x aus X gelten: \n1. Zu jedem s aus S gibt es eine Fortsetzung r aus R, so dass die Projektion von r auf S gleich s ist. \n2. Die Projektion von r auf X stimmt mit x überein.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1130,
    "category": 5,
    "difficulty": 1,
    "text": "Eine Relation, die die Entity-Integrität besitzt, hat",
    "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die Entity-Integrität, wenn jede Relation einen Primärschlüssel besitzt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "einen oder keinen Primärschlüssel.",
        "solution": "false"
      },
      {
        "text": "genau einen Primärschlüssel.",
        "solution": "true"
      },
      {
        "text": "einen oder mehrere Primärschlüssel.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1131,
    "category": 3,
    "difficulty": 1,
    "text": "Welche Vorteile haben künstliche Schlüssel?",
    "explanation": "Künstliche Schlüssel werden zum schnelleren Suchen benutzt und sind kein Abbild eines realen Attributs.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Einfacher Indexaufbau",
        "solution": "true"
      },
      {
        "text": "Besseres Abbild der Realität",
        "solution": "false"
      },
      {
        "text": "Schnelleres Suchen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1132,
    "category": 4,
    "difficulty": 1,
    "text": "Die Differenz ist kommutativ.",
    "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind kommutativ (vertauschbar), die Differenz aber nicht. \nEs macht sehr wohl einen semantischen Unterschied, ob man die \"Artikel ohne Rechnungen\" oder die \"Rechnungen ohne Atrikel\" anfragt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1133,
    "category": 4,
    "difficulty": 1,
    "text": "Die Division ist kommutativ.",
    "explanation": "Kartesisches Produkt, Vereinigung, Durchschnitt und Join-Operation sind kommutativ (vertauschbar), die Division aber nicht. \nEs macht sehr wohl einen semantischen Unterschied, ob man die \"Kunden, die alle Artikel gekauft haben\" oder die \"Artikel, die von allen Kunden gekauft wurden\" anfragt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1134,
    "category": 4,
    "difficulty": 2,
    "text": "Bei welcher Join-Operation müssen die Join-Attribute vom Namen her übereinstimmen?",
    "explanation": "Die Join-Attribute der beiden betroffenen Relationen müssen nicht den gleichen Namen haben, außer beim Natural-Join: In diesem Fall müssen die Join-Attribute den gleichen Namen haben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Theta-Join",
        "solution": "false"
      },
      {
        "text": "Equi-Join",
        "solution": "false"
      },
      {
        "text": "Natural Join",
        "solution": "true"
      },
      {
        "text": "Outer Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1136,
    "category": 6,
    "difficulty": 1,
    "text": "Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden rückwirkend alle in der Datenbank vorhanden Daten geprüft, ob sie dem CONSTRAINT genügen. Falls dies nicht der Fall ist, kann das CONSTRAINT nicht erzeugt werden.",
    "explanation": "Genau das ist der 100% Schutz, den Datenbanksysteme bei Constraints bieten. Wenn man in der USER_CONSTRAINTS des Dictionary sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabhängig vom Zeitpunkt der Speicherung korrekt sind. \nDas ist einer der Punkte, bei dem sich Integritätsprüfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden nur für alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung überprüft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1137,
    "category": 13,
    "difficulty": 3,
    "text": "Das Mutating-Table-Problem hat als Ursache",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sicherstellung der Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung",
        "solution": "true"
      },
      {
        "text": "keine dieser Ursachen",
        "solution": "false"
      },
      {
        "text": "die mangelhafte Prioritätensteuerung von Triggern",
        "solution": "false"
      },
      {
        "text": "den fehlerhaften Einsatz eines Statement-Triggers",
        "solution": "false"
      },
      {
        "text": "die kaskadierenden Triggern",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1138,
    "category": 13,
    "difficulty": 2,
    "text": "In BEFORE-Triggern sind keine DML-Operationen zulässig",
    "explanation": "In ORACLE-SQL führt uner Umständen dies zum Mutating-Table-Problem, ist aber zulässig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "in ORACLE-SQL",
        "solution": "false"
      },
      {
        "text": "in DB2-SQL",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1139,
    "category": 10,
    "difficulty": 1,
    "text": "Mit welcher Methode der Klasse DriverManager erzeugt man eine Connection-Schnittstelle?",
    "explanation": "Beim Aufruf von getConnection wird für alle registrierten Treiber (Class.ForName(\"DBDriver\")) der Reihe nach der gewünschte Verbindungsaufbau getestet. Der erste Treiber, der erfolgreich getestet wurde, wird verwendet und das Connection-Objekt, welches die Verbindung realisiert, wird zurückgegeben.",
    "type": "text",
    "answers": [
      {
        "text": "Die Methode heißt (ohne Klammern)",
        "solution": "getConnection"
      }
    ]
  },
  {
    "id": 1140,
    "category": 10,
    "difficulty": 3,
    "text": "Mit welcher Methode der Klasse Driver Manager werden alle registrierten Treiber nach dem gewünschten Verbindungsaufbau getestet?",
    "explanation": "Beim Aufruf von getConnection wird für alle registrierten Treiber (Class.ForName(\"DBDriver\")) der Reihe nach der gewünschte Verbindungsaufbau getestet. Der erste Treiber, der erfolgreich getestet wurde, wird verwendet und die Connection-Objekt, das die Verbindung realisiert, wird zurückgegeben.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist (ohne Klammern)",
        "solution": "getConnection"
      }
    ]
  },
  {
    "id": 1731,
    "category": 7,
    "difficulty": 2,
    "text": "Welche der folgenden SQL-Statements ist syntaktisch korrekt?",
    "explanation": "Bei \"revoke select from public on test;\" hat die falsche Reihenfolge der Schlüsselwörter.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "revoke select on test from public;",
        "solution": "true"
      },
      {
        "text": "revoke select from public on test;",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1142,
    "category": 6,
    "difficulty": 3,
    "text": "In welchen SQL-Statements können SEQUENCES angewendet werden ?",
    "explanation": "Eine Sequenz generiert eine fortlaufende Nummer. Häufigste Einsatzgebiete sind Abfragen (SELECT) oder Zuweisungen (INSERT, UPDATE). Dort kann an der Stelle eines Spaltennamens oder einer Konstante der Aufruf des nächsten Nummernwertes erfolgen mit .NEXTVAL. \nGrundsätzlich ließe sich eine Sequenz auch in einem DELETE in der WHERE-Klausel anwenden , wenn es den semantisch sinnvoll wäre.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSERT",
        "solution": "true"
      },
      {
        "text": "SELECT",
        "solution": "true"
      },
      {
        "text": "UPDATE",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1732,
    "category": 6,
    "difficulty": 1,
    "text": "Mit welcher ORACLE-SQL-Funktion kann man aus einem String ein Stück ausschneiden?",
    "explanation": "SUBSTR(spalteA, 1, 7) liefert die ersten 7 Zeichen des Inhalts von spalteA zurück.\nSUBSTR(spalteA, LENTGH(spalteA, 3) liefert die letzten 3 Zeichen des Inhalts von spalteA zurück.\nINSTR sucht eine gegebene Zeichenfolge in einem String und gibt dessen Position zurück.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSTR",
        "solution": "false"
      },
      {
        "text": "SUBSTR",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1733,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt unter ORACLE eine spezielle Tabellenart, in der jeder Datensatz als Objekt gespeichert wird?",
    "explanation": "Das ist die Definition einer Objekttabellen. Neben Objettabellen gibt es noch Tupeltabellen, bei denen jede Spalte einen eigenen Datentyp hat, der auch selbstdefiniert sein kann.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist eine (in deutsch schreiben, ohne Bindestriche)",
        "solution": "Objekttabelle"
      }
    ]
  },
  {
    "id": 1734,
    "category": 6,
    "difficulty": 2,
    "text": "Mit welcher ORACLE-SQL-Funktion kann man innerhalb eines Strings nach einer Zeichenfolge suchen?",
    "explanation": "INSTR sucht eine gegebene Zeichenfolge in einem String und gibt dessen Position zurück.\nSELECT INSTR(bemerkung, 'zahlungsfreudig') FROM kunden;\nGibt für jeden Kundendatensatz die Position der Wortes 'zahlungsfreudig' an.  \n\nSUBSTR schneidet aus einem Datenwert (1. Parameter) ab einer übergebenen Position (2. Parameter) eine Zeichenkette bestimmter Länge (3. Parameter) ab und gibt sie zurück.\nSUBSTR(spalteA, 1, 7) liefert die ersten 7 Zeichen des Inhalts von spalteA zurück.\nSUBSTR(spalteA, LENTGH(spalteA, 3) liefert die letzten 3 Zeichen des Inhalts von spalteA zurück.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SUBSTR",
        "solution": "false"
      },
      {
        "text": "INSTR",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1773,
    "category": 12,
    "difficulty": 1,
    "text": "Aus welchen verschiedenen Komponenten bestehen Packages?",
    "explanation": "Pakete (PACKAGES) sind Oracle-Datenbankobjekte, mit denen logisch in Verbindung stehende Programmkonstrukte, wie\n\nProzeduren,\nFunktionen,\nCURSOR,\nVariablen und Konstanten sowie\nEXCEPTIONS \n\n\nzu einer Einheit zusammengefasst werden.  \nIm BODY-Teil eines PACKAGES wird der Source-Code der zugehörigen Module abgelegt, im Header werden die Komponenten des Packages definiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Body",
        "solution": "true"
      },
      {
        "text": "Soul",
        "solution": "false"
      },
      {
        "text": "Header",
        "solution": "true"
      },
      {
        "text": "Feet",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1737,
    "category": 9,
    "difficulty": 2,
    "text": "Welche Kollektionstypen gibt es unter ORACLE?",
    "explanation": "Objekt-Tabellen und Typen sind keine Kollektionen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "VARRAYS",
        "solution": "true"
      },
      {
        "text": "NESTED TABLES",
        "solution": "true"
      },
      {
        "text": "OBJEKT -Tabellen",
        "solution": "false"
      },
      {
        "text": "OBJEKT-Typen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1775,
    "category": 10,
    "difficulty": 2,
    "text": "Welche Isolationsgrade kennt JDBC im Zusammenhang mit der Transaktionsverwaltung?",
    "explanation": "Die einzelnen Isolationsgrade haben (wie bei SQL) folgende Bedeutung:\n\nTRANSACTION_NONE : Es werden keine Sperren in der DB gesetzt. \nTRANSACTION_READ_UNCOMMITTED: Lesende Transaktionen verursachen keine\nSperren.  \nTRANSACTION_READ_COMMITTED:  Lesende Transaktionen verursachen Sperren. \nTRANSACTION_SERIALIZABLE Transaktionen werden geblockt und hintereinander ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "TRANSACTION_SERIALIZABLE",
        "solution": "true"
      },
      {
        "text": "TRANSACTION_YES",
        "solution": "false"
      },
      {
        "text": "TRANSACTION_NONE",
        "solution": "true"
      },
      {
        "text": "TRANSACTION_WRITE_COMMITTED",
        "solution": "false"
      },
      {
        "text": "TRANSACTION_NO_SERIALIZABLE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1776,
    "category": 11,
    "difficulty": 3,
    "text": "Welche Aussagen über SQLJ sind wahr?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SQLJ-Quelltext-Dateien besitzen per Konvention die Endung sqlj.",
        "solution": "true"
      },
      {
        "text": "SQLJ unterstützt die Ausführung von SQL-DML-Anweisungen (SELECT, INSERT, UPDATE, DELETE), nicht aber von SQL-DDL-Anweisungen (CREATE, ALTER, DROP,).",
        "solution": "false"
      },
      {
        "text": "Um aus SQLJ-Code ausführbaren Code zu erhalten, wird zuerst der Java-Compiler auf dem SQLJ-Code ausgeführt und Java-Code mit JDBC-Aufrufen erzeugt, der dann noch vom SQLJ-Translator in ausführbare Class-Files übersetzt wird.",
        "solution": "false"
      },
      {
        "text": "In SQLJ-Programmen können Default-Verbindungen, sog. Default-Kontexte, aufgebaut werden.",
        "solution": "true"
      },
      {
        "text": "Host-Variablen sind SQL-Variablen, die in der jeweiligen Host-Sprache, z.B. Java, verwendet werden können. Mit ihrer Hilfe können Daten zwischen SQL und der Host-Programmiersprache ausgetauscht werden.",
        "solution": "false"
      },
      {
        "text": "Der Verbindungskontext spezifiziert die Datenbank mit den assoziierten Schemata und die Verbindungsinformationen.",
        "solution": "true"
      },
      {
        "text": "Mehrere Verbindungskontexte können gleichzeitig instanziiert und genutzt werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1777,
    "category": 11,
    "difficulty": 3,
    "text": "Was passiert bei der Registrierung von Java Stored Procedures in der Datenbank?",
    "explanation": "\n    ist noch nicht da.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der zugehörige SQL-Name wird dem DBMS bekannt gemacht.",
        "solution": "true"
      },
      {
        "text": "Es werden die SQL-Datentypen der Parameter bekannt gemacht.",
        "solution": "true"
      },
      {
        "text": "Es wird ein jar.Archiv erstellt und in die Datenbank geladen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1778,
    "category": 11,
    "difficulty": 3,
    "text": "Welche Aussagen über Java Stored-Procedures sind wahr?",
    "explanation": "null",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es kann auf das lokale Dateisystem zugegriffen werden.",
        "solution": "false"
      },
      {
        "text": "Es können GUI-Funktionen ausgeführt werden.",
        "solution": "false"
      },
      {
        "text": "Es können SQL-Befehle wie SELECT, INSERT, UPDATE und DELETE ausgeführt werden.",
        "solution": "true"
      },
      {
        "text": "Es kann, über die explizite Angabe des Kontextes, auf andere Datenbanksysteme zugegriffen werden.",
        "solution": "false"
      },
      {
        "text": "Es sind statische Java-Methoden.",
        "solution": "true"
      },
      {
        "text": "Sie können aus SQL-Statements heraus aufgerufen werden, ebenso wie aus Triggern, PL/SQL-Funktionen und -Prozeduren.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1788,
    "category": 5,
    "difficulty": 1,
    "text": "Eine Relation in der ersten Normalform mit nur einem Primärschlüsselattribut ist automatisch in der zweiten Normalform.",
    "explanation": "Das Gegebensein der 1. NF ist Grundvoraussetzung für die 2. NF. \nWenn ein Primärschlüssel nur aus Attribut besteht, dann sind alle abhängigen Attribute zwingend voll funktional abhängig. Partiell abhängig hieße ja, dass Nichtschlüsselattribute nur von einer Teilmenge der Attribute abhängig wären, was bei nur einem Attribut des Primärschlüssels nicht geht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1790,
    "category": 4,
    "difficulty": 1,
    "text": "Der Vereinigung als Mengenoperation der relationalen Algebra entspricht unter SQL",
    "explanation": "Die Mengenoperatoren der Relationalen Algebra lassen sich mit folgenden SQL-Operatoren implementieren: \n\nRA -SQL:\nVereinigung - UNION\nDifferenz - EXCEPT / MINUS\nDurchschnitt - INTERSECTION",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INTERSECT",
        "solution": "false"
      },
      {
        "text": "UNION",
        "solution": "true"
      },
      {
        "text": "MINUS",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1800,
    "category": 4,
    "difficulty": 2,
    "text": "SQL ist eine Sprache der",
    "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ersten Generation",
        "solution": "false"
      },
      {
        "text": "zweiten Generation",
        "solution": "false"
      },
      {
        "text": "dritten Generation",
        "solution": "false"
      },
      {
        "text": "vierten Generation",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1798,
    "category": 5,
    "difficulty": 1,
    "text": "Welche Aussagen über Normalformen sind wahr?",
    "explanation": "Richtig ist: \"Jede 1NF-Relation mit einem Primärschlüssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 2NF.\" \nWenn ein Primärschlüssel nur aus einem Attribut besteht, wie soll es da eine partielle Abhängigkeit geben? Partielle heißt ja, dass einige Nichtschlüsselattribute nur von Teilen des Primärschlüssels abhängig sind, was bei einem Schlüssel mit nur einen Attribut ja ausgeschlossen ist. \nFalsch ist: \"Jede 1NF-Relation mit einem Primärschlüssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 3NF.\"\nGegenbeispiel: A->B,C und B->C und einer Relation R(A (PK),B,C).\n\nFalsch ist: \"Bei der Überführung in die dritte Normalform sind die vorher zu erstellende 2NF-Relationen immer von den endgültigen 3NF-Relationen verschieden.\" \nWenn es keine transitiven Abhängigkeiten gibt, dann gilt: 2. NF = 3. NF und damit sind die Relationen gleich in beiden NFs.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Jede 1NF-Relation mit einem Primärschlüssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 2NF.",
        "solution": "true"
      },
      {
        "text": "Jede 1NF-Relation mit einem Primärschlüssel, der aus einem einzigen Attribut besteht, ist immer automatisch auch 3NF.",
        "solution": "false"
      },
      {
        "text": "Bei der Überführung in die dritte Normalform sind die vorher zu erstellende 2NF-Relationen immer von den endgültigen 3NF-Relationen verschieden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1799,
    "category": 5,
    "difficulty": 2,
    "text": "Das Versicherungsbüro Schutzengel hat die Daten über Versicherungspolicen in einer Relation \nVertraege(Vertrags_Nr, Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision) \ngespeichert, wobei die Vertrags_Nr der Primärschlüssel dieser Relation ist.\n\nBei der Überführung in eine Normalform entstehen die Relationen Kunden, Vertraege und Vertragsarten.",
    "explanation": "Aus der Relation lassen Vertraege(Vertrags_Nr, Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision) lassen sich folgende funktioanle Abhängigkeiten ableiten: \nVertrags_Nr -> Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision \nweil Vertrags_Nr einziges Primärschküsselattribut ist \nKunden_NR -> Kundenname, Kundenadresse  \nVertragsart -> Abschlussprovision \nBei den beiden Abhängigkeiten von Kunden_NR und Vertragsart handelt es sich um transitive Abhängigkeiten, da diese wiederum von Kunden_NR abhängig sind. \nUnd daraus ergeben sich dann folgende drei Relationen: \nKunden (Kunden_NR (PK), Kundenname, Kundenadresse)  \nVertragsarten (Vertragsart (PK), Abschlussprovision) \nVertraege (Vertrags_Nr (PK), Vertragsart, Betrag, Kunden_NR)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es handelt sich um eine Überführung in die 1NF.",
        "solution": "false"
      },
      {
        "text": "Es handelt sich um eine Überführung in die 3NF.",
        "solution": "true"
      },
      {
        "text": "Es handelt sich um eine Überführung in die 2NF.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1801,
    "category": 4,
    "difficulty": 1,
    "text": "Java ist eine Sprache der",
    "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "zweiten Generation",
        "solution": "false"
      },
      {
        "text": "ersten Generation",
        "solution": "false"
      },
      {
        "text": "dritten Generation",
        "solution": "true"
      },
      {
        "text": "vierten Generation",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1805,
    "category": 3,
    "difficulty": 2,
    "text": "Welche Aussagen über (nicht-)identifizierende Beziehungen sind wahr?",
    "explanation": "Bei identifizierenden Beziehungen wird in der Detail-Entitymenge der Fremdschlüssel zum Primärschlüssel hinzugenommen, bei nicht identifizierenden Beziehungen wird der Fremdschlüssel nur als Attribut eingetragen, welches nicht zum Primärschlüssel der Relation gehört. Der Grund für den Ausschluss idendifizierender Beziehungen bei künstlichen Primärschlüsseln liegt darin, dass künstliche Primärschlüssel per Definition nur aus einem Attribut bestehen dürfen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es gibt fixe, anwendungsunabhängige Regeln, die für alle Anwendungsfälle vorgeben, wann eine identifizierende und wann eine nicht identifizierende Beziehung zu verwenden ist.",
        "solution": "false"
      },
      {
        "text": "Bei identifizierenden Beziehungen treten die Primärschlüsselattribute der Master-Entity-Menge als Fremdschlüssel-Attribute im Primärschlüssel bei der Detail-Entity-Menge auf.",
        "solution": "true"
      },
      {
        "text": "Bei nicht-identifizierenden Beziehungen treten die Primärschlüsselattribute der Detail-Entity-Menge nur als \"einfache\" Fremdschlüssel-Attribute bei der Master-Entity-Menge auf.",
        "solution": "false"
      },
      {
        "text": "Verfügen die an einer 1:cn-Beziehung beteiligten Entity-Mengen allesamt über künstliche Primärschlüssel, dann sind nur nicht-identifizierenden Beziehungen zugelassen.",
        "solution": "true"
      },
      {
        "text": "Eine 1:c1-Beziehung kann als identifizierende verwendet werden, wenn die Master-Entity-Menge einen künstlichen Primärschlüssel hat und die Detail-Entity-Menge keinen eigenen Primärschlüssel, sondern nur den künstlichen, vererbten über die identif. 1:c1-Beziehung.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1803,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie die Tabelle Angestellte(Ang_Nr, Nachname, Jahresgehalt). \nEs werden die Angestellten gesucht, die das höchste Jahresgehalt haben. Welche Abfrage liefert das gewünschte Ergebnis?",
    "explanation": "Die Abfrage \nSELECT nachname, max(jahresgehalt)\nFROM angestellte\nGROUP by nachname;\nist syntaktisch korrekt, aber nicht semantisch, da die höchsten Jahresgehälter je Nachname berechnet werden.\n\nAnsonsten kann das Ergebnis über \"where jahresgehalt >= ALL(...)\"berechnet werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT ang_nr\nFROM angestellte\nWHERE jahresgehalt > all ;",
        "solution": "false"
      },
      {
        "text": "SELECT max( all jahresgehalt)\nFROM angestellte;",
        "solution": "false"
      },
      {
        "text": "SELECT nachname, max(jahresgehalt)\nFROM angestellte\nGROUP by nachname;",
        "solution": "false"
      },
      {
        "text": "SELECT nachname, max(jahresgehalt) \nFROM angestellte;",
        "solution": "false"
      },
      {
        "text": "SELECT a.nachname, a.jahresgehalt\nFROM angestellte a\nWHERE a.jahresgehalt = max(jahresgehalt);",
        "solution": "false"
      },
      {
        "text": "SELECT ang_nr, jahresgehalt\nfrom angestellte\nwhere jahresgehalt = (SELECT max(jahresgehalt) from angestellte);",
        "solution": "true"
      },
      {
        "text": "SELECT ang_nr\nFROM angestellte\nwhere jahresgehalt > ALL(\nSELECT jahresgehalt from angestellte)",
        "solution": "false"
      },
      {
        "text": "select ang_nr, jahresgehalt\nFROM angestellte\nwhere jahresgehalt >= ALL(\nSELECT jahresgehalt from angestellte);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1804,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie die Tabelle Angestellte(Ang_Nr, Nachname, Jahresgehalt) und die Tabelle Kurse(Kurs, Ang_NR, Anzahl). Es werden die Angestellten gesucht, die meisten Kurse abgehalten haben. Welche Abfrage liefert das gewünschte Ergebnis?",
    "explanation": "Diese Anfrage kann nur über eine Unterabfrage beantwortet werden; in den anderen Abfragen ist die Gruppenfunktion SUM falsch verwendet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT nachname\nFROM angestellte\nWHERE ang_nr = (SELECT SUM(ang_nr)\nFROM kurse\nGROUP BY  k.ang_nr);",
        "solution": "false"
      },
      {
        "text": "SELECT  a.ang_nr, a.Nachname, SUM(anzahl)\nFROM    angestellte a , kurse b\nWHERE a.ang_nr = b.ang_nr\nGROUP BY a.ang_nr, Nachname\nHAVING SUM(anzahl)  >= ALL\n       (SELECT SUM(anzahl)\n        FROM    angestellte a , kurse b\n        WHERE a.ang_nr = b.ang_nr\n        GROUP BY a.ang_nr);",
        "solution": "true"
      },
      {
        "text": "SELECT SUM(anzahl), a.nachname\nFROM angestelltea, kurse b,\nWHERE a.ang_nr = b.ang_nr\nGROUP BY a.nachname\nORDER BY SUM(b.anzahl) DESC ;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1806,
    "category": 3,
    "difficulty": 2,
    "text": "Welche Aussagen über nicht identifizierende Beziehungen in ER-Diagrammen sind richtig?",
    "explanation": "Bei identifizierenden Beziehungen wird in der Detail-Entitymenge der Fremdschlüssel zum Primärschlüssel hinzugenommen, bei nicht identifizierenden Beziehungen wird der Fremdschlüssel nur als Attribut eingetragen, welches nicht zum Primärschlüssel der Relation gehört.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Attribute des Primärschlüssels der Master-Tabelle treten als Primärschlüsselattribute in der Detail-Tabelle auf.",
        "solution": "false"
      },
      {
        "text": "Die Attribute des Primärschlüssels der Master-Entitymenge treten als Nichtschlüsselattribute in der Detail-Tabelle auf.",
        "solution": "true"
      },
      {
        "text": "Die Inhalte des Primärschlüssels der Master-Entitymenge stellen einen dynamischen Wertebereich für die zugehörigen Fremdschlüsselattribute der Detail-Entitymenge dar.",
        "solution": "true"
      },
      {
        "text": "Die Attribute des Primärschlüssels der Detail-Entitymenge treten als Primärschlüsselattribute in der Master-Entitymenge auf.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1774,
    "category": 10,
    "difficulty": 3,
    "text": "Welche Aussagen über JDBC sind wahr?",
    "explanation": "Innerhalb eines ResultSets kann mann auch über den Spaltennamen auf die \nErgebnismenge einer DB-Anfrage zugreifen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die JDBC-API ist zu 100% in Java geschrieben und damit plattformunabhängig.",
        "solution": "true"
      },
      {
        "text": "Ein \"native protocol pure Java Treiber ist komplett in Java implementiert und kommuniziert direkt mit dem Datenbankmanagementsystem. Er ist Applet-fähig.",
        "solution": "true"
      },
      {
        "text": "Ein \"native API partly Java\" Treiber ist clientseitig komplett in Java implementiert und verwendet ein DBMS-unabhägiges Netzwerkprotokoll für die Kommunikation mit dem Applicationserver; der die Anweisungen dann in ein DB-Protokoll übersetzt und an das DBMS weiterleitet.",
        "solution": "false"
      },
      {
        "text": "Innerhalb der Datensätze der Ergebnismenge einer DB-Anfrage kann mittels verschiedener Methodenaufrufe wie z.B. first(), previous(), hin und her navigiert werden.",
        "solution": "true"
      },
      {
        "text": "Auf die einzelnen Spalten innerhalb der Ergebnismenge einer DB-Anfrage kann nur mittels Spaltennummern zugegriffen werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1730,
    "category": 7,
    "difficulty": 3,
    "text": "Welche der folgenden INSERT -Ausdrücke in die Teile-Tabelle  sind syntaktisch und semantisch korrekt, wenn die Teile-Tabelle durch das folgende CREATE-Table-Statement angelegt wird:\n\nCREATE TABLE TEILE\n( TNR NUMBER(38) NOT NULL,\n  BEZEICHNUNG VARCHAR2(50) NOT NULL,\n  TYP VARCHAR2(50),\n  MINDESTBESTAND NUMBER,\n  BESTAND NUMBER,\n  ZEITSTEMPEL DATE,\n  CONSTRAINT pruefe_bestand CHECK (Bestand >= Mindestbestand )\n);",
    "explanation": "Bei einem INSERT-Befehl müssen alle Spalten, die mit NOT-NULL angelegt wurden, auch mit einem Wert versorgt werden,",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSERT INTO Teile\n(TNR, BEZEICHNUNG, TYP, MINDESTBESTAND, BESTAND, ZEITSTEMPEL)\nVALUES  (33,  \"Dynamo\", \"Material\", 15, 20, \"01.01.2000\");",
        "solution": "true"
      },
      {
        "text": "keiner von allen",
        "solution": "false"
      },
      {
        "text": "INSERT INTO Teile\n       (TNR, BEZEICHNUNG, TYP, MINDESTBESTAND, BESTAND, ZEITSTEMPEL)\nVALUES  (3333,  \"Dynamo\", \"Material\", 20, 15, \"01.01.2000\");",
        "solution": "false"
      },
      {
        "text": "INSERT INTO Teile (TNR, TYP, BEZEICHNUNG)\nVALUES  (\"33\", \"fremd\", Dynamo);",
        "solution": "true"
      },
      {
        "text": "INSERT INTO Teile\nVALUES  (33, \"kg\", \"Dynamo\",  \"Material\", 20, 15;",
        "solution": "false"
      },
      {
        "text": "INSERT INTO Teile (TNR, TYP, BEZEICHNUNG)\nVALUES  (33, \"Material\", \"Dynamo\");",
        "solution": "true"
      },
      {
        "text": "INSERT INTO Teile (TYP, BEZEICHNUNG)\nVALUES  (\"Material\", \"Dynamo\");",
        "solution": "false"
      },
      {
        "text": "INSERT INTO Teile (TNR, TYP)\nVALUES  (\"33\", \"Material\");",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1482,
    "category": 12,
    "difficulty": 2,
    "text": "Was verbirgt sich hinter der Abkürzung NDS in PL/SQL?",
    "explanation": "In PL/SQL kann nur SQL-Manipulationsanweisungen, aber keine DDL-Anweisungen wie CREATE, ALTER, DROP etc.,keine DCL wie GRANT, REVOKE etc. und keine SESSION CONTROL-Anweisungen wie ALTER SESSION\nverarbeiten. Einen Ausweg aus dieser Situation bietet dynamisches SQL unter PL/SQL mit NDS, dem Native Dynamic SQL. Die auszuführende SQL-Anweisung wird ohne abschließendes Semikolon als Zeichenkette oder in einer Textvariablen dem Befehl EXECUTE IMMEDIATE übergeben, der diesen Text ungeprüft zur Ausführung an das Datenbankmanagementsystem sendet. Der Befehl EXECUTE IMMEDIATE selbst wird aber mit einem Semikolon abgeschlossen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "Native Dynamic SQL"
      }
    ]
  },
  {
    "id": 801,
    "category": 4,
    "difficulty": 3,
    "text": "Welcher Optimierungsvorgang transformiert einen algebraischen Ausdruck der relationalen Algebra auf einen semantisch äquivalenten Ausdruck?",
    "explanation": "Bei der logischen Optimierung wird ein algebraischer Ausdruck der relationalen Algebra auf einen semantisch äquivalenten Ausdruck transformiert, der weniger Laufzeit benötigt. Je weniger Tupel die Zwischenergebnismengen haben, umso schneller ist die Anfrageauswertung.",
    "type": "text",
    "answers": [
      {
        "text": "Dies ist die ...",
        "solution": "logische Optimierung"
      }
    ]
  },
  {
    "id": 807,
    "category": 5,
    "difficulty": 3,
    "text": "Welche Vorteile hat eine Normalisierung von Relationen?",
    "explanation": "Es soll insgesamt ein \"gutes\" Datenbankschema entstehen, wobei sich die Güte misst in \nleichterer Handhabbarkeit, möglichst wenig Redundanzen und  Übersichtlichkeit. \nDemgegenüber kennzeichnen sich schlechte Datenbankschemata durch: Redundanzen, die zu unnötigem Speicherplatzverbrauch führen.Änderungsanomalien: Bei Änderungen muss der gleiche Wert an mehreren Stellen aktualisiert werden.Einfügeanomalien: Bereits vorhandene Daten werden an anderer Stelle wiederholt eingefügt.Löschanomalien: Die Daten müssen an mehreren Stellen gelöscht werden.Hohe Fehleranfälligkeit: Die Fehlerhäufigkeit ist erhöht, da bei diesen Änderungen Daten anfallen können, die nicht alle auf den gleichen Stand gebracht wurden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Einfügeanomalien werden vermieden",
        "solution": "true"
      },
      {
        "text": "Inkonsistenzen treten nicht auf",
        "solution": "true"
      },
      {
        "text": "Änderungsanomalien werden vermieden",
        "solution": "true"
      },
      {
        "text": "Speicherplatzverbrauch wird reduziert.",
        "solution": "true"
      },
      {
        "text": "Das Konzept der Objektorientierung wird umgesetzt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1153,
    "category": 13,
    "difficulty": 1,
    "text": "Sobald ein Datenbanktrigger erzeugt und aktiviert wird, werden rückwirkend alle in der Datenbank vorhanden Daten geprüft, ob sie dem Trigger genügen. Falls dies nicht der Fall ist, kann der Trigger nicht erzeugt werden.",
    "explanation": "Die Eigenschaft, dass rückwirkend die Daten kontrolliert werden, haben nur Constraints. Das führt dazu, dass man keinen Constraint anlegen kann, wenn die bestehenden Daten nicht der in dem Constraint enthaltenen Bedingung genügen. Für Trigger ist das nicht der Fall. Um die Kontrolle, die im Trigger enthalten ist, auszuführen, muss der Trigger angestoßen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1154,
    "category": 1,
    "difficulty": 1,
    "text": "Zu welcher Ebene einer Datenbankarchitektur gehört die Transaktionsverwaltung?",
    "explanation": "Eine Folge von Lese- und Schreibzugriffen, die als Einheit ausgeführt werden müssen, wird als Transaktion bezeichnet. Transaktionsverwaltung und Scheduler, wenn mehrere Personen gleichzeitig mit dem Datenbanksystem arbeiten, müssen einen Multiuser-Betrieb und die Synchronisation paralleler Transaktionen ermöglichen. Diese Aufgabe übernimmt der Scheduler.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1. Ebene: Verarbeitung von Benutzereingaben",
        "solution": "false"
      },
      {
        "text": "2. Ebene: Anfrageverarbeitung",
        "solution": "false"
      },
      {
        "text": "3. Ebene: Zugriffsstrukturen und Codeerzeugung",
        "solution": "false"
      },
      {
        "text": "4. Ebene: Synchronisation paralleler Zugriffe",
        "solution": "true"
      },
      {
        "text": "5. Ebene: Speicherverwaltung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 808,
    "category": 5,
    "difficulty": 1,
    "text": "Eine vollständige Normalisierung hat den Nachteil, dass es Performanceverluste beim Lesen durch eine große Anzahl von Relationen geben kann.",
    "explanation": "Durch die Normalisierung ergibt sich bei größeren Projekten eine Vielzahl von mit Fremdschlüsselbeziehungen verbundenen Relationen. Informationen, die inhaltlich im Sinne der Objektorientierung zusammengehören, werden unter Umständen auf viele Relationen verteilt. Bei Abfragen kann es zu erheblichen Performanceverlusten kommen, da oft viele Relationen aufwändig miteinander verknüpft werden müssen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1155,
    "category": 4,
    "difficulty": 3,
    "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass jeder Wert eines Fremdschlüssels einer Relation Wert eines Primärschlüssel in einer anderen Relation ist.",
    "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrität, wenn jeder Wert eines Fremdschlüssels einer Relation Ri Wert eines Primärschlüssels in einer anderen Relation Rj ist. Handelt es sich bei den Relationen Ri und Rj um die gleiche Relation, so wird diese Form der Referenz Selbstreferenz oder auch rekursive Referenz genannt.",
    "type": "text",
    "answers": [
      {
        "text": "Diese Eigenschaft heißt",
        "solution": "Referentielle Integrität"
      }
    ]
  },
  {
    "id": 814,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welcher Aktion (Option des CONSTRAINTs REFERENCES/FOREIGN KEY) kann man in ORACLE-SQL wie auch im SQL-Standard kaskadierendes Löschen abbilden?",
    "explanation": "Für das Fremdschlüssel-Constraint (REFERNCES/FOREIGN KEY) gibt es folgende Option: \n<Fehlerkorrektur Definition> ::= \nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n\nHintergrund der Problematik ist, dass wenn eine Fremdschlüsselbeziehung besteht, das Löschen von Datensätzen, die referenziert werden, problematisch ist.\n\nON DELETE Die definierte Fehlerkorrekturoption wird ausgeführt, wenn der referenzierte Master-Datensatz gelöscht wird.\nON UPDATE Die definierte Fehlerkorrekturoption wird ausgeführt, wenn der Wert des referenzierten Schlüsselattributs in der Master-Tabelle geändert wird.\nCASCADE Die Detaildatensätze, deren Fremdschlüssel den manipulierten Master-Datensatz referenzieren, werden ebenfalls gelöscht (kaskadierendes Löschen) bzw. deren Schlüsselwert wird entsprechend geändert (kaskadierendes Ändern). \nSET DEFAULT Die Fremdschlüsselspalten des Detaildatensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf den für diese Spalte definierten DEFAULT-Wert gesetzt.\nSET NULL Die Fremdschlüsselspalten des Detail-Datensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf NULL gesetzt.\nNO ACTION/RESTRICT Auf den Integritätsfehler wird je nach Prüfungszeitpunkt mit dem Zurückrollen der gesamten Transaktion bzw. der fehlerhaften DML-Anweisung reagiert (Reaktion wie bei den anderen CONSTRAINTS auch).",
    "type": "text",
    "answers": [
      {
        "text": "Der Ausdruck heißt",
        "solution": "ON DELETE CASCADE"
      }
    ]
  },
  {
    "id": 815,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welcher Aktion (Option der CONSTRAINT REFERENCES-Klausel des CREATE/ALTER-TABLE-Befehls) kann man in ORACLE und beim SQL-Standard bei einer DELETE-Anweisung erreichen, dass NULL-Werte in abhängige Spalten eingetragen werden?",
    "explanation": "Hintergrund der Problematik ist, dass das Löschen von Datensätzen, die referenziert werden, problematisch ist, wenn eine Fremdschlüsselbeziehung besteht. \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION \n\n\nON DELETE: Die definierte Fehlerkorrekturoption wird ausgeführt, wenn der referenzierte Master-Datensatz gelöscht wird.\nON UPDATE: Die definierte Fehlerkorrekturoption wird ausgeführt, wenn der Wert des referenzierten Schlüsselattributs in der Master-Tabelle geändert wird.\nCASCADE: Die Detaildatensätze, deren Fremdschlüssel den manipulierten Master-Datensatz referenzieren, werden ebenfalls gelöscht kaskadierendes Löschen) bzw. deren Schlüsselwert wird entsprechend geändert (kaskadierendes Ändern).\nSET DEFAULT: Die Fremdschlüsselspalten des Detaildatensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf den für diese Spalte definierten DEFAULT-Wert gesetzt.\nSET NULL: Die Fremdschlüsselspalten des Detail-Datensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf NULL gesetzt.\nNO ACTION: Auf den Integritätsfehler wird je nach Prüfungszeitpunkt mit dem Zurückrollen der gesamten Transaktion bzw. der fehlerhaften DML-Anweisung reagiert (Reaktion wie bei den anderen CONSTRAINTS auch).\nRESTRICT: Diese Option ist analog zur NO ACTION-Funktionalität zu sehen.",
    "type": "text",
    "answers": [
      {
        "text": "Der Ausdruck heißt",
        "solution": "ON DELETE SET NULL"
      }
    ]
  },
  {
    "id": 816,
    "category": 7,
    "difficulty": 3,
    "text": "Wo findet man unter ORACLE den Source-Code einer View, auf den jeder Benutzer Zugriff hat und in der nur die Views eingetragen sind, die dem Benutzer selber gehören?",
    "explanation": "Das Dictionary von Oracle umfasst eine Vielzahl von Tabellen bzw. Sichten und u.a. auch die USER_VIEWS für den Code einer Sichtdefinition. \nDie Dictionary -Tabellen/Sichten sind in verschiedene Gruppen aufgeteilt, die im Namen deutlich werden:\nUSER_...: Sichten für alle DB-Objekte, die ein Benutzer selbst angelegt hat.\nALL_...: Sichten für alle DB-Objekte, die ein Benutzer selbst angelegt hat bzw. für die er von anderen Anwendern Zugriffsrechte vergeben bekommen hat.\nDBA_...: Sichten für alle DB-Objekte, die überhaupt in der Datenbank existieren. Auf diese Sichten hat nur ein Benutzer mit Administrationsrechten Zugriff.\nV$-Views: Sichten mit statistischen Informationen.",
    "type": "text",
    "answers": [
      {
        "text": "Die Data-Dictionary-View heißt",
        "solution": "USER_VIEWS"
      }
    ]
  },
  {
    "id": 822,
    "category": 6,
    "difficulty": 1,
    "text": "Was versteht man unter transitionalen Integritätsbedingungen?",
    "explanation": "Transitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel aus der Fahrrad-Welt Byce & Co. wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über \nDatenbanktrigger realisieren.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diesen Begriff gibt es nicht.",
        "solution": "false"
      },
      {
        "text": "Das sind Bedingungen, die Transaktionen abbilden.",
        "solution": "false"
      },
      {
        "text": "Das sind Bedingungen bei denen der alte und der neue Zustand eines Datensatzes oder gar eine Folge von solchen Zustandsübergängen kontrolliert wird.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 819,
    "category": 5,
    "difficulty": 3,
    "text": "Eine Menge von Relationen besitzt die Eigenschaft, dass die Korrektheit der Eingaben der Benutzer gewährleistet ist.",
    "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die semantische Integrität, wenn die Korrektheit der Eingaben der Benutzer gewährleistet ist.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist die ...",
        "solution": "semantische Integrität"
      }
    ]
  },
  {
    "id": 823,
    "category": 4,
    "difficulty": 2,
    "text": "Welche Schlüsselbegriffe gibt es nicht in der relationalen Algebra?",
    "explanation": "Eine Attributkombination L wird eindeutiger Schlüssel der Relation R1(A1,...An) genannt, wenn \n1. L → (A1,...,An) und \n2. (A1,...,An) von keiner echten Teilmenge von L funktional abhängig ist. \nIn jeder Relation wird genau ein eindeutiger Schlüssel zum Primärschlüssel (primary key, Hauptschlüssel) erklärt, über den die Tupel der Relation eindeutig identifiziert werden können. Ein Primärschlüssel ist immer obligatorisch und darf keine NULL-Werte haben. \nZusätzlich können in einer Relation zur Beschleunigung des Zugriffs bestimmte Attribute zu Zweitschlüsseln ernannt werden. Anders als beim Primärschlüssel müssen die Zweitschlüssel weder eindeutig sein noch sind NULL-Werte verboten. Es werden Indizes in Hilfstabellen erstellt, über die der schnellere Zugriff auf die Attribute des Zweitschlüssels möglich ist.  \n\nDie übrigen Schlüsselbegriffe gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Indexschlüssel",
        "solution": "true"
      },
      {
        "text": "Primärschlüssel",
        "solution": "false"
      },
      {
        "text": "Eindeutiger Schlüssel",
        "solution": "false"
      },
      {
        "text": "Zweitschlüssel",
        "solution": "false"
      },
      {
        "text": "Fremdschlüssel",
        "solution": "false"
      },
      {
        "text": "Drittschlüssel",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1156,
    "category": 11,
    "difficulty": 2,
    "text": "Welche Komponente von SQLJ erstellt SQLJ-Profile ?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Translator",
        "solution": "true"
      },
      {
        "text": "Customizer",
        "solution": "false"
      },
      {
        "text": "Laufzeitsystem",
        "solution": "false"
      }
    ]
  },
  {
    "id": 828,
    "category": 6,
    "difficulty": 1,
    "text": "Wozu gehört der Ausdruck \"START WITH\" in Standard-SQL?",
    "explanation": "Hier ein Beispiel für eine Sequenz:\n\n    Betrachten Sie die folgende Definition einer Sequenz:\n\n    CREATE SEQUENCE Kun_seq\n\n    INCREMENT BY 1\n\n    START WITH 1\n\n    NOMAXVALUE\n\n    NOCYCLE\n\n    CACHE 10;\n\n    \n\n    CONNECT BY gehört nicht zum Standard-SQL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE SEQUENCE",
        "solution": "true"
      },
      {
        "text": "CONNECT BY",
        "solution": "false"
      },
      {
        "text": "Diesen Ausdruck gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 829,
    "category": 7,
    "difficulty": 1,
    "text": "Die Programmierung einer rekursiven Anfrage mittels CONNECT-BY-Klausel ist ORACLE-spezifisch.",
    "explanation": "Die Programmierung einer rekursiven Anfrage mittels CONNECT BY-Klausel ist ORACLE-spezifisch. In SQL gibt es dafür eine WITH RECURSIVE-Klausel, mit der rekursive temporäre Hilfssichten programmiert werden können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1157,
    "category": 11,
    "difficulty": 3,
    "text": "Welche drei grundlegenden Komponenten hat SQLJ ? Bitte in alphabetischer Reihenfolge eintragen!",
    "type": "text",
    "answers": [
      {
        "text": "Komponente 1",
        "solution": "Customizer"
      },
      {
        "text": "Komponente 2",
        "solution": "Laufzeitsystem"
      },
      {
        "text": "Komponente 3",
        "solution": "Translator"
      }
    ]
  },
  {
    "id": 832,
    "category": 12,
    "difficulty": 1,
    "text": "PL/SQL wird immer beim SERVER ausgeführt.",
    "explanation": "PL/SQL ist eine Oracle-spezifische prozedurale Erweiterung von SQL, die auf ADA basiert. Sie stellt somit eine Möglichkeit dar, die mengenorientierten SQL-DML-Anweisungen Datensatz für Datensatz zu verarbeiten. PL/SQL kann sowohl beim Server als auch beim Client ausgeführt werden. Findet die Ausführung auf dem Server statt, dann handelt es sich um in der Datenbank gespeicherte Prozeduren und Funktionen, die durch externe Aufrufe (RPC Remote Procedure\nCall) angestoßen werden oder über Datenbanktrigger. PL/SQL-Aufrufe können alternativ auch beim Client verarbeitet werden. In diesem Fall wird der PL/SQL-Programmcode auf der Client-Seite bearbeitet und das Ergebnis dem Oracle-Datenbank-Server übergeben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 836,
    "category": 12,
    "difficulty": 1,
    "text": "Die kleinste Einheit eines PL/SQL-Programms",
    "explanation": "Die kleinste Einheit von PL/SQL ist ein sogenannter PL/SQL-Block, der aus bis zu drei PL/SQL-Abschnitten bestehen kann. \n\nDer Deklarationsabschnitt  enthält Deklarationen von benutzerdefinierten Datentypen, Variablen, Konstanten, CURSOR und\nbenutzerdefinierte EXCEPTIONS, Unterprozedurenund -funktionen und ist optional. \nDer Ausführungsabschnitt   enthält PL/SQL-Anweisungen und bestimmte SQL-Anweisungen\nwie INSERT, UPDATE, DELETE, SELECT,\nCOMMIT, ROLLBACK und ist obligatorisch. \n\nDer Fehlerbehandlungsabschnitt   gibt an, welche Aktionen ausgeführt werden sollen, wenn im Ausführungsabschnitt  Fehler auftreten und ist optional.",
    "type": "text",
    "answers": [
      {
        "text": "heißt",
        "solution": "Block"
      }
    ]
  },
  {
    "id": 834,
    "category": 12,
    "difficulty": 1,
    "text": "Mit welchen Zeichen beginnen in PL/SQL einzeilige Kommentare?",
    "explanation": "Wie in anderen Programmiersprachen auch, können in PL/SQL an jeder beliebigen Stelle Kommentare untergebracht werden. Das doppelte Minuszeichen \"--\" wird verwendet, um einzeilige Kommentare einzufügen und die beiden Zeichen /* */ begrenzen einen mehrzeiligen Kommentar.",
    "type": "text",
    "answers": [
      {
        "text": "Das sind die Zeichen",
        "solution": "--"
      }
    ]
  },
  {
    "id": 835,
    "category": 12,
    "difficulty": 1,
    "text": "In PL/SQL können sich Kommentare wie in JAVA oder C auch über mehrere Zeilen erstrecken.",
    "explanation": "Wie in anderen Programmiersprachen auch, können in PL/SQL an jeder beliebigen\nStelle Kommentare untergebracht werden. Das doppelte Minuszeichen \"--\" wird verwendet,\num einzeilige Kommentare einzufügen und die beiden Zeichen /* */\nbegrenzen einen mehrzeiligen Kommentar.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "false"
      },
      {
        "text": "stimmt",
        "solution": "true"
      }
    ]
  },
  {
    "id": 838,
    "category": 12,
    "difficulty": 2,
    "text": "Welcher PL/SQL-Abschnitt ist optional?",
    "explanation": "Die kleinste Einheit von PL/SQL ist ein sogenannter PL/SQL-Block, der aus bis zu drei PL/SQL-Abschnitten bestehen kann. \n\nDer Deklarationsabschnitt  enthält Deklarationen von benutzerdefinierten Datentypen, Variablen, Konstanten, CURSOR und\nbenutzerdefinierte EXCEPTIONS, Unterprozedurenund -funktionen und ist optional. \nDer Ausführungsabschnitt   enthält PL/SQL-Anweisungen und bestimmte SQL-Anweisungen\nwie INSERT, UPDATE, DELETE, SELECT,\nCOMMIT, ROLLBACK und ist obligatorisch. \n\nDer Fehlerbehandlungsabschnitt   gibt an, welche Aktionen ausgeführt werden sollen, wenn im Ausführungsabschnitt  Fehler auftreten und ist optional.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Deklarationsteil",
        "solution": "true"
      },
      {
        "text": "Ausführungsteil",
        "solution": "false"
      },
      {
        "text": "Fehlerbehandlungsteil",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1158,
    "category": 11,
    "difficulty": 3,
    "text": "Welche Komponente von SQLJ passt die SQLJ-Profile an die Datenbank an, damit herstellerspezifische Dialekte verwendet werden können?",
    "type": "text",
    "answers": [
      {
        "text": "Das ist der",
        "solution": "Customizer"
      }
    ]
  },
  {
    "id": 840,
    "category": 12,
    "difficulty": 2,
    "text": "Welche Kategorien von PL/SQL-Blöcken gibt es?",
    "explanation": "PL/SQL unterscheidet vier Typen von Blöcken: \n\nEin Anonymer Block ist ein unbenannter PL/SQL-Block, der in einer Anwendung (Prozedur, Funktion ) eingebettet ist oder interaktiv eingegeben wird. \nEine Stored Routine ist ein benannter PL/SQL-Block, der Parameter haben kann und als Prozedur oder Funktion definiert ist. Er wird im Datenbanksystem gespeichert und auf dem Server von der PL/SQL-Engine ausgeführt. \nEin PACKAGE ist ein benannter PL/SQL-Block, der logisch verwandte Prozeduren und Funktionen, Deklarationen etc. zu einer Bibliothek zusammenfasst. \nEin Datenbanktrigger ist ein PL/SQL-Block, der zu einem definierten Ereignis (INSERT, UPDATE oder DELETE) automatisch vom Datenbankmanagementsystem aktiviert und ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Anonyme Blöcke",
        "solution": "true"
      },
      {
        "text": "Pakete",
        "solution": "true"
      },
      {
        "text": "Funktionen",
        "solution": "true"
      },
      {
        "text": "Prozeduren",
        "solution": "true"
      },
      {
        "text": "Datenbanktrigger",
        "solution": "true"
      }
    ]
  },
  {
    "id": 877,
    "category": 12,
    "difficulty": 1,
    "text": "Benannte PL/SQL-Blöcke (anonyme ausgeschlossen)  werden kompiliert in der Datenbank gespeichert.",
    "explanation": "Der in die Oracle-DB integrierte Compiler prüft die Syntax und sichert den übersetzten Code in der Datenbank ab, damit er bei Aufrufen direkt zur Verfügung steht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 843,
    "category": 12,
    "difficulty": 1,
    "text": "Welcher Parametertyp entspricht unter PL/SQL der DEFAULT-Einstellung?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. Bei IN OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "OUT",
        "solution": "false"
      },
      {
        "text": "IN OUT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1694,
    "category": 14,
    "difficulty": 2,
    "text": "Welche Aussagen über \"Transaktionen und Integritätsprüfung in SQL\" sind richtig?",
    "explanation": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integritätsprüfung erkannt, so wird NICHT die gesamte Transaktion zurückgerollt, sondern nur die fehlerhafte Datenmanipulation.\n\nWird vom DBMS ein Fehler bei der DEFERRED-Integritätsprüfung erkannt, so wird die gesamte Transaktion zurückgerollt, denn die DEFERRED-Bedingungen werden ja erst zum Transaktionsende geprüft.\n\nIMMEDIATE bezeichnet die Integritätsprüfung unmittelbar im Anschluss an die Ausführung des DML-Befehls und DEFERRED erst zum Transaktionsende. \n\nIn SQL gibt es fünf CONSTRAINTs mittels denen die Datenintegrität gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wird vom DBMS ein Fehler bei der IMMEDIATE-Integritätsprüfung erkannt, so wird die gesamte Transaktion zurückgerollt.",
        "solution": "false"
      },
      {
        "text": "Wird vom DBMS ein Fehler bei der DEFERRED-Integritätsprüfung erkannt, so wird nur der fehlerhafte DML-Befehl zurückgerollt.",
        "solution": "false"
      },
      {
        "text": "IMMEDIATE bezeichnet die Integritätsprüfung unmittelbar im Anschluss an die Ausführung des DML-Befehls und DEFERRED erst zum Transaktionsende.",
        "solution": "true"
      },
      {
        "text": "In SQL gibt es fünf CONSTRAINTs mittels denen die Datenintegrität gesichert werden kann:\n[NOT] NULL, PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1695,
    "category": 6,
    "difficulty": 2,
    "text": "Ein COLUMN CONSTRAINT kann einen Fremdschlüssel definieren.",
    "explanation": "Klar geht das, alle Tabellen- und Spalten-Constraints haben die gleichen Typen (PRIMARY KEY, CHECK, UNIQUE, Fremdschlüssel) bis auf das [NOT] NULL-Constraint, das gibt es nur bei den Spalten-Constraints. Beim Fremdschlüssel besteht jedoch der syntaktische Unterschied, dass dieses Constraint als Tabellen-Constraint mit der Option FOREIGN KEY startet und als Spalten-Constraint direkt mit REFERENCES. \n\n ::= \n[ CONSTRAINT Constraintname ]  \n[ <CONSTRAINT Characteristika> ] \n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1713,
    "category": 7,
    "difficulty": 3,
    "text": "Wie heißen SELECT-Anweisungen auf die man die Mengenoperationen UNION, INTERSECT und EXCEPT bzw. MINUS anwenden kann?",
    "explanation": "SELECT-Anweisungen heißen <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform , wenn die beteiligten SELECT-Ausdrücke (UNION, INTERSECT und MINUS) die gleichen Spaltendefinitionen haben, also nicht zwingend gleich heißen, sondern nur die Anzahl und die Datentypen und Inhalte kompatibel sind sowie die Reihenfolge übereinstimmen.",
    "type": "text",
    "answers": [
      {
        "text": "Solche Anweisungen heißen",
        "solution": "vereinigungskonform"
      }
    ]
  },
  {
    "id": 1697,
    "category": 6,
    "difficulty": 2,
    "text": "Welche CONSTRAINT-Typen gibt es in SQL?",
    "explanation": "Je nach der Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung) differenziert. \nDen Begriff USER_CONSTRAINTS gibt es nur als Name der Tabelle im Oracle-Data-Dictionary, in der alle angelegten Constraints eingetragen sind, nicht aber als Constraint-Typ. Den Begriff der SEQUENCE CONSTRAINTS gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SEQUENCE CONSTRAINTS",
        "solution": "false"
      },
      {
        "text": "COLUMNS CONSTRAINTS",
        "solution": "true"
      },
      {
        "text": "TABLE CONSTRAINTS",
        "solution": "true"
      },
      {
        "text": "USER_CONSTRAINTS",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1794,
    "category": 3,
    "difficulty": 2,
    "text": "Welche Aussagen über Beziehungen in ER-Modellen sind wahr?",
    "explanation": "Beziehungen beschreiben Aktivitäten zwischen Entity-Mengen, nicht zwischen deren Attributen. \nJede Beziehung hat zwei Enden, entsprechend werden sie auch in beiden Richtungen gelesen und für beide Enden die Kardinalitäten festgelegt. Am Besten ist es, sie immer in beiden Richtungen zu beschriften, damit man die Kardinalität für jedes Ende gelesen und bestimmt hat. Ein häufig gemachter Fehler ist es, nur eine Richtung zu lesen und nur für eine Richtung die Kardinalität festzulegen. \nRekursive Beziehungen sind möglich und werden durch eine Linie von einer Entity-Menge wieder auf sich selbst dargestellt.\nBei einer 1:n- bzw. c:cn-Beziehung wird die Entity-Menge beim 1-Ende als Master bezeichnet und die Entity-Menge beim n-Ende als Detail. \nUnd zwischen zwei Entity-Menen können beliebig viele Beziehungen modelliert werden. Die Anzahl hängt ab von der Semantik der Aufgabenstellung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Beziehungen beschreiben die Aktivitäten zwischen Attributen",
        "solution": "false"
      },
      {
        "text": "Beziehungen haben nur eine Richtung.",
        "solution": "false"
      },
      {
        "text": "Rekursive Beziehungen sind möglich.",
        "solution": "true"
      },
      {
        "text": "Bei einer 1:n- bzw. c:cn-Beziehung wird die Entity-Menge beim 1-Ende als Master bezeichnet und die Entity-Menge beim n-Ende als Detail.",
        "solution": "true"
      },
      {
        "text": "Beziehungen haben nur die Leserichtung von links nach rechts.",
        "solution": "false"
      },
      {
        "text": "Zwischen zwei Entity-Mengen können mehrere Beziehungen modelliert werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1795,
    "category": 3,
    "difficulty": 2,
    "text": "Welche Aussagen über Fremdschlüssel sind wahr?",
    "explanation": "Nein, m:n bzw. cm:cn-Beziehungen werden nicht als Fremdschlüssel  bezeichnet. Es sind ie 1:n bzw. c:cn-Beziehungen, die als Fremdschlüssel bezeichnet werden. \nDie Master-Entitymenge stellt einen Wertebereich für das Fremdschlüsselattribut bei der Detail-Entitymenge dar. Werden Werte für das Fremdschlüsselattribut bei der Detail-Entitymenge eingetragen, so müssen diese Werte mit Werten aus der Master-Entitymenge übereinstimmen. Wenn nicht, kann der Wert der Detail-Entitymenge nicht akzeptiert werden. \nDieser Satz ist falsch: \"Werden Detail-Tupel gelöscht, so wird vom Datenbankmanagementsystem kontrolliert, ob noch abhängige Master-Tupel existieren.\" Es ist genau anders herum: Wenn Master-Tupel gelöscht werden, wird geprüft, ob noch abhängige Detail-Tupel existieren. Wenn ja, kann der Master nicht gelöscht werden. \nAuch dieser Satz ist falsch: \"Werden Master-Tupel eingefügt, so wird vom Datenbankmanagementsystem kontrolliert, ob bereits passende Detail-Tupel existieren.\" Eine Fremdschlüssel-Beziehung ist so definiert, dass dieser Sachverhalt völlig irrelevant ist. Es kann Master-Tupel geben, ohne zugehörige Detail-Tupel. Aber nicht umgekehrt: Es kann keine Detail-Tupel ohne zugehörige Master-Tupel  geben, wenn das Fremdschlüsselattribt nicht leer sein darf. Das hat schon rein praktische Gründe, was sollte man den zuerst erfassen, den Master oder den Detail, wenn der eine den anderen vorraussetzt. Das ginge ja gar nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Als Fremdschlüssel werden m:n bzw. cm:cn-Beziehungen bezeichnet.",
        "solution": "false"
      },
      {
        "text": "Die Master-Entitymenge stellt einen Wertebereich für das Fremdschlüsselattribut bei der Detail-Entitymenge dar.",
        "solution": "true"
      },
      {
        "text": "Werden Detail-Tupel gelöscht, so wird vom Datenbankmanagementsystem kontrolliert, ob noch abhängige Master-Tupel existieren.",
        "solution": "false"
      },
      {
        "text": "Werden Master-Tupel eingefügt, so wird vom Datenbankmanagementsystem kontrolliert, ob bereits passende Detail-Tupel existieren.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1807,
    "category": 5,
    "difficulty": 2,
    "text": "Jede Relation, die die Entity-Integrität besitzt hat, hat neben einem Primärschlüssel auch immer mindestens einen Fremdschlüssel, wenn mehr als zwei Relationen in der Datenbank vorhanden sind.",
    "explanation": "Eine Menge von Relationen R1,...,Rk besitzt die referentielle Integrität, wenn jeder Wert eines Fremdschlüssels einer Relation Ri Wert eines Primärschlüssels in einer anderen Relation Rj ist.  \nEine Menge von Relationen R1,...,Rk besitzt die Entity-Integrität, wenn jede Relation einen Primärschlüssel besitzt. \nDas Konzept Primärschlüssels ist unabhängig von den Fremdschlüsseln. Es kann Relationen mit Primärschlüsseln geben (Entity-intregrität) ohne das es Fremdschlüssel (referentielle Integrität) gibt. Andersherum können Fremdschlüssel nur definiert werden, wenn es Primärschlüssel gibt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1631,
    "category": 7,
    "difficulty": 1,
    "text": "Auf einer Tabelle A soll ein Fremdschlüssel mit Bezug auf die Spalte \"Nr\" der Tabelle B definiert werden. Dazu muss auf der Spalte \"Nr\" in B vorher ein Primärschlüssel oder als UNIQUE KEY angelegt werden.",
    "explanation": "Spalte A gehört der Detailtabelle an und enthält Werte, die Spaltenwerte in B der Mastertabelle referenzieren. Das kann nur funktionieren, wenn die Werte in A eindeutig einen Datensatz der Mastertabelle referenzieren. Dies wird dadurch gewährleistet, dass die referenzierte Spalte B als PRIMARY oder UNIQUE KEY definiert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1714,
    "category": 14,
    "difficulty": 1,
    "text": "Eine Transaktion unter SQL ist",
    "explanation": "Eine SQL-Transaktion ist eine Folge von Änderungsanweisungen, die aus einer oder mehreren SQL-DML- und DQL-Anweisungen (INSERT, UPDATE, DELETE, SELECT) besteht und über die ACID-Eigenschaften verfügt. Die Reihenfolge ergibt sich aus dem zeitlichen Ablauf der Ausführung der DML-Anweisungen. \n\nIn der Wissenschaft wird eine Transaktion oft auch als Menge von Änderungsanweisungen definiert, woraus sich zusätziche interessante Aspekte erforschen lassen ;-)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "eine Folge von Änderungen",
        "solution": "true"
      },
      {
        "text": "eine Menge von Änderungen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1716,
    "category": 14,
    "difficulty": 2,
    "text": "Wie viele Sperrzustände werden beim 2-Phasen-Sperrprotokoll verwendet?",
    "explanation": "Nur die beiden Zustände LOCK und UNLOCK sind sehr \"grob\" und lassen wenig parallen Zugriff zu, da nicht zwischen \"schreiben\" und \"lesen\" differenziert wird. \nDaher wird mit drei Sperrzuständen gearbeitet: \nUNLOCK - entsperrt\nWRITELOCK - exklusiv sperren für einen Schreibzugriff\nREADLOCK - sperren für parallele Lesezugriffe",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1",
        "solution": "false"
      },
      {
        "text": "2",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "true"
      },
      {
        "text": "4",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1715,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Sperren können beim 2-Phasen-Sperrprotokoll gesetzt werden?",
    "explanation": "LOCK ist eine sehr undifferenzierte Sperre, die wenig Parallelität zuläßt, daher wird sie nicht verwendet. \nVerwendet werden: \nREAD_LOCK hingegen läßt paralleles Lesen zu und WRITE_LOCK sorgt für das exclusive Sperren bei Datenänderungen/-einfügungen. \nUNLOCK gibt die gesetzten Sperren wieder frei.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "read_lock",
        "solution": "true"
      },
      {
        "text": "write_lock",
        "solution": "true"
      },
      {
        "text": "lock",
        "solution": "false"
      },
      {
        "text": "unlock",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1718,
    "category": 14,
    "difficulty": 2,
    "text": "Welcher LOCKMODE wird unter ORACLE-SQL automatisch benutzt, wenn ein SELECT ausgeführt wird?",
    "explanation": "Beim SELECT ohne FOR UPDATE-Klausel, wird gar nichts gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten nur angezeigt werden sollen oder wenn \"optimistisches Sperren\" praktiziert wird. \n\nBeim SELECT mit FOR UPDATE-Klausel, werden die selektierten Datensätze exklusiv gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten selektiert werden, die anschließend manipuliert werden sollen oder wenn \"pessimistisches Sperren\" praktiziert wird. \n\nÜbersicht über automatische Sperren bei ORACLE:\n\nSELECT  -  Keine<\nSELECT FOR UPDATE  -  ROW EXCLUSIV-Sperre für die selektierten\nDatensätze\nINSERT  -  ROW EXCLUSIV\nUPDATE  -  ROW EXCLUSIV\nDELETE  -  ROW EXCLUSIV\nALTER TABLE  -  EXCLUSIV",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SHARE",
        "solution": "false"
      },
      {
        "text": "EXCLUSIV",
        "solution": "false"
      },
      {
        "text": "ROW SHARE",
        "solution": "false"
      },
      {
        "text": "ROW EXCLUSIV",
        "solution": "false"
      },
      {
        "text": "SHARE ROW EXCLUSIV",
        "solution": "false"
      },
      {
        "text": "Es wird überhaupt kein LOCK gesetzt",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1719,
    "category": 14,
    "difficulty": 2,
    "text": "Welcher LOCKMODE wird unter ORACLE-SQL automatisch benutzt, wenn ein INSERT, UPDATE oder DELETE ausgeführt wird?",
    "explanation": "Beim SELECT ohne FOR UPDATE-Klausel, wird gar nichts gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten nur angezeigt werden sollen oder wenn \"optimistisches Sperren\" praktiziert wird.\n\nBeim SELECT mit FOR UPDATE-Klausel, werden die selektierten Datensätze exklusiv gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten selektiert werden, die anschließend manipuliert werden sollen oder wenn \"pessimistisches Sperren\" praktiziert wird.\n\nÜbersicht über automatische Sperren bei ORACLE:\n\nSELECT  -  Keine\nSELECT FOR UPDATE  -  ROW EXCLUSIV-Sperre für die selektierten\nDatensätze\nINSERT  -  ROW EXCLUSIV\nUPDATE  -  ROW EXCLUSIV\nDELETE  -  ROW EXCLUSIV\nALTER TABLE  -  EXCLUSIV",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SHARE",
        "solution": "false"
      },
      {
        "text": "EXCLUSIV",
        "solution": "false"
      },
      {
        "text": "ROW SHARE",
        "solution": "false"
      },
      {
        "text": "ROW EXCLUSIV",
        "solution": "true"
      },
      {
        "text": "SHARE ROW EXCLUSIV",
        "solution": "false"
      },
      {
        "text": "Es wird überhaupt kein LOCK gesetzt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1720,
    "category": 14,
    "difficulty": 3,
    "text": "Welcher LOCKMODE wird unter ORACLE-SQL automatisch benutzt, wenn ein ALTER TABLE ausgeführt wird?",
    "explanation": "Beim SELECT ohne FOR UPDATE-Klausel, wird gar nichts gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten nur angezeigt werden sollen oder wenn \"optimistisches Sperren\" praktiziert wird.\n\nBeim SELECT mit FOR UPDATE-Klausel, werden die selektierten Datensätze exklusiv gesperrt. Dieser SELECT wird vom Entwickler verwendet, wenn Daten selektiert werden, die anschließend manipuliert werden sollen oder wenn \"pessimistisches Sperren\" praktiziert wird.\n\nÜbersicht über automatische Sperren bei ORACLE:\n\nSELECT  -  Keine<\nSELECT FOR UPDATE  -  ROW EXCLUSIV-Sperre für die selektierten\nDatensätze\nINSERT  -  ROW EXCLUSIV\nUPDATE  -  ROW EXCLUSIV\nDELETE  -  ROW EXCLUSIV\nALTER TABLE  -  EXCLUSIV",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SHARE",
        "solution": "false"
      },
      {
        "text": "EXCLUSIV",
        "solution": "true"
      },
      {
        "text": "ROW SHARE",
        "solution": "false"
      },
      {
        "text": "ROW EXCLUSIV",
        "solution": "false"
      },
      {
        "text": "SHARE ROW EXCLUSIV",
        "solution": "false"
      },
      {
        "text": "Es wird überhaupt kein LOCK gesetzt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1722,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welchem SQL-Befehl ändert man Daten?",
    "explanation": "Mit der UPDATE-Anweisung unter SQL können Mengen von Daten oder einzelne Datensätze in Tabellen verändert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SAVE",
        "solution": "false"
      },
      {
        "text": "MODIFY",
        "solution": "false"
      },
      {
        "text": "UPDATE",
        "solution": "true"
      },
      {
        "text": "SAVE AS",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1723,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welcher SQL-Anweisung löscht man Daten aus einer Tabelle, ohne die Tabellendefinition zu löschen?",
    "explanation": "Die DROP-Anweisung löscht auch die Tabellendefinitionen, die anderen Anweisungen gibt es unter SQL nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "REMOVE",
        "solution": "false"
      },
      {
        "text": "DELETE",
        "solution": "true"
      },
      {
        "text": "DROP",
        "solution": "false"
      },
      {
        "text": "COLLAPSE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1724,
    "category": 7,
    "difficulty": 1,
    "text": "Mit welcher SQL-Anweisung fügt man Daten in eine Tabelle ein?",
    "explanation": "Eine INSERT-Anweisung hat unter SQL immer ein INTO, die anderen Anweisungen gibt es unter SQL nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSERT INTO",
        "solution": "true"
      },
      {
        "text": "INSERT NEW",
        "solution": "false"
      },
      {
        "text": "ADD",
        "solution": "false"
      },
      {
        "text": "ADD RECORD",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1725,
    "category": 7,
    "difficulty": 1,
    "text": "Wie liest man alle Daten aus einer Tabelle \"Test\" unter Standard-SQL aus?",
    "explanation": "SELECT * FROM Test ist korrekt,  die anderen Anweisungen entsprechen nicht dem SQL-Standard.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT Test;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM Test;",
        "solution": "true"
      },
      {
        "text": "SELECT ALL FROM Test;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1726,
    "category": 4,
    "difficulty": 3,
    "text": "Wie heißen Tupel, die bei einem Natural Join verloren gehen können?",
    "explanation": "Beim natürlichen Join werden diejenigen Tupel, die nur in einer Relation vorkommen, unterdrückt. Diese Tupel bezeichnet man auch als \"Dangeling\"-Tupel (dangling tuples).",
    "type": "text",
    "answers": [
      {
        "text": "Diese Tupel heißen (englischsprachiger Begriff, alles kleingeschrieben):",
        "solution": "dangling tupels"
      }
    ]
  },
  {
    "id": 1997,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Tupel hat der Natural Join der Tabelle Test mit sich selber?",
    "explanation": "Der Natural Join einer Tabelle mit sich selber ergibt wieder die Ursprungstabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "5",
        "solution": "true"
      },
      {
        "text": "25",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1998,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Tupel hat das kartesische Produkt der Tabelle Test mit sich selber?",
    "explanation": "Beim kartesischen Produkt wird jedes Tupel mit der beteiligten Tabellen miteinander verknüpft, im Beispiel ergibt das 5 * 5 = 25 Tupel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "5",
        "solution": "false"
      },
      {
        "text": "10",
        "solution": "false"
      },
      {
        "text": "25",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1999,
    "category": 7,
    "difficulty": 2,
    "text": "JOIN-Verknüpfungen können nicht über Binary Large Object-Spalten (BLOBS) ausgeführt werden.",
    "explanation": "Der Vergleich über Binärwerte ist wohl etwas aufwendig :-).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2008,
    "category": 3,
    "difficulty": 1,
    "text": "Ternäre Beziehungen lassen sich immer in binäre Beziehungen auflösen, ohne eine Entity-Menge hinzuzufügen.",
    "explanation": "Um ternäre Beziehungen in binäre Beziehungen aufzulösen, braucht man eine zusätzliche Entity-Menge.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1957,
    "category": 7,
    "difficulty": 2,
    "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr}\n\nAbteilungen hat den Primärschlüssel Abt_nr und den Fremdschlüssel Leiter_Ang_Nr.\nAngestellte hat den Primärschlüssel Ang_nr und den Fremdschlüssel Abt_Nr.\n\nWelche der folgenden SELECT-Anweisungen liefern das gleiche Ergebnis?",
    "explanation": "RICHTIG sind: \nDie Anfragen \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ORT = Abteilungen.ORT AND Angestellte.Ang_Nr = Abteilungen.ABT_Nr;\" \nund \n\"SELECT * FROM Angestellte NATURAL JOIN Abteilungen;\"\nhaben die gleiche Semantik: \"Welche Mitarbeiter arbeiten im gleichen Ort, in dem sie auch wohnen?\"\n\nOb Fremd-, Eíndeutigkeits- oder Primärschlüssel auf diesen Spalten definiert sind, ist unerheblich für die Ausführung des NATURAL JOINs, dessen Bedingung alle gleich lautenden Spalten auf Gleichheit prüft und mit AND verknüpft.\n\n\nFALSCH ist: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nhat die Semantik: \"Welche Mitarbeiter arbeiten in welchen Abteilungen?\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr;",
        "solution": "true"
      },
      {
        "text": "SELECT *\nFROM Angestellte NATURAL JOIN Abteilungen;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2040,
    "category": 3,
    "difficulty": 1,
    "text": "Ein Fremdschlüssel kann auch rekursiv definiert werden, d.h. der Primärschlüssel einer Entity-Menge kann als Fremdschlüssel in der gleichen Entity-Menge verwendet werden.",
    "explanation": "Diese Rekursivität ist im ER-Modell vorgesehen, auch wenn hier die Frage nach Henne und Ei ungelöst bleibt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2018,
    "category": 3,
    "difficulty": 3,
    "text": "Ein EERM enthält zusätzlich zu den klassischen Beziehungsarten und Domänen",
    "explanation": "Ein ER-Modell, das zusätzlich zu den klassischen Beziehungsarten IS-A-Beziehungen und Aggregation sowie mehrwertige und zusammengesetzte Attribute vorsieht, bezeichnen wir als EERM.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Assoziationen",
        "solution": "false"
      },
      {
        "text": "Aggregationen",
        "solution": "true"
      },
      {
        "text": "IS-A-Beziehungen",
        "solution": "true"
      },
      {
        "text": "mehrwertige Attribute",
        "solution": "true"
      },
      {
        "text": "zusammengesetzte Attribute",
        "solution": "true"
      },
      {
        "text": "zeitabhängige Attribute",
        "solution": "false"
      },
      {
        "text": "IST-Teil-von-Beziehungen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2044,
    "category": 4,
    "difficulty": 1,
    "text": "Ein Operatorbaum wächst",
    "explanation": "Um Anfragen an einen Datenbestand zu formulieren, können Operationen der relationalen Algebra beliebig ineinander geschachtelt werden. Bei komplexen Anfragen ist daher die oben verwendete sogenannte \"Inline-Notation\" schwer lesbar. Für diesen Zweck verwendet man Operatorbäume statt der Inline-Notation. Bei dieser grafischen Darstellung erstellt und liest man die Abfrage von unten nach oben. Operationen, die miteinander verknüpft sind, sind durch Kanten im Graphen miteinander verbunden. Gestartet wird mit den relvanten Relationen als unterster Teil des OP-Baumes.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "von unten nach oben",
        "solution": "true"
      },
      {
        "text": "von oben nach unten",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2046,
    "category": 5,
    "difficulty": 3,
    "text": "Welche Aussagen über Zerlegungen von Relationen sind beim Übergang in die 2NF bzw. 3NF korrekt?",
    "explanation": "Wiederherstellbarkeit: Eine Zerlegung einer Relation ist verlustfrei, wenn sich alle Tupel der ursprünglichen Relation durch einen Join aus den abgeleiteten Relationen wiederherstellen lassen. Eine verlustfreie Zerlegung stellt damit die Wiederherstellbarkeit der ursprünglichen Relation sicher. \nAbhängigkeitswahrung: Die Zerlegung einer Relation ist abhängigkeitstreu, wenn jede funktionale Abhängigkeit der Ausgangsrelation in einer der resultierenden Relationen erhalten bleibt. Eine abhängigkeitstreue Zerlegung stellt damit die Wiederherstellbarkeit der ursprünglichen funktionalen Abhängigkeiten sicher. \n  \nEine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Primärschlüssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine verlustfreie Zerlegung sichert die Wiederherstellbarkeit der ursprünglichen Relation.",
        "solution": "true"
      },
      {
        "text": "Eine abhängigkeitstreue Zerlegung sichert die Wiederherstellbarkeit der ursprünglichen Relation.",
        "solution": "false"
      },
      {
        "text": "Eine abhängigkeitstreue Zerlegung sichert die Wiederherstellbarkeit der ursprünglichen funktionalen Abhängigkeiten.",
        "solution": "true"
      },
      {
        "text": "Eine verlustfreie Zerlegung sichert die Wiederherstellbarkeit der ursprünglichen funktionalen Abhängigkeiten.",
        "solution": "false"
      },
      {
        "text": "Die 2NF beseitigt alle transitiven Abhängigkeiten",
        "solution": "false"
      },
      {
        "text": "Die 3NF beseitigt alle partiellen Abhängigkeiten",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2051,
    "category": 6,
    "difficulty": 1,
    "text": "Welche Aussagen über Fremdschlüssel-Beziehungen sind richtig?",
    "explanation": "Klar geht das, alle Tabellen- und Spalten-Constraints haben die gleichen Typen (PRIMARY KEY, CHECK, UNIQUE, Fremdschlüssel) bis auf das [NOT] NULL-Constraint, das gibt es nur bei den Spalten-Constraints. Beim Fremdschlüssel besteht jedoch der syntaktische Unterschied, dass dieses Constraint als Tabellen-Constraint mit der Option FOREIGN KEY startet und als Spalten-Constraint direkt mit REFERENCES. Die Semantik bleibt jedoch in beiden Fällen gleich \n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ] \n\n ::= \nNOT NULL\n| PRIMARY KEY\n| UNIQUE\n| \n| CHECK (  )\n\n ::=\n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Fremdschlüssel-Constraints können nur als Tabellen-Constraints definiert werden.",
        "solution": "false"
      },
      {
        "text": "Fremdschlüssel-Constraints können nur als Spalten-Constraints definiert werden.",
        "solution": "false"
      },
      {
        "text": "Fremdschlüssel-Constraints können sowohl als Tabellen- wie auch Spalten-Constraint definiert werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1907,
    "category": 13,
    "difficulty": 1,
    "text": "Im SQL-Standard und bei ORACLE gibt es auch Trigger, die mit COMMIT bzw. ROLLBACK ausgelöst werden.",
    "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1935,
    "category": 13,
    "difficulty": 1,
    "text": "Die NEW-Variablen sind in BEFORE TRIGGERN beschreibbar.",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. NEW-Variablen sind beschreibbar, wenn Sie existieren. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1970,
    "category": 9,
    "difficulty": 2,
    "text": "Ein benutzerdefinierter Datentyp unter ORACLE ist immer instanzierbar",
    "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint. \n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1913,
    "category": 14,
    "difficulty": 1,
    "text": "Welcher Modus ist bei ORACLE als DEFAULT voreingestellt?",
    "explanation": "Bei ORACLE ist die Standardarbeitsweise AUTOCOMMIT OFF, d.h. in diesem Modus können Transaktionen bei ORACLE aus mehr als nur einer DML-Anweisung bestehen. Soll eine Transaktion beendet werden, so muss der Anwender explizit COMMIT eingeben. \n  \nBei MYSQL ist das ganz anders, dort ist AUTOCOMMIT ON die übliche Arbeitsweise. Somit wird bei MYSQL nach jeder SQL-Anweisung automatisch ein COMMIT durchgeführt, eine Eingabe des Befehls ist hier nicht notwendig. Transaktionen bestehen also nur aus genau einer SQL-Anweisung.  \n  \nBei beiden DB-Systemen kann der Modus entsprechend umgesetzt werden. z.B.: \nSET AUTOCOMMIT Anweisung (Oracle)> ::=\n   SET AUTOCOMMIT { OFF | ON };",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "AUTOCOMMIT ON",
        "solution": "false"
      },
      {
        "text": "AUTOCOMMIT OFF",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1914,
    "category": 14,
    "difficulty": 1,
    "text": "Bei ORACLE können Sperren (LOCKS) auch auf Sichten vergeben werden.",
    "explanation": "Bei Oracle werden Sichten weitgehend wie Tabellen behandelt. Es sind DML-Operationen (INSERT, UPDATE, DELETE) auf Sichten erlaubt und damit müssen auch LOCKs auf Sichten gesetzt werden können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1917,
    "category": 15,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation mit vier Spalten. \nWie viele Indizes kann man  anlegen?",
    "explanation": "Bei vier Spalten berechnet sich die Anzahl der mögliche Indizes x nach der Formel: x = Summe [k=1..n] (n!/(n-k)!), wobei n! die Fakultät ist.Für n= 4 erhält man:    x = 4x3x2x1 + 4x3x2 + 4x3 + 4 = 64Für n= 3 bei drei Spalten entsprechend:    x = 3x2x1 + 3x2 + 3x1 = 15Das ist die Anzahl der möglichen nicht leeren geordneten Teilmengen einer vierelementigen Menge. Diese Mengen heißen in der Kombinatorik Variationen, siehe auch http://de.wikipedia.org/wiki/Abzählende_Kombinatorik.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "1",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "false"
      },
      {
        "text": "5",
        "solution": "false"
      },
      {
        "text": "9",
        "solution": "false"
      },
      {
        "text": "15",
        "solution": "false"
      },
      {
        "text": "18",
        "solution": "false"
      },
      {
        "text": "64",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1918,
    "category": 15,
    "difficulty": 2,
    "text": "Betrachten Sie eine Relation mit zwei Spalten. \nWie viele Indizes kann man  anlegen?",
    "explanation": "Die Reihenfolge der Attribute spielt ja eine Rolle, daher 4 Kombinationsmöglichkeiten bei zwei Spalten a, b: \na, b, \nab, ba,",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1",
        "solution": "false"
      },
      {
        "text": "2",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "false"
      },
      {
        "text": "4",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1933,
    "category": 12,
    "difficulty": 3,
    "text": "Mit welchem SQL - Statement räumt man allen Benutzern Ausführungsrechte auf einer gespeicherten Prozedure Test ein (mit Semikolon schreiben)?",
    "explanation": "GRANT EXECUTE on Test TO PUBLIC; räumt diese Rechte allen Benutzern ein, GRANT EXECUTE on Test TO Hugo; nur dem  DB-Benutzer Hugo.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "GRANT EXECUTE on Test TO PUBLIC;"
      }
    ]
  },
  {
    "id": 1936,
    "category": 13,
    "difficulty": 1,
    "text": "In BEFORE-Triggern sind unter ORACLE auch DML-Operationen zugelassen.",
    "explanation": "Dies ist der Grund für das Mutating-Table-Problem, dass nur unter Oracle auftritt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1937,
    "category": 13,
    "difficulty": 2,
    "text": "In Before-Triggern sind im Standard SQL2003 auch DML-Operationen zugelassen.",
    "explanation": "Dies ist der Grund für das Mutating-Table-Problem, dass nur unter Oracle auftritt, also nicht im SQL-Standard.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1971,
    "category": 9,
    "difficulty": 2,
    "text": "Zur Definition einer Object-View ist ein selbstdefinierter Type (CREATE TYPE...) notwendig",
    "explanation": "Die Definition einer Objekt-Sicht (View) ist hier analog einer Objekttabelle möglich.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2011,
    "category": 3,
    "difficulty": 2,
    "text": "Welche Aussagen über das EERM sind wahr?",
    "explanation": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen ergänzt werden können. \nEin weiterer wichtiger Beziehungstyp ist die Aggregation, die die \"Ist Teil von\" Beziehung beschreibt. Mithilfe dieses Beziehungstyps lassen sich komplexe Objekte modellieren. Beispielsweise ist es möglich, in der ER-Modellierung von Byce & Co. auf die Struktur-Entity-Menge zu verzichten und stattdessen die Bestandteile eines Fahrrads explizit aufzulisten. \nUnter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp, und unter einer Generalisierung den genau umgekehrten Prozess, die Gewinnung eines Supertypen aus gegebenen Subtypen. \nEin System von Subtypen und Supertypen nennt man vollständig, wenn der Supertyp keine eigenen Elemente enthält, also jedes Element in einem der Subtypen enthalten ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen ergänzt werden können.",
        "solution": "true"
      },
      {
        "text": "Eine Aggregation ist eine Beziehung zwischen einem Supertyp und einem Subtyp, wobei der Subtyp alle Attribute des Supertyps erbt, die um eigene Attribute und Beziehungen ergänzt werden können.",
        "solution": "false"
      },
      {
        "text": "Unter einer Generalisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.",
        "solution": "false"
      },
      {
        "text": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.",
        "solution": "true"
      },
      {
        "text": "Ein System von Subtypen und Supertypen heißt vollständig, wenn die einzelnen Subtypen keine gemeinsamen Elemente haben.",
        "solution": "false"
      },
      {
        "text": "Ein System von Subtypen und Supertypen nennt man vollständig, wenn der Supertyp keine eigenen Elemente enthält, also jedes Element in einem der Subtypen enthalten ist.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2023,
    "category": 4,
    "difficulty": 2,
    "text": "Welcher Typkonstruktor hat homogene Elemente und erlaubt keine Duplikate?",
    "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschränkter Kardinalität), \nLIST (ohne Beschränkung der Kardinalität).  \nInhomogene (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogene (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SET",
        "solution": "true"
      },
      {
        "text": "ROW",
        "solution": "false"
      },
      {
        "text": "UNION",
        "solution": "false"
      },
      {
        "text": "ARRAY",
        "solution": "false"
      },
      {
        "text": "LIST",
        "solution": "false"
      },
      {
        "text": "MULTISET",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2024,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Typkonstruktoren hat die relationale Algebra?",
    "explanation": "Wir nähern uns dem grundlegenden relationalen Modell auf zwei Wegen: zum einen als Teilmenge eines kartesischen Produkts im mathematischen Sinn und zum anderen als Datenmodell, welches als Typkonstruktoren nur SET und ROW benutzt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ROW",
        "solution": "true"
      },
      {
        "text": "UNION",
        "solution": "false"
      },
      {
        "text": "SET",
        "solution": "true"
      },
      {
        "text": "ARRAY",
        "solution": "false"
      },
      {
        "text": "LIST",
        "solution": "false"
      },
      {
        "text": "MULTISET",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2060,
    "category": 6,
    "difficulty": 1,
    "text": "Welche Typen von Integritätsbedingungen gibt es?",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \n\nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen  beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingungen",
        "solution": "true"
      },
      {
        "text": "dynamische, transitionale Bedingungen",
        "solution": "true"
      },
      {
        "text": "statische, transitionale Bedingungen",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingungen",
        "solution": "true"
      },
      {
        "text": "statische, temporale Bedingungen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1980,
    "category": 7,
    "difficulty": 3,
    "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Standort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche Abfragen liefern das gleiche Ergebnis, wenn die Tabellen mit Daten gefüllt sind?",
    "explanation": "RICHTIG ist: \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr\nAND  Angestellte.Ang_Nr = Abteilungen.Ang_Nr;\" \nweil ein Natural Join, über alle Spalten dieser Tabellen, die gleich heißen, Abt_Nr, Ang_Nr, auf Gleichheit verglichen werden und die Teilbedingungen mit AND verknüpft werden. \noder diese Anfrage: \nSELECT * FROM Angestellte NATURAL JOIN Abteilungen;\n\n\nDie Semantik dieses natürlichen Joins heißt: \"Welche Mitarbeiter arbeiten in Abteilungen, deren Leiter sie sind?\"\n\n\nFALSCH sind:\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verknüpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.Ort = Abteilungen.Standort AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN, weil über zwei Spalten verglichen wird, die nicht gleich heißen: \"Angestellte.Ort = Abteilungen.Standort\". \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen AND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN, weil nur über eine gleich heißende Spalte verknüpft wird und nicht über alle beide.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.ORT = Abteilungen.STANDORT\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM     Angestellte, Abteilungen\nAND Angestellte.ABT_Nr = Abteilungen.ABT_Nr;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ang_Nr = Abteilungen.Ang_Nr\nAND   Angestellte.ABT_Nr = Abteilungen.ABT_Nr;",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM \nAngestellte NATURAL JOIN Abteilungen;",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1958,
    "category": 7,
    "difficulty": 3,
    "text": "Worauf muss man bei Gruppierungen in SQL achten?",
    "explanation": "Die WHERE-Klausel bezieht sich auf einzelne Tupel, daher sind Aggregationsfunktionen nicht zulässig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nach allen nicht aggregierten Projektionsattributen der SELECT-Klausel muss gruppiert werden.",
        "solution": "true"
      },
      {
        "text": "In der SELECT-Klausel darf nur auf aggregierte Attribute projiziert werden.",
        "solution": "false"
      },
      {
        "text": "Die WHERE-Klausel darf keine Aggregationsfunktionen (SUM, AVG, MIN, MAX, COUNT) benutzen.",
        "solution": "true"
      },
      {
        "text": "Die Having-Klausel darf keine Aggregationsfunktionen (SUM, AVG, MIN, MAX, COUNT) benutzen.",
        "solution": "false"
      },
      {
        "text": "In der WHERE-Klausel dürfen nur Gruppierungsattribute auftreten.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1934,
    "category": 12,
    "difficulty": 2,
    "text": "In der DECLARE-Komponente eines CURSORS kann auch eine SELECT-INTO-Anweisung stehe.",
    "explanation": "SELECT INTO ist nur bei impliziten Cursorn vorgesehen, die genau einen Wert liefern und ohne explizite Cursordefinition benutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1959,
    "category": 7,
    "difficulty": 1,
    "text": "Wenn in durch AVG aggregierten Attributen NULL-Werte auftreten, dann",
    "explanation": "Null-Werte werden in Gruppenfunktionen (AVG, SUM, COUNT, MIN und MAX) einfach ignoriert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "wird das ganze Ergebnis zu NULL",
        "solution": "false"
      },
      {
        "text": "geht das Tupel mit 0 in die Berechnung ein",
        "solution": "false"
      },
      {
        "text": "wird das Tupel in der Berechnung ignoriert",
        "solution": "true"
      },
      {
        "text": "wird ein Fehler ausgegeben",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1977,
    "category": 4,
    "difficulty": 1,
    "text": "Ein natürlicher Join (Natural Join) unterdrückt",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "doppelte Attribute (gleicher Attributname)",
        "solution": "true"
      },
      {
        "text": "doppelte Tupel",
        "solution": "false"
      },
      {
        "text": "keins von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1978,
    "category": 12,
    "difficulty": 3,
    "text": "Wie gibt man unter PL/SQL Übersetzungsfehler aus?",
    "explanation": "RAISE und RAISE_APPLICATION_ERROR werfen einen Fehler, dem man eine eigene Fehlermeldung zuordnen kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "RAISE_APPLICATION_ERROR (.....)",
        "solution": "false"
      },
      {
        "text": "RAISE (.....)",
        "solution": "false"
      },
      {
        "text": "SHOW ERRORS",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM USER_ERRORS",
        "solution": "true"
      },
      {
        "text": "keine  von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2022,
    "category": 4,
    "difficulty": 3,
    "text": "Welcher Typkonstruktor hat homogene Elemente und erlaubt Duplikate?",
    "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschränkter Kardinalität), \nLIST (ohne Beschränkung der Kardinalität).  \nInhomogene (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogene (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SET",
        "solution": "false"
      },
      {
        "text": "ROW",
        "solution": "false"
      },
      {
        "text": "UNION",
        "solution": "false"
      },
      {
        "text": "ARRAY",
        "solution": "true"
      },
      {
        "text": "LIST",
        "solution": "true"
      },
      {
        "text": "MULTISET",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2030,
    "category": 4,
    "difficulty": 1,
    "text": "Welche Outer-Join-Operatoren gibt es in der relationalen Algebra?",
    "explanation": "Der linke Outer-Join (linker äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdrückt werden, als Tupel mit\naufgeführt und in den Attributen, die zu R2 gehören, mit NULL-Werten aufgefüllt werden. \nDer rechte Outer-Join (rechter äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdrückt werden, als Tupel mit aufgeführt und in den Attributen, die zu R1 gehören, mit NULL-Werten aufgefüllt werden.  \nDer Full Outer-Join (beidseitiger, vollständiger äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgefüllt\nwerden, die beim natürlichen Join herausfallen würden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Vollständiger Outer-Join",
        "solution": "true"
      },
      {
        "text": "Rechter Outer-Join",
        "solution": "true"
      },
      {
        "text": "Halber Outer-Join",
        "solution": "false"
      },
      {
        "text": "Linker Outer Join",
        "solution": "true"
      },
      {
        "text": "Super Outer-Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2064,
    "category": 6,
    "difficulty": 3,
    "text": "Der SQL-Ausdruck UNIQUE kann verwendet werden:",
    "explanation": "Ein INDEX verbessert den Datenzugriff durch den Aufbau von gut zu durchsuchenden separaten Verzeichnissen der Gestalt (Wert, Adresse). Die Spaltenwerte eines solchen Index können nun optional eindeutig (UNIQUE) sein oder nicht.\n \n\n<CREATE INDEX Anweisung> ::= \nCREATE [UNIQUE] INDEX Indexname ON Tabellenname  \n       (Spaltenname [, Spaltenname]... );\n \n\nUNIQUE ist einer der 5 SQL-Constraints und zwar der für die Eindeutikeitsschlüssel (Zweitschlüssel aus dem relationalen Modell) und bestimmt eine oder mehrere Spalten als eindeutigen Schlüssel. Die Werte dieser Schlüsselspalten erlauben keine Duplikate, dürfen jedoch NULL-Werte enthalten. Mehrere UNIQUE KEYS sind je Tabelle definierbar. Für die Schlüsselspalten wird automatisch ein INDEX angelegt.\n \nHier das Syntaxbeispiel für die Tabellen-Constraints, gleiches gilt aber auch für die Spalten-Constraints:\n \n ::=\nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... ) \n| CHECK (  )",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "bei CONSTRAINTS",
        "solution": "true"
      },
      {
        "text": "in einer CREATE-INDEX-Anweisung",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1947,
    "category": 7,
    "difficulty": 3,
    "text": "Mit welchem Operator werden auch auch mehrfach vorkommenden Datensätze des gleichen Satzaufbaus vereinigt?",
    "explanation": "UNION unterdrückt mehrfach vorkommende Datensätze, bei UNION ALL bleiben sie erhalten.",
    "type": "text",
    "answers": [
      {
        "text": "Dieser  Operator heißt:",
        "solution": "UNION ALL"
      }
    ]
  },
  {
    "id": 1981,
    "category": 7,
    "difficulty": 3,
    "text": "Wie viele Tupel liefert der folgende SELECT ausgeführt auf einer Angestellten-Tabelle mit 10 Datensätzen, die sich auf 4 Abteilungen verteilen: \n\nSELECT AVG(AVG(Gehalt)) FROM Angestellte GROUP BY ABT_NR;",
    "explanation": "Die innere Aggregation AVG((Gehalt) ermittelt die Durchschnittsgehälter je Gruppe, also je Abteilung und damit für 4 Datensätze. \nDie äußere Aggregation AVG(AVG((Gehalt)) ermittelt das Durchschnittsgehalt aller Durchschnittsgehälter der Abteilungen und damit bleibt letztlich 1 Datensatz übrig.",
    "type": "text",
    "answers": [
      {
        "text": "Die Zahl ist",
        "solution": "1"
      }
    ]
  },
  {
    "id": 2007,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Regeln gehören zu den zwölf Basisregeln, die E.F. Codd für relationale Datenbanksysteme aufstellte?",
    "explanation": "E. F. Codd, einer der Begründer der relationalen Datenbanken, beschreibt\nzwölf Basisregeln, die eine relationale Datenbank auszeichnen,\nsich aber auch auf andere Datenbanktypen verallgemeinern lassen\n\nRegel 1: Informationsregel\nJede Information einer relationalen Datenbank wird in genau einer Weise durch Werte in\nRelationen dargestellt und damit redundanzfrei und einheitlich verwaltet. \n\nRegel 2: Garantierter Zugriff\nJedes einzelne Feld der Datenbank ist durch eine Kombination von Relationsname,\nPrimärschlüssel und Spaltenname erreichbar.\n\nRegel 3: Systematische Behandlung fehlender Information\nIn einer relationalen Datenbank müssen Spalten mit fehlender Information (Nullwerte)\neinheitlich darstellbar sein. Diese Nullwerte werden systematisch als fehlende\nInformation von den Standardwerten (z.B. Strings mit Leerzeichen) unterschieden.\nSpalten können auch so eingerichtet werden, dass Nullwerte nicht erlaubt sind.\n\nRegel 4: Dynamischer Online-Katalog (Data Dictionary)\nEin Datenbankschema wird in derselben Weise wie die gespeicherten Daten selbst\nbeschrieben ¿ nämlich in Tabellen, dem sogenannten Data Dictionary. Autorisierte\nBenutzer können das Data Dictionary in gleicher Weise abfragen wie die eigentliche\nDatenbasis.\n\nRegel 5: Allumfassende Sprache\nEin Datenbanksystem muss eine Sprache unterstützen, die allumfassend sein, d.h. sie \nerfüllt die folgenden Aufgaben:\nDefinition der Benutzerdaten,\nDefinition von Sichten als virtuelle Tabellen,\nManipulation von Benutzerdaten,\nÜberprüfung von Integritätsregeln,\nVergabe von Benutzerrechten und Autorisierung,\nTransaktionskontrolle und Transaktionshandling \n\nRegel 6: Benutzersichten und Datenänderungen\nFür unterschiedliche Benutzergruppen und Anwendungen sind unterschiedliche\nSichten (Views) auf die Datenbank notwendig. In einfachen Views, z.B. Teilansichten\neiner Tabelle, sollen auch Datenänderungen möglich sein.\n\nRegel 7: HIGH-LEVEL INSERT, UPDATE und DELETE\nIn der Datenbank muss das Einfügen, Ändern und Löschen von Daten möglich sein.\nDabei soll das System sich den optimalen Zugriffspfad zur schnellen Durchführung\nder Transaktion selbst suchen.\n\nRegel 8: Physische Datenunabhängigkeit\nAnwendungsprogramme und Anwenderoberflächen bleiben unverändert, wenn Veränderungen\nan der Speicherstruktur oder der Zugriffsmethode in der Datenbank vorgenommen werden.\n\nRegel 9: Logische Datenunabhängigkeit\nAnwendungsprogramme und Anwenderoberflächen bleiben unverändert, wenn sich\nBasisrelationen verändern, die nicht direkt die Anwendungsprogramme betreffen. \n\nRegel 10: Integritätsunabhängigkeit\nIntegritätsbedingungen, die von der Datenbank erfüllt werden müssen, werden mithilfe\nder relationalen Datenbanksprache definiert, im Data Dictionary abgelegt und\nvom DBMS ausgeführt. Diese Integritätsbedingungen gehören nicht ins Anwenderprogramm.\n\nRegel 11: Verteilungsunabhängigkeit\nEine relationale Datenbank besitzt die Verteilungsunabhängigkeit. Das heißt, die Anwendungsprogramme\nbleiben unverändert, wenn die verteilte Datenhaltung auf mehreren\nRechnern eingeführt oder wieder zurückgenommen wird und mehrere Datenbanken zu\neiner Datenbank zusammengelegt werden.\n\nRegel 12: Unterwanderungsverbot\nFalls das DBMS eine andere 3GL-Sprache wie C oder Java zulässt, darf diese Sprache\nnicht die aufgestellten Regeln 1 bis 11 ver",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Informationsregel",
        "solution": "true"
      },
      {
        "text": "Physische Datenunabhängigkeit",
        "solution": "true"
      },
      {
        "text": "Unterwanderungsverbot",
        "solution": "true"
      },
      {
        "text": "Persistencesicherung",
        "solution": "false"
      },
      {
        "text": "Veränderungsgebot",
        "solution": "false"
      },
      {
        "text": "Garantierter Zugriff",
        "solution": "true"
      },
      {
        "text": "Sicherheitsregel",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2009,
    "category": 3,
    "difficulty": 3,
    "text": "Welche Aussagen über schwache Entity-Mengen sind wahr?",
    "explanation": "Schwache Entity-Mengen hängen in ihrer Existenz von einer übergeordneten Entity-Menge ab und haben einen (zusammengesetzten) Schlüssel, der den Primärschlüssel der übergeordneten Entity-Menge als Teilschlüssel hat. Grafisch werden sie durch ein doppelt gezeichnetes Rechteck dargestellt. Da der Schlüssel der schwachen Entity-Mengen den übergeordneten Primärschlüssel als Teilschlüssel enthält, ist die Beziehung zu Master-Entity-Menge immer identifizierend.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Bei schwachen Entity-Mengen ist die Beziehung zur Master-Entity-Menge immer identifizierend.",
        "solution": "true"
      },
      {
        "text": "Bei schwachen Entity-Mengen ist die Beziehung zur Master-Entity-Menge nie identifizierend.",
        "solution": "false"
      },
      {
        "text": "Jede identifizierende Beziehung erzeugt eine schwache Entity-Menge.",
        "solution": "false"
      },
      {
        "text": "Jede nicht identifizierende Beziehung erzeugt eine schwache Entity-Menge.",
        "solution": "false"
      },
      {
        "text": "Jede schwache Entity-Menge hat einen zusammengesetzten Primärschlüssel.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2020,
    "category": 4,
    "difficulty": 2,
    "text": "Welche Typkonstruktoren sind homogen?",
    "explanation": "Homogene Elemente lassen nur Elemente gleichen Typs zu, dazu gehören: ARRAY, LIST, MULTISET und SET. \nInhomogene Elemente lassen nur Elemente unterschiedlichen Typs zu, dazu gehören: ROW und UNION",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SET",
        "solution": "true"
      },
      {
        "text": "ROW",
        "solution": "false"
      },
      {
        "text": "UNION",
        "solution": "false"
      },
      {
        "text": "ARRAY",
        "solution": "true"
      },
      {
        "text": "LIST",
        "solution": "true"
      },
      {
        "text": "MULTISET",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2021,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Typkonstruktoren sind homogen und geordnet?",
    "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschränkter Kardinalität), \nLIST (ohne Beschränkung der Kardinalität).  \nInhomogene (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogene (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SET",
        "solution": "false"
      },
      {
        "text": "ROW",
        "solution": "false"
      },
      {
        "text": "UNION",
        "solution": "false"
      },
      {
        "text": "ARRAY",
        "solution": "true"
      },
      {
        "text": "LIST",
        "solution": "true"
      },
      {
        "text": "MULTISET",
        "solution": "false"
      }
    ]
  },
  {
    "id": 637,
    "category": 2,
    "difficulty": 3,
    "text": "Welche Komponenten gehören zu einem Datenbankschema?",
    "explanation": "In der Entwurfsphase wird das konzeptionelle Schema auf ein relationales Datenbankschema abgebildet und eine Normalisierung durchgeführt. Das Datenbankschema ist ein auf den Datenbanktyp abgestimmtes Datenmodell, im relationalen Fall also ein relationales Schema, bestehend aus miteinander verknüpften Relationen.\n\n    \n\n    Ferner wird das Schema ergänzt um einzelne Benutzersichten, Indexangaben zur Zugriffsoptimierung und Speicherstrukturen, wie B-Baum, oder HASH- Verfahren sowie die Zugriffsrechte der Benutzer im Multiuser-System.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Normalisierte Relationen",
        "solution": "true"
      },
      {
        "text": "Primärschlüssel",
        "solution": "true"
      },
      {
        "text": "Fremdschlüssel",
        "solution": "true"
      },
      {
        "text": "Beziehungen",
        "solution": "false"
      },
      {
        "text": "Wertebereiche der Attribute",
        "solution": "true"
      },
      {
        "text": "Indizes",
        "solution": "true"
      },
      {
        "text": "Überblick über Zugriffsrechte",
        "solution": "true"
      },
      {
        "text": "Spezielle Benutzersichten (Views)",
        "solution": "true"
      },
      {
        "text": "SQL-Skripte",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2031,
    "category": 4,
    "difficulty": 1,
    "text": "Ein Outer-Join ist eine Spezialform des Natural-Joins",
    "explanation": "Ein Natural Join liefert nur eine Teilmenge der Tupel, die ein Outer-Join liefern würde, namlich die Tupel, die in beiden Relationen enthalten sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2032,
    "category": 4,
    "difficulty": 1,
    "text": "Ein vollständiger Outer-Join ist immer verlustfrei.",
    "explanation": "Eine Join-Operation  zwischen R und S heißt verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2041,
    "category": 4,
    "difficulty": 2,
    "text": "Welcher Typkonstruktor ist homogen, hat geordnete Elemente und beschränkte Kardinalität?",
    "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschränkter Kardinalität), \nLIST (ohne Beschränkung der Kardinalität).  \nInhomogene (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogen (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ARRAY",
        "solution": "true"
      },
      {
        "text": "MULTISET",
        "solution": "false"
      },
      {
        "text": "SET",
        "solution": "false"
      },
      {
        "text": "UNION",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2042,
    "category": 4,
    "difficulty": 2,
    "text": "Welcher Typkonstruktor ist homogen, hat ungeordnete Elemente und erlaubt Duplikate?",
    "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschränkter Kardinalität), \nLIST (ohne Beschränkung der Kardinalität).  \nInhomogen (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogen (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ARRAY",
        "solution": "false"
      },
      {
        "text": "MULTISET",
        "solution": "true"
      },
      {
        "text": "LIST",
        "solution": "false"
      },
      {
        "text": "ROW",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2043,
    "category": 4,
    "difficulty": 2,
    "text": "Welcher Typkonstruktor ist homogen, hat ungeordnete Elemente und erlaubt keine Duplikate?",
    "explanation": "Homogene (Elemente gleichen Typs) und geordnete Typkonstruktoren: \nARRAY (mit beschränkter Kardinalität), \nLIST (ohne Beschränkung der Kardinalität).  \nInhomogen (Elemente unterschiedlichen Typs) Typkonstruktoren: ROW, UNION \nHomogen (Elemente gleichen Typs) und ungeordnete (keine geordneten Elemente) Typkonstruktoren: \nSET(ohne Duplikate), \nMULTISET (mit Duplikaten)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ROW",
        "solution": "false"
      },
      {
        "text": "SET",
        "solution": "true"
      },
      {
        "text": "LIST",
        "solution": "false"
      },
      {
        "text": "MULTISET",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2045,
    "category": 5,
    "difficulty": 1,
    "text": "Beim Übergang zur ersten Normalform werden",
    "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.  \nEine Relation R mit Primärschlüssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.  \nEine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "alle mehrwertigen Attribute aufgelöst",
        "solution": "true"
      },
      {
        "text": "alle zusammengesetzten Attribute aufgelöst",
        "solution": "false"
      },
      {
        "text": "alle partiellen funktionalen Abhängigkeiten beseitigt",
        "solution": "false"
      },
      {
        "text": "alle transitiven funktionalen Abhängigkeiten beseitigt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1967,
    "category": 9,
    "difficulty": 2,
    "text": "Wenn man unter ORACLE eine BLOB-Spalte mit UPDATE ändern will, muss man diese mit EMPTY_BLOB() initialisieren.",
    "explanation": "Bevor man einen BLOB-Datentyp benutzen kann, muss er mit EMPTY_BLOB() initialisiert werden. Bei einen CLOB ist es die Funktion EMPTY_CBLOB().",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1969,
    "category": 9,
    "difficulty": 2,
    "text": "Benutzerdefinierte Typen unter ORACLE stimmen einschließlich der Methoden mit dem SQL-Standard 2003 überein.",
    "explanation": "Leider gibt es zahlreiche Abweichungen, wie z.B. die Definition der Methoden eines benutzerdefinierten Typs, die Anlage einer Objekttabelle oder einer eingebetteten Tabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2301,
    "category": 9,
    "difficulty": 3,
    "text": "In welcher Methode gibt es bei Oracle einen impliziten SELF-Parameter?",
    "explanation": "Eine MEMBER-Methode bezieht sich auf eine Instanz, das heißt eine Tabelle, die auf diesem Typ basiert. Eine STATIC-Methode bezieht\nsich auf den Typ selbst. Eine MEMBER-Methode wird aufgerufen über Instanzname.method(), eine STATIC-Routine über Typname.method(). In der MEMBER-Routine existiert immer ein implizites Argument SELF im Methoden-Body, das die Instanz repräsentiert, für die die Methode aufgerufen wurde. SELF existiert bei STATIC-Routinen\nnatürlich nicht.",
    "type": "text",
    "answers": [
      {
        "text": ".",
        "solution": "Member"
      }
    ]
  },
  {
    "id": 2302,
    "category": 9,
    "difficulty": 3,
    "text": "Strukturierte Datentypen können bei Oracle wie auch bei OR-SQL in welcher/n Tabellenform/en verwendet werden.",
    "explanation": "Manchmal ist alles korrekt :-).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "in relationale Tabellen",
        "solution": "true"
      },
      {
        "text": "in Objekttabellen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2303,
    "category": 9,
    "difficulty": 1,
    "text": "Objektrelationale DBS sind streng typisiert.",
    "explanation": "Ja, ORDBS sind streng typisiert, mit der Konsequenz, dass für die Typtransformation von benuzterdefinierten Typen entsprechende Konvertierungsfunktionen (CAST-Funktionen) definiert werden müssen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2332,
    "category": 9,
    "difficulty": 2,
    "text": "Die vom Oracle-DBS systemgenerierte OID ist",
    "explanation": "Die OID-Generierung bietet zwei Möglichkeiten: SYSTEM GENERATED bedeutet,dass eine weltweit eindeutige OID erzeugt wird, PRIMARY KEY entspricht dem Konzept eines Primärschlüssels. \n\nObjekttabellenhierarchien gibt es unter Oracle nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "innerhalb einer Objekttabelle eindeutig.",
        "solution": "false"
      },
      {
        "text": "innerhalb einer Objekttabellenhierarchie eindeutig.",
        "solution": "false"
      },
      {
        "text": "innerhalb einer Typhierarchie eindeutig.",
        "solution": "false"
      },
      {
        "text": "innerhalb eines DB-Schemas eindeutig.",
        "solution": "false"
      },
      {
        "text": "innerhalb einer Datenbank eindeutig.",
        "solution": "false"
      },
      {
        "text": "weltweit eindeutig.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2351,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussagen über Referenzen sind wahr?",
    "explanation": "Referenzen sind nicht identisch zu Fremdschlüsseln, da auch NULL-Pointer vorkommen können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Referenzen verweisen von einer Instanz direkt auf verbundene Objektinstanzen.",
        "solution": "true"
      },
      {
        "text": "Referenzen im OR-Modell sind funktional identisch zu den Fremdschlüsseln im relationalen Modell.",
        "solution": "false"
      },
      {
        "text": "Referenzen machen Join-Operationen wie in relationalen DBS überflüssig.",
        "solution": "true"
      },
      {
        "text": "Um Referenzen mit den Möglichkeiten des relationalen Modells zu simulieren, würde man Fremdschlüssel verwenden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2358,
    "category": 10,
    "difficulty": 1,
    "text": "Welcher Befehl ist syntaktisch richtig, um in JDBC einen Befehl dynamisch erst zur Laufzeit zusammenzusetzen? Con ist dabei das Verbindungsobjekt.",
    "explanation": "Der Platzhalter für Parameter unter JDBC ist \" ? .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PreparedStatement updOrt =\n     con.PrepareStatement(\"UPDATE Kunden SET Ort = !\");",
        "solution": "false"
      },
      {
        "text": "PreparedStatement updOrt =\n     con.PrepareStatement(\"UPDATE Kunden SET Ort = *\");",
        "solution": "false"
      },
      {
        "text": "PreparedStatement updOrt =\n     con.PrepareStatement(\"UPDATE Kunden SET Ort = ?\");",
        "solution": "true"
      },
      {
        "text": "So etwas geht bei JDBC gar nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2360,
    "category": 10,
    "difficulty": 2,
    "text": "Geben Sie die Reihenfolge (1 - 5) an, in der die folgenden Befehle programmiert werden müssen. Falsche/überflüssige Befehle können mit 0 gekennzeichnet werden.Damit die Lösung eindeutig wird: Die String-Spezifikation soll als erstes erfolgen.",
    "explanation": "Zuerst wird der String (1) definiert, dann muss das PreparedStatement-Objekt (2) erstellt werden, dann updateOrt (3) deklariert werden, dann wird der Parameter mit einem Wert bestückt (4) und zum Schluss mit updateOrt.executeUpdate(); ausgeführt (5).  \n\nLösung: 3, 4, 2, 5, 1",
    "type": "text",
    "answers": [
      {
        "text": "updateOrt = v_connection.prepareStatement(updateString);",
        "solution": "3"
      },
      {
        "text": "updateOrt.setString(1, \"Köln\");",
        "solution": "4"
      },
      {
        "text": "PreparedStatement updateOrt;",
        "solution": "2"
      },
      {
        "text": "updateOrt.executeUpdate();",
        "solution": "5"
      },
      {
        "text": "String updateString = \"update kunden set ort = ?\";",
        "solution": "1"
      }
    ]
  },
  {
    "id": 2361,
    "category": 10,
    "difficulty": 1,
    "text": "Mit der Methode prepareCall der Schnittstelle Connection wird ein CallableStatement-Objekt erzeugt, um folgendes aufzurufen:",
    "explanation": "prepareCall erzeugt ein Callable-Statement -Objekt, mit dem man in der Datenbank gespeicherte Prozeduren aufrufen kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DB-Trigger",
        "solution": "false"
      },
      {
        "text": "In der DB gespeicherte Prozeduren",
        "solution": "true"
      },
      {
        "text": "In der DB gespeicherte Funktionen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2362,
    "category": 10,
    "difficulty": 1,
    "text": "Welcher Befehl ist syntaktisch richtig, um in JDBC eine gespeicherte Routine auszuführen? Con ist dabei das Verbindungsobjekt.",
    "explanation": "prepareCall erzeugt ein Callable-Statement-Objekt, mit dem man in der Datenbank gespeicherte Prozeduren aufrufen kann.\n\nDie exakte Syntax ist: \n\nCallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(?)}\");",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CallableStatement callst = \n         con.prepareCall(\"{exec setze_zeitstempel(?)}\");",
        "solution": "false"
      },
      {
        "text": "CallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(?)}\");",
        "solution": "true"
      },
      {
        "text": "CallableStatement callst = \n         con.prepareCall(\"{run setze_zeitstempel(?)}\");",
        "solution": "false"
      },
      {
        "text": "So etwas geht bei JDBC gar nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2363,
    "category": 10,
    "difficulty": 1,
    "text": "Welcher Befehl ist syntaktisch richtig, um in JDBC eine gespeicherte Routine auszuführen? Con ist dabei das Verbindungsobjekt.",
    "explanation": "prepareCall erzeugt ein Callable-Statement-Objekt, mit dem man in der Datenbank gespeicherte Prozeduren aufrufen kann.\n\nDie exakte Syntax ist: \n\nCallableStatement callst = \n                con.prepareCall(\"{call setze_zeitstempel(?)}\");",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(?)}\");",
        "solution": "true"
      },
      {
        "text": "CallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(*)}\");",
        "solution": "false"
      },
      {
        "text": "CallableStatement callst = \n         con.prepareCall(\"{call setze_zeitstempel(!)}\");",
        "solution": "false"
      },
      {
        "text": "So etwas geht bei JDBC gar nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2048,
    "category": 5,
    "difficulty": 2,
    "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema mittels Universalrelation. Die Universalrelation wird nicht weiter zerlegt und die Subtypen werden durch ein diskriminierendes Attribut beschrieben.\n\nUm welchen Fragmentierungstyp handelt es sich hier?",
    "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp gehören, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch. \nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enthält alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschlüssel mit dem Supertyp verbunden und haben den gleichen Primärschlüssel wie der Supertyp. Außerdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "virtuelle Fragmentierung",
        "solution": "true"
      },
      {
        "text": "vertikale Fragmentierung",
        "solution": "false"
      },
      {
        "text": "horizontale Fragmentierung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2049,
    "category": 5,
    "difficulty": 1,
    "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema. Welche Fragmentierungstypen gibt es?",
    "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp gehören, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch. \nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enthält alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschlüssel mit dem Supertyp verbunden und haben den gleichen Primärschlüssel wie der Supertyp. Außerdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "virtuelle Fragmentierung",
        "solution": "true"
      },
      {
        "text": "vertikale Fragmentierung",
        "solution": "true"
      },
      {
        "text": "horizontale Fragmentierung",
        "solution": "true"
      },
      {
        "text": "faktische Fragmentierung",
        "solution": "false"
      },
      {
        "text": "abgeleitete Fragmentierung",
        "solution": "false"
      },
      {
        "text": "diagonale Fragmentierung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2052,
    "category": 4,
    "difficulty": 2,
    "text": "Welche Integritätsbedingung werden wie folgt charakterisiert:\n\"Sie beschreiben, welche Bedingungen beim Übergang von einem Zustand in einen anderen Zustand erfüllt sein müssen.\"",
    "explanation": "Bei der Integrität lassen sich die folgenden Arten unterscheiden:\n- statische Bedingungen und\n- dynamische Bedingungen:\n    - transitionale Bedingungen und\n    - temporale Bedingungen.\nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss. Dazu gehören die Entity-Integrität und die referentielle Integrität. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel aus der Fahrrad-Welt Byce & Co. wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Statische Integritätsbedingungen",
        "solution": "false"
      },
      {
        "text": "Dynamisch, transitionale Integritätsbedingungen",
        "solution": "true"
      },
      {
        "text": "Dynamisch, temporale Integritätsbedingungen",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2053,
    "category": 4,
    "difficulty": 1,
    "text": "Welche Integritätsbedingung werden wie folgt charakterisiert:\n\"Sie beschreiben einen Zustand, der von einer Datenbasis erfüllt sein muss.\"",
    "explanation": "Bei der Integrität lassen sich die folgenden Arten unterscheiden:\n- statische Bedingungen und\n- dynamische Bedingungen:\n    - transitionale Bedingungen und\n    - temporale Bedingungen.\nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss. Dazu gehören die Entity-Integrität und die referentielle Integrität. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel aus der Fahrrad-Welt Byce & Co. wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Statische Integritätsbedingungen",
        "solution": "true"
      },
      {
        "text": "Dynamische, transitionale Integritätsbedingungen",
        "solution": "false"
      },
      {
        "text": "Dynamische, temporale Integritätsbedingungen",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2054,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Integritätsbedingung werden wie folgt charakterisiert:\n\"Sie beschreiben, welche Bedingungen an ein Folge von Zustandsänderungen zu stellen sind.\"",
    "explanation": "Bei der Integrität lassen sich die folgenden Arten unterscheiden:\n- statische Bedingungen und\n- dynamische Bedingungen:\n    - transitionale Bedingungen und\n    - temporale Bedingungen.\nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss. Dazu gehören die Entity-Integrität und die referentielle Integrität. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel aus der Fahrrad-Welt Byce & Co. wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Statische Integritätsbedingungen",
        "solution": "false"
      },
      {
        "text": "Dynamische, transitionale Integritätsbedingungen",
        "solution": "false"
      },
      {
        "text": "Dynamische, temporale Integritätsbedingungen",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2160,
    "category": 10,
    "difficulty": 2,
    "text": "Welche Endung besitzen JDBC-Quelltexte?",
    "explanation": "JDBC-Quelltexte besitzen als reine Java-Quelltexte die Endung .java",
    "type": "text",
    "answers": [
      {
        "text": "Die Endung ist",
        "solution": ".java"
      }
    ]
  },
  {
    "id": 2162,
    "category": 6,
    "difficulty": 3,
    "text": "In welchen Punkten unterscheidet sich ein PRIMARY KEY-Constraint von einem UNIQUE-Constraint?",
    "explanation": "Die Constraints UNIQUE und PRIMARY KEY unterscheiden sich in den beiden Punkten: \nEs gibt pro Tabelle nur einen PRIMARY KEY aber beliebig viele UNIQUE-Schlüssel.\nDie Spalten eines PRIMARY KEY sind implizit auch Pflichteingabespalten, während die Spalten des UNIQUE-Schlüssels auch leer sein dürfen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Primärschlüssel muss immer NOT NULL sein",
        "solution": "true"
      },
      {
        "text": "Ein UNIQUE-Schlüssel muss immer NOT NULL sein",
        "solution": "false"
      },
      {
        "text": "Primärschlüssel sind automatisch indiziert, UNIQUE-Schlüssel nicht.",
        "solution": "false"
      },
      {
        "text": "Es ist nur ein Primärschlüssel pro Tabelle zulässig, aber viele UNIQUE-Schlüssel.",
        "solution": "true"
      },
      {
        "text": "Ein Primärschlüssel darf nicht zusammengesetzt sein aus mehreren Spalten.",
        "solution": "false"
      },
      {
        "text": "Ein UNIQUE-Schlüssel darf nicht zusammengesetzt sein aus mehreren Spalten.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2187,
    "category": 4,
    "difficulty": 1,
    "text": "Der Durchschnittsoperator ist aus den Grundoperatoren der relationalen Algebra (Selektion, Projektion, Kartesisches Produkt, Differenz, Union)  ableitbar.",
    "explanation": "Die Simulation sieht wie folgt aus: \n(A Durchschnitt B)  =  ( A ohne (A ohne B) ) \n\n(A Durchschnitt B)  =  ( A Differenz (A Differenz B) ) \n\nPS: Zeichnen Sie sich ruhig die Venn-Diagramme auf - es hilft ;-) \nPS: War mal Klausuraufgabe :-)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2387,
    "category": 9,
    "difficulty": 1,
    "text": "Objektrelationale Sichten sind typisierte Sichten.",
    "explanation": "Welche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht über beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nermöglicht logische Datenunabhängigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen möglich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2389,
    "category": 9,
    "difficulty": 2,
    "text": "Objektrelationale Sichten sind ein Hilfsmittel für die physische Datenunabhängigkeit",
    "explanation": "Nein, für die logische Datenunabhängigkeit. \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht über beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nermöglicht logische Datenunabhängigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen möglich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2394,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Semantik hat die folgende Anfrage?\n\nSELECT m.pers_nr, m.name, m.vorname, a.bez, \n       l.name||l.vorname, v.name||v.vorname \nFROM mitarbeiter_r m, abteilungen_r a, \n       mitarbeiter_r l, mitarbeiter_r v\nWHERE  m.abt_nr       = a.abt_nr \n   AND a.leiter       = l.pers_nr \n   AND m.vorgesetzter = v.pers_nr;",
    "explanation": "Richtig ist: \nAnzeige der Mitarbeiter (Personalnummer, Name, Vorname), die in Abteilungen arbeiten, mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung; \n\nAufgrund der Join-Verknüpfung zwischen den Tabellen, werden hier nur die Angestellten angezeigt, die auch in Abteilungen arbeiten. Wenn es Mitarbeiter gibt, die in keinen Abteilungen arbeiten, so werden sie bei dieser Anfrage nicht angezeigt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Anzeige der Mitarbeiter (Personalnummer, Name, Vorname), die in Abteilungen arbeiten, mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung;",
        "solution": "true"
      },
      {
        "text": "Anzeige aller Mitarbeiter (Personalnummer, Name, Vorname) mit den Namen ihrer Abteilungen und mit den Vor- und Nachnamen ihren Vorgesetzten und den Leitern ihrer Abteilung;",
        "solution": "false"
      },
      {
        "text": "Keine dieser Antworten ist richtig.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2398,
    "category": 9,
    "difficulty": 3,
    "text": "Mit welchem/n Befehl/en kann man bei Oracle Methoden programmieren?",
    "explanation": "Einen CREATE METHOD-Befehl gibt es bei Oracle nicht. Die Methoden-Deklaration und -Definition wird im CREATE TYPE-Befehl vorgenommen analog zum Package-Konzept und zwar die Deklaration des Methoden-Kopfs im CREATE TYPE und die Definition mit Programmcode im CREATE TYPE BODY. \n\nCREATE [OR REPLACE] TYPE  AS OBJECT\u000b\n(  )\u000b\n[[NOT] FINAL] \u000b[[NOT] INSTANTIABLE] \n\u000b[]\n\nCREATE [OR REPLACE] TYPE BODY  AS \n[]",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPLACE PROCEDURE <methodenname> ;",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE FUNCTION <methodenname> ;",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE METHOD <methodenname> ;",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE TYPE <typname> ;",
        "solution": "true"
      },
      {
        "text": "CREATE OR REPLACE TYPE BODY <typname> ;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2474,
    "category": 7,
    "difficulty": 2,
    "text": "Wie heißen die SQL-Befehle, mit den man eine Transaktion abschließen kann? \nBitte in alphabetischer Reihenfolge aufschreiben und durch ein Komma trennen!",
    "explanation": "Mit COMMIT werden die Datenänderungen einer Transaktion persistent in der Datenbasis gespeichert. Die Anweisung löst eine DEFERRED-Integritätsprüfung aus, die im Fehlerfall die gesamte Transaktion zurückrollt. \nMit ROLLBACK werden die Datenänderungen einer Transaktion zurückgerollt, d.h. rückgängig gemacht.",
    "type": "text",
    "answers": [
      {
        "text": "Das sind:",
        "solution": "commit, rollback"
      }
    ]
  },
  {
    "id": 2477,
    "category": 5,
    "difficulty": 3,
    "text": "Welche Aussagen hinsichtlich Normalisierung und Normalformen sind wahr?",
    "explanation": "1. Die Normalisierung geht von einem Datenvolumen aus, bei dem die in den Relationen enthaltenen Daten schon vorhanden sind und sich nicht verändern. Auf diesen Relationen werden aufgrund funktionaler Abhängigkeiten Maßnahmen zur besseren Strukturierung durchgeführt. In der Praxis sind natürlich die Relationen beim Datenbankentwurf noch nicht in allen Fällen mit Daten gefüllt; Bewegungsdaten verändern sich immer im laufenden Betrieb. Der Entwickler muss also einen\ngewissen Spürsinn haben, wo in Zukunft unerwünschte funktionale Abhängigkeiten und Redundanzen auftreten könnten. Außerdem wird beim konzeptionellen Modell als ER-Modell oft schon intuitiv die dritte Normalform gewählt. \n2. Anders sieht das Ganze bei der Reorganisation alter Datenbestände aus. In diesen Fällen ist die Normalformenlehre ein nützliches Instrument, um Redundanzen zu beseitigen und eine gute Datenstruktur zu erreichen. \n3. Durch die Normalisierung ergibt sich bei größeren Projekten eine Vielzahl von mit Fremdschlüsselbeziehungen verbundenen Tabellen. Informationen, die inhaltlich im Sinne der Objektorientierung zusammengehören, werden unter Umständen auf viele Tabellen verteilt. Bei Abfragen kann es zu erheblichen Performanceverlusten kommen, da oft viele Relationen aufwändig miteinander verknüpft werden müssen. \n4. Aus den angeführten Gründen ist eine Verletzung der dritten Normalform (Denormalisierung) in der Praxis manchmal gewollt. Die Normalisierung ist nicht als Dogma zu verstehen, aber nach wie vor ein analytisches Instrument, um Relationenstrukturen auf ihre Qualität hin zu überprüfen. Mit Datenbanktriggern wird das Problem der Redundanzen handhabbar.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Problematisch ist, dass der Normalisierungsprozess von den vorhandenen Daten ausgeht.",
        "solution": "true"
      },
      {
        "text": "Die Aufteilung auf viele Relationen kann zu längeren Antwortzeiten bei Anfragen führen.",
        "solution": "true"
      },
      {
        "text": "Die Idee der Normalisierung widerspricht der Objektorientierung.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2061,
    "category": 6,
    "difficulty": 2,
    "text": "Um welchen Typ einer Integritätsbedingung handelt es sich hier?\n\nDer durchschnittliche Rabatt aller Kunden darf 30 Prozent nicht überschreiten.",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingung",
        "solution": "true"
      },
      {
        "text": "dynamische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, temporale Bedingung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2062,
    "category": 6,
    "difficulty": 1,
    "text": "Um welchen Typ einer Integritätsbedingung handelt es sich hier?\n\nEine Rechnung muss einen positiven Gesamtbetrag aufweisen, eine Gutschrift einen negativen.",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingung",
        "solution": "true"
      },
      {
        "text": "dynamische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, temporale Bedingung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2223,
    "category": 12,
    "difficulty": 1,
    "text": "Wie lautet das Ergebnis der Berechnung im folgenden PL/SQL-Block?\n\n    DECLARE\n\n       v1 NUMBER := 5;\n\n       v2 NUMBER := NULL;\n\n    BEGIN\n\n       v1 := v1 + v2;\n\n    END;",
    "explanation": "\n    Die Summe aus einer Zahl und einem NULL-Wert ist NULL.",
    "type": "text",
    "answers": [
      {
        "text": "v1:",
        "solution": "NULL"
      },
      {
        "text": "v2:",
        "solution": "NULL"
      }
    ]
  },
  {
    "id": 2224,
    "category": 7,
    "difficulty": 2,
    "text": "Wie lautet das Ergebnis der folgenden ORACLE-SQL-Anfrage?\n\nSELECT  (5 * 6) + NULL AS ergebnis  FROM dual;",
    "explanation": "Das Ergebnis einer numerischen Operation (+, - , * /) und eines NULL-Werts ist immer selber Null.",
    "type": "text",
    "answers": [
      {
        "text": "ergebnis:",
        "solution": "NULL"
      }
    ]
  },
  {
    "id": 2225,
    "category": 12,
    "difficulty": 3,
    "text": "Welche/r Parametertyp/en können beim Aufruf der Routine (Prozedur oder Funktion) sowohl mit einer Konstanten als auch mit einer initialisierten Variablen belegt werden?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "INOUT",
        "solution": "false"
      },
      {
        "text": "OUT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2226,
    "category": 12,
    "difficulty": 3,
    "text": "Welche/r Parametertyp/en können beim Aufruf der Routine (Prozedur oder Funktion) mit einer initialisierten Variablen belegt werden?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "INOUT",
        "solution": "true"
      },
      {
        "text": "OUT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2227,
    "category": 12,
    "difficulty": 1,
    "text": "Welche/r Parametertyp/en können beim Aufruf der Routine (Prozedur oder Funktion) mit einer Konstanten belegt werden?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "true"
      },
      {
        "text": "INOUT",
        "solution": "false"
      },
      {
        "text": "OUT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2228,
    "category": 12,
    "difficulty": 2,
    "text": "Mit welchem Befehl kann man eine Meldung in PL/SQL anzeigen lassen und gleichzeitig das Programm fehlerhaft abbrechen lassen?",
    "explanation": "RAISE_APPLICATION_ERROR(negative_nr, Text, { TRUE | FALSE } ):  \nDieser Befehl zeigt auch eine Fehlermeldung an, die als Text vorgegeben wird. Zudem erzeugt er aber auch einen neuen Fehler und bricht das Programm fehlerhaft ab. Mit diesem Befehl erreicht man also, dass in den EXCEPTIONS ein Fehler behandelt wird und das Programm trotzdem fehlerhaft abbricht. Die negative Zahl muss im Bereich von -20000 bis -20999 liegen. Sie spielt eine Rolle, wenn mehrere solcher Nachrichten zu unterscheiden sind und wenn Fehler\nbei geschachtelten Programmen zur späteren Bearbeitung nach oben weitergereicht werden. Mit TRUE wird spezifiziert, dass die Fehlermeldung auf einem System-Fehler- Stack oben aufgelegt werden soll, und mit dem Default-Wert FALSE, dass die Meldung alle bisherigen Meldungen des Stack überschreibt.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist: (Befehlsname ohne Parameter)",
        "solution": "RAISE_APPLICATION_ERROR"
      }
    ]
  },
  {
    "id": 2229,
    "category": 12,
    "difficulty": 2,
    "text": "Welche SQL-Anweisungen können in PL/SQL direkt und ohne syntaktische Änderungen ausgeführt werden?",
    "explanation": "SELECT braucht eine INTO-Klausel oder einen Cursor, DDL-Anweisungen sind in PL/SQL nicht vorgesehen. Sie können nur über dynamischens SQL  (NDS, EXECUTE IMMEDIATE) ausgeführt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSERT, UPDATE, DELETE",
        "solution": "true"
      },
      {
        "text": "COMMIT, ROLLBACK",
        "solution": "true"
      },
      {
        "text": "CREATE, ALTER, DROP",
        "solution": "false"
      },
      {
        "text": "SELECT",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2232,
    "category": 13,
    "difficulty": 3,
    "text": "Welcher Ausführungsmodus spezifiziert, dass die Triggeraktion unter Oracle PL/SQL anstelle des feuernden Ereignisses ausgeführt werden soll? Wenn es keines gibt schreiben Sie einfach \"keiner als Lösung.",
    "explanation": "INSTEAD-OF-Trigger werden für Manipulationsereignisse auf Sichten, materialisierte wie auch virtuelle, definiert und statt dieses Ereignisses ausgeführt. Im Aktionsteil sind die Manipulationsanweisungen für die relevanten Basistabellen programmiert, die anstelle der Änderungen der View-Daten durchzuführen sind.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "INSTEAD OF"
      }
    ]
  },
  {
    "id": 2237,
    "category": 12,
    "difficulty": 2,
    "text": "Die Tabelle Kunden hat 1000 Datensätze. Primärschlüssel ist die Spalte Kund_id.\nEs wird die folgende Anfrage ausgeführt:\n  SELECT funktionsname(spalte1, spalte2) FROM Kunden; \n\nwobei funktionsname eine PL-SQL-Funktion ist.",
    "explanation": "Die Funktion wird 1000 mal aufgerufen, da Kun_id der Primärschlüssel der Tabelle Kunden ist, die Kun_id aber nicht in der Abfrage festgelegt ist.",
    "type": "text",
    "answers": [
      {
        "text": "Wie oft wird die Funktion ausgeführt?",
        "solution": "1000"
      }
    ]
  },
  {
    "id": 2239,
    "category": 12,
    "difficulty": 1,
    "text": "Die Tabelle Kunden hat 1000 Datensätze. Primärschlüssel ist die Spalte Kund_id.\nEs wird die folgende Anfrage ausgeführt:\n  SELECT funktionsname(spalte1, spalte2) \n    FROM Kunden WHERE Kund_id = 4711;",
    "explanation": "Die Funktion wird nur einmal aufgerufen, da Kun_id der Primärschlüssel der Tabelle Kunden ist.",
    "type": "text",
    "answers": [
      {
        "text": "Wie oft wird die Funktion ausgeführt?",
        "solution": "1"
      }
    ]
  },
  {
    "id": 2252,
    "category": 13,
    "difficulty": 1,
    "text": "Das Mutating Table-Problem tritt bei Oracle",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "in zeilenorientierten Triggern auf.",
        "solution": "true"
      },
      {
        "text": "in befehlsorientierten Triggern auf.",
        "solution": "false"
      },
      {
        "text": "gar nicht auf.",
        "solution": "false"
      },
      {
        "text": "in beiden Triggerarten auf.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2253,
    "category": 13,
    "difficulty": 3,
    "text": "Wie können Informationen an einen Oracle-Trigger übergeben werden?",
    "explanation": "Das feuernde Ereignis liefert die Werte für die Transitionsvariablen :NEW und :OLD (Oracle leider keine Transitionstabellen), die in den ROW-Triggern verfügbar sind. \n\nAndere Möglichkeiten, Daten an einen Trigger zu übergeben, sind eine SELECT-Anweisung oder eine öffentliche Package-Variable.\n\nEin Trigger verfügt über keine Parameter. Dieses Konzept ist nur bei Funktionen und Prozeduren bekannt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "durch das feuernde Ereignis",
        "solution": "true"
      },
      {
        "text": "durch Anfragen an Tabellen",
        "solution": "true"
      },
      {
        "text": "mittels Parameterübergabe: IN, OUT, INOUT",
        "solution": "false"
      },
      {
        "text": "durch öffentliche (public) Variablen in einem Package",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2254,
    "category": 13,
    "difficulty": 1,
    "text": "Einen Oracle-Trigger, der für mehrere Ereignisse definiert ist,",
    "explanation": "Verschiedene Ereignisse (INSERT, UPDATE oder DELETE) können unter Oracle_SQL den gleichen Programmcode im Action-Teil eines Triggers ausführen und dort mit IF INSERTING....., IF DELETING..., IF UPDATETING ...... abgefragt werden. Dies gilt nicht für Standard-SQL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "gibt es bei Oracle nicht.",
        "solution": "false"
      },
      {
        "text": "kann für alle Ereignisse nur den gleichen Programmcode ausführen.",
        "solution": "false"
      },
      {
        "text": "kann für die verschiedenen Ereignisse auch unterschiedlichen Programmcode ausführen.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2255,
    "category": 13,
    "difficulty": 1,
    "text": "Welcher ORACLE-Ausführungsmodus spezifiziert, dass die Triggeraktion anstelle des feuernden Ereignisses ausgeführt werden soll?",
    "explanation": "INSTEAD_OF-Trigger werden für Manipulationsereignisse auf Sichten, materialisierte wie auch virtuelle, definiert und statt dieses Ereignisses ausgeführt. Im Aktionsteil sind die Manipulationsanweisungen für die relevanten Basistabellen programmiert, die anstelle der Änderungen der View-Daten durchzuführen sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSTEAD OF",
        "solution": "true"
      },
      {
        "text": "REPLACE",
        "solution": "false"
      },
      {
        "text": "solch einen Modus gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2256,
    "category": 12,
    "difficulty": 3,
    "text": "Betrachten Sie die folgende Package-Definition:\n\n    Welche Prozedur-Spezifikation/en ist/sind nicht zulässig?\n\n    CREATE PACKAGE xyz IS PROCEDURE a (p1 NUMBER); -- Nr 1\n\n    PROCEDURE a (p1 NUMBER, p2 NUMBER); -- Nr 2\n\n    PROCEDURE a (p3 NUMBER); -- Nr 3\n\n    PROCEDURE a (p1 DATE); -- Nr 4\n\n    PROCEDURE a (p1 NUMBER); -- Nr 5\n\n    END;\n\n    Welche Prozedur-Spezifikation/en ist/sind nicht zulässig?",
    "explanation": "Eine Prozedur kann den gleichen Namen und unterschiedliche Parametertypen und -anzahlen, aber nicht den gleichen Namen und sowohl gleiche Parameteranzahlen wie auch Parametertypen haben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nr 1",
        "solution": "false"
      },
      {
        "text": "Nr 2",
        "solution": "false"
      },
      {
        "text": "Nr 3",
        "solution": "false"
      },
      {
        "text": "Nr 4",
        "solution": "false"
      },
      {
        "text": "Nr 5",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2270,
    "category": 10,
    "difficulty": 3,
    "text": "Welche Methoden hat das Interface connection?",
    "explanation": "Ein JAVA-Programm kann eine oder mehrere Verbindungen zu einer oder mehreren Datenbanken unterhalten.\nJede Verbindung wird durch ein Objekt realisiert, das das Interface Connection implementiert.\nDieses Interface definiert unter anderem folgende Methoden:\nMit der Methode createStatement() kann ein Objekt, welches das Interface Statement implementiert, erzeugt werden.  Analog dazu wird mit der Methode prepareStatement(String sql) eine Anweisung vorbereitet.  Durch den Aufruf von setAutoCommit(boolean) wird der Autocommit-Modus der Verbindung an- oder ausgeschaltet.  \n- Mit getAutoCommit() wird geprüft, welcher Modus vorliegt.\n- Mit close() wird die Verbindung explizit geschlossen,\n- mit isClosed() kann dies nachgeprüft werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "createStatement",
        "solution": "true"
      },
      {
        "text": "prepareStatement",
        "solution": "true"
      },
      {
        "text": "prepareCallableStatement",
        "solution": "true"
      },
      {
        "text": "prepareCall",
        "solution": "true"
      },
      {
        "text": "createCall",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2280,
    "category": 9,
    "difficulty": 3,
    "text": "Welche/r Datentyp/en / Typkonstruktoren führen zu einer Verletzung der 1. Normalform bei objektrelationalen DBSen von Oracle/ bei SQL2003?",
    "explanation": "TABLE, VARRAY und NESTED TABLE beinhalten per Definition eine Verletzung der ersten Normalform, da sie sogenannte Kollektionsdatentypen sind und es ermöglichen, mengenwertige Attribute zu spezifizieren. Die 1. Normalform hingegen schließt genau diese mengenwertigen Attribute aus.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NUMBER",
        "solution": "false"
      },
      {
        "text": "VARRAY / ARRAY",
        "solution": "true"
      },
      {
        "text": "DATE",
        "solution": "false"
      },
      {
        "text": "BLOB",
        "solution": "false"
      },
      {
        "text": "NESTED TABLE / MULTISET",
        "solution": "true"
      },
      {
        "text": "Benutzerdefinierte Datentypen ohne Kollektionsdatentypen",
        "solution": "false"
      },
      {
        "text": "CLOB, NCLOB",
        "solution": "false"
      },
      {
        "text": "BFILE",
        "solution": "false"
      },
      {
        "text": "TABLE",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2281,
    "category": 9,
    "difficulty": 1,
    "text": "Für welche/s Einsatzgebiet/e sind objektrelationale DBS am besten geeignet?",
    "explanation": "Komplexe Datenstrukturen können mit den objektrelationalen Features wie CREATE TYPE .. gut abgebildet werden. Für Abfragen ist in einem ORDBMS SQL ausgebaut worden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Keine Anfragen und einfache Daten",
        "solution": "false"
      },
      {
        "text": "Viele Anfragen und einfache Daten",
        "solution": "false"
      },
      {
        "text": "Viele Anfragen und komplexe Daten",
        "solution": "true"
      },
      {
        "text": "Keine Anfragen und komplexe Daten",
        "solution": "false"
      },
      {
        "text": "Dies sind keine geeigneten Kriterien für eine Einsatzentscheidung.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2282,
    "category": 9,
    "difficulty": 1,
    "text": "Objektrelationale DBS sind bestens geeignet, wenn komplexe Daten zu verwalten sind und keine Anfragen gestellt werden.\n\nDiese Aussage",
    "explanation": "Komplexe Datenstrukturen können mit den objektrelationalen Features wie CREATE TYPE .. gut abgebildet werden. Für Abfragen ist in einem ORDBMS SQL ausgebaut worden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2283,
    "category": 9,
    "difficulty": 1,
    "text": "Objektrelationale DBS sind bestens geeignet, wenn einfache Daten zu verwalten sind und viele Anfragen gestellt werden.\n\nDiese Aussage",
    "explanation": "Falls einfach strukturierte Daten vorliegen, reicht ein relationales Datenbanksystem vollständig aus.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2284,
    "category": 9,
    "difficulty": 1,
    "text": "Objektrelationale DBS sind bestens geeignet, wenn komplexe Daten zu verwalten sind und viele Anfragen gestellt werden.\n\nDiese Aussage",
    "explanation": "Falls kein objektrelationales Datenbanksystem zur Verfügung steht, können zu einem objektrelationalen Datenmodell Standardabbildungen definiert werden, die den Entwurf auf ein relationales Datenbankschema definieren. Diese Abbildungen heißen objektrelationale Abbildungen. Das Vorgehen ist in der Praxis weit verbreitet, da sich objektrelationale Modelle gut zur Beschreibung komplexer Probleme eignen und man den Umstieg auf ein objektrelationales System noch scheut.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2286,
    "category": 9,
    "difficulty": 2,
    "text": "Nach einer objektorientierten Analyse z.B. mit UML wird mittels einem relationalem DBS implementiert.",
    "explanation": "Problem ist hier das die mächtigen OO-Konzepte (Klassen, Methoden, Objektidentität, Aggregation, ...) auf einfache relationale Strukturen (Relationen, Prozeduren, Funktionen, Primärschlüssel, Fremdschlüssel) abgebildet werden müssen - das macht OR-Mapping notwendig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dieser Weg ist in der Praxis kaum zu finden",
        "solution": "false"
      },
      {
        "text": "Dieser Weg ist relativ unproblematisch.",
        "solution": "false"
      },
      {
        "text": "Dieser Weg beinhaltet das Impadance Missmatch-Problem und erfordert OR-Mapping.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2287,
    "category": 9,
    "difficulty": 2,
    "text": "Was gehört zu einem objektrelationalen DBS?",
    "explanation": "Dieser User ist noch nicht erfunden worden :-).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "objektrelationales Typsystem",
        "solution": "true"
      },
      {
        "text": "objektrelationale Tabellen",
        "solution": "true"
      },
      {
        "text": "objektrelationale Sichten",
        "solution": "true"
      },
      {
        "text": "objektrelationale User",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2291,
    "category": 9,
    "difficulty": 3,
    "text": "Es gibt beim Oracle-ORDBS",
    "explanation": "Tabellenhierarchien existieren nur im Standard-SQL, Benutzerhierarchien überhaupt nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typhierarchien",
        "solution": "true"
      },
      {
        "text": "Tabellenhierarchien",
        "solution": "false"
      },
      {
        "text": "Sichthierarchien",
        "solution": "true"
      },
      {
        "text": "Benutzerhierarchien",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2292,
    "category": 9,
    "difficulty": 2,
    "text": "Es gibt beim objektrelationalen SQL",
    "explanation": "Beim objektrelationalem SQL gibt es für Typen, Tabellen und Sichten entsprechende Hierarchiekonzepte mit Vererbung. \nBenutzerhierarchien sind hingegen unbekannt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typhierarchien",
        "solution": "true"
      },
      {
        "text": "Tabellenhierarchien",
        "solution": "true"
      },
      {
        "text": "Sichthierarchien",
        "solution": "true"
      },
      {
        "text": "Benutzerhierarchien",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2293,
    "category": 9,
    "difficulty": 2,
    "text": "Welche Klausel sorgt dafür, dass ein definierter Typ ein Supertyp werden kann?",
    "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt über die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist die Klausel:",
        "solution": "NOT FINAL"
      }
    ]
  },
  {
    "id": 2294,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Klausel sorgt bei Oracle dafür, dass ein definierter Typ ein Subtyp wird? Geben Sie nur die Klausel ohne Zusätze an!",
    "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt über die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist die Klausel:",
        "solution": "UNDER"
      }
    ]
  },
  {
    "id": 2295,
    "category": 9,
    "difficulty": 1,
    "text": "Welcher Befehl definiert bei Oracle einen Subtypen?",
    "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt über die der UNDER-Klausel: CREATE TYPE  UNDER  AS  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TYPE <Typname> AS OBJECT ...",
        "solution": "false"
      },
      {
        "text": "CREATE TYPE <Subtypname> UNDER <Supertypname> AS",
        "solution": "true"
      },
      {
        "text": "CREATE SUBTYPE <Subtypname> OF <Supertypname> AS",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2296,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussagen über Typkonstruktoren sind wahr?",
    "explanation": "Hier ist der Typkonstruktor gemeint, im Gegensatz zum Wert-oder Instanzkonstruktor, der eine Instanz eines Datentyps erzeugt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie erzeugen einen Datentyp.",
        "solution": "true"
      },
      {
        "text": "Benannte Datentypen werden in SQL und bei Oracle mittels CREATE TYPE erzeugt.",
        "solution": "true"
      },
      {
        "text": "Er wird auch als Instanz- oder Wertkonstruktor bezeichnet.",
        "solution": "false"
      },
      {
        "text": "Das DBMS erzeugt automatisch für jeden angelegten (instanzierbaren) Datentyp einen Konstruktor, mit dem Werte dieses Datentyps erzeugt werden können.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2297,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussagen über Konstruktoren sind wahr?",
    "explanation": "Hier ist der Wert- / Instanzkonstruktor gemeint, im Gegensatz zum Typkonstruktor, der einen Datentyp erzeugt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie erzeugen einen Datentyp.",
        "solution": "false"
      },
      {
        "text": "Benannte Datentypen werden in SQL und bei Oracle mittels des Konstruktors CREATE TYPE erzeugt.",
        "solution": "false"
      },
      {
        "text": "Ein Konstruktor wird auch als Instanz- oder Wertkonstruktor bezeichnet.",
        "solution": "true"
      },
      {
        "text": "Das DBMS erzeugt automatisch für jeden angelegten (instanziierbaren)\nDatentyp einen Konstruktor, mit dem Werte dieses Datentyps erzeugt\nwerden können.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2298,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Arten von benutzerdefinierten Methoden gibt es beim objektrelationalen SQL?",
    "explanation": "Es kann auch alles richtig sein :-).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Methoden",
        "solution": "true"
      },
      {
        "text": "Instanzmethode",
        "solution": "true"
      },
      {
        "text": "benutzerdefinierte Konstuktormethoden",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2304,
    "category": 9,
    "difficulty": 3,
    "text": "Der Begriff der strengen Typisierung bedeutet, dass",
    "explanation": "Typumwandlungen können mit expliziten und impliziten Typumwandlungen durchgeführt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "für die Attribute von Objekttabellen nur strukturierte Datentypen verwendet werden können.",
        "solution": "false"
      },
      {
        "text": "keine Vergleichbarkeit von verschiedenen Typen mit gleicher Struktur möglich ist.",
        "solution": "true"
      },
      {
        "text": "die Typkonvertierung ausschließlich mittels expliziter Typumwandlungen durchgeführt werden.",
        "solution": "false"
      },
      {
        "text": "die Typkonvertierung ausschließlich mittels impliziter Typumwandlungen durchgeführt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2078,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussage über einen Join in SQL2003 ist richtig?",
    "explanation": "richtig sind: \nEin Theta-Join kann eine USING-Komponente haben.\n\nfalsch sind: \nEin Theta-Join kann eine USING-Komponente sowie eine ON-Komponente in der gleiche FROM -Klausel haben. \nEin Natural-Join kann eine USING-Komponente haben.\nEin Natural-Join kann eine ON-Komponente haben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Theta-Join kann eine USING-Komponente haben.",
        "solution": "true"
      },
      {
        "text": "Ein Theta-Join kann eine USING-Komponente sowie eine ON-Komponente in der gleiche FROM -Klausel haben.",
        "solution": "false"
      },
      {
        "text": "Ein Natural-Join kann eine USING-Komponente haben.",
        "solution": "false"
      },
      {
        "text": "Ein Natural-Join kann eine ON-Komponente haben.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2081,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Typkonstruktoren hat SQL?",
    "explanation": "Das relationale Modell basiert auf den beiden Typkonstruktoren ROW(Basisdatentyp) und SET(ROW(Basisdatentyp)). \nSQL hingegen basiert auf den beiden Typkonstruktoren ROW(Basisdatentyp) und MULTISET(ROW(Basisdatentyp)). \nDie beiden Modelle unterscheiden sich also dahingehend, dass bei SQL doppelte Datensätze zugelassen sind, während bei der RA doppelte Tupel automatisch von den Operatoren eliminiert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ROW",
        "solution": "true"
      },
      {
        "text": "UNION",
        "solution": "false"
      },
      {
        "text": "SET",
        "solution": "false"
      },
      {
        "text": "ARRAY",
        "solution": "false"
      },
      {
        "text": "LIST",
        "solution": "false"
      },
      {
        "text": "MULTISET",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2083,
    "category": 7,
    "difficulty": 3,
    "text": "Welche SQL-Ausdrücke liefern unter ORACLE das gleiche Ergebnis, unabhängig vom Inhalt der Tabellen Auftraege und Kunden?",
    "explanation": "Der (+) Operator in der WHERE-Klausel ist die ursprüngliche, Oracle-Syntax des Outer-Joins.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT   Kun_Nr, Nachname, Auftragsnr\nFROM     Auftraege  RIGHT OUTER JOIN Kunden \nUSING   (Kun_Nr);",
        "solution": "true"
      },
      {
        "text": "SELECT k.Kun_Nr, Nachname, Auftragsnr\nFROM   Auftraege b, Kunden k\nWHERE  k.Kun_Nr = b.Kun_Nr (+);",
        "solution": "true"
      },
      {
        "text": "SELECT k.Kun_Nr, Nachname, Auftragsnr\nFROM Auftraege b, Kunden k\nWHERE k.Kun_Nr(+)= b.Kun_Nr;",
        "solution": "false"
      },
      {
        "text": "SELECT k.Kun_Nr, Nachname, Auftragsnr\nFROM Auftraege b, Kunden k\nWHERE k.Kun_Nr = b.Kun_Nr;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2101,
    "category": 1,
    "difficulty": 3,
    "text": "Welche Aussagen über ein Datenmodell sind wahr?",
    "explanation": "Ein Datenmodell stellt einen allgemeinen Begriffsapparat zur Verfügung, der es gestattet, Realitätsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren. Mit dem Datenmodell werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, ähnlich wie bei einer Programmiersprache, in der auch Ausdrücke und Regeln festgelegt sind, die in der Programmiersprache\nbenutzt werden dürfen.  \n\nEin Datenmodell hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Datenmodell stellt einen allgemeinen Begriffsapparat zur Verfügung, der es gestattet, Realitätsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren.",
        "solution": "true"
      },
      {
        "text": "Mit dem Datenmodell werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, ähnlich wie bei einer Programmiersprache, in der auch Ausdrücke und Regeln festgelegt sind, die in der Programmiersprache benutzt werden dürfen.",
        "solution": "true"
      },
      {
        "text": "Ein Datenmodell ist die konkrete Ausprägung eines bestimmten Datenbankschemas mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.",
        "solution": "false"
      },
      {
        "text": "Ein Datenmodell hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.",
        "solution": "true"
      },
      {
        "text": "Bei einem Datenmodell werden die Daten in Dateien gespeichert, die nur von einem Programm genutzt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2103,
    "category": 4,
    "difficulty": 2,
    "text": "Welche der genannten Operatoren sind Operatoren der Relationalen Algebra?",
    "explanation": "Die Konkatenation bezeichnet das Zusammenfügen z.B. von zwei Zeichenketten und ist als separate Funktion bei SQL verfügbar, es ist aber kein Operator der RA.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "true"
      },
      {
        "text": "Projektion",
        "solution": "true"
      },
      {
        "text": "Vereinigung",
        "solution": "true"
      },
      {
        "text": "Durchschnitt",
        "solution": "true"
      },
      {
        "text": "Division",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "true"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Theta-Join",
        "solution": "true"
      },
      {
        "text": "Natural Join",
        "solution": "true"
      },
      {
        "text": "Equi-Join",
        "solution": "true"
      },
      {
        "text": "Outer Join (Left, Full, Right)",
        "solution": "true"
      },
      {
        "text": "Konkatenation",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2104,
    "category": 4,
    "difficulty": 3,
    "text": "Welche der genannten Operatoren sind abgeleitete Operatoren der Relationalen Algebra, die mittels der Basisoperatoren simuliert werden können?",
    "explanation": "Basisoperatoren sind: Selektion, Projektion, Differenz, kartesisches Produkt, Vereinigung. \nTheta-, Equi- und die Outer Joins lassen sich mittels kartesischem Produkt und Selektion simulieren. \nNatural Join lässt sich mittels kartesischem Produkt Selektion und Pojektion simulieren. \nDie Division lässt sich mittels Selektion, Projektion, kartesischem Produkt und Differenz ableiten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Vereinigung",
        "solution": "false"
      },
      {
        "text": "Division",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "false"
      },
      {
        "text": "Theta-Join",
        "solution": "true"
      },
      {
        "text": "Natural Join",
        "solution": "true"
      },
      {
        "text": "Equi-Join",
        "solution": "true"
      },
      {
        "text": "Outer Join (Left, Full, Right)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2106,
    "category": 6,
    "difficulty": 2,
    "text": "Was versteht man unter \"Dangling-Datensätzen\" in SQL?",
    "explanation": "Werden Fremdschlüssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datensätze, die noch von Detail-Datensätze referenziert werden, gelöscht oder deren Schlüsselwert geändert wird und das anschließend Detail-Datensätze existieren, für deren Fremdschlüsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt. \nDas Einfügen von Master-Datensätzen ist immer unproblematisch, da eine Fremdschlüsselbedingung es zuläßt, dass es Master-Datensätze gibt, für die es keine Detail-Datensätze gibt. \n\nAnaloge Probleme können bei Join-Operationen (Theta, Equi, Natural) auftreten. In die Ergebnismenge werden nur die Datensätze aufgenommen, die die Verknüpfungsbedingung erfüllen. Alle anderen fallen heraus, das sind die sog. \"dangling tuples\". Will man diese auch anzeigen lassen, muss man mit LEFT/RIGHT/FULL OUTER JOINs arbeiten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Datensätze, die nicht gesichert werden.",
        "solution": "false"
      },
      {
        "text": "Datensätze, denen bei Join-Operationen bzw. bei Fremdschlüsselbeziehungen die entsprechenden Datensätze in der anderen Tabelle fehlen, mit denen sie verknüpft werden können.",
        "solution": "true"
      },
      {
        "text": "Datensätze, denen Attributwerte fehlen.",
        "solution": "false"
      },
      {
        "text": "Geänderte Datensätze, deren Transaktion noch nicht abgeschlossen ist.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2073,
    "category": 7,
    "difficulty": 1,
    "text": "Welcher Join-Tabellen-Typ hat eine ON-Klausel?",
    "explanation": "Beim CROSS JOIN, dem kartesischen Produkt, gibt es gar keine Verknüpfungsbedingung. Jeder Datensatz der einen Relation wird \"grundlos\" mit jedem anderen aus der anderen Relation verknüpft.\nBeim NATURAL JOIN gibt es zwar eine Bedingung, aber die ist vordefiniert, so dass sie nicht mittels USING spezifiziert werden muss. Die vordefinierte Bedingung heißt: Alle Spalten mit gleichen Namen werden auf Gleichheit verglichen und die Teilbedingungen ggf. mit AND verknüpft.\nLediglich beim THETA JOIN wird eine Bedingung angegeben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CROSS-Join",
        "solution": "false"
      },
      {
        "text": "THETA-Join",
        "solution": "true"
      },
      {
        "text": "NATURAL-Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2074,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussage über einen Theta-Join in SQL2003 ist richtig?",
    "explanation": "Jede Using-Komponente lässt sich auch über eine ON-Komponente formulieren. \nDie bei der USING-Klausel angegebenen Spalten werden implizit auf Gleichheit verglichen. Bei der ON-Klausel können beliebige Verküpfungsbedingungen definiert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Jede Using-Komponente lässt sich auch über eine ON-Komponente formulieren.",
        "solution": "true"
      },
      {
        "text": "Jede ON-Komponente lässt sich auch über eine USING-Komponente formulieren.",
        "solution": "false"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2092,
    "category": 7,
    "difficulty": 3,
    "text": "Die Tabellen \"ausleihen\" und \"fahrzeuge\" sollen unter anderem folgende Spalten  haben: \nausleihen (kfz_nr, Kunden_Nr, von, bis,....)\nFahrzeuge (kfz_nr, nummernschild,...)\n\nWelche SELECT-Anweisung beantwortet die Anfrage: Gibt es Fahrzeuge, die noch nie ausgeliehen wurden?",
    "explanation": "RICHTIG sind: \nDer LEFT OUTER JOIN nimmt alle Datensätze der linken Tabelle, also der Fahrzeuge und verknüpft sie falls möglich mit Ausleihvorgängen. Bei den Fahrzeugen, für die es keine Ausleihvorgänge gibt, ist die Spalte von NULL. \nDer FULL OUTER JOIN nimmt sowohl von den Ausleihen wie auch von den Fahrzeugen alle Datensätze und verfährt dann weiter wie beim LEFT OUTER JOIN. Der FULL ist etwas \"oversized\", der LEFT reicht völlig aus für den gewünschten Effekt.\nBeim NOT IN werden alle Fahrzeug-Datensätze geprüft, ob es für ihre kfz_nr einen Datensatz in der Ausleihe-Tabelle gibt, wenn nicht, dann kommt dieser Fahrzeug-Datensatz in die Ergebnismenge. \n\nFALSCH sind: \nRIGHT OUTER Join heißt ja, das die rechte Tabelle vollständig übernommen wird, hier also die Ausleihen und falls möglich mit KFZs verbunden wird und die sonst fehlenden Spalten mit NULL aufgefüllt werden. Damit ist die Semantik mit der IS NULL-Bedingung: \"Für welche Ausleihen haben keine Fahrzeuge?\" \n\nDer NATURAL JOIN ist falsch, weil er implizit die Bedingung \"WHERE ausleihen.kfz_nr = fahrzeuge.kfz_nr\" ausführt. Seine Semantik wäre bis dahin: \"Welche Fahrzeuge wurden ausgeliehen?\" Die zusätzliche Bedingung \"von IS NULL\" führt für den Fall, dass \"von\" für Ausleihen Pflichteinfabefeld ist, zu einer unerfüllbaren Bedingung, so dass die Ergebnismenge immer leer ist. Ist die Spalte \"von\" kein Pflichteingabefeld, so ist die Semantik der Anfrage: \"Welche Fahrzeuge wurden ausgeliehen und deren von-Datum ist vergessen worden einzutragen.\"\n\nDie NOT EXISTS-Anfrage wäre richtig, wenn sie korreliert wäre, also die Bedingung \"WHERE ausleihen.kfz_nr = fahrzeuge.kfz_nr\" hätte. So liefert die Unteranfrage immer dann wenigstens einen Datensatz, wenn die Tabelle Ausleihen gefüllt ist - und damit ist NOT EXISTS immer FALSE, wenn die Ausleihen-Tabelle Datensätze enthält, unabhängig davon, welche KfFZ_NR dort vertreten sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge LEFT OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;",
        "solution": "true"
      },
      {
        "text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge RIGHT OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;",
        "solution": "false"
      },
      {
        "text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge FULL OUTER JOIN ausleihen USING (kfz_nr)\nWHERE von IS NULL;",
        "solution": "true"
      },
      {
        "text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;",
        "solution": "false"
      },
      {
        "text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)",
        "solution": "true"
      },
      {
        "text": "SELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT EXISTS (SELECT DISTINCT kfz_nr from ausleihen)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2125,
    "category": 7,
    "difficulty": 3,
    "text": "Gegeben sei folgender Ausschnitt eines relationale Schemas einer Datenbank \nSpieler (Spieler_id, Name, Adresse, Geburtsdatum)\nVereine (V_Kuerzel, Vereinsname, Ort, Gruendungsjahr)\nSpiele  (Spiel_id, Heim_V_Kuerzel, Gast_V_Kuerzel, Spieltag, Ergebnis, Anzahl_Zuschauer)\nSpieleinsatz (Spiel_id, Spieler_id, von_Minute, bis_Minute)\n\nWelche der angegeben SQL-Abfragen beantwortet/en die Frage: \nWelche Vereine (Kürzel, Name) haben wenigstens ein Auswärtsspiel, also wenigstens ein Spiel als Gastmannschaft in der Rückrunde (Spieltag 18-34) absolviert?",
    "explanation": "RICHTIG sind: alle Anfragen\nDie Teilaussage \"...welche Vereine haben gespielt...\" kann durch einen (Natural) Join, einen IN- oder auch einen EXISTS-Operator formuliert werden. \nDa der BETWEEN-Operator die Grenzen mit einschließt, muss die Simulation <= und >= verwenden. \n\nFALSCH ist: keine der Anfragen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND  spieltag BETWEEN 18 AND 34;",
        "solution": "true"
      },
      {
        "text": "SELECT v_kuerzel, vereinsname     \nFROM verein, spiele \nWHERE v_kuerzel = gast_v_kuerzel    \nAND spieltag >= 18 AND spieltag <= 34;",
        "solution": "true"
      },
      {
        "text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE v_kuerzel IN \n(SELECT gast_v_kuerzel FROM spiele \n WHERE spieltag BETWEEN 18 AND 34);",
        "solution": "true"
      },
      {
        "text": "SELECT v_kuerzel, vereinsname FROM verein \nWHERE EXISTS \n(SELECT * FROM spiele \n WHERE spieltag BETWEEN 18 AND 34\n AND gast_v_kuerzel = v_kuerzel);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2098,
    "category": 1,
    "difficulty": 2,
    "text": "ANSI-3-Ebenen-Modell: Was gehört zur externen Ebene?",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "physische Datenstruktur",
        "solution": "false"
      },
      {
        "text": "konzeptionelles Schema",
        "solution": "false"
      },
      {
        "text": "Anwendungen",
        "solution": "true"
      },
      {
        "text": "Datenbankschema",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2099,
    "category": 1,
    "difficulty": 1,
    "text": "ANSI-3-Ebenen-Modell: Was gehört zur internen Ebene?",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "externe Datenstruktur",
        "solution": "false"
      },
      {
        "text": "physische Datenstruktur",
        "solution": "true"
      },
      {
        "text": "konzeptionelles Schema",
        "solution": "false"
      },
      {
        "text": "Anwendungen",
        "solution": "false"
      },
      {
        "text": "Datenbankschema",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2100,
    "category": 1,
    "difficulty": 1,
    "text": "ANSI-3-Ebenen-Modell: Was gehört zur konzeptionellen Ebene?",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "externe Datenstruktur",
        "solution": "false"
      },
      {
        "text": "physische Datenstruktur",
        "solution": "false"
      },
      {
        "text": "konzeptionelles Schema",
        "solution": "true"
      },
      {
        "text": "Anwendungen",
        "solution": "false"
      },
      {
        "text": "Datenbankschema",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2107,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation Test(Spalte_1, Spalte_2, Spalte_3), in die fünf Tupel eingetragen sind.\n\nWie viele Spalten hat der Natural Join der Tabelle Test mit sich selber?",
    "explanation": "Der Natural Join einer Tabelle mit sich selber ergibt wieder die Ursprungstabelle, und die hat hier 3 Spalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "5",
        "solution": "false"
      },
      {
        "text": "10",
        "solution": "false"
      },
      {
        "text": "25",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2137,
    "category": 7,
    "difficulty": 2,
    "text": "Die Tabellen \"ausleihen\" und \"fahrzeuge\" sollen unter anderem folgende Spalten  haben: \nausleihen (kfz_nr, Kunden_Nr, von, bis,....)\nFahrzeuge (kfz_nr, nummernschild,...)\n\nWelche SELECT-Anweisung beantwortet die Anfrage: \n\"Gibt es Fahrzeuge, die noch nie ausgeliehen wurden?\"",
    "explanation": "RICHTIG sind: \nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT EXISTS \n(SELECT * from ausleihen WHERE fahrzeuge.kfz_nr = ausleihen.kfz_nr)\n\nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)\n \n\nFALSCH sind: \nSELECT kfz_nr, nummernschild, ausleihen.von\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;\nmit der Semantik: \"Welche Fahrzeuge wurden ausgeliehen?\" \n\nSELECT kfz_nr, nummernschild, ausleihen.von \nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr;\nmit einer unerfüllbaren Bedingung. Die implizite Bedingung des Natural Joins \"fahrzeuge.kfz_nr = ausleihen.kfz_nr\" wiederspricht der formulierten WHERE-Klausel \"WHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE von IS NULL;",
        "solution": "false"
      },
      {
        "text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge \nWHERE kfz_nr NOT IN (SELECT DISTINCT kfz_nr from ausleihen)",
        "solution": "true"
      },
      {
        "text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge \nWHERE NOT EXISTS \n(SELECT * from ausleihen WHERE fahrzeuge.kfz_nr = ausleihen.kfz_nr)",
        "solution": "true"
      },
      {
        "text": "SELECT kfz_nr, nummernschild\nFROM fahrzeuge NATURAL JOIN ausleihen \nWHERE fahrzeuge.kfz_nr <> ausleihen.kfz_nr;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2138,
    "category": 7,
    "difficulty": 2,
    "text": "Damit die folgende UPDATE-Anweisung ausgeführt werden kann:\nUPDATE TABELLE 1 SET SPALTE1 = (SELECT SPALTE2 FROM TABELLE2);",
    "explanation": "Die Abfrage darf nur einen Ergebnisdatensatz liefern, da ein Tupel in einem Feld (hier Spalte1) auch nur einen Wert aufnehmen kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "darf die Abfrage nur einen Ergebnisdatensatz liefern.",
        "solution": "true"
      },
      {
        "text": "muss die Abfrage so viele Ergebnisdatensätze liefern, wie Datensätze mit der UPDATE-Anweisung geändert werden.",
        "solution": "false"
      },
      {
        "text": "gelten keine Einschränkungen hinsichtlich der Ergebnismenge der Abfrage.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2063,
    "category": 6,
    "difficulty": 2,
    "text": "Um welchen Typ einer Integritätsbedingung handelt es sich hier?\n\nDer Einkaufspreis eines Produkts darf innerhalb eines Jahres nicht um mehr als 10 % steigen.",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingung",
        "solution": "true"
      },
      {
        "text": "statische, temporale Bedingung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2084,
    "category": 7,
    "difficulty": 3,
    "text": "Welche SELECT-Abfragen sind syntaktisch korrekt?",
    "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt für alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \n* Die beteiligten Tabellen (Eingangsdatenmengen) müssen die gleichen Spaltendefinitionen aufweisen: \n* Die Anzahl der Spalten muss übereinstimmen. \n* Die Datentypen der der Spalten müssen gleich sein.  \n* Die Reihenfolge der Spalten muss übereinstimmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT Nachname, Vorname\nFROM Angestellte\n    UNION\nSELECT Nachname\nFROM Kunden;",
        "solution": "false"
      },
      {
        "text": "SELECT Nachname\nFROM Angestellte\n    UNION\nSELECT Nachname\nFROM Kunden;",
        "solution": "true"
      },
      {
        "text": "SELECT Nachname\nFROM Angestellte\n    MINUS\nSELECT Vorname\nFROM Kunden;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2379,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Eigenschaften hat eine objektrelationale Sicht bei Oracle?",
    "explanation": "Welche Tabellen-/Sichtformen kann es in einem ORDBMS geben?\n\nDefinitionsart: untypisiert vs. typisiert \n- Untypisiert: die Struktur ergibt sich direkt aus den Attributstrukturen (RM)\n- Typisiert: Sicht-/Tabellendefinition basiert auf benutzerdefinierten Typ (OR)\n\nZeilentyp: tupelwertig vs. objektwertig \n- Tupelwertig: keine Methodenaufrufe für ein konkretes Tupel (RM)\n- Objektwertig: Methodenaufrufe des zugehörigen Objekttyps direkt über die Zeilenvariable (OR)\n\nReferenzierbarkeit: nicht referenzierbar vs. referenzierbar  \n- Nicht referenzierbar: Zeilen sind nicht referenzierbar (RM)\n- Referenzierbar: Zeilen sind mittels Referenzspalten (OIDs) referenzierbar; setzt OIDs voraus (OR)\n\n\nRelationale Tabellen sind: \n- tupelwertig, \n- untypisiert, \n- nicht referenzierbar\n\nObjektorientierte/objektrelationale Klassen/Tabellen sind: \n- objektwertig, \n- typisiert, \n- referenzierbar",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typisiert",
        "solution": "true"
      },
      {
        "text": "Untypisiert",
        "solution": "false"
      },
      {
        "text": "Tupelwertig",
        "solution": "false"
      },
      {
        "text": "Objektwertig",
        "solution": "true"
      },
      {
        "text": "Referenzierbar",
        "solution": "true"
      },
      {
        "text": "Nicht referenzierbar",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2409,
    "category": 6,
    "difficulty": 1,
    "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle: \n\n    CREATE TABLE Zeitschrift ( Zeitschrift_id INTEGER NOT NULL, Namen VARCHAR2(20) NULL, PRIMARY KEY (Zeitschrift_id));\n\n    CREATE TABLE Aufsatz ( Aufsatz_id INTEGER NOT NULL, Titel VARCHAR2(20) NULL, Zeitschrift_id INTEGER NOT NULL, PRIMARY KEY (Aufsatz_id), FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\n    Welche der beiden Tabellen kann zuerst gelöscht werden?",
    "explanation": "Eine Tabelle mit einem Primary-Key (hier Zeitschrift mit Zeitschrift_id) , der als Foreign-Key in einer anderen Tabelle vorkommt, kann nicht gelöscht werden, solange die Verweistabelle noch existiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zeitschrift",
        "solution": "false"
      },
      {
        "text": "Aufsatz",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2410,
    "category": 6,
    "difficulty": 1,
    "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle: \n\nCREATE TABLE Zeitschrift ( Zeitschrift_id INTEGER NOT NULL, Namen VARCHAR2(20) NULL, PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz ( Aufsatz_id INTEGER NOT NULL, Titel VARCHAR2(20) NULL, Zeitschrift_id INTEGER NOT NULL, PRIMARY KEY (Aufsatz_id), FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\nAuf welcher der beiden Tabellen ist ein ON DELETE CASCADE möglich, mit dem Zweck, dass zu einer Zeitschrift auch die zuhörigen Aufsätze gelöscht werden?",
    "explanation": "ON DELETE CASCADE ist eine Option des Fremdschlüssel-Constraints und da bei der Zeitschriften-Tabelle gar kein Fremdschlüssel definiert ist, kann auch kein ON DELETE CASCADE spezifiziert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zeitschrift",
        "solution": "false"
      },
      {
        "text": "Aufsatz",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2412,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Datenbankobjekte können unter Oracle mit CREATE OR REPLACE angelegt werden?",
    "explanation": "Datensätze werden mittels INSERT eingefügt und mittels UPDATE geändert. \nFür Benutzer gibt es nur eine CREATE-Anweisung, ebenso wie für Tabellen. \nCREATE OR REPLACE-Anweisungen gibt es für gespeicherte Routinen, Views, Trigger.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Tabellen",
        "solution": "false"
      },
      {
        "text": "Views",
        "solution": "true"
      },
      {
        "text": "Benutzer",
        "solution": "false"
      },
      {
        "text": "Trigger",
        "solution": "true"
      },
      {
        "text": "gespeicherte Prozeduren",
        "solution": "true"
      },
      {
        "text": "Datensätze",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2439,
    "category": 7,
    "difficulty": 2,
    "text": "In einer Oracle-When-Bedingung eines Zeilentriggers kann eine SELECT-Anweisung stehen.",
    "explanation": "Die  WHEN-Bedingung  formuliert eine beliebige SQL-Suchbedingung mit ein paar Modifikationen. Statt wie in der WHERE-Klausel einfach die Spalten zu verwenden, deren Tabellen in der FROM-Klausel spezifiziert wurden, kann in der WHEN-Bedingung auf die Daten der zugehörigen Tabelle mittels Transitionstabellen und -variablen zugegriffen werden. Nur wenn diese Bedingung zu TRUE ausgewertet wird, wird der Aktionsteil auch ausgeführt (bei FALSE und NULL nicht). Sie muss immer in Klammern  stehen.\n\n    \n\n    Zu beachten ist, dass die WHEN-Bedingung kein Teil des Ereignisses ist. Erst wenn das feuernde Ereignis eingetreten und der Trigger aktiviert ist, wird mit der Bedingung geprüft, ob der Aktionsteil ausgeführt wird. SELECT-Anweisungen sind hier nicht zugelassen\n\n    \n\n    Da Oracle keine Transitionstabellen kennt und Transitionsvariablen zu zeilenorienterten Triggern mit einer WHEN -Bedingung gehören, sind ORACLE-Trigger mit einer WHEN-Bedingung immer zeilenorientiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2440,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Primärschlüssel A, S den Primärschlüssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz?",
    "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS ausgedrückt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT *\nFROM R\nWHERE A NOT IN (SELECT B FROM S);",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM S\n MINUS\nSELECT * FROM R;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1501,
    "category": 6,
    "difficulty": 3,
    "text": "Mit dem ALTER TABLE-Befehl kann man unter Oracle-SQL",
    "explanation": "Der Befehl RENAME benennt eine Tabelle um.\nMit einem ALTER TABLE hingegen kann eine Spalte umbenannt werden, eine Spalte vergrößert werden oder auch gelöscht werden und vieles vieles mehr.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "eine Spalte hinzufügen",
        "solution": "true"
      },
      {
        "text": "eine Tabelle umbenennen",
        "solution": "false"
      },
      {
        "text": "eine Spalte umbenennen",
        "solution": "true"
      },
      {
        "text": "eine Spalte vergrößern",
        "solution": "true"
      },
      {
        "text": "eine Spalte löschen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1510,
    "category": 6,
    "difficulty": 3,
    "text": "Zu SQL2003 gehören folgende Datentypen:",
    "explanation": "Zum SQL2003-Standard gehören folgende Datentypen: \nCHARACTER, CHARACTER VARYING, CHARACTER LARGE OBJECT, BINARY LARGE OBJECT, NUMERIC, DECIMAL, SMALLINT, INTEGER, BIGINT, FLOAT, REAL, DOUBLE PRECISION, BOOLEAN, DATE, TIME, TIMESTAMP, INTERVAL. \n\nDie übrigen Datentypen gehören zu Oracle: \nLONG RAW, BFILE, LOB, CLOB, BLOB, NCLOB",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LONG RAW",
        "solution": "false"
      },
      {
        "text": "NCLOB",
        "solution": "false"
      },
      {
        "text": "BOOLEAN",
        "solution": "true"
      },
      {
        "text": "BLOB",
        "solution": "false"
      },
      {
        "text": "CLOB",
        "solution": "false"
      },
      {
        "text": "LOB",
        "solution": "false"
      },
      {
        "text": "BFILE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1511,
    "category": 9,
    "difficulty": 3,
    "text": "Aus welchen Komponenten besteht ein LOB-Datentyp? (in alphabetischer Reihenfolge und englisch)",
    "explanation": "Der LOB-Locator ist der Zeiger auf die Adresse des LOBS in der Datenbank, der LOB-Value der eigentliche Wert, der die Binärdaten enthält.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist der LOB",
        "solution": "Locator"
      },
      {
        "text": "und der LOB",
        "solution": "Value"
      }
    ]
  },
  {
    "id": 1512,
    "category": 9,
    "difficulty": 2,
    "text": "Über eine SELECT-Anweisung an eine CLOB-Spalte werden selektiert",
    "explanation": "Eine SELECT-Anweisung auf einer BLOB-, CLOB- oder NCLOB-Spalte selektiert immer nur den LOB-Locator, also nicht den LOB-Value.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "der Inhalt des Textes, der in der CLOB-Spalte abgelegt ist",
        "solution": "false"
      },
      {
        "text": "nur der LOB-Locator",
        "solution": "true"
      },
      {
        "text": "keins von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1513,
    "category": 9,
    "difficulty": 3,
    "text": "Mit welchem Befehl legt man unter ORACLE ab Version 8 ein Verzeichnis an, in das LOBS (Large Objects) vom Datentyp BFILE abgelegt werden können?",
    "explanation": "Der Oracle-Befehl 'CREATE DIRECTORY DIR-Name as 'VERZEICHNIS';' legt ein Verzeichnis im Dateisystem des Datenbankservers an, auf den dann z.B.mit BFILENAME(...) oder dem DBMS_LOB-Paket zugegriffen werden kann. Ein GRANT-Befehl der Form 'grant read, write on VERZEICHNIS to micky_mouse;' ist notwendig, wenn ein anderer Benutzer dieses Verzeichnis nutzen möchte.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "CREATE DIRECTORY"
      }
    ]
  },
  {
    "id": 1515,
    "category": 7,
    "difficulty": 2,
    "text": "Welcher der folgenden UPDATE-Befehle ist syntaktisch korrekt, vorausgesetzt, die Tabellen haben die angegebenen Spalten?",
    "explanation": "In einem UPDATE-Befehl kann man nur über eine SELECT-Anweisung auf eine andere Tabelle zugreifen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "UPDATE tab1\nSET spalte1 = tab2.spalte2\nWHERE tab1.spalte3 = tab2.spalte3;",
        "solution": "false"
      },
      {
        "text": "UPDATE tab1\nSET spalte1 = \n   (SELECT tab2.spalte2 FROM tab2\n    WHERE  tab1.spalte3 = tab2.spalte3);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1516,
    "category": 6,
    "difficulty": 3,
    "text": "Welche ORACLE-Datumsformate sind korrekt?",
    "explanation": "Alle sind richtig. DD steht für den Tag, MM für den Monat, RRRR/YYYY für das Jahr. Ein Jahr kann zwei- oder vierstellig sein. Das Trennzeichen ist beliebig, hier z.B. . und / oder -, ...",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DD-MON-RR",
        "solution": "true"
      },
      {
        "text": "DD.MM.RR",
        "solution": "true"
      },
      {
        "text": "DD.MM.RRRR",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2130,
    "category": 7,
    "difficulty": 1,
    "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN\"",
    "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "bewirkt keine Sortierung",
        "solution": "true"
      },
      {
        "text": "bewirkt eine absteigende Sortierung über den Nachnamen",
        "solution": "false"
      },
      {
        "text": "bewirkt eine aufsteigende Sortierung über den Nachnamen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2131,
    "category": 7,
    "difficulty": 3,
    "text": "Der Ausdruck \"SELECT Nachname, SUM(Umsaetze) FROM KUNDEN GROUP BY Nachname\"",
    "explanation": "GROUP By bewirkt hier keine Sortierung über den Nachnamen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "bewirkt eine Gruppierung",
        "solution": "true"
      },
      {
        "text": "bewirkt eine absteigende Sortierung über den Nachnamen",
        "solution": "false"
      },
      {
        "text": "bewirkt eine aufsteigende Sortierung über den Nachnamen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1744,
    "category": 1,
    "difficulty": 3,
    "text": "ANSI-3-Ebenen-Modell: Ein Anwendungsprogramm wird entwickelt, das neue, zusätzliche Datenstrukturen benötigt.",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Änderung betrifft die externe Ebene.",
        "solution": "true"
      },
      {
        "text": "Diese Änderung betrifft die interne Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft die konzeptionelle Ebene.",
        "solution": "true"
      },
      {
        "text": "Diese Änderung betrifft keine Ebene.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1749,
    "category": 4,
    "difficulty": 2,
    "text": "Bestimmen Sie den linken Outer-Join der folgenden beiden Relationen über R1.S1 = R2.S3!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z",
    "explanation": "Der linke Outer-Join (linker äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdrückt werden, als Tupel mit aufgeführt und in den Attributen, die zu R2 gehören, mit NULL-Werten aufgefüllt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z",
        "solution": "false"
      },
      {
        "text": "Keine dieser Ergebnismengen ist richtig.",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nC  Y  C  Y",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y",
        "solution": "true"
      },
      {
        "text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1751,
    "category": 6,
    "difficulty": 1,
    "text": "Wie erzeugt man mit einem ALTER TABLE-Befehl einen TABLE-CONSTRAINT?",
    "explanation": "Mit der Option ADD beim ALTER TABLE können Constraint einer bereits bestehenden Tabelle hinzugefügt werden. Die Option MODIFY gibt es nicht für CONSTRAINTS selber, sondern nur für Spaltendefinitionen, die aber einen COMSTRAINT haben können. \nConstraints sind keine eigenständigen DB-Objekte, so dass es für sie keine eigenen CREATE, ALTER, DROP-Befehle gibt. Sie können nur durch entsprechende CREATE TABLE, ALTER TABLE, DROP TABLE-Befehle erzeugt, manipuliert oder gelöscht werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mit dem Zusatz MODIFY",
        "solution": "false"
      },
      {
        "text": "Mit dem Zusatz ADD",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1750,
    "category": 5,
    "difficulty": 2,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E) mit den funktionalen Abhängigkeiten AB -> C, BC ->D, CD -> E. Welche Attributkombination ist ein (minimaler) eindeutiger Schlüssel?",
    "explanation": "Die beiden einzigen Attribute, die von keinem anderen Attribut abhängig sind, sind A und B, also ist die Lösung AB.\n\nAndererseits bestimmt eine Kombination aus AB und einem anderen Atrribut aus (C, D) alle anderen Attribute.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "AB"
      }
    ]
  },
  {
    "id": 1752,
    "category": 6,
    "difficulty": 1,
    "text": "Wie viele Spalten kann man innerhalb eines ALTER-Table-Befehls (ALTER TABLE XXX ADD (...)) verändern bzw. neu hinzufügen?",
    "explanation": "Man kann mit einem ALTER TABLE xxx ADD | MODIFY mehrere Spalten ändern bzw. hinzufügen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "eine Spalte",
        "solution": "false"
      },
      {
        "text": "mehrere Spalten",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1762,
    "category": 12,
    "difficulty": 1,
    "text": "In PL/SQL kann man mit dynamischem SQL eine Stored Procedure schreiben, die sich selber in der Datenbank löscht.",
    "explanation": "PL/SQL nimmt einfach den String entgegen, der in einer Textvariablen gespeichert ist und führt in als SQL-Anweisung aus. Das kann auch zum Selbstmord der PL/SQL-Prozedur führen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1622,
    "category": 15,
    "difficulty": 2,
    "text": "Bei welcher Speicherstruktur gibt es einen Algorithmus, mit dem man die Adresse auf der Basis des Schlüsselwertes berechnen kann?",
    "explanation": "Das ist die Definition der Hash-Speicherstruktur.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HEAP",
        "solution": "false"
      },
      {
        "text": "ISAM",
        "solution": "false"
      },
      {
        "text": "B+ Baum",
        "solution": "false"
      },
      {
        "text": "HASH",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1623,
    "category": 15,
    "difficulty": 3,
    "text": "Bei welcher Speicherstruktur werden die Daten sequentiell in der Reihenfolge der Eingabe abgelegt?",
    "explanation": "Das ist die Definition der Heap-Speicherstruktur. Hash ist auch richtig, wenn man nur die Daten selber ohne den Hash-Algorithmus betrachtet",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "HEAP",
        "solution": "true"
      },
      {
        "text": "ISAM",
        "solution": "false"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      },
      {
        "text": "HASH",
        "solution": "true"
      },
      {
        "text": "B-Baum",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1665,
    "category": 2,
    "difficulty": 3,
    "text": "Aus welchen Phasen besteht das Vorgehensmodell zur Systementwicklung nach Balzert, das auch in der Datenbankentwicklung benutzt wird? Tragen Sie die Phasen in der korrekten Reihenfolge ein!",
    "explanation": "Aus dem konzeptionellen Schema wird das konkrete Datenbankschema abgeleitet. Das Datenbankschema ist ein auf den Datenbanktyp abgestimmtes Datenmodell, im relationalen Fall also ein relationales Schema, bestehend aus miteinander verknüpften Relationen. Dieser Transformationsvorgang kann weitgehend automatisiert werden, Entity-Mengen und Beziehungen werden nach einem Verfahren, das in Kapitel 4 behandelt wird, auf Relationen abgebildet. Das entstandene Schema wird normalisiert und zum Datenbankschema vervollständigt . Ferner wird das Modell ergänzt um einzelne Benutzersichten, Indexangaben zur Zugriffsoptimierung und Speicherstrukturen, wie B-Baum, oder HASH- Verfahren sowie die Zugriffsrechte der Benutzer im Multiuser-System. Da diese Punkte abhängig sind vom verwendeten Datenbanksystem, werden sie erst jetzt in der Entwurfsphase durchgeführt. Wurden die Wertebereiche der Attribute und Integritätsbeziehungen nicht bereits während der Analysephase festgelegt, so sind auch diese jetzt zu definieren.",
    "type": "text",
    "answers": [
      {
        "text": "Die vierte Phase ist die",
        "solution": "Abnahme- und Einführungsphase"
      },
      {
        "text": "Die fünfte Phase ist die",
        "solution": "Wartungs- und Pflegephase"
      },
      {
        "text": "Die zweite Phase ist die",
        "solution": "Entwurfsphase"
      },
      {
        "text": "Die erste Phase ist die",
        "solution": "Analysephase"
      },
      {
        "text": "Die dritte Phase ist die",
        "solution": "Implementierungsphase"
      }
    ]
  },
  {
    "id": 1676,
    "category": 3,
    "difficulty": 3,
    "text": "Auf welche Weise sollte man so genannte Stammdaten modellieren, deren Wertebereich sich nur selten ändert, wie z.B. die Kontaktarten (Telefon, Brief, persönliches Gespräch, Email,... ) zur näheren Spezifikation eines Kundenkontakts eines Beraters mit seinen Kunden?",
    "explanation": "Die Möglichkeiten, dies über eine Domäne oder über eine Entitymenge, die als Wertebereich dient und mit nichtidentifizierender Beziehung mit der Haupt-Entitymenge verbunden sind, sind hier äquivalent. \nIn der Praxis sollte man sich nach den Möglichkeiten des konkreten Datenbanksystems richten. Ein identifizierende Beziehung macht hier keinen Sinn, da das Attribut nicht zum Primärschlüssel gehören soll.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Als eigene Entitymenge \"Kontaktart\" mit identifizierender 1:n-Beziehung zur Entitymenge \"Kundenkontakt\".",
        "solution": "false"
      },
      {
        "text": "Als eigene Entitymenge \"Kontaktart\" mit nicht identifizierender 1:n-Beziehung zur Entitymenge \"Kundenkontakt\".",
        "solution": "true"
      },
      {
        "text": "Als Wertebereichsdefinition einer selbst definierten Domäne, die dem Textfeld \"Kontaktart\" in der Entitymenge \"Kundenkontakt\" anstelle eines Datentyps zugeordnet wird.",
        "solution": "true"
      },
      {
        "text": "Als vom Anwender frei eingebbares Textfeld \"Kontaktart\" in der Entitymenge \"Kundenkontakt\".",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2132,
    "category": 7,
    "difficulty": 3,
    "text": "In welcher Reihenfolge werden in einem SELECT-Befehl die folgenden Komponenten vom DBMS ausgeführt? (Geben Zahlen von 1 bis 6 an)",
    "explanation": "Für die SELECT-Anweisungen gelten folgende Ausführungsreihenfolgen der einzelnen Klauseln: \n6. SELECT\n1. FROM\n2. WHERE\n3. GROUP BY \n4. HAVING\n5. ORDER BY",
    "type": "text",
    "answers": [
      {
        "text": "WHERE",
        "solution": "2"
      },
      {
        "text": "FROM",
        "solution": "1"
      },
      {
        "text": "ORDER BY",
        "solution": "5"
      },
      {
        "text": "HAVING",
        "solution": "4"
      },
      {
        "text": "GROUP BY",
        "solution": "3"
      },
      {
        "text": "SELECT",
        "solution": "6"
      }
    ]
  },
  {
    "id": 1624,
    "category": 3,
    "difficulty": 1,
    "text": "Welche Aussagen über Primärschlüssel sind wahr?",
    "explanation": "Primärschlüssel können aus einem oder mehreren Attributen bestehen und sind minimal in dem Sinne, dass sie aus einer minimalen Menge von Attributen bestehen, die eine Entität eindeutig identifizieren.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Primärschlüssel bestehen immer aus einem einzelnen Attribut, z.B. einer fortlaufenden Nummer.",
        "solution": "false"
      },
      {
        "text": "Primärschlüssel können auch aus mehreren Attributen zusammengesetzt sein.",
        "solution": "true"
      },
      {
        "text": "Primärschlüssel sind eine minimale Menge von Attributen, die die zugeordnete Entität eindeutig identifizieren.",
        "solution": "true"
      },
      {
        "text": "Primärschlüssel sind eine maximale Menge von Attributen, die die zugeordnete Entität eindeutig identifizieren.",
        "solution": "false"
      },
      {
        "text": "Schlüsselattribute sind nicht obligatorisch, d.h. können auch einen NULL-Wert enthalten.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1626,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie die folgende Abfrage an eine Angestellten-Tabelle:\nWelche Angestellten wohnen in Köln oder Gummersbach?\nWelche der folgenden Abfragen liefert das gewünschte Ergebnis:",
    "explanation": "Der logische Operator \"=\" kann nur mit einem einzelnen Wert vergleichen.\nEine Ort kann nicht gleichzeitig Köln und Gummersbach heißen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = 'Köln'\nOR ORT = 'Gummersbach'",
        "solution": "true"
      },
      {
        "text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT in ( 'Köln',  'Gummersbach')",
        "solution": "true"
      },
      {
        "text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = ( 'Köln',  'Gummersbach')",
        "solution": "false"
      },
      {
        "text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = ALL ( 'Köln',  'Gummersbach')",
        "solution": "false"
      },
      {
        "text": "SELECT Ang_nr, Nachname\nFROM Angestellte\nWHERE ORT = 'Köln'\nAND ORT = 'Gummersbach'",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1627,
    "category": 15,
    "difficulty": 2,
    "text": "Betrachten Sie einen B-Baum vom Typ 1 mit 15 Einträgen. Welche Höhe h hat der Baum maximal?",
    "explanation": "Wenn jeder Knoten nur einen Eintrag hat, ergibt sich die Höhe 3.",
    "type": "text",
    "answers": [
      {
        "text": "Die Höhe h ist",
        "solution": "3"
      }
    ]
  },
  {
    "id": 1628,
    "category": 15,
    "difficulty": 1,
    "text": "Betrachten Sie einen B-Baum vom Typ 1 mit 14 Einträgen. Welche Höhe h hat der Baum minimal?",
    "explanation": "Wenn jeder Knoten zwei Einträge hat, ergibt sich als Höhe  der Wert 2.",
    "type": "text",
    "answers": [
      {
        "text": "Die Höhe ist",
        "solution": "2"
      }
    ]
  },
  {
    "id": 1629,
    "category": 15,
    "difficulty": 3,
    "text": "Wie viele Einträge hat ein B-Baum vom Typ 2 der Höhe 2 maximal?",
    "explanation": "Ein B-Baum vom Typ 2 hat maximal eine Wurzel, 5 Knoten auf der ersten Ebene (h = 1) und nochmal 5*5 = 25 Knoten auf der zweiten Ebene (h=2).Insgesamt sind das 31 Knoten mit maximal 124 = 31 * 4 Einträgen.",
    "type": "text",
    "answers": [
      {
        "text": "Die Anzahl ist:",
        "solution": "124"
      }
    ]
  },
  {
    "id": 1630,
    "category": 15,
    "difficulty": 3,
    "text": "Wie viele Einträge hat ein B-Baum vom Typ 1 der Höhe 2 maximal?",
    "explanation": "Die Wurzel: hat 2 Einträge\n\n    1. Ebene: 2+2+2=6 Einträge\n\n    2. Ebene: 3*(2+2+2)=18 Einträge\n\n    \n\n    Summe: 26",
    "type": "text",
    "answers": [
      {
        "text": "Die Anzahl ist",
        "solution": "26"
      }
    ]
  },
  {
    "id": 1743,
    "category": 3,
    "difficulty": 2,
    "text": "Welches/welche der folgenden Attribute einer Entitymenge \"Spiele (Heimmannschaft_id, Gastmannschaft_id, Spieltag, Ergebnis, Anzahl_Zuschauer,  Starttermin) sind notwendig für die Definition des Primärschlüssels, wenn die Daten der Fußball-Bundesliga für mehrere Saisons gespeichert werden sollen? Gehen Sie dabei davon aus, dass eine Heimmannschaft nur einmal an einem Tag spielen kann. Kreuzen Sie aus den angegebene Attributen die Primärschlüsselattribute an!",
    "explanation": "Da eine Heimmannschaft nur einmal an einem Tag spielen kann, sind die Heimmannschaft und der Starttermin  ausreichend für den Primärschlüssel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Spieltag (Wert: 1-34)",
        "solution": "false"
      },
      {
        "text": "Heimmannschaft_ID",
        "solution": "true"
      },
      {
        "text": "Ergebnis",
        "solution": "false"
      },
      {
        "text": "Gastmannschaft_ID",
        "solution": "false"
      },
      {
        "text": "Anzahl_Zuschauer",
        "solution": "false"
      },
      {
        "text": "Starttermin (Datum und Uhrzeit des Anpfiffs)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1644,
    "category": 15,
    "difficulty": 2,
    "text": "Wie viele Einträge sind in einem B-Baum vom Typ 3 in der Wurzel mindestens enthalten?",
    "explanation": "In der Wurzel kann nach Definition des B-Baumes auch nur ein Element, unabhängig von Typ des Baumes, enthalten sein.",
    "type": "text",
    "answers": [
      {
        "text": "Die Anzahl ist (als Zahl eintragen):",
        "solution": "1"
      }
    ]
  },
  {
    "id": 1645,
    "category": 6,
    "difficulty": 3,
    "text": "Welche SQL-Anweisungen mit CONSTRAINTS sind syntaktisch korrekt?",
    "explanation": "RICHTIG sind: \nknz      VARCHAR2(1)    CHECK (knz IN ('J','N'))\nknz      VARCHAR2(1)    CHECK (knz = ALL ('J','N'))\nBeide CHECK-Bedingungen sind syntaktisch richtig, verfügen aber eine unterschiedliche Semantik. Beim IN wird geprüft, ob der Wert der Spalte knz 'J' oder 'N' ist. Beim =ALL wird geprüft, ob der Wert der Spalte knz die beiden Werte 'J' und 'N' hat. Diese Bedingung ist nicht erfüllbar, denn wie kann eine Spalte gleichzeitig zwei verschiedene Werte enthalten. Semantisch äquivalent wäre die Formulierung mit =ANY. \nFALSCH ist: \nWenn ein Vergleichsoperand eine Menge kosntanter Werte ist, da hilft ein einfaches \"=\" nicht weiter, nur ein IN oder ein \"=\" mit ANY- oder ALL-Option.\nDies \"IN ('J','N')\" reicht syntaktisch auch nicht aus. Ein CHECK-Constraint startet mit \"CHECK ( spaltenname ...\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz IN ('J','N')));",
        "solution": "true"
      },
      {
        "text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz = ('J','N')));",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    CHECK (knz = ALL ('J','N')));",
        "solution": "true"
      },
      {
        "text": "keine dieser SQL-Anweisungen",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE patienten\n(patienten_id NUMBER(12) PRIMARY KEY,  \n nachname VARCHAR2(50)   NOT NULL,       \n vorname  VARCHAR2(20)   NOT NULL,         \n knz      VARCHAR2(1)    IN ('J','N'));",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1654,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie die folgenden Mini-Datenbank eines Weinhändlers:\nRebsorte (Sorte, Name, Farbe)\nWein (WeinID, Name, Rebsorte)\nJahrgang (WeinID, Jahr, Preis, Qualitaet)\n\nWelche SELECT-Abfrage beantwortet die folgende Anfrage:\n\nWelche Riesling Weine haben in keinem Jahrgang die Qualitätsstufe 3 besessen?",
    "explanation": "Die Antworten mit NOT EXISTS  entsprechen den Antworten mit NOT IN. Allerdings muss man darauf achten, dass man korrelierte Subselects verwendet, damit man auch die Weine enthält, die der Semantik (Welche Riesling Weine haben in keinem Jahrgang die Qualitätsstufe 3 besessen?) genügen. Die äußeren SELECT-Anweisungen müssen mit den inneren über Join-Bedingungen verknüpft werden. Wenn eine Join-Verknüpfung fehlt, liefert der NOT EXISTS immer ein Ergebnis.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte  = r.sorte\nAND    r.name      = 'Riesling'\nAND    NOT EXISTS (SELECT j.wein_id\n                   FROM   jahrgang j\n                   WHERE  j.qualitaet = 3);\n",
        "solution": "false"
      },
      {
        "text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name       = 'Riesling'\nAND    w.wein_id NOT IN (SELECT j.wein_id\n                         FROM   jahrgang j\n                         WHERE  j.qualitaet > 3);\n",
        "solution": "false"
      },
      {
        "text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte  = r.sorte\nAND    r.name      = 'Riesling'\nAND    NOT EXISTS (SELECT j.wein_id\n                   FROM   jahrgang j\n                   WHERE  j.qualitaet = 3\n           AND    j.wein_id   = w.wein_id);",
        "solution": "true"
      },
      {
        "text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name       = 'Riesling'\nAND    w.wein_id NOT EXISTS(SELECT j.wein_id\n                          FROM   jahrgang j\n                          WHERE  j.qualitaet = 3);\n",
        "solution": "false"
      },
      {
        "text": "SELECT w.name   \nFROM   wein w, rebsorte r\nWHERE  w.rebsorte   = r.sorte\nAND    r.name    = 'Riesling'\nAND    w.wein_id NOT IN (SELECT j.wein_id\n                         FROM   jahrgang j\n                         WHERE  j.qualitaet = 3);\n",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1656,
    "category": 1,
    "difficulty": 1,
    "text": "Wann entstand das hierarchische Datenmodell?",
    "explanation": "Das hierarchisches Datenbankmodell ist das älteste Datenbankmodell, es bildet die reale Welt durch eine hierarchische Baumstruktur ab und wurde später Grundlage des Netzwerkdatenmodells. Es entstand schon in den 60er Jahren und wurde Grundlage des Systems IMS/DB der Firma IBM. \nHeutzutage erlebt die hierarchische Datenspeicherung  eine Renaissance in Verbindung mit XML.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "50er Jahre",
        "solution": "false"
      },
      {
        "text": "60er Jahre",
        "solution": "true"
      },
      {
        "text": "70er Jahre",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1655,
    "category": 1,
    "difficulty": 1,
    "text": "Wann entstand das Netzwerkdatenmodell?",
    "explanation": "Das Netzwerkdatenmodell wurde schon 1971 von der Codasyl-DBTG-Gruppe gemeinsam mit dem Cobol-Standard vorgeschlagen und wurde die theoretische Grundlage der Netzwerkdatenbanken.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "50er Jahre",
        "solution": "false"
      },
      {
        "text": "60er Jahre",
        "solution": "true"
      },
      {
        "text": "70er Jahre",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1658,
    "category": 1,
    "difficulty": 1,
    "text": "Die Anwenderprogramme sind nicht von den Daten abhängig. Programme sollen anwendungsstabil gegenüber der Änderung der Datenstrukturen sein.",
    "explanation": "Das ist die Definition der vertikalen, logischen Datenunabhängigkeit.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Eigenschaft nennt man vertikale, logische Datenunabhängigkeit.",
        "solution": "true"
      },
      {
        "text": "Diese Eigenschaft nennt man physische Datenunabhängigkeit.",
        "solution": "false"
      },
      {
        "text": "Diese Eigenschaft nennt man horizontale, logische Datenunabhängigkeit.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1687,
    "category": 7,
    "difficulty": 2,
    "text": "Welche der folgenden SELECT-Abfragen ist syntaktisch korrekt?",
    "explanation": "Die WHERE-Klausel steht immer vor der Group-By-Klausel. \nIn der SELECT-Klausel dürfen nur zwei Arten von Spalten vorkommen:\n\ndie, die mit einer Gruppenfunktion versehen sind (hier Gehalt) \ndie anderen Spalten müssen in der GROUP-BY-Klausel enthalten sein.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT COUNT(*), Gruppe\nFROM Praktikum\nWHERE Fachkuerzel = 'DBS'\nGROUP BY Gruppe;",
        "solution": "true"
      },
      {
        "text": "SELECT COUNT(*), Gruppe\nFROM Praktikum\nGROUP BY Gruppe\nWHERE Fachkuerzel = 'DBS';",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(*), Gruppe\nFROM Praktikum;",
        "solution": "false"
      },
      {
        "text": "keine",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1659,
    "category": 5,
    "difficulty": 2,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E) mit den funktionalen Abhängigkeiten \nAB -> C, CD-> E und D -> B. Welche Attributkombination ist ein (minimaler) eindeutiger Schlüssel?",
    "explanation": "Es kann nur AD sein, weil dies die beiden einzigen Attribute sind, die von keinen anderen Attributen funktional abhängig sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "AB",
        "solution": "false"
      },
      {
        "text": "AD",
        "solution": "true"
      },
      {
        "text": "ABC",
        "solution": "false"
      },
      {
        "text": "ABCD",
        "solution": "false"
      },
      {
        "text": "ABE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1663,
    "category": 12,
    "difficulty": 2,
    "text": "Zu IF in PL/SQL gehört noch",
    "explanation": "Das Syntaxdiagramm der IF-Anweisung in PL/SQL ist:\n<IF Anweisung> ::=  \nIF  THEN   \n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]...\n[ ELSIF  THEN\n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]... ]...\n[ ELSE\n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]... ]\nEND IF;",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "THEN",
        "solution": "true"
      },
      {
        "text": "ENDIF",
        "solution": "false"
      },
      {
        "text": "END IF",
        "solution": "true"
      },
      {
        "text": "ELSE",
        "solution": "true"
      },
      {
        "text": "ELSEIF",
        "solution": "false"
      },
      {
        "text": "ELSIF",
        "solution": "true"
      },
      {
        "text": "ELSE IF",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1661,
    "category": 12,
    "difficulty": 2,
    "text": "Zu einer IF-Anweisung in PL/SQL kann es",
    "explanation": "Das Syntaxdiagramm der IF-Anweisung in PL/SQL ist:\n<IF Anweisung> ::=  \nIF  THEN   \n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]...\n[ ELSIF  THEN\n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]... ]...\n[ ELSE\n<SQL- und PL/SQL-Anweisung>; [ <SQL- und PL/SQL-Anweisung>; ]... ]\nEND IF;",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "nur eine ELSE-Anweisung geben",
        "solution": "true"
      },
      {
        "text": "mehrere ELSE-Anweísungen geben",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1679,
    "category": 5,
    "difficulty": 2,
    "text": "A und B  seien zwei Attribute einer Relation R.\nWoran erkennt man eine (volle) funktionale Abhängigkeit A -> B?",
    "explanation": "X und Y seien zwei Teilmengen von Attributen einer Relation R. \nY heißt funktional abhängig von X, wenn Folgendes gilt: \nFür alle Tupel r, s aus R gilt: \nAus ProjX(s) = ProjX(r) folgt stets: ProjY(s) = ProjY(r). \nAus dieser Definition folgt für einen Attributwert in A (=X) dass es in B (=Y) genau einen Attributwert gibt. \nAndere Aussagen lässt diese Definition nicht zu.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zu einem Spaltenwert B gibt es mehrere Spaltenwerte in A.",
        "solution": "false"
      },
      {
        "text": "Zu einem Spaltenwert B gibt es genau einen  Spaltenwert in A.",
        "solution": "false"
      },
      {
        "text": "Es gibt einen Spaltenwert B, zu dem es keinen Spaltenwert in A gibt.",
        "solution": "false"
      },
      {
        "text": "Zu einem Spaltenwert A gibt es mehrere Spaltenwerte in B.",
        "solution": "false"
      },
      {
        "text": "Zu einem Spaltenwert A gibt es genau einen  Spaltenwert in B.",
        "solution": "true"
      },
      {
        "text": "Es gibt einen Spaltenwert A, zu dem es keinen Spaltenwert in B gibt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1666,
    "category": 3,
    "difficulty": 1,
    "text": "Wie viele Beziehungsarten gibt es in ER-Diagrammen, wenn man die Kardinalität und die Optionalität, aber nicht die Symmetrie (1:n und n:1 bezeichnen den gleichen Typ) mit einbezieht? Dabei soll auch nicht  berücksichtigt werden, ob die Beziehung identifizierend  ist oder nicht.",
    "explanation": "(1:1) (1:C) (1:M) (1:CM)+\n\n    (C:C) (C:M) (C:CM)+\n\n    (N:M) (N:CM)+\n\n    (CN :CM)+\n\n    ================================\n\n    10 Beziehungstypen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "4",
        "solution": "false"
      },
      {
        "text": "8",
        "solution": "false"
      },
      {
        "text": "10",
        "solution": "true"
      },
      {
        "text": "12",
        "solution": "false"
      },
      {
        "text": "16",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1671,
    "category": 3,
    "difficulty": 3,
    "text": "Welche Aussagen über identifizierende 1:cn-Beziehungen in ER-Diagrammen sind richtig?",
    "explanation": "Bei identifizierenden Beziehungen werden in der Detail-Entitymenge die Fremdschlüsselattribute zum Primärschlüssel hinzugenommen, bei nicht identifizierenden Beziehungen werden die Fremdschlüsselattribute nur als \"normales\" Nichtschlüsselattribut eingetragen, welches nicht zum Primärschlüssel der Relation gehört. Dass die Aussage über die Nichtverwendung von identifizierenden Beziehungen bei künstlichen Primärschlüsseln korrekt ist, liegt an der Definition der künstlichen Primärschlüssel, die ja nur aus einem Attribut bestehen dürfen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Inhalte der Primärschlüsselspalten der Master-Entitymenge stellen einen dynamischen Wertebereich für die zugehörigen Fremdschlüsselspalten der Detail-Entitymenge dar.",
        "solution": "true"
      },
      {
        "text": "Die Attribute des Primärschlüssels der Master-Entitymenge treten als Nichtschlüsselattribute in der Detail-Entitymenge auf.",
        "solution": "false"
      },
      {
        "text": "Die Attribute des Primärschlüssels der Master-Entitymenge treten als Primärschlüsselattribute in der Detail-Entitymenge auf.",
        "solution": "true"
      },
      {
        "text": "Die Attribute des Primärschlüssels der Detail-Entitymenge treten als Primärschlüsselattribute in der Master-Entitymenge auf.",
        "solution": "false"
      },
      {
        "text": "Für den Fall, dass die an einer 1:cn-Beziehung beteiligten Entity-Menngen allesamt künstliche Primärschlüssel verwenden, gilt, dass keine identifizierenden Beziehungen verwendet werden dürfen.",
        "solution": "true"
      },
      {
        "text": "Eine 1:c1-Beziehung kann als identifizierende verwendet werden, wenn die Master-Entity-Menge einen künstlichen Primärschlüssel hat und die Detail-Entity-Menge keinen eigenen Primärschlüssel, sondern nur den künstlichen, vererbten über die identif. 1:c1-Beziehung.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1674,
    "category": 3,
    "difficulty": 2,
    "text": "Künstliche Schlüssel haben folgende Vorteile:",
    "explanation": "Schlüssel sind definiert als Menge von Attributen einer Entity-Menge, die eine Entität eindeutig identifizieren. Eine Entity-Menge kann auch mehrere Schlüssel haben. Ein Angestellter z.B. lässt sich über seine Personalnummer wie auch über die Attributkombination Name, Vorname, Adresse, Geburtsdatum identifizieren. Der letztgenannte Schlüssel ist ein Beispiel für einen zusammengesetzten Schlüssel. Bei der Modellierung wird ein Schlüssel als Primärschlüssel ausgezeichnet.\n\nZusammengesetzte Primärschlüssel sind in der Praxis schwer zu handhaben. Sobald sie als Fremdschlüssel in anderen Entity-Mengen auftreten, müssen bei lesendem Zugriff über diese Entitymenge und die Master-Entitymenge  immer alle Schlüsselattribute aufgeführt werden. Werden Teile des Schlüssels bei der Programmierung vergessen, kann das schwerwiegende Folgen für die Korrektheit der Lösung haben. Ein Index über mehrere Attribute hat außerdem den Nachteil, dass der Zugriff bei alternativen Attributreihenfolgen, die nicht dem Index entsprechen, langsamer ist. \nDaher werden in der Praxis häufig sogenannte künstliche Schlüssel (surrogate keys) verwendet. Ein künstlicher Schlüssel ist ein zusätzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Zähler vom\nDatentyp Integer, der systemintern verwaltet wird, nach außen nicht sichtbar ist und ausschließlich für die Primär- und Fremdschlüsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und Ähnlichem zu unterscheiden, die nach außen sichtbar sind und im Schriftverkehr verwendet oder zur\nIdentifikation beim Kunden erfragt werden. Wenn man sich für die Verwendung von künstlichen Primärschlüsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen für das gesamte Modell, unabhängig von den sonstigen Schlüsseln der Entity-Mengen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie reduzieren die Größe von Fremdschlüsseln",
        "solution": "true"
      },
      {
        "text": "Sie ermöglichen eine schnelle Suche",
        "solution": "true"
      },
      {
        "text": "Sie sind Abbild eines Attributs der realen Welt.",
        "solution": "false"
      },
      {
        "text": "Sie dienen der Objektorientierung der Datenbank.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1791,
    "category": 1,
    "difficulty": 2,
    "text": "Welche Aussagen über eine Datenbank sind richtig?",
    "explanation": "Ein DBS (Datenbanksystem) besteht aus zwei Teilen: dem Datenbankmanagementsystem (DBMS) und der Menge der zu verwaltenden Daten, der eigentlichen Datenbank. \nDas DBMS organisiert intern die strukturierte Speicherung der Daten und kontrolliert alle lesenden und schreibenden Zugriffe auf die Datenbank. \nZur Abfrage und Verwaltung der Daten bietet ein Datenbanksystem eine Datenbanksprache an. Daher ist DBS = Datenbasi + DBMS richtig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DBS = Datenbasis + DBMS",
        "solution": "true"
      },
      {
        "text": "DBS ist die Abkürzung für Datenbasis",
        "solution": "false"
      },
      {
        "text": "Als Datenbasis werden die nach einheitlichen Regeln in einem DBS persistent gespeicherten Daten bezeichnet",
        "solution": "true"
      },
      {
        "text": "DBMS = DBS + Datenbasis",
        "solution": "false"
      },
      {
        "text": "Das DBMS liegt in der Funktionalität zwischen Anwendungsprogrammen und Betriebssystem",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1683,
    "category": 13,
    "difficulty": 1,
    "text": "Welche der beiden Datenbanktrigger löst das Mutating-Table-Problem aus?",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.   \n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE or REPLACE TRIGGER pruefen\nAFTER INSERT ON test\nFOR EACH ROW\nDECLARE\nMY_VAR number;\nBEGIN\n      SELECT count(*) INTO MY_VAR\n    FROM Test;    \n    \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-2001, 'Zu viele Daten!');\n    END IF;\nEND;\n",
        "solution": "true"
      },
      {
        "text": "CREATE or REPLACE TRIGGER pruefen\nAFTER INSERT ON test\nDECLARE\nMY_VAR number;\nBEGIN\n      SELECT count(*) INTO MY_VAR\n    FROM Test;    \n    \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-2001, 'Zu viele Daten!');\n    END IF;\nEND;\n",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1792,
    "category": 1,
    "difficulty": 2,
    "text": "Welche Aussagen über das Data Dictionary sind richtig?",
    "explanation": "Das Data Dictionary enthält Daten (sogenannte Metadaten), die die Datenbasis, z.B. Tabellenstrukturen, definieren. Es umfasst außerdem Daten über die Verwendung und Bedeutung des Datenmodells, die Beziehungen der Daten untereinander und Integritätsbedingungen. \nDaher beruht es auf den gleichen Konzepten wie das Datenbanksystem selber und ist nicht optional,  also immer vorhanden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das Data Dictionary kann optional für ein Datenbanksystem eingerichtet werden",
        "solution": "false"
      },
      {
        "text": "Das Data Dictionary basiert auf den gleichen Konzepten wie das Datenbanksystem selbst, nämlich Tabellen, Attribute und Beziehungen",
        "solution": "true"
      },
      {
        "text": "Das Data Dictionary enthält Daten, die den Datenbestand beschreiben, also die Metadaten für die vom Benutzer angelegten Tabellen, Attribute, und Datentypen.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1682,
    "category": 11,
    "difficulty": 2,
    "text": "Wie gibt man unter SQLJ einen expliziten Kontext an?",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "#sql [context] { sql-Anweisung}",
        "solution": "true"
      },
      {
        "text": "#sql (context) { sql-Anweisung}",
        "solution": "false"
      },
      {
        "text": "#sql context = { sql-Anweisung}",
        "solution": "false"
      },
      {
        "text": "#sql context { sql-Anweisung}",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1684,
    "category": 1,
    "difficulty": 1,
    "text": "Welche Aufgabe hat ein SQL-Parser?",
    "explanation": "Ein SQL-Parser verarbeitet die Eingaben des Benutzers, indem er die Syntax, z.B. Verwendung von Schlüsselwörtern anlysiert.\nSo würde z.B. \"SLECT\" anstelle von \"SELECT\" zurückgewiesen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein SQL-Parser übersetzt SQL-Anteile in eine Programmiersprache, wie z.B. C.",
        "solution": "false"
      },
      {
        "text": "Der SQL-Parser analysiert die Syntax, z.B. die korrekte Verwendung von Schlüsselwörtern.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1685,
    "category": 3,
    "difficulty": 3,
    "text": "Modelliert man ein Attribut mit vorgegebenem Wertebereich, bei dem sich die Werte nur selten ändern (sogenannte Stammdaten) als ein vom Anwender frei eingebbares Textfeld, so können Probleme auftreten. Als Beispiel sei hier auf die Kontaktarten (Telefon, Brief, persönliches Gespräch, Email,... ) zur näheren Spezifikation eines Kundenkontakts eines Beraters mit seinen Kunden hingewiesen, die als Attribut \"Kontaktart\" in der Entitymenge \"Kundenkontakt\" modelliert werden kann.",
    "explanation": "Für diese Zwecke sind eine selbstdefinierte Domäne oder eine Werte-Entitymenge mit nicht identifizirender Beziehung am besten geeignet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dieses Problem kann mit einer eigenen Entitymenge für die Kontaktarten lösen, wobei eine 1:n-Beziehung zur Entitymenge \"Kundenkontakt\" modelliert wird.",
        "solution": "true"
      },
      {
        "text": "Dieses Problem kann mit einer eigenen Entitymenge für die Kontaktarten lösen, wobei eine 1:1-Beziehung zur Entitymenge \"Kundenkontakt\" modelliert wird.",
        "solution": "false"
      },
      {
        "text": "Dieses Problem kann man mit der Definition einer Domäne lösen.",
        "solution": "true"
      },
      {
        "text": "Nein, es können keine Probleme auftreten.",
        "solution": "false"
      },
      {
        "text": "Da für jeden Datensatz der Wert der Kontaktart eingetippt werden muss, können Rechtschreibfehler bei den verschiedenen Einträgen gemacht werden. Aufgrund dieser Rechtschreibfehler wird es schwierig, alle Einträge eines Werts mit seinen unterschiedlichen Schreibweisen wieder zu finden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1688,
    "category": 12,
    "difficulty": 2,
    "text": "Mit welcher Anweisung werden in SQL*PLUS bzw. dem SQL-Developer Ausgaben aus PL/SQL mit DBMS_OUTPUT.PUT_LINE (...) erst sichtbar?",
    "explanation": "Mit SET SERVEROUTPUT ON kann man das Ergebnis von DBMS_OUTPUT.PUT_LINE ()sichtbar machen und die Bildschirmbuffergröße über SIZE XXX ändern. Ohne SET SERVEROUTPUT ON ist das Ergebnis einer PL/SQL-Prozedur zunächst unsichtbar.",
    "type": "text",
    "answers": [
      {
        "text": "Die Anweisung (ohne Semikolon) heißt:",
        "solution": "SET SERVEROUTPUT ON"
      }
    ]
  },
  {
    "id": 1689,
    "category": 4,
    "difficulty": 1,
    "text": "Welche Operation aus der relationalen Algebra setzt den \"Für-Alle-Quantor\" (Allaussage) um?",
    "explanation": "Mit der Division wird der All-Quantor dargestellt, zum Beispiel werden Anfragen der Gestalt \"Welche Lieferanten liefern alle Materialien?\" beantwortet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Addition",
        "solution": "false"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Division",
        "solution": "true"
      },
      {
        "text": "Produkt",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1793,
    "category": 3,
    "difficulty": 2,
    "text": "Welche Aussagen über Attribute einer Entity-Menge sind wahr?",
    "explanation": "In ER-Modellen sind Entity-Mengen mit Attributen, die NULL-Werte zulassen, vorgesehen, aber keine mengenwertigen Attribute.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Attribut ist eine Eigenschaft, die allen Entitäten einer Entity-Menge gemeinsam ist.",
        "solution": "true"
      },
      {
        "text": "Attribute sind die Spalten der Entity-Mengen.",
        "solution": "true"
      },
      {
        "text": "Attribute sind immer optional.",
        "solution": "false"
      },
      {
        "text": "Ein Schlüssel kann aus einem oder mehreren Attributen bestehen.",
        "solution": "true"
      },
      {
        "text": "Attribute können Mengen von Werten enthalten (nicht atomar).",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1691,
    "category": 4,
    "difficulty": 1,
    "text": "Der Full Outer Join ist kommutativ.",
    "explanation": "Der Outer-Join (beidseitiger, vollständiger äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgefüllt werden, die beim natürlichen Join herausfallen würden. \nDie rechten und linken Outer-Joins sind hingegen nicht kommutativ, da entweder nur die rechte oder nur die linke Relation vollständig mit allen Tupeln in die Ergebnismenge aufgenommen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1692,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welchem CONSTRAINT_CHARACTERISTICA  kann man den Prüfungszeitpunkt unmittelbar direkt nach einer DML-Anweisung ausführen?",
    "explanation": "<CONSTRAINT Characteristika> ::= \n{ INITIALLY DEFERRED | INITIALLY IMMEDIATE } [ [ NOT ] DEFERRABLE ]\n\nMit DEFERRED (verzögert) wird die Prüfung der Integritätsbedingung zum Ende der Transaktion (COMMIT) bezeichnet. IMMEDIATE (unmittelbar) beschreibt die Prüfung unmittelbar im Anschluss an die Ausführung einer einzelnen Änderungsanweisung. \nIMMEDIATE hat den Vorteil, dass Integritätsfehler so früh wie möglich erkannt werden und DEFERRED, dass während der laufenden Transaktion durch nachfolgende Anweisungen ein zwischenzeitlich inkonsistenter Zustand wieder korrigiert werden kann.",
    "type": "text",
    "answers": [
      {
        "text": "CONSTRAINT_CHARACTERISTICA  =",
        "solution": "INITIALLY IMMEDIATE"
      }
    ]
  },
  {
    "id": 1693,
    "category": 6,
    "difficulty": 2,
    "text": "Ein CHECK-CONSTRAINT kann sich als COLUMN-Constraint auch auf mehrere Spalten beziehen.",
    "explanation": "Das ist ja gerade der entscheidende Unterschied zwischen Spalten- (COLUMN-) und Tabellen-Constraints (TABLE-Constraint). Spalten-Constraints können sich nur auf eine Spalte beziehen, während Tabellen-Constraints sich sowohl auf nur eine oder auf mehrere Spalten beziehen kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2441,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Primärschlüssel A, S den Primärschlüssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz)?",
    "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS ausgedrückt werden. Der Natural Join ähnelt dem Durchschnitt, nur das doppelte Spalten unterdrückt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT *\nFROM R\nWHERE NOT EXISTS (SELECT B FROM S where a = b);",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM R natural Join S;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2442,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie zwei Relationen R und S mit nur einer Spalte A bzw. B und dem Datentyp Integer. R habe den Primärschlüssel A, S den Primärschlüssel B.\nWelcher SELECT- Anweisung entspricht dem RA-Ausdruck R-S (Differenz)?",
    "explanation": "Die Differenz kann mit dem Minus-Operator (Reihenfolge beachten!) oder mit NOT IN bzw. NOT EXISTS oder einem LEFT Outer Join ausgedrückt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT A \nFROM R LEFT OUTER JOIN S ON S.B = R.A\nWHERE B is NULL;",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM R,S WHERE R.ID <> S.ID;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM R\nJOIN S USING (R.id !0 S.ID);",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2947,
    "category": 1,
    "difficulty": 1,
    "text": "In einer Datenbank sollen alle Daten widerspruchsfrei gespeichert werden. Diese Eigenschaft nennt man:",
    "explanation": "Das ist die Definition von konsistenten Daten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Konsistenz",
        "solution": "true"
      },
      {
        "text": "Persistenz",
        "solution": "false"
      },
      {
        "text": "Renitenz",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2164,
    "category": 15,
    "difficulty": 1,
    "text": "Welche Aussagen über B-Bäume sind wahr?",
    "explanation": "Da beim Einfügen eines Elements das mittlere Element nach oben gereicht wird, kann dies rekursiv zum Erzeugen von mehreren neuen Knoten (bis zur Wurzel) im B-Baum führen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nach einer Einfügung eines neuen Elements in einen B-Baum müssen höchstens zwei Knoten wegen Überlaufs aufgeteilt werden.",
        "solution": "false"
      },
      {
        "text": "Nach einer Einfügung eines neuen Elements in einen B-Baum können auch mehr als zwei Knoten wegen Überlaufs aufgeteilt werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2197,
    "category": 12,
    "difficulty": 2,
    "text": "Womit kann man in PL/SQL einen Record definieren, dessen Datentyp sich auf eine Tabellendefinition bezieht und der bei Änderungen der Tabellendefinition entsprechend aktualisiert wird?",
    "explanation": "Mit Tabellenname%ROWTYPeE wird die Attributstruktur einer Tabelle komplett übertragen, mit Tabellenname.Spaltenname%TYPE nur die Spaltendefinition einer einzigen Spalte der Tabelle.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "%ROWTYPE"
      }
    ]
  },
  {
    "id": 2198,
    "category": 12,
    "difficulty": 2,
    "text": "Womit kann man in PL/SQL eine Variable definieren, deren Datentyp sich auf eine einzelne Spaltendefinition bezieht und die bei Änderungen der Tabellendefinition entsprechend aktualisiert wird?",
    "explanation": "Mit Tabellenname%ROWTYPeE wird die Attributstruktur einer Tabelle komplett übertragen, mit Tabellenname.Spaltenname%TYPE nur die Spaltendefinition einer einzigen Spalte der Tabelle.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "%TYPE"
      }
    ]
  },
  {
    "id": 2216,
    "category": 13,
    "difficulty": 2,
    "text": "Transitionsvariablen sind bei SQL und Oracle in STATEMENT-Triggern verfügbar.",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).  \n\nLiegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich\nder Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.  \nDer SQL-Standard definiert Transitionstabellen  und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2309,
    "category": 9,
    "difficulty": 3,
    "text": "Welche/r Befehl/e sind bei Oracle syntaktisch richtig und erzeugen einen VARRAY?",
    "explanation": "Bei einem VARRAY kann nach der OF-Klausel nur ein Standarddatentyp (hier varchar2(25)) oder ein selbstdefinierter Typ (hier kinder_typ) stehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF Name VARCHAR2(25);",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF VARCHAR2(25);",
        "solution": "true"
      },
      {
        "text": "CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF \n                Name        VARCHAR2(25), \n                Geb_Datum   DATE;",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE TYPE kinder_typ AS OBJECT (Name VARCHAR2(25, Geb_Datum DATE);\n\n    CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF kinder_typ;",
        "solution": "true"
      },
      {
        "text": "CREATE OR REPLACE TYPE kinder_vartyp AS VARRAY(5) OF Name VARCHAR2;",
        "solution": "false"
      },
      {
        "text": "keiner von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2329,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind Subklassen der Geschäftspartner. \nWelche (Objekt-)Tabellen werden benötigt, wenn man diesen Sachverhalt gemäß der horizontalen Fragmentierung implementieren möchte?",
    "explanation": "Es gibt drei Fragmentierungstypen:  \n\nhorizontalen Fragmentierung  \nBei der horizontalen Form werden für jeden Subtyp eine Tabelle angelegt, aber nicht für den Supertypen, geht also nur, wenn die Subtypen vollständig sind. Die Subtypen-Tabellen verfügen neben den eigenen Attributen zudem über die Attribute des Supertypen.  \n\nvertikale Fragmentierung: \nBei der vertikalen Form werden für jeden Subtyp eine Tabelle angelegt und auch für den Supertypen, geht also, wenn die Subtypen unvollständig sind. Subtypen- und Supertyp-Tabellen verfügen jeweils über ihre eigenen Attribute. \n \nvirtuelle Fragmentierung:  \nBei der virtuellen Form wird nur eine Tabelle mit den Attributen aller Super- und Subtyen angelegt. Um unterscheiden zu können, welcher Datensatz nun zu welchem Subtypen gehört, werden entweder subtypenspezifische Attribute abgefragt oder eine zusätzliche sog. Diskriminatorspalte angelegt, die für jeden Subtpyen einen spezifischen Wert annimmt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen und einem Kennzeichenattribut, welches die Partnerart spezifiziert",
        "solution": "false"
      },
      {
        "text": "Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen sowie alle kunden- und lieferantenspezifischen Attribute und einem Kennzeichenattribut, welches die Partnerart spezifiziert",
        "solution": "false"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen und den kundenspezifischen",
        "solution": "true"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen und den lieferantenspezifischen",
        "solution": "true"
      },
      {
        "text": "Kunden, nur mit den kundenspezifischen Attributen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, nur mit den lieferantenspezifischen Attributen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2411,
    "category": 7,
    "difficulty": 1,
    "text": "Welche Aussagen über WHERE und GROUP BY sind korrekt?",
    "explanation": "Die Reihenfolge der Klauseln der SELECT-Anweisung ist folgende: \nSELECT ...\nFROM ...\nWHERE ....\nGROUP BY ...\nHAVING ...\nORDER BY ....",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die GROUP-BY-Klausel steht immer vor der WHERE-Klausel",
        "solution": "false"
      },
      {
        "text": "Die GROUP-BY-Klausel steht immer nach der WHERE-Klausel",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2305,
    "category": 9,
    "difficulty": 2,
    "text": "Welche objektrelationalen Datentypen/Typkonstruktoren  sind bei Oracle neu gegenüber dem relationalen DBS?",
    "explanation": "Atomare Werte gab es schon im relationalen Modell und der boolesche Datentyp fehlt nach wie vor.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "OID (object identifier)",
        "solution": "true"
      },
      {
        "text": "Atomare Werte",
        "solution": "false"
      },
      {
        "text": "LOB (large objects)",
        "solution": "true"
      },
      {
        "text": "VARRAY",
        "solution": "true"
      },
      {
        "text": "NESTED TABLE",
        "solution": "true"
      },
      {
        "text": "OBJECT (Objekttyp)",
        "solution": "true"
      },
      {
        "text": "REF (Referenz)",
        "solution": "true"
      },
      {
        "text": "BOOLEAN",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2209,
    "category": 13,
    "difficulty": 3,
    "text": "Was bewirkt der folgende Oracle-Trigger?  \n\nCREATE OR REPLACE TRIGGER test_trg\nAFTER UPDATE ON test_tabelle \nFOR EACH ROW \nBEGIN \n  :NEW.benutzer := USER; \nEND;",
    "explanation": "Da der Trigger erst nach dem Ereignis AFTER-UPDATE gefüllt wird, ändert sich nichts mehr in der Tabelle test_tabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Er sorgt dafür, dass der Wert der Spalte Benutzer mit der Kennung des angemeldeten Anwenders gefüllt wird.",
        "solution": "false"
      },
      {
        "text": "Er sorgt dafür, dass der Wert der Spalte Benutzer mit dem Wort 'User' gefüllt wird. \n",
        "solution": "false"
      },
      {
        "text": "nichts",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2082,
    "category": 7,
    "difficulty": 1,
    "text": "SELECT-Abfragen, die SELECT-Anweisungen der Grundform über einen UNION, einen INTERSECT oder MINUS verknüpfen, müssen",
    "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt für alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) müssen die gleichen Spaltendefinitionen aufweisen: \nDie Anzahl der Spalten muss übereinstimmen. \nDie Datentypen der der Spalten müssen gleich sein.  \nDie Reihenfolge der Spalten muss übereinstimmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "disjunkt sein",
        "solution": "false"
      },
      {
        "text": "vollständig sein",
        "solution": "false"
      },
      {
        "text": "vereinigungskonform sein",
        "solution": "true"
      },
      {
        "text": "linear äquivalent sein",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2093,
    "category": 6,
    "difficulty": 1,
    "text": "Mit welchem Befehl löscht man alle Rechte auf einer Tabelle XYZ für einen Benutzer Hugo?\nBitte Befehl mit Semikolon beenden!",
    "explanation": "RICHTIG ist: \nREVOKE ALL ON XYZ FROM Hugo;  \nweil die Syntaxvorgabe folgende ist:  \n<REVOKE Anweisung> ::=  \nREVOKE  ON [ Tabellenname | Sichtname ] FROM ;  \nFALSCH ist: \nREVOKE ALL FROM XYZ OF Hugo; weil falsche Schlüsselwörter FROM und OF.\nGRANT ALL FROM XYZ OF HUGO; weil mit GRANT Rechtevergeben werden und die Schlüsselwörter FROM und OF total falsch sind. \nDROP ALL ON XYZ; weil DROP ein Befehl zum Löschen von DB-Objekten wie Tabellen, Sichten, Sequenzen, Indexen etc. ist, aber nicht zum Löschen von Rechtezuordnungen zwischen Benutzern und DB-Objekten.\nDELETE ALL FROM XYZ; weil DELETE ein DML-Befehl zum Löschen von Datensätzen ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "REVOKE ALL FROM XYZ OF Hugo;",
        "solution": "false"
      },
      {
        "text": "REVOKE ALL ON XYZ FROM Hugo;",
        "solution": "true"
      },
      {
        "text": "GRANT ALL ON XYZ TO HUGO;",
        "solution": "false"
      },
      {
        "text": "DROP ALL ON XYZ FROM Hugo;",
        "solution": "false"
      },
      {
        "text": "DELETE ALL FROM XYZ OF Hugo;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2094,
    "category": 1,
    "difficulty": 1,
    "text": "Was versteht man unter der Abkürzung DDL?",
    "explanation": "DDL (Data Definition Language):\n\nDie DDL stellt Sprachelemente zur Verfügung, mit denen die Datenbankobjekte definiert, modifiziert und gelöscht werden. Einsatzgebiet ist die konzeptionelle Ebene im ANSI-3-Ebenen-Modell.",
    "type": "text",
    "answers": [
      {
        "text": "Man versteht darunter:",
        "solution": "Data Definition Language"
      }
    ]
  },
  {
    "id": 2095,
    "category": 1,
    "difficulty": 1,
    "text": "Was versteht man unter der Abkürzung DML?",
    "explanation": "DML (Data Manipulation Language):\nDie DML stellt Sprachelemente zum Anlegen, Ändern und Löschen von Daten zur Verfügung. Einsatzgebiet ist die externe Ebene im ANSI-3-Ebenen-Modell.",
    "type": "text",
    "answers": [
      {
        "text": "Man versteht darunter:",
        "solution": "Data Manipulation Language"
      }
    ]
  },
  {
    "id": 2096,
    "category": 1,
    "difficulty": 1,
    "text": "Was versteht man unter der Abkürzung DCL?",
    "explanation": "DCL (Data Control Language)\nDie DCL stellt Sprachelemente zur Definition der Speicherstrukturen und Zugriffsmechanismenzur Verfügung. Dazu gehören:\n\nFestlegung von Speicherstrukturen,\nFestlegung von Zugriffs- und Integritätskontrollen,\nFestlegung der Sicherungsstrategie,\nÜberwachung der Systemauslastung und des Laufzeitverhaltens (Performance) und \nTuning des Systems zur optimalen Anpassung an laufende oder neue Aufgabenstellungen",
    "type": "text",
    "answers": [
      {
        "text": "Man versteht darunter:",
        "solution": "Data Control Language"
      }
    ]
  },
  {
    "id": 2097,
    "category": 7,
    "difficulty": 1,
    "text": "Was versteht man unter der Abkürzung DQL?",
    "explanation": "Die DQL (Data Query Language) besteht nur eine einzigen SQL-Anweisung, der SELECT-Anweisung.",
    "type": "text",
    "answers": [
      {
        "text": "Man versteht darunter:",
        "solution": "Data Query Language"
      }
    ]
  },
  {
    "id": 2102,
    "category": 1,
    "difficulty": 2,
    "text": "Welche Aussagen über ein Datenbankschema sind wahr?",
    "explanation": "Ein Datenbankschema ist die konkrete Ausprägung eines bestimmten Datenmodells mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Datenbankschema stellt einen allgemeinen Begriffsapparat zur Verfügung, der es gestattet, Realitätsausschnitte ohne Eingrenzung auf ein bestimmtes Sachgebiet zu modellieren.",
        "solution": "false"
      },
      {
        "text": "Mit dem Datenbankschema werden die Datenobjekte und die Operatoren auf diesen Objekten festgelegt, ähnlich wie bei einer Programmiersprache, in der auch Ausdrücke und Regeln festgelegt sind, die in der Programmiersprache benutzt werden dürfen.",
        "solution": "false"
      },
      {
        "text": "Ein Datenbankschema ist die konkrete Ausprägung eines bestimmten Datenmodells mit Daten, die einen Ausschnitt aus der Wirklichkeit modellieren.",
        "solution": "true"
      },
      {
        "text": "Ein Datenbankschema hat Basisdatentypen und Typkonstruktoren, um aus den einfachen Datentypen komplexere Daten sowie Typkonstruktionsregeln zu konstruieren. Die Typkonstruktionsregeln legen fest, in welcher Form sich Basisdatentypen und Typkonstruktoren miteinander kombinieren lassen.",
        "solution": "false"
      },
      {
        "text": "Bei einem Datenbankschema werden die Daten in Dateien gespeichert, die nur von einem Programm genutzt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2207,
    "category": 13,
    "difficulty": 3,
    "text": "Wie können Informationen an einen Oracle-Trigger übergeben werden?",
    "explanation": "ORACLE-Trigger verwenden Transitionsvariablen :NEW und :OLD, aber leider keine Transitionstabellen, wie im SQL-Standard vorsehen. \n\nEine andere Möglichkeit, Daten an einen Trigger zu übergeben, ist eine SELECT-Anweisung oder eine öffentliche Package-Variablen.\n\nEin Trigger verfügt über keine Parameter. Dieses Konzept ist nur bei Funktionen und Prozeduren bekannt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Transitionsvariablen",
        "solution": "true"
      },
      {
        "text": "Transitionstabellen",
        "solution": "false"
      },
      {
        "text": "Aufrufparameter",
        "solution": "false"
      },
      {
        "text": "Public Package-Variable",
        "solution": "true"
      },
      {
        "text": "Anfrage an eine Tabelle",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2208,
    "category": 13,
    "difficulty": 3,
    "text": "Welche/r Trigger verhindert, dass die oid-Spalte geändert wird?",
    "explanation": "Ein Trigger mit \"BEFORE UPDATE ON Test\" ohne Spaltenangabe verhindert, dass irgendein Wert in der Tabelle Test verändert wird, nicht nur die OID. \n\nEin Trigger kann kein ROLLBACK enthalten, da er Bestandteil einer Transaktion ist. \n\nDBMS_OUTPUT.PUT_LINE (...) löst kein Rollback aus, dass heißt, die Spalte OID kann verändert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPLACE TRIGGER update_verhindern\nAFTER UPDATE ON test_tabelle OF oid \nFOR EACH ROW \nBEGIN \n  RAISE_APPLICATION_ERROR(-20002,\"OID nicht geändert!\"); \nEND;",
        "solution": "true"
      },
      {
        "text": "CREATE OR  REPLACE TRIGGER update_verhindern\nBEFORE UPDATE ON test_tabelle OF oid \nFOR EACH ROW \nBEGIN  \n  RAISE_APPLICATION_ERROR(-20002,\"OID nicht geändert!\"); \nEND;",
        "solution": "true"
      },
      {
        "text": "CREATE OR  REPLACE TRIGGER update_verhindern\nBEFORE UPDATE ON test_tabelle OF oid \nFOR EACH ROW \nBEGIN  \n  DBMS_OUTPUT.PUT_LINE(\"OID nicht geändert!\"); \nEND;",
        "solution": "false"
      },
      {
        "text": "keiner von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2210,
    "category": 13,
    "difficulty": 1,
    "text": "Was bewirkt der folgende Oracle-Trigger?  \n\nCREATE OR REPLACE TRIGGER test_trg\nBEFORE UPDATE ON test_tabelle \nFOR EACH ROW \nBEGIN \n  :NEW.benutzer := USER; \nEND;",
    "explanation": "Da der Trigger vor nach dem Ereignis BEFORE-UPDATE gefüllt wird, ändert sich in der Tabelle test_tabelle der Eintrag in der Spalte Benutzer. Es wird die Systemvariable USER, also die Kennung des angemeldeten Anwenders eingetragen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Er sorgt dafür, dass der Wert der Spalte Benutzer mit der Kennung des angemeldeten Anwenders gefüllt wird.",
        "solution": "true"
      },
      {
        "text": "Er sorgt dafür, dass der Wert der Spalte Benutzer mit dem Wort 'User' gefüllt wird. \n",
        "solution": "false"
      },
      {
        "text": "nichts",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2211,
    "category": 13,
    "difficulty": 2,
    "text": "Eine Preiserhöhung darf nicht mehr als 10% betragen. Wie kann diese Integritätsbedingung ganz einfach geprüft werden?",
    "explanation": "Diese Integritätsbedingung lässt sich nur mit ROW-Triggern realisieren, da CHECK-Constraints nur eine sehr eingeschränkte Syntax haben und STATEMENT-Trigger keinen Zugriff auf eine einzelne Zeile erlauben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Tabellen-CHECK-Constraint",
        "solution": "false"
      },
      {
        "text": "Spalten-CHECK-Constraint",
        "solution": "false"
      },
      {
        "text": "ROW-Trigger",
        "solution": "true"
      },
      {
        "text": "STATEMENT-Trigger",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2220,
    "category": 13,
    "difficulty": 3,
    "text": "Welche Anweisungen sind in ORACLE-Triggern zugelassen?",
    "explanation": "Alle DML-Anweisungen und SELECT sind möglich, genauso wie natürlich PL/SQL-Statements. DDL-Anweisungen können aus Sicherheitsgründen und da Trigger Bestandteile eine Transaktion sind nur über dynamisches SQL ausgeführt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INSERT, UPDATE, DELETE",
        "solution": "true"
      },
      {
        "text": "COMMIT, ROLLBACK",
        "solution": "false"
      },
      {
        "text": "CREATE, ALTER, DROP",
        "solution": "false"
      },
      {
        "text": "alle PL/SQL-Anweisungen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2221,
    "category": 13,
    "difficulty": 2,
    "text": "Es wird eine UPDATE-Anweisung auf der Tabelle X ausgeführt, von der aber keine Datensätze betroffen sind. Für diese Tabelle X ist je ein BEFORE-STATEMENT- und ein BEFORE-ROW-Trigger definiert. Wie oft werden diese Trigger jeweils ausgeführt?",
    "explanation": "Da keine Spalte verändert wird, wird der BEFORE-ROW-Trigger nicht angestoßen, während der BEFORE-UPDATE-STATEMENT-Trigger genau einmal ausgeführt wird.",
    "type": "text",
    "answers": [
      {
        "text": "BEFORE-UPDATE-STATEMENT-Trigger",
        "solution": "1"
      },
      {
        "text": "BEFORE-UPDATE-ROW-Trigger",
        "solution": "0"
      }
    ]
  },
  {
    "id": 2222,
    "category": 13,
    "difficulty": 1,
    "text": "Es wird eine UPDATE-Anweisung auf der Tabelle X ausgeführt, von der 6 Datensätze betroffen sind. Für diese Tabelle X ist je ein BEFORE-STATEMENT- und ein BEFORE-ROW-Trigger definiert. Wie oft werden diese Trigger jeweils ausgeführt?",
    "explanation": "Da 6 Spaltenwerte verändert werden, wird der BEFORE-ROW-Trigger 6-mal angestoßen, während der BEFORE-UPDATE-STATEMENT-Trigger genau einmal ausgeführt wird.",
    "type": "text",
    "answers": [
      {
        "text": "BEFORE-UPDATE-STATEMENT-Trigger",
        "solution": "1"
      },
      {
        "text": "BEFORE-UPDATE-ROW-Trigger",
        "solution": "6"
      }
    ]
  },
  {
    "id": 2233,
    "category": 7,
    "difficulty": 2,
    "text": "Transitionsvariablen werden bei Oracle",
    "explanation": "Transitionstabellen (Referencing Tables: OLD TABLE, NEW TABLE) sind sowohl in Befehls- wie auch in Zeilentriggern verfügbar.  Transitionsvariablen  (Referencing Variables: OLD [ROW], NEW [ROW]) hingegen sind nur in Zeilentriggern zugreifbar. Die Transitionstabellen beinhalten während der Triggerausführung den alten und den neuen Zustand der Triggertabelle. Um auf den neuen oder alten Wert eines Attributs zugreifen zu können, wird dem Attributnamen das Schlüsselwort NEW bzw. OLD in Punktnotation vorangestellt (z.B. OLD.Spalte).\n\n    \n\n    Liegt ein UPDATE-Ereignis vor, so sind die OLD wie auch die NEW-Variablen und -Tabellen mit den zugehörigen alten/neuen Werten gefüllt. Beim DELETE-Ereignis sind nur die OLD-Variablen und -Tabellen belegt. Beim INSERT sind es nur die NEW-Variablen und -Tabellen. Für BEFORE TRIGGER gilt die zusätzliche Restriktion, dass keine Transitionstabellen verfügbar sind. Der Geltungsbereich der Transitionsvariablen und -tabellen sind die Trigger, die für das zugehörige Ereignis gefeuert wurden. In der Referenzklausel besteht nun die Möglichkeit die Schlüsselwörter OLD bzw. NEW [ROW] sowie OLD und NEW TABLE umzubenennen in selbst gewählte Bezeichnungen, die Zeilenalias_alter/neuer_Wert und Tabellenalias_ alter/neuer_Wert.\n\n    \n\n    Der SQL-Standard definiert Transitionstabellen und Transitionsvariablen, DB2 kennt beide Typen, Oracle nur Transitionsvariablen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "in allen Triggerkomponenten mit Doppelpunkt geschrieben.",
        "solution": "false"
      },
      {
        "text": "in der WHEN-Bedingung mit Doppelpunkt geschrieben.",
        "solution": "false"
      },
      {
        "text": "in der WHEN-Bedingung ohne Doppelpunkt geschrieben.",
        "solution": "true"
      },
      {
        "text": "im Aktionsteil mit Doppelpunkt geschrieben.",
        "solution": "true"
      },
      {
        "text": "im Aktionsteil ohne Doppelpunkt geschrieben.",
        "solution": "false"
      },
      {
        "text": "in allen Triggerkomponenten ohne Doppelpunkt geschrieben.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2234,
    "category": 13,
    "difficulty": 2,
    "text": "Wie wird ein Trigger mit dem Bezeichner triggername aufgerufen und ausgeführt?",
    "explanation": "Trigger werden nur durch das auslösende Ereignis (INSERT / UPDATE / DELETE) angestoßen, eine andere Möglichkeit gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Unter SQL-Plus/ISQL-Plus mit     EXECUTE triggername",
        "solution": "false"
      },
      {
        "text": "Im PL/SQL-Programm einfach nur mit dem   triggername",
        "solution": "false"
      },
      {
        "text": "Durch ein eingetretenes Ereignis",
        "solution": "true"
      },
      {
        "text": "Durch einen eingetretenen Ausführungszeitpunkt",
        "solution": "false"
      },
      {
        "text": "In SELECT- und DML-Anweisungen durch Verwendung von   triggername",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2257,
    "category": 12,
    "difficulty": 1,
    "text": "Mit  welchem PL/SQL-Blocktyp ermittelt man immer einen Wert und gibt ihn zurück?",
    "explanation": "PL/SQL unterscheidet vier Typen von Blöcken: \n\nEin Anonymer Block ist ein unbenannter PL/SQL-Block, der in einer Anwendung (Prozedur, Funktion ) eingebettet ist oder interaktiv eingegeben wird. \nEine Stored ist ein benannter PL/SQL-Block, der Parameter haben kann und als Prozedur oder Funktion definiert ist. Er wird im Datenbanksystem gespeichert und auf dem Server von der PL/SQL-Engine ausgeführt. Stored Functions geben über RETURN einen Wert an das aufrufende Programm zurück\nEin PACKAGE ist ein benannter PL/SQL-Block, der logisch verwandte Prozeduren und Funktionen, Deklarationen etc. zu einer Bibliothek zusammenfasst. \nEin Datenbanktrigger ist ein PL/SQL-Block, der zu einem definierten Ereignis (INSERT, UPDATE oder DELETE) automatisch vom Datenbankmanagementsystem aktiviert und ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Prozedur",
        "solution": "false"
      },
      {
        "text": "Trigger",
        "solution": "false"
      },
      {
        "text": "Funktion",
        "solution": "true"
      },
      {
        "text": "Paket",
        "solution": "false"
      },
      {
        "text": "Anonymer Block",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2258,
    "category": 12,
    "difficulty": 2,
    "text": "Womit kann man in PL/SQL einen Record definieren, dessen Datentyp sich auf eine Tabellendefinition bezieht und der bei  Änderungen der Tabellendefinition entsprechend aktualisiert wird?",
    "explanation": "Mit Tabellenname%ROWTYPE wird die Attributstruktur einer Tabelle komplett an einen PL/SQL-Rekord übertragen und dynamisch angepasst. wenn sich dien Tabellendefinition ändert. Mit Tabellenname.Spaltenname%TYPE kann man eine Variable entsprechend der Spalte einer Tabelle definieren.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "%ROWTYPE"
      }
    ]
  },
  {
    "id": 2259,
    "category": 12,
    "difficulty": 3,
    "text": "Womit kann man in PL/SQL eine Variable definieren, deren Datentyp sich auf eine Tabellendefinition bezieht und die bei Änderungen der Tabellendefinition entsprechend aktualisiert wird?",
    "explanation": "Mit Tabellenname%ROWTYPE wird die Attributstruktur einer Tabelle komplett an einen PL/SQL-Rekord übertragen und dynamisch angepasst. wenn sich die Tabellendefinition ändert. Mit Tabellenname.Spaltenname%TYPE kann man eine Variable entsprechend einer einzelnen Spalte einer Tabelle definieren.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "\r\n    %ROWTYPE\r"
      }
    ]
  },
  {
    "id": 2260,
    "category": 12,
    "difficulty": 2,
    "text": "Mit welchem Befehl kann man unter PL/SQL eine Meldung anzeigen lassen und gleichzeitig das Programm fehlerhaft abbrechen lassen?",
    "explanation": "RAISE und RAISE_APPLICATION_ERROR werfen einen Fehler, dem man eine eigene Fehlermeldung zuordnen kann. Damit wird das PL/SQL-Programm unterbrochen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "RAISE_APPLICATION_ERROR"
      }
    ]
  },
  {
    "id": 2261,
    "category": 12,
    "difficulty": 1,
    "text": "Welche Klausel kommt bei SELECT-Anweisungen unter PL/SQL neu hinzu?",
    "explanation": "SELECT INTO var \nübergibt genau einen Datensatz oder Wert an die INTO-Variable var, die nur genau einen Wert oder Datensatz aufnehmen kann.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "INTO"
      }
    ]
  },
  {
    "id": 2288,
    "category": 9,
    "difficulty": 1,
    "text": "Aufgrund der strengen Typisierung bei ORBS sind implizite und explizite Typumwandlungen notwendig.",
    "explanation": "Das ist die Definition der strengen Typisierung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2289,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Datentypen sind gängige Basisdatentypen in einem ORDBS?",
    "explanation": "VARRAY und NESTED-Table sind ORACLE-Konstrukte, die nicht zum Standard-SQL gehören.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NUMBER",
        "solution": "true"
      },
      {
        "text": "VARRAY",
        "solution": "false"
      },
      {
        "text": "DATE",
        "solution": "true"
      },
      {
        "text": "BLOB",
        "solution": "true"
      },
      {
        "text": "NESTED TABLE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2290,
    "category": 9,
    "difficulty": 3,
    "text": "Typkonstuktoren in ORDBS",
    "explanation": "Typkonstruktoren können auch in Tupeltabellen benutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "sind beliebig schachtelbar",
        "solution": "true"
      },
      {
        "text": "können nicht geschachtelt aufgerufen werden",
        "solution": "false"
      },
      {
        "text": "sollen eine intuitivere Abbildung der Realität ermöglichen.",
        "solution": "true"
      },
      {
        "text": "können nur in Objekttabellen verwendet werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2306,
    "category": 9,
    "difficulty": 3,
    "text": "Welche objektrelationalen Datentypen sind in der Theorie objektrelationaler DBS vorgesehen, die es beim relationalen Modell nicht gibt?",
    "explanation": "Atomare Werte und boolesche Datentypen gehören zum relationalen Modell.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "OID (object identifier)",
        "solution": "true"
      },
      {
        "text": "Atomare Werte",
        "solution": "false"
      },
      {
        "text": "LOB (large objects)",
        "solution": "true"
      },
      {
        "text": "ARRAY",
        "solution": "true"
      },
      {
        "text": "MULTISET",
        "solution": "true"
      },
      {
        "text": "SET",
        "solution": "true"
      },
      {
        "text": "LIST",
        "solution": "true"
      },
      {
        "text": "OBJECT (Objekttyp)",
        "solution": "true"
      },
      {
        "text": "ROW",
        "solution": "true"
      },
      {
        "text": "REF (Referenz)",
        "solution": "true"
      },
      {
        "text": "BOOLEAN",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2307,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussagen über VARRAY-Datentypen sind bei Oracle wahr?",
    "explanation": "Bis auf die Einschränkung, dass einzelne Einträge nicht verändert werden können, sind alle Aussagen der Frage zu den VARRAY richtig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie sind eine geordnete Menge Elementen von Datenelementen.",
        "solution": "true"
      },
      {
        "text": "Alle Datenelemente haben den gleichen Datentyp.",
        "solution": "true"
      },
      {
        "text": "Es wird eine maximale Anzahl an Einträgen vorgegeben.",
        "solution": "true"
      },
      {
        "text": "Innerhalb dieser Eintragsgrenze ist die Anzahl an Einträgen variabel.",
        "solution": "true"
      },
      {
        "text": "Es wird automatisch eine Konstruktormethode erzeugt, die genauso heißt wie der VARRAY-Typ.",
        "solution": "true"
      },
      {
        "text": "Daten werden unter Verwendung der Konstruktormethode eingefügt.",
        "solution": "true"
      },
      {
        "text": "Daten werden unter Verwendung der Konstruktormethode geändert.",
        "solution": "true"
      },
      {
        "text": "Einzelne Einträge in einem VARRAY können direkt geändert werden.",
        "solution": "false"
      },
      {
        "text": "VARRAYs sind Kollektionsdatentypen und stellen daher eine Verletzung der 1. NF im relationalen Modell dar.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2312,
    "category": 9,
    "difficulty": 2,
    "text": "Beim Erzeugen eines NESTED TABLE-Datentyps kann man bei Oracle nur ein Datentyp spezifiziert werden, so dass es nur einspaltige NESTED TABLEs gibt.",
    "explanation": "NESTED TABLE \nMit der STORE-Klausel können tabellenwertige Spalten beschrieben werden. Für jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher inneren Tabelle die tabellenwertigen Spalten abgelegt werden. Der Kollektionstyp kann dabei wieder auf einem benutzerdefinierten Datentyp aufsetzen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dieses Problem gibt es nicht bei Oracle.",
        "solution": "false"
      },
      {
        "text": "Will man dieses Problem umgehen, so kann man bei Oracle einen strukturierten Datentyp verwenden, der aus mehreren Attributen besteht.",
        "solution": "true"
      },
      {
        "text": "Will man dieses Problem umgehen, so kann man bei Oracle für die Datentypdefinition einen ROW-Kontruktor verwenden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2313,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt die Klausel bei Oracle, mit der man den Namen einer NESTED-TABLE spezifiziert? Wenn es eine solche Klausel nicht gibt, schreiben Sie \"gibt es nicht\"",
    "explanation": "NESTED TABLE \nMit der STORE AS Klausel können tabellenwertige Spalten beschrieben werden. Für jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher inneren Tabelle die tabellenwertigen Spalten abgelegt werden. Der Kollektionstyp kann dabei wieder auf einem benutzerdefinierten Datentyp aufsetzen.",
    "type": "text",
    "answers": [
      {
        "text": "Sie heißt:",
        "solution": "STORE AS"
      }
    ]
  },
  {
    "id": 2314,
    "category": 9,
    "difficulty": 2,
    "text": "In welchem Befehl wird beim Oracle-DBS der Tabellenname für ein NESTED-TABLE-Attribut spezifiziert?",
    "explanation": "Die STORE AS-Klausel wird bei der Tabellendefinition, nicht bei der Typdefinition angegeben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPLACE TYPE <typname>   STORE AS <tabellenname>;",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE <tabellenname> AS OBJECT   STORE AS <tabellenname>;",
        "solution": "true"
      },
      {
        "text": "Solch eine Klausel gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2178,
    "category": 14,
    "difficulty": 2,
    "text": "Es ist folgende Tabelle mit zwei persistent gespeicherten Datensätzen gegeben:\nCREATE TABLE trans_tab (s1  NUMBER(3) PRIMARY KEY INITIALLY IMMEDIATE, \n                        s2  VARCHAR2(20) UNIQUE INITIALLY DEFERRED);\nINSERT INTO trans_tab VALUES (1, 'Mustermann');\nINSERT INTO trans_tab VALUES (2, 'Musterfrau');\nCOMMIT;\n\nSchauen Sie sich nachfolgende Anweisungen an und geben Sie an, welche Datensätze zum Zeitpunkt b) mit der SELECT-Anfrage angezeigt werden. \n\nSELECT * FROM trans_tab;                -- Zeitpunkt a)\nINSERT INTO trans_tab VALUES (3, 'Schmitt');\nINSERT INTO trans_tab VALUES (4, 'Schmidt');\nINSERT INTO trans_tab VALUES (4, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                -- Zeitpunkt b)\nINSERT INTO trans_tab VALUES (5, 'Schmitzchen');\nINSERT INTO trans_tab VALUES (6, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                 -- Zeitpunkt c)\nCOMMIT;\n\nSELECT * FROM trans_tab;                -- Zeitpunkt d)",
    "explanation": "Nach dem CREATE-TABLE werden zwei Datensätze eingefügt, die keines der Constraints verletzt, und anschließend mit COMMIT persistent gespeichert, so dass folgender Inhalt beim a)-SELECT gegen ist. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n\nVon den drei bis zum b)-SELECT eingefügten Datensätzen verletzt der letzte mit dem Primärschlüssel 4 das PRIMARY KEY-Constraint und da dies als IMMEDIATE definiert ist, wird nur dieser fehlerhafte, letzte Datensatz zurückgewiesen. Die beiden vorherigen richtigen Datensätze bleiben in der aktuellen Transaktion. Aber Achtung, da hier nicht \"committed\" wird, werden diese beiden Datensätze nicht persistent gespeichert. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen",
        "solution": "false"
      },
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt",
        "solution": "true"
      },
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2179,
    "category": 14,
    "difficulty": 2,
    "text": "Es ist folgende Tabelle mit zwei persistent gespeicherten Datensätzen gegeben:\nCREATE TABLE trans_tab (s1  NUMBER(3) PRIMARY KEY INITIALLY IMMEDIATE, \n                        s2  VARCHAR2(20) UNIQUE   INITIALLY DEFERRED);\nINSERT INTO trans_tab VALUES (1, 'Mustermann');\nINSERT INTO trans_tab VALUES (2, 'Musterfrau');\nCOMMIT;\n\nSchauen Sie sich nachfolgende Anweisungen an und geben Sie an, welche Datensätze zum Zeitpunkt c) mit der SELECT-Anfrage angezeigt werden. \n\nSELECT * FROM trans_tab;                -- Zeitpunkt a)\nINSERT INTO trans_tab VALUES (3, 'Schmitt');\nINSERT INTO trans_tab VALUES (4, 'Schmidt');\nINSERT INTO trans_tab VALUES (4, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                -- Zeitpunkt b)\nINSERT INTO trans_tab VALUES (5, 'Schmitzchen');\nINSERT INTO trans_tab VALUES (6, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                 -- Zeitpunkt c)\nCOMMIT;\n\nSELECT * FROM trans_tab;                -- Zeitpunkt d)",
    "explanation": "Nach dem CREATE-TABLE werden zwei Datensätze eingefügt, die keines der Constraints verletzt, und anschließend mit COMMIT persistent gespeichert, so dass folgender Inhalt beim a)-SELECT gegen ist. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n\nVon den drei bis zum b)-SELECT eingefügten Datensätzen verletzt der letzte mit dem Primärschlüssel 4 das PRIMARY KEY-Constraint und da dies als IMMEDIATE definiert ist, wird nur dieser fehlerhafte, letzte Datensatz zurückgewiesen. Die beiden vorherigen richtigen Datensätze bleiben in der aktuellen Transaktion. Aber Achtung, da hier nicht \"committed\" wird, werden diese beiden Datensätze nicht persistent gespeichert. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n\nDie laufende Transaktion wird mit zwei weiteren INSERTs (5, 6) fortgesetzt. Der zweite davon verletzt mit einer erneuten Einfügung des Namens \"Schmitzschen\" zwar das UNIQUE-Constraint, aber da dies als DEFERRED definiert ist, wird dieser Fehler noch nicht vom DBS erkannt, die beiden neuen Datensätze gehören zum Zeitpunkt des c)-SELECTs nun auch der aktuellen Transaktion an.  \n\n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen",
        "solution": "true"
      },
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt",
        "solution": "false"
      },
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2180,
    "category": 14,
    "difficulty": 2,
    "text": "Es ist folgende Tabelle mit zwei persistent gespeicherten Datensätzen gegeben:\nCREATE TABLE trans_tab (s1  NUMBER(3) PRIMARY KEY INITIALLY IMMEDIATE, \n                        s2  VARCHAR2(20) UNIQUE   INITIALLY DEFERRED);\nINSERT INTO trans_tab VALUES (1, 'Mustermann');\nINSERT INTO trans_tab VALUES (2, 'Musterfrau');\nCOMMIT;\n\nSchauen Sie sich nachfolgende Anweisungen an und geben Sie an, welche Datensätze zum Zeitpunkt d) mit der SELECT-Anfrage angezeigt werden. \n\nSELECT * FROM trans_tab;                -- Zeitpunkt a)\nINSERT INTO trans_tab VALUES (3, 'Schmitt');\nINSERT INTO trans_tab VALUES (4, 'Schmidt');\nINSERT INTO trans_tab VALUES (4, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                -- Zeitpunkt b)\nINSERT INTO trans_tab VALUES (5, 'Schmitzchen');\nINSERT INTO trans_tab VALUES (6, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                 -- Zeitpunkt c)\nCOMMIT;\n\nSELECT * FROM trans_tab;                -- Zeitpunkt d)",
    "explanation": "Nach dem CREATE-TABLE werden zwei Datensätze eingefügt, die keines der Constraints verletzt, und anschließend mit COMMIT persistent gespeichert, so dass folgender Inhalt beim a)-SELECT gegen ist. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n\nVon den drei bis zum b)-SELECT eingefügten Datensätzen verletzt der letzte mit dem Primärschlüssel 4 das PRIMARY KEY-Constraint und da dies als IMMEDIATE definiert ist, wird nur dieser fehlerhafte, letzte Datensatz zurückgewiesen. Die beiden vorherigen richtigen Datensätze bleiben in der aktuellen Transaktion. Aber Achtung, da hier nicht \"committed\" wird, werden diese beiden Datensätze nicht persistent gespeichert. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n\nDie laufende Transaktion wird mit zwei weiteren INSERTs (5, 6) fortgesetzt. Der zweite davon verletzt mit einer erneuten Einfügung des Namens \"Schmitzschen\" zwar das UNIQUE-Constraint, aber da dies als DEFERRED definiert ist, wird dieser Fehler noch nicht vom DBS erkannt, die beiden neuen Datensätze gehören zum Zeitpunkt des c)-SELECTs nun auch der aktuellen Transaktion an.  \n\n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen\n\nDie aktuelle Transaktion bestehend aus den Datensätzen 3, 4, 5, 6 wird vor dem d)-SELECT mittels COMMIT abgeschlossen. Damit werden alle DEFERRED-Constraints geprüft und in diesem Fall der UNIQUE-Fehler mit \"Schmitzchen\" erkannt. Da bei DEFERRED-Fehlern die gesamte Transaktion zurückgerollt wird, bleiben nur noch die beiden ursprünglichen Datensätze übrig, die mit der ersten Transaktion \"committed\" wurden. \n\n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen",
        "solution": "false"
      },
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt",
        "solution": "false"
      },
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2181,
    "category": 13,
    "difficulty": 3,
    "text": "Betrachten Sie die Tabelle Test:\n\nCREATE TABLE TEST\n(OID NUMBER(38),\n bezeichnung VARCHAR2(100));\n\nWelche/r Trigger ist syntaktisch korrekt und verhindert nur für die OID-Spalte, dass sie verändert wird?",
    "explanation": "Ein Trigger mit \"BEFORE UPDATE ON Test\" ohne Spaltenangabe verhindert, dass irgendein Wert in der Tabelle Test verändert wird, nicht nur die OID. \n\nEin Trigger kann kein ROLLBACK enthalten, da er Bestandteil einer Transaktion ist. \n\nDBMS_OUTPUT.PUT_LINE (...) löst kein Rollback aus, dass heißt, die Spalte OID kann verändert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPLACE trigger update_verhindern\nAFTER UPDATE OF OID ON Test\nFOR EACH ROW\nBEGIN\n   RAISE_APPLICATION_ERROR \n           (-20003, 'Sie können die Spalte oid nicht verändern!');\nEND; /\n",
        "solution": "true"
      },
      {
        "text": "CREATE OR REPLACE trigger update_verhindern\nBEFORE UPDATE OF OID ON Test FOR EACH ROW\nBEGIN\n   RAISE_APPLICATION_ERROR \n           (-20003, 'Sie können die Spalte oid nicht verändern!'); END;\n/\n",
        "solution": "true"
      },
      {
        "text": "CREATE OR REPLACE trigger update_verhindern BEFORE UPDATE ON Test\nFOR EACH ROW\nBEGIN\n  RAISE_APPLICATION_ERROR \n           (-20003, 'Sie können die Spalte oid nicht verändern!');END;\n/\n",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE trigger update_verhindern\nAFTER UPDATE OF oid ON Test FOR EACH ROW\nBEGIN\n  IF :NEW.OID <> :OLD.OID THEN\n    ROLLBACK;\n  END IF;\nEND;\n/",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE trigger update_verhindern AFTER UPDATE OF OID ON Test FOR EACH ROW\nBEGIN\n DBMS_OUTPUT.PUT_LINE \n         ('Sie können die Spalte oid nicht verändern!'); END; /\n",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE trigger update_verhindern\nAFTER UPDATE ON Test\nFOR EACH ROW\nWHEN (NEW.OID <> OLD.OID)\nBEGIN\n RAISE_APPLICATION_ERROR \n           (20000, 'Sie können die Spalte oid nicht verändern!');\n  \nEND; /\n",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2251,
    "category": 13,
    "difficulty": 1,
    "text": "Betrachten Sie einen ROW-Trigger auf der Tabelle Test_Tab (nr1 NUMBER, nr2 NUMBER) der Gestalt:  \n\nCREATE OR REPLACE TRIGGER test_tab_trg\n            AFTER UPDATE ON test_tab FOR EACH ROW BEGIN  END; \n\nWelche Aussagen sind für diesen ORACLE-Trigger wahr, wenn sich nur die Spalte nr1 mittels UPDATE ändert?",
    "explanation": "Da das Ereignis nach einem UPDATE angestoßen wird und es sich um eine Zeilentrigger handelt, der nicht von einer Spalte abhängt, ist auch die Transitionsvariable NEW.n2 gefüllt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Transitionsvariable NEW für nr2 ist gefüllt.",
        "solution": "true"
      },
      {
        "text": "Die Transitionsvariable NEW für nr2 ist nicht gefüllt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2218,
    "category": 13,
    "difficulty": 3,
    "text": "Die Theorie sieht bei ECMA-Regeln unter anderem folgende Ereignisse vor:",
    "explanation": "Alle diese Ereignisse sind in der Theorie vorgesehen, im SQL-Standard sind leider nur die DML-Ereignisse zulässig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Änderungsoperationen auf Daten",
        "solution": "true"
      },
      {
        "text": "Zeitereignisse",
        "solution": "true"
      },
      {
        "text": "Prozedur- und Funktionsaufrufe",
        "solution": "true"
      },
      {
        "text": "Datendefinitionsanweisungen",
        "solution": "true"
      },
      {
        "text": "Mittels einer Algebra kombinierte Ereignisse",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2230,
    "category": 12,
    "difficulty": 3,
    "text": "Das Oracle-Package NDS (Native Dynamic SQL) wird gebraucht, um folgende Befehle auszuführen:",
    "explanation": "In PL/SQL kann nur SQL-Manipulationsanweisungen, aber keine DDL-Anweisungen wie CREATE, ALTER, DROP etc.,keine DCL wie GRANT, REVOKE etc. und keine SESSION CONTROL-Anweisungen wie ALTER SESSION\nverarbeiten. Einen Ausweg aus dieser Situation bietet dynamisches SQL unter PL/SQL mit NDS, dem Native Dynamic SQL. Die auszuführende SQL-Anweisung wird ohne abschließendes Semikolon als Zeichenkette oder in einer Textvariablen dem Befehl EXECUTE IMMEDIATE übergeben, der diesen Text ungeprüft zur Ausführung an das Datenbankmanagementsystem sendet. Der Befehl EXECUTE IMMEDIATE selbst wird aber mit einem Semikolon abgeschlossen.Eine andere ältere und etwas aufwändigere  Möglichkeit ist die Verwendung des Pakets DBMS_SQL.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT-Anweisungen, die erst zur Laufzeit zusammengesetzt werden",
        "solution": "true"
      },
      {
        "text": "SELECT-Anweisungen, deren Formulierung bei der Programmierung fix ist",
        "solution": "false"
      },
      {
        "text": "INSERT-, UPDATE-, DELETE-Anweisungen, die erst zur Laufzeit zusammengesetzt werden",
        "solution": "true"
      },
      {
        "text": "INSERT-, UPDATE-, DELETE-Anweisungen, deren Formulierung bei der Programmierung fix ist",
        "solution": "false"
      },
      {
        "text": "CREATE-Anweisungen",
        "solution": "true"
      },
      {
        "text": "ALTER-Anweisungen",
        "solution": "true"
      },
      {
        "text": "DROP-Anweisungen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2236,
    "category": 12,
    "difficulty": 3,
    "text": "Wie wird eine Prozedur mit dem Bezeichner prozedurname aufgerufen?",
    "explanation": "Beispiele für Prozeduraufrufe sind:\n\n    SQL-Developer\n\n    EXECUTE prozedurname(var_y, var_x)\n\n    \n\n    Im PL/SQL-Programm:\n\n    prozedurname(var_y, var_x)\n\n    \n\n    SELECT/DML-Anweisung, IF-Bedingung und Zuweisungen sind Aufrufformen für Funktionen. Und Trigger werden \"durch ein eingetretenes Ereignis\" gefeuert und zu einem \"einen eingetretenen Ausführungszeitpunkt\" ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Im SQL-Editor von TOAD oder des SQL Developers mit EXECUTE prozedurname",
        "solution": "true"
      },
      {
        "text": "Im PL/SQL-Programm einfach nur mit   prozedurname",
        "solution": "true"
      },
      {
        "text": "Durch ein eingetretenes Ereignis",
        "solution": "false"
      },
      {
        "text": "Durch einen eingetretenen Ausführungszeitpunkt",
        "solution": "false"
      },
      {
        "text": "In SELECT- und DML-Anweisungen durch Verwendung von   prozedurname",
        "solution": "false"
      },
      {
        "text": "In IF-Bedingungen",
        "solution": "false"
      },
      {
        "text": "In Zuweisungen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2250,
    "category": 13,
    "difficulty": 1,
    "text": "Zu welchem Problem führt das Ausführungsmodell von Oracle, wenn in einem Row-Trigger mittels DML-Anweisung auf die Tabelle zugegriffen wird, für die der Trigger definiert ist?",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Impedance Missmatch",
        "solution": "false"
      },
      {
        "text": "Mutating Table",
        "solution": "true"
      },
      {
        "text": "keins von allen",
        "solution": "false"
      },
      {
        "text": "Kakadierende Trigger",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2263,
    "category": 12,
    "difficulty": 2,
    "text": "Welche EXCEPTION wird geworfen, wenn eine SELECT-Anweisung unter PL/SQL mehrere Datensätze liefert?",
    "explanation": "SELECT INTO übergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datensätze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datensätze verarbeiten kann.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "TOO_MANY_ROWS"
      }
    ]
  },
  {
    "id": 2326,
    "category": 9,
    "difficulty": 2,
    "text": "Will man ein Objektklasse aus einem objektorientierten Modell auf ein relationales Modell abbilden,",
    "explanation": "RICHTIG ist: \n\"so wird eine Klasse auf eine oder mehrere relationale Tabellen abgebildet.\"\n\nWenn die Attribute einer Klasse z.B. nur mit einfachen Datentypen (INT, CHAR, NUMBER, ...) definiert sind, so kann man eine Klasse auf genau eine Relation abbilden. \n\nHat man jedoch z.B. eine Klasse mit mengenwertigen Attributen (ARRAY, LIST, ...), so könnte eine Form der relationalen Implementierung aussehen, dass man das mengenwertige Attribut in einer eigenen Relation \"auslagert\" und beide Relationen mit einer 1:n-Beziehung verbindet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "so wird eine Klasse immer auf genau eine relationale Tabelle abgebildet.",
        "solution": "false"
      },
      {
        "text": "so wird eine Klasse immer auf mehrere relationale Tabellen abgebildet.",
        "solution": "false"
      },
      {
        "text": "so wird eine Klasse auf eine oder mehrere relationale Tabellen abgebildet.",
        "solution": "true"
      },
      {
        "text": "Keine dieser Abbildungen ist richtig.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2330,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind Subklassen der Geschäftspartner. \nWelche (Objekt-)Tabellen werden benötigt, wenn man diesen Sachverhalt gemäß der vertikalen Fragmentierung implementieren möchte?",
    "explanation": "Es gibt drei Fragmentierungstypen:  \n\nhorizontalen Fragmentierung \nBei der horizontalen Form werden für jeden Subtyp eine Tabelle angelegt, aber nicht für den Supertypen, geht also nur, wenn die Subtypen vollständig sind. Die Subtypen-Tabellen verfügen neben den eigenen Attributen zudem über die Attribute des Supertypen. \n\nvertikale Fragmentierung: \nBei der vertikalen Form werden für jeden Subtyp eine Tabelle angelegt und auch für den Supertypen, geht also, wenn die Subtypen unvollständig sind. Subtypen- und Supertyp-Tabellen verfügen jeweils über ihre eigenen Attribute.\n\nvirtuelle Fragmentierung:  \nBei der virtuellen Form wird nur eine Tabelle mit den Attributen aller Super- und Subtyen angelegt. Um unterscheiden zu können, welcher Datensatz nun zu welchem Subtypen gehört, werden entweder subtypenspezifische Attribute abgefragt oder eine zusätzliche sog. Diskriminatorspalte angelegt, die für jeden Subtpyen einen spezifischen Wert annimmt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "true"
      },
      {
        "text": "Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen sowie alle kunden- und lieferantenspezifischen Attribute und einem Kennzeichenattribut, welches die Partnerart spezifiziert",
        "solution": "false"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen und den kundenspezifischen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen und den lieferantenspezifischen",
        "solution": "false"
      },
      {
        "text": "Kunden, nur mit den kundenspezifischen Attributen",
        "solution": "true"
      },
      {
        "text": "Lieferanten, nur mit den lieferantenspezifischen Attributen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2470,
    "category": 6,
    "difficulty": 2,
    "text": "Wie heißt der CONSTRAINT, wenn eine Spalte Primärschlüssel ist?",
    "explanation": "Das Primärschlüssel-Constraint heißt PRIMARY KEY.\n\n    \n\n    Die übrigen vier  Constraints sind: UNIQUE, CHECK, FOREIGN KEY und NOT NULL.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "PRIMARY KEY"
      }
    ]
  },
  {
    "id": 2468,
    "category": 3,
    "difficulty": 1,
    "text": "Eine m:n-Beziehung im ERD (ohne beteiligte Entity-Mengen) wird beim Übergang zum DB-Schema in wie viele der folgenden Objekte überführt?",
    "explanation": "Eine n-m-Beziehung wird bei diesem Übergang in einer Relation und zwei 1:n-Beziehungen aufgelöst, die durch Fremdschlüssel dargestellt  werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine 1:1-Beziehung und zwei Relationen",
        "solution": "false"
      },
      {
        "text": "Zwei 1:1-Beziehungen und eine Relation",
        "solution": "false"
      },
      {
        "text": "Zwei 1:n-Beziehungen und eine Relation",
        "solution": "true"
      },
      {
        "text": "Zwei 1:n-Beziehungen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2498,
    "category": 7,
    "difficulty": 1,
    "text": "Über die Verwendung von Primärschlüsseln für Anfragen sind folgende Aussagen wahr:",
    "explanation": "Die einzig richtige Aussage ist: \"Primärschlüsselspalten können eine Rolle spielen, wenn die Laufzeit von Anfragen verbessert werden muss.\". \nDie übrigen Aussagen sind falsch: Primärschlüsselspalten werden weder für die Projektion noch für die Selektion von Daten gebraucht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Man kann in der SELECT-Klausel nur Primärschlüsselspalten projizieren.",
        "solution": "false"
      },
      {
        "text": "Man kann in der WHERE-Klausel nur über Primärschlüsselspalten suchen.",
        "solution": "false"
      },
      {
        "text": "Primärschlüsselspalten können eine Rolle spielen, wenn die Laufzeit von Anfragen verbessert werden muss.",
        "solution": "true"
      },
      {
        "text": "Keine von diesen Aussagen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2159,
    "category": 6,
    "difficulty": 3,
    "text": "Betrachten Sie folgenden CREATE TABLE-Befehl: \n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Angestellter) REFERENCES Hierarchie (Vorgesetzter) ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?",
    "explanation": "Der Primärschlüssel ist als Tabellen-Constraint definiert. Gut zu erkennen an dem trennenden Komma zu der vorangehenden Spaltendefinition der Spalte Vorgesetzter.\n\n    \n\n    Die Eingabe der Datensätze \"(\"Hugo\",\"Emil\"), (\"Erna\",\"Emil\"), (\"Anna\",\"Emil\")\" wird bereits beim 1. Datensatz fehl schlagen, da die Fremdschlüsselbeziehung für \"Emil\" fehl schlägt, weil es keinen Mitarbeitersatz für Emil mit seinem Vorgesetzten gibt z.B. mit (\"Emil\",\"Annna\").\n\n    \n\n    Die Einfügung von Anton schlägt ebenfalls fehl, weil für Anton der Name seines Vorgesetzten fehlt, den er ja nicht hat. Die Spalte Vorgesetzter ist jedoch Pflichteingabe (NOT NULL).\n\n    \n\n    Wenn für eine Einfügung eines neuen Datensatzes die Primärschlüsselbedingung fehl schlägt, dann wird die Einfügung rückgängig gemacht und eine entsprechende Fehlermeldung angezeigt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der Primärschlüssel ist als Spalten-Constraint definiert.",
        "solution": "false"
      },
      {
        "text": "Es sollen die folgenden 3 Datensätze in die noch leere Tabelle Hierarchie eingefügt werden:\n \n('Hugo','Emil'), ('Erna','Emil'), ('Anna','Emil')\n\nStimmt die Aussage: \n\"Das ist ein semantisch korrekter Inhalt der Tabelle Hierarchie.\"?",
        "solution": "false"
      },
      {
        "text": "Als erster Datensatz wird erfolgreich der 'oberste Chef' Anton eingefügt: \n\nINSERT INTO hierarchie VALUES ('Anton',NULL);",
        "solution": "false"
      },
      {
        "text": "Wenn für eine Einfügung eines neuen Datensatzes die Primärschlüsselbedingung fehl schlägt, dann wird die Einfügung rückgängig gemacht und eine entsprechende Fehlermeldung angezeigt.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2161,
    "category": 4,
    "difficulty": 3,
    "text": "Mit welchen Operatoren aus der relationalen Algebra lässt sich der Durchschnittsoperator simulieren?",
    "explanation": "Die Simulation sieht wie folgt aus: \n(A Durchschnitt B)  =  ( A ohne (A ohne B) ) \n\n(A Durchschnitt B)  =  ( A Differenz (A Differenz B) ) \n\nPS: Zeichnen Sie sich ruhig die Venn-Diagramme auf - es hilft ;-) \nPS: War mal Klausuraufgabe :-)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Division",
        "solution": "false"
      },
      {
        "text": "Mit keinem Operator aus der relationalen Algebra",
        "solution": "false"
      },
      {
        "text": "Differenz",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2163,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie zwei Relationen R und S mit jeweils einer Spalte A mit dem Datentyp Integer. \n\nWelche SQL-Anweisung beantwortet die Anfrage R - S (Differenz) aus der relationalen Algebra?",
    "explanation": "SELECT *\nFROM S\nWHERE A NOT IN (SELECT B FROM R); \nist falsch, da S-R berechnet wird \n\nMit UNION kann keine Differenz, sondern nur die Vereinigungsmenge berechnet werden. \n\nMinus kann ansonsten mit NOT IN oder über den LEFT JOIN ausgedrückt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM R\nWHERE A NOT IN (SELECT A FROM S);",
        "solution": "true"
      },
      {
        "text": "SELECT * FROM R\n MINUS\nSELECT * FROM S;",
        "solution": "true"
      },
      {
        "text": "SELECT *\nFROM S\nWHERE A NOT IN (SELECT A FROM R);",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM R\n UINON\nSELECT * FROM S;",
        "solution": "false"
      },
      {
        "text": "SELECT A FROM R LEFT OUTER JOIN S  ON S.A = R.A\nWHERE S.A IS NULL;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2213,
    "category": 13,
    "difficulty": 1,
    "text": "In ROW- und in STATEMENT-Triggern sind im Aktionsteil die gleichen Anweisungen möglich.",
    "explanation": "IN ROW-Triggern lösen DML-Anweisungen auf den auslösenden Tabellen unter Oracle das Mutating-Table-Problem aus, im SQL-Standard sind sie gar nicht zugelassen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2214,
    "category": 13,
    "difficulty": 2,
    "text": "Mit Triggern lassen sich DEFERRED-Integritätsprüfungen durchführen",
    "explanation": "Aufgrund ihres Ausführungsmodus BEFORE oder AFTER des feuernden Ereignisses können nur IMMEDIATE zu prüfende Integritätsbedingungen simuliert werden. Es gibt leider keine Trigger mit dem feuernden Ereignis der COMMIT-Anweisung, so dass keine Bedingungen zum DEFERRED-Zeitpunkt geprüft werden können. Nur in dem äußerst seltenen Fall, dass die Transaktion nur eine Manipulationsanweisung enthält, kann man den Zeitpunkt für die AFTER TRIGGER mit dem COMMIT-Zeitpunkt gleichsetzen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2215,
    "category": 13,
    "difficulty": 1,
    "text": "Mit Triggern lassen sich IMMEDIATE-Integritätsprüfungen durchführen.",
    "explanation": "Aufgrund ihres Ausführungsmodus BEFORE oder AFTER des feuernden Ereignisses können nur IMMEDIATE zu prüfende Integritätsbedingungen simuliert werden. Es gibt leider keine Trigger mit dem feuernden Ereignis der COMMIT-Anweisung, so dass keine Bedingungen zum DEFERRED-Zeitpunkt geprüft werden können. Nur in dem äußerst seltenen Fall, dass die Transaktion nur eine Manipulationsanweisung enthält, kann man den Zeitpunkt für die AFTER TRIGGER mit dem COMMIT-Zeitpunkt gleichsetzen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2219,
    "category": 13,
    "difficulty": 3,
    "text": "Welche Aussagen über ORACLE-Trigger und Integritätsprüfung sind wahr? Mit ihnen können",
    "explanation": "Mit Triggern kann nur der Prüfungszeitpunkt DEFERRED simuliert werden.  \n\nTrigger sind Bestandteile eine Transaktion und können daher nicht eine komplette Transaktion zurückrollen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "alle CONSTRAINTS sowie die beiden Prüfungszeitpunkte simuliert werden.",
        "solution": "false"
      },
      {
        "text": "transitionale Bedingungen geprüft werden.",
        "solution": "true"
      },
      {
        "text": "Fehler korrigiert werden, die beim Einfügen und Ändern von Daten entstehen",
        "solution": "true"
      },
      {
        "text": "Fehler erkannt und die Transaktion zurückgerollt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2231,
    "category": 13,
    "difficulty": 3,
    "text": "Welchen Befehl muss man programmieren, damit sich die Triggerausführung analog zu einem aufgetretenen IMMEDIATE-Integritätsfehler verhält? Wenn es keinen solchen Befehle gibt schreiben Sie bitte \"gibt es nicht\", wenn doch reicht der Befehlsname ohne Parameter.",
    "explanation": "RAISE_APPLICATION_ERROR(-..) bewirkt genau das Zurückrollen des aktuellen DML-Befehls und entspricht damit der IMMEDIATE-Integritätsprüfung,",
    "type": "text",
    "answers": [
      {
        "text": "Das ist",
        "solution": "RAISE_APPLICATION_ERROR"
      }
    ]
  },
  {
    "id": 2238,
    "category": 12,
    "difficulty": 1,
    "text": "Die Tabelle Kunden hat 1000 Datensätze. Primärschlüssel ist die Spalte Kund_id.\nEs wird die folgende Anfrage ausgeführt:\n  SELECT funktionsname(spalte1, spalte2) FROM Dual;",
    "explanation": "Die Funktion wird nur einmal aufgerufen, da die Pseudotabelle dual nur einen Datensatz hat.",
    "type": "text",
    "answers": [
      {
        "text": "Wie oft wird die Funktion ausgeführt?",
        "solution": "1"
      }
    ]
  },
  {
    "id": 2240,
    "category": 12,
    "difficulty": 3,
    "text": "Welche Aufgabe hat eine öffentliche Package-Variable?",
    "explanation": "Hier sind alle Antworten richtig bis auf \"Sie dient ausschließlich dem Informationsaustausch zwischen Routinen des gleichen Packages.\", da dies nur eine von mehreren Möglichkeiten ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie dient ausschließlich dem Informationsaustausch zwischen Routinen des gleichen Packages.",
        "solution": "false"
      },
      {
        "text": "Sie dient dem Informationsaustausch zwischen Routinen (auch ohne Package-Zugehörigkeit).",
        "solution": "true"
      },
      {
        "text": "Sie dient dem Informationsaustausch zwischen Triggern.",
        "solution": "true"
      },
      {
        "text": "Sie kann in DML und DQL-Anweisungen bei Oracle verwendet werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2308,
    "category": 9,
    "difficulty": 1,
    "text": "VARRAY-Datentypen sind bei Oracle als eine geordnete Menge von Elementen, die alle den gleichen Datentyp und eine maximale Anzahl haben, implementiert.",
    "explanation": "Für eine geordnete Menge von Elementen, die nicht  alle den gleichen Datentyp  haben, benötigt man einen benutzerdefinierten Typ und und einen TABLE-Konstruktor.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2310,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussagen über NESTED TABLE-Datentypen sind bei Oracle wahr?",
    "explanation": "Da Nested-Table über den TABLE-Konstruktor angelegt werden, ist eine maximale Anzahl der Einträge nicht vorgesehen. Alle anderen Aussagen sind richtig..",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie sind eine ungeordnete Menge Elementen von Datenelementen.",
        "solution": "true"
      },
      {
        "text": "Alle Datenelemente haben den gleichen Datentyp.",
        "solution": "true"
      },
      {
        "text": "Es wird eine maximale Anzahl an Einträgen vorgegeben.",
        "solution": "false"
      },
      {
        "text": "Innerhalb dieser Eintragsgrenze ist die Anzahl an Einträgen variabel.",
        "solution": "false"
      },
      {
        "text": "Es wird automatisch eine Konstruktormethode erzeugt, die genauso heißt wie der NESTED TABLE-Typ.",
        "solution": "true"
      },
      {
        "text": "Jedes Element hat nur eine Spalte, die entweder einen atomaren oder einen strukturierten Datentyp hat.",
        "solution": "true"
      },
      {
        "text": "Einzelne Einträge in einer NESTED TABLE können direkt geändert werden.",
        "solution": "true"
      },
      {
        "text": "Die Daten der NESTED TABLE-Spalte werden in einer separaten Tabelle gespeichert.",
        "solution": "true"
      },
      {
        "text": "NESTED TABLEs sind Kollektionsdatentypen und stellen daher eine Verletzung der 1. NF im relationalen Modell dar.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2311,
    "category": 9,
    "difficulty": 2,
    "text": "NESTED TABLE-Datentypen sind bei Oracle als eine einspaltige, ungeordnete Menge Elementen von Datenelementen, die alle den gleichen Datentyp haben, implementiert.",
    "explanation": "NESTED TABLE \nMit der STORE-AS-Klausel können tabellenwertige Spalten beschrieben werden. Für jede Spalte mit einem benutzerdefinierten tabellenwertigen Kollektionstyp (VARRAY, TABLE-Type) muss eine Store-Klausel definiert werden, die angibt, in welcher inneren Tabelle die tabellenwertigen Spalten abgelegt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2331,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind Subklassen der Geschäftspartner. \nWelche (Objekt-)Tabellen werden benötigt, wenn man diesen Sachverhalt gemäß der virtuellen Fragmentierung implementieren möchte?",
    "explanation": "Es gibt drei Fragmentierungstypen:  \n\nhorizontalen Fragmentierung \nBei der horizontalen Form werden für jeden Subtyp eine Tabelle angelegt, aber nicht für den Supertypen, geht also nur, wenn die Subtypen vollständig sind. Die Subtypen-Tabellen verfügen neben den eigenen Attributen zudem über die Attribute des Supertypen. \n\nvertikale Fragmentierung: \nBei der vertikalen Form werden für jeden Subtyp eine Tabelle angelegt und auch für den Supertypen, geht also, wenn die Subtypen unvollständig sind. Subtypen- und Supertyp-Tabellen verfügen jeweils über ihre eigenen Attribute.\n\nvirtuelle Fragmentierung:  \nBei der virtuellen Form wird nur eine Tabelle mit den Attributen aller Super- und Subtyen angelegt. Um unterscheiden zu können, welcher Datensatz nun zu welchem Subtypen gehört, werden entweder subtypenspezifische Attribute abgefragt oder eine zusätzliche sog. Diskriminatorspalte angelegt, die für jeden Subtpyen einen spezifischen Wert annimmt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen sowie alle kunden- und lieferantenspezifischen Attribute und einem Kennzeichenattribut, welches die Partnerart spezifiziert",
        "solution": "true"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen und den kundenspezifischen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen und den lieferantenspezifischen",
        "solution": "false"
      },
      {
        "text": "Kunden, nur mit den kundenspezifischen Attributen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, nur mit den lieferantenspezifischen Attributen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2544,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Operatoren gibt es im objektrelationalen SQL/ORACLE-Dialekt?",
    "explanation": "Eine geschachtelte Tabelle wird mit dem Operator TABLE flachgeklopft und auf eine relationale Tabelle abgebildet.Außerdem gibt es den Typkonstruktor TABLE, der einem nicht beschränkten Vektor entspricht. \n\nVALUE wird wie im relationalen SQL einmal in einem INSERT-Befehlt verwendet und zum anderen gibt der VALUE-Operator das Objekt als solches in einer REF-Beziehung zurück.\n\nARRAY und REF sind objektrelationale Datentypen, aber keine Operatoren. \n\nCURSOR ist zum einen ein PL/SQL-Konzept zum Ausführen von SELECT-Anweisungen, das es erlaubt, eine Ergebnismenge Datensatz für Datensatz abzuarbeiten.  \nAls objektrelationaler Operator erzeugt der CURSOR-Operator eine Unterabfrage an die geschachtelte Tabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "VALUE",
        "solution": "true"
      },
      {
        "text": "REF",
        "solution": "true"
      },
      {
        "text": "ARRAY",
        "solution": "false"
      },
      {
        "text": "TABLE",
        "solution": "true"
      },
      {
        "text": "CURSOR",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2558,
    "category": 4,
    "difficulty": 2,
    "text": "Wie viele Tupel hat die Ergebnismenge des Natural Joins von zwei Relationen, die 18 bzw. 20 Tupel beinhalten, wobei es für 14 Tupel der einen Relation Tupel der anderen Relation gibt, die in einem gleichheißenden Attribut die gleichen Werte aufweisen?",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft. Diese Bedingung trifft für 14 Tupel zu.",
    "type": "text",
    "answers": [
      {
        "text": "Der Natural Join hat ... Tupel.",
        "solution": "14"
      }
    ]
  },
  {
    "id": 2156,
    "category": 7,
    "difficulty": 3,
    "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nWelche der folgenden Anfragen liefern das gleiche Ergebnis?",
    "explanation": "Das gleiche Ergebnis liefern: \n\nSELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);\n\nSELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN  (SELECT b.TNr FROM Auftragspositionen b \n         WHERE a.TNr = b.TNr);\n\nDie Semantik dieser Anfragen ist: \"Welche Artikel wurden verkauft?\"\n\nEine ganz andere Semantik hat:  \nSELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;\nSemantik: \"Für welche Auftraege gibt es auch verkaufte Artikel?\"\n\n\nSELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT b.TNR FROM Auftragspositionen b);\nDiese Anfrage hätte eine richtige Semantik, wenn die Anfrage korreliert wäre, d.h. es gäbe eine Bedingung bei der unteren Anfrage, die die obere und die untere Anfrage in Beziehung setzt: \"WHERE b.tnr=a.trn\". Ohne diese Korrelation liefert diese Anfrage immer alle Artikel, sobald in der Auftragspositionen-Tabelle wenigstens ein Datensatz gespeichert ist - unabhängig davon, ob die TNR übereinstimmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT  DISTINCT a.TNr,  a.Bezeichnung\nFROM    Artikel a, (SELECT * FROM Auftragspositionen) b\nWHERE      a.TNr = b.TNr;",
        "solution": "true"
      },
      {
        "text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);",
        "solution": "true"
      },
      {
        "text": "SELECT  a.Tnr, a.Bezeichnung\nFROM    Artikel a\nWHERE   EXISTS (SELECT b.TNR FROM Auftragspositionen b);",
        "solution": "false"
      },
      {
        "text": "SELECT  DISTINCT b.TNr, b.Bezeichnung\nFROM    Auftragspositionen a, Artikel b \nWHERE   a.tnr = b.Tnr;",
        "solution": "true"
      },
      {
        "text": "SELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   TNR IN  (SELECT b.TNr FROM Auftragspositionen b \n         WHERE a.TNr = b.TNr);",
        "solution": "true"
      },
      {
        "text": "SELECT     a.TNr, a.Bezeichnung\nFROM    Auftragspositionen a, Auftraege b \nWHERE      a.Tnr = b.Tnr;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2557,
    "category": 4,
    "difficulty": 2,
    "text": "Wie viele Attribute hat die Ergebnismenge des Natural Joins von zwei Relationen, die über 15 bzw. 25 Attribute verfügen, wobei es in der einen Relation drei Attribute gibt, die gleich heißen wie in der anderen?",
    "explanation": "Die Struktur der Ergebnismenge des Natural Joins verfügt über alle Attribute aus beiden beteiligten Relationen, wobei die doppelten Attribute nur einmal vertreten sind: 15+25-3= 37 Attribute.",
    "type": "text",
    "answers": [
      {
        "text": "Der Natural Join hat ... Attribute.",
        "solution": "37"
      }
    ]
  },
  {
    "id": 2559,
    "category": 4,
    "difficulty": 1,
    "text": "Welche Operatoren der Relationalen Algebra sind unär?",
    "explanation": "Unär:  F1 : Rn --> Rm      mit n , m ∈ Nbinär: F2 : Rn × Rm --> Rk mit n , m , k ∈ N unäre Operatoren: Selektion, Projektion\nBinäre Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "true"
      },
      {
        "text": "Projektion",
        "solution": "true"
      },
      {
        "text": "Division",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "false"
      },
      {
        "text": "Join-Operatoren (Theta, Equi, Natural, Left Outer, Right Outer, Outer)",
        "solution": "false"
      },
      {
        "text": "Vereinigung",
        "solution": "false"
      },
      {
        "text": "Differenz",
        "solution": "false"
      },
      {
        "text": "Durchschnitt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2570,
    "category": 4,
    "difficulty": 1,
    "text": "Der Left Outer Join ist kommutativ.",
    "explanation": "Der linke Outer-Join (linker äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der linken Relation, hier R1, die im Natural-Join unterdrückt werden, als Tupel mit\naufgeführt und in den Attributen, die zu R2 gehören, mit NULL-Werten aufgefüllt werden. \nDie rechten und linken Outer-Joins sind nicht kommutativ, da entweder nur die rechte oder nur die linke Relation vollständig mit allen Tupeln in die Ergebnismenge aufgenommen werden. \nDer Full-Outer-Join (beidseitiger, vollständiger äußerer Join) zweier Relationen R1 und R2 ist ist jedoch kommutativ, da bei ihn sowohl die rechte als aich die linke Relation vollständig mit allen Tupeln in die Ergebnismenge aufgenommen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2572,
    "category": 4,
    "difficulty": 2,
    "text": "Bestimmen Sie den rechten Outer-Join der folgenden beiden Relationen über R1.S1 = R2.S3!\n\nR1: </br\nS1  S2    \nA    W \nC    Y </br\n\nR2: </br\nS3  S4 \nC    Y \nD    Z",
    "explanation": "Der rechte Outer-Join (rechter äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdrückt werden, als Tupel mit aufgeführt und in den Attributen, die zu R1 gehören, mit NULL-Werten aufgefüllt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z",
        "solution": "false"
      },
      {
        "text": "Keine dieser Ergebnismengen ist richtig.",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nC  Y  C  Y",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2580,
    "category": 4,
    "difficulty": 2,
    "text": "Es sind die folgenden beiden Relationen R1, R2 gegeben:\n\n    R1: S1 S2 C Y A W\n\n    R2: S2 S3 S4 V C Y W D Z",
    "explanation": "Seien zwei Relationen R1(A1,...,An) und R2(B1,...,Bm) gegeben. Das kartesische Produkt ist die Menge aller Paare aus Tupeln der ersten Relation R1 verknüpft mit Tupeln der zweiten Relation R2 unabhängig von irgenwelchen gleichen oder ungleichen Attributwerten für die einzelnen Attribute.",
    "type": "text",
    "answers": [
      {
        "text": "Welche Operation der Relationalen Algebra hat folgende Ergebnismenge? \n(deutschsprachige Bezeichnung, nur Kleinbuchstaben, Wörter durch ein Leerzeichen getrennt, keine Bindestriche etc.)\n\nS1 S2 S2 S3 S4\nC  Y  W  D  Z\nC  Y  V  C  Y\nA  W  W  D  Z\nA  W  V  C  Y",
        "solution": "kartesisches produkt"
      }
    ]
  },
  {
    "id": 2582,
    "category": 4,
    "difficulty": 1,
    "text": "Es sind die folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4 gegeben: \n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z\n\nDie folgende Menge ist das Ergebnis der Anwwendung des Natural Joins auf R1 und R2. \n\nS1 S2 S2 S3 S4\nA  W  W  D  Z",
    "explanation": "Diese Ergebnismenge passt nicht, weil die Projektion auf nur eines der doppelten Attribute S2 fehlt. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "true"
      },
      {
        "text": "stimmt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2315,
    "category": 9,
    "difficulty": 3,
    "text": "In welchem/n Befehl/en können beim Oracle-ORDBS Constraints definiert werden?",
    "explanation": "Constraints können nicht in der TYP-Deklaration angelegt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPLACE TYPE <typname> ;",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE <tabellenname> AS OBJECT ;",
        "solution": "true"
      },
      {
        "text": "Constraints gehören zum relationalen Konzept und können für Objekte nicht definiert werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2316,
    "category": 9,
    "difficulty": 3,
    "text": "Beim ORDBS von Oracle gibt es folgende Hierarchien:",
    "explanation": "Tabellenhierachien gibt es in Standard-SQL, aber nicht unter Oracle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typhierarchien",
        "solution": "true"
      },
      {
        "text": "Tabellenhierarchien",
        "solution": "false"
      },
      {
        "text": "Sichthierarchien",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2317,
    "category": 9,
    "difficulty": 2,
    "text": "Was erbt beim Oracle-DBS wie auch bei OR-SQL ein Subtyp von seinem Supertypen?",
    "explanation": "Ein Typ beinhaltet keine CONSTRAINTS und die Möglichkeit, Typenhierarchien zu bilden, ist sowohl bei Oracle als auch im Standard von SQL vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Attribute",
        "solution": "true"
      },
      {
        "text": "Constraints",
        "solution": "false"
      },
      {
        "text": "Methoden",
        "solution": "true"
      },
      {
        "text": "Gar nichts, da keine Typhierarchien gebildet werden können.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2318,
    "category": 9,
    "difficulty": 3,
    "text": "Was erbt beim Oracle-DBS wie auch bei OR-SQL eine Subtabelle von seiner Supertabelle?",
    "explanation": "Die Vererbung erfolgt über den zugehörigen Typ, nicht die Tabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Attribute",
        "solution": "false"
      },
      {
        "text": "Constraints",
        "solution": "false"
      },
      {
        "text": "Methoden",
        "solution": "false"
      },
      {
        "text": "Gar nichts, da keine Tabellenhierarchien gebildet werden können",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2319,
    "category": 9,
    "difficulty": 2,
    "text": "Welche Arten von Vererbung gibt es bei Oracle und bei OR-SQL?",
    "explanation": "In beiden Fällen ist nur die Einfachvererbung vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mehrfachvererbung",
        "solution": "false"
      },
      {
        "text": "Einfachvererbung",
        "solution": "true"
      },
      {
        "text": "kKeine Vererbung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2320,
    "category": 9,
    "difficulty": 1,
    "text": "Mehrfachvererbung heißt, dass ein Subtyp von mehreren Supertypen erbt.",
    "explanation": "Das ist die Definition der Mehrfachvererbung :-).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2321,
    "category": 7,
    "difficulty": 3,
    "text": "Wie heißt bei Oracle die Klausel, mit der man einen potentiellen Supertypen spezifiziert? Wenn es eine solche Klausel nicht gibt, schreiben Sie,  \"gibt es nicht\"",
    "explanation": "[NOT] FINAL:\n\n    NOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt über die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n\n    [NOT] OVERRIDING:\n\n    Damit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n\n    [NOT] INSTANTIABLE:\n\n    \u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "text",
    "answers": [
      {
        "text": "Sie heißt:",
        "solution": "NOT FINAL"
      }
    ]
  },
  {
    "id": 2322,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt bei Oracle die Klausel, mit der man eine ererbte Methode redefiniert? Wenn es eine solche Klausel nicht gibt, schreiben Sie \"gibt es nicht\".",
    "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt über die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "text",
    "answers": [
      {
        "text": "Sie heißt:",
        "solution": "OVERRIDING"
      }
    ]
  },
  {
    "id": 2323,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt bei Oracle die Klausel, mit der man einen Typen oder eine Methode als nicht instanzierbar spezifiziert? Wenn es eine solche Klausel nicht gibt, schreiben Sie \"gibt es nicht\"",
    "explanation": "[NOT] FINAL: \nNOT FINAL spezifiziert einen Supertypen, wobei der Default FINAL ist, d.h. ein Typ kann nicht als Supertyp verwendet werden.\u000b Deklariert werden FINAL und NOT FINAL beim Supertypen und den Subtypen, für die wiederum\u000b Subtypen definiert werden sollen. Ein Suptyp erbt über die der UNDER-Klausel: CREATE TYPE... UNDER Supertyp  Methoden und Attribute vom Supertyp.\n[NOT] OVERRIDING: \nDamit ist die \u000bRedefinition (Overloading) einer vererbten Supertyp-Methode gemeint.\n[NOT] INSTANTIABLE: \n\u000bMit NOT INSTANTIABLE ist der Typ oder die Methode nicht instanzierbar, d.h. es gibt keine Konstruktormethoden, so dass keine Instanzen erzeugt werden können. INSTANTIABLE wird deklariert beim Supertypen oder einem Subtypen.",
    "type": "text",
    "answers": [
      {
        "text": "Sie heißt:",
        "solution": "NOT INSTANTIABLE"
      }
    ]
  },
  {
    "id": 2324,
    "category": 9,
    "difficulty": 3,
    "text": "Was wird beim Oracle-DBS für einen neuen Typen automatisch nicht erzeugt, wenn dieser Typ als nicht instanzierbar spezifiziert ist?(deutscher Begriff)",
    "explanation": "Der Konstruktor dienst zum Anlegen von Instanzen eines instanzierbaren strukturierten Datentyps.",
    "type": "text",
    "answers": [
      {
        "text": ".",
        "solution": "Konstruktor"
      }
    ]
  },
  {
    "id": 2325,
    "category": 9,
    "difficulty": 2,
    "text": "Welche/r Befehl/e sind beim Oracle-DBS syntaktisch richtig und erzeugen einen Subtyp?",
    "explanation": "Die Klausel zur Vererbung eines Typs heißt nicht SUPTYP sondern UNDER.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPLACE TYPE <subtypname> AS SUBTYP OF <supertypname> ;",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE TYPE <subtypname> OF SUPERTYP <supertypname> ;",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE TYPE <subtypname> UNDER <supertypname> ;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2327,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind vollständig und disjunkte Subklassen der Geschäftspartner. \nWelche Objekttabellen werden benötigt, wenn man diesen Sachverhalt abbilden will?",
    "explanation": "vollständig und disjunkte Kunden und Lieferanten  \nwerden abgebildet auf folgende Objekttabellen: \n- Kunden, mit den Attributen, die alle Geschäftspartner betreffen und den kundenspezifischen \n- Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen und den lieferantenspezifischen\n\nVollständig heißt, dass es nur Kunden und Lieferanten gibt, es müssen also keine sonstigen Geschäftspartner gespeichert werden, so dass keine Geschäftspartnertabelle notwendig ist. \nDisjunkt heißt, dass kein Geschäftspartner sowohl Lieferant als auch Kunde sein kann. Um dies zu gewährleisten müssten Trigger programmiert werden, die gleiche Daten bei Lieferanten und Kunden kontrollieren und verhindern.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen und den kundenspezifischen",
        "solution": "true"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen und den lieferantenspezifischen",
        "solution": "true"
      },
      {
        "text": "Kunden, nur mit den kundenspezifischen Attributen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, nur mit den lieferantenspezifischen Attributen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2328,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei folgende Klassenhierarchie gegeben: Die Kunden und die Lieferanten sind unvollständig und disjunkte Subklassen der Geschäftspartner. \n\nWelche Objekttabellen werden benötigt, wenn man diesen Sachverhalt abbilden will?",
    "explanation": "unvollständig und disjunkte Kunden und Lieferanten \nwerden abgebildet auf folgende Objekttabellen: \n- Kunden, nur mit den kundenspezifischen Attributen \n- Lieferanten, nur mit den lieferantenspezifischen Attributen\n- Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen\n\nUnvollständig  heißt, dass es neben Kunden und Lieferanten auch noch sonstigen Geschäftspartner gibt und die werden in nur in der Geschäftspartner-Tabelle gespeichert. Kunden- und Lieferanten-Datensätze werden entsprechend in zwei Tabellen gespeichert, der Geschäftspartner- und in der Kunden- bzw. Lieferanten-Tabelle. \nDisjunkt heißt, dass kein Geschäftspartner sowohl Lieferant als auch Kunde sein kann. Um dies zu gewährleisten müssten Trigger programmiert werden, die gleiche Daten bei Lieferanten und Kunden kontrollieren und verhindern.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Geschäftspartner, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "true"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen",
        "solution": "false"
      },
      {
        "text": "Kunden, mit den Attributen, die alle Geschäftspartner betreffen und den kundenspezifischen",
        "solution": "false"
      },
      {
        "text": "Lieferanten, mit den Attributen, die alle Geschäftspartner betreffen und den lieferantenspezifischen",
        "solution": "false"
      },
      {
        "text": "Kunden, nur mit den kundenspezifischen Attributen",
        "solution": "true"
      },
      {
        "text": "Lieferanten, nur mit den lieferantenspezifischen Attributen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2072,
    "category": 7,
    "difficulty": 1,
    "text": "Welcher JOIN-Tabellen-Typ hat eine USING-Klausel?",
    "explanation": "Beim CROSS JOIN, dem kartesischen Produkt, gibt es gar keine Verknüpfungsspalten. Jeder Datensatz der einen Relation wird \"grundlos\" mit jedem anderen aus der anderen Relation verknüpft.\nBeim NATURAL JOIN gibt es zwar eine Bedingung, aber die ist vordefiniert, so dass keine Spalten mittels ON spezifiziert werden müssen. Die vordefinierte Bedingung heißt: Alle Spalten mit gleichen Namen werden auf Gleichheit verglichen und die Teilbedingungen ggf. mit AND verknüpft.\nLediglich beim THETA JOIN können Spalten für die JOIN-Bedingung angegeben werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CROSS-Join",
        "solution": "false"
      },
      {
        "text": "THETA-Join",
        "solution": "true"
      },
      {
        "text": "NATURAL-Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2126,
    "category": 6,
    "difficulty": 3,
    "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?",
    "explanation": "Ja, die CREATE-Anweisung ist syntaktisch korrekt.\n\n    \n\n    Ja, die Angestellten-Vorgesetzten-Beziehung wird hier semantisch korrekt abgebildet, weil der Fremdschlüssel der Vorgesetzten-Spalte auf den Primärschlüssel des Angestellten zeigt, der sein Vorgesetzter ist.\n\n    \n\n    z.B.: Emil hat den Vorgesetzten Hugo:\n\n    Angestellter Vorgesetzter\n\n    (\"Hugo\",\"Anton\"),\n\n    (\"Emil\",\"Hugo\"),\n\n    \n\n    Der 1. Datensatz ist der Mitarbeiter-Datensatz von Hugo und der 2. der von Emil. Der Fremdschlüssel des Emil-Datensatzes verweist auf den Mitarbeiter Hugo, der sein Vorgesetzter ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dieser SQL-Befehl ist syntaktisch nicht korrekt.",
        "solution": "false"
      },
      {
        "text": "Dieser SQL-Befehl ist syntaktisch korrekt.",
        "solution": "true"
      },
      {
        "text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch nicht korrekt ab.",
        "solution": "false"
      },
      {
        "text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch korrekt ab.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2127,
    "category": 6,
    "difficulty": 3,
    "text": "Betrachten Sie folgenden CREATE TABLE-Befehl: \n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL, Vorgesetzter VARCHAR2(20) NOT NULL, PRIMARY KEY (Angestellter), FOREIGN KEY (Angestellter) REFERENCES Hierarchie (Vorgesetzter) ON DELETE CASCADE);\n\n    Welche Aussage/n ist/sind korrekt?",
    "explanation": "Nein, die CREATE-Anweisung ist syntaktisch  nicht korrekt, weil eine Spalte referenziert wird, die gar keine Schlüsselspalte ist. Die Fremdschlüsselbeziehung kann nur funktionieren, wenn die referenzierte Spalte der Master-Tabelle, hier Vorgesetzter, auch eindeutig ist. Für den Vorgesetzten fehlt jedoch ein PRIMARY KEY- oder UNIQUE-Constraint.\n\n    \n\n    Nein, die Angestellten-Vorgesetzten-Beziehung wird hier nicht semantisch korrekt abgebildet, weil der Fremdschlüssel von der Angestellten-Spalte auf die Vorgesetzten-Spalte referenziert, dort können Werte mehrfach auftreten, so dass eine eindeutige Referenz nicht gegeben ist. z.B.\n\n    \n\n    Angestellter Vorgesetzter\n\n    (\"Hugo\",\"Anton\"),\n\n    (\"Emil\",\"Hugo\"),\n\n    (\"Erna\",\"Hugo\")\n\n    \n\n    Emil und Erna haben beide den Vorgesetzten Hugo. Hier tritt jedoch ein Konflikt ein, weil der Fremdschlüssel immer den Master-Datensatz referenziert und der muss eindeutig sein. Hier würde vom 1. Datensatz mit dem Wert \"Hugo\" auf sowohl den 2. wie auch den 3. referenziert werden - so etwas geht nicht!",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dieser SQL-Befehl ist syntaktisch nicht korrekt.",
        "solution": "true"
      },
      {
        "text": "Dieser SQL-Befehl ist syntaktisch korrekt.",
        "solution": "false"
      },
      {
        "text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch nicht korrekt ab.",
        "solution": "true"
      },
      {
        "text": "Dieser SQL-Befehl bildet die Angestellten-Vorgesetzten-Beziehung semantisch korrekt ab.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2128,
    "category": 7,
    "difficulty": 1,
    "text": "Der Ausdruck \"SELECT Nachname FROM KUNDEN ORDER BY Nachname ASC\"",
    "explanation": "Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "bewirkt eine Gruppierung",
        "solution": "false"
      },
      {
        "text": "bewirkt eine absteigende Sortierung über den Nachnamen",
        "solution": "false"
      },
      {
        "text": "bewirkt eine aufsteigende Sortierung über den Nachnamen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2136,
    "category": 7,
    "difficulty": 2,
    "text": "Welcher Operator der Relationalen Algebra verbirgt sich hinter der ORDER BY-Klausel einer SQL-Anfrage?",
    "explanation": "Order By ist in der Relationalen Algebra nicht vorgesehen, da Relationen als ungegeordnete Mengen vereinbart sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Sortierung",
        "solution": "false"
      },
      {
        "text": "keiner der RA-Operatoren",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2469,
    "category": 3,
    "difficulty": 2,
    "text": "Folgende Aussagen über Subtypen sind wahr:",
    "explanation": "Bei Subtypen werden identifizierende Beziehungen verwendet, da Supertyp und Subtyp den gleichen  Primärschlüssel haben",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Identifizierende Beziehungen können verwendet werden.",
        "solution": "true"
      },
      {
        "text": "Nicht-identifizierende Beziehungen können verwendet werden.",
        "solution": "false"
      },
      {
        "text": "Identifizierende und nicht-identifizierende Beziehungen können verwendet werden.",
        "solution": "false"
      },
      {
        "text": "Es gibt Entity-Mengen, die aufgrund von 1:n-Beziehungen Fremdschlüssel besitzen, die aus mehreren Spalten bestehen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2501,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussagen über Unterabfragen sind wahr?",
    "explanation": "Korreliert bedeutet, dass die Spalten der äußeren Anweisung mit der innneren SELECT-Anweisung durch eine WHERE-Klausel verknüpft werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Unterabfragen, die mit einem Vergleichsoperator (=,<,>,) aber ohne ANY oder ALL, dürfen nur maximal einen Ergebnisdatensatz liefern.",
        "solution": "true"
      },
      {
        "text": "Unterabfragen mit einem IN-Operator sind aufgrund der Syntax immer korrelierte Unterabfragen.",
        "solution": "false"
      },
      {
        "text": "Unterabfragen können in der WHERE-Klausel wie auch der FROM-Klausel auftreten.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2370,
    "category": 15,
    "difficulty": 1,
    "text": "Berechnen Sie die HASH-Funktion 23 modulo 7!",
    "explanation": "Die Modul-Funktion ist das Teilen mit Rest, also hier der Rest der beim Teilen von 23 durch 7 entsteht: Das ist 2.",
    "type": "text",
    "answers": [
      {
        "text": "Das Ergebnis ist",
        "solution": "2"
      }
    ]
  },
  {
    "id": 2380,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei folgende Typdefinition gegeben: \nCREATE OR REPLACE TYPE kd_typ AS OBJECT \n   (kd_id NUMBER, name VARCHAR2(100), adresse VARCHAR2(200));\n\nWelche/r Befehl/e erzeugen bei Oracle eine Objekttabelle?",
    "explanation": "Bei OBJECT IDENTIFIER IS PRIMARY KEY  muss der Primary KEY auch als CONSTRAINT der Spalte angegeben werde. \n\nOBJECT IDENTIFIER IS SYSTEM  ist auch ohne  GENERATED UNIQUE;  eindeutig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TABLE kunden_ot OF kd_typ (kd_id PRIMARY KEY) \n   OBJECT IDENTIFIER IS PRIMARY KEY;",
        "solution": "true"
      },
      {
        "text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS PRIMARY KEY (kd_id);",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS SYSTEM GENERATED (kd_id);",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS SYSTEM GENERATED;",
        "solution": "true"
      },
      {
        "text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS SYSTEM GENERATED UNIQUE;",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS USER GIVEN (kd_oid);",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE kunden_ot OF kd_typ  \n   OBJECT IDENTIFIER IS USER GIVEN INTO kd_oid;",
        "solution": "false"
      },
      {
        "text": "Keiner der Befehle ist richtig.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2395,
    "category": 5,
    "difficulty": 2,
    "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema mittels Universalrelation. Welche Art der Fragmentierung ist das?",
    "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp gehören, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch. \nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enthält alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschlüssel mit dem Supertyp verbunden und haben den gleichen Primärschlüssel wie der Supertyp. Außerdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.\nBegriffe wie diagonale, abgeleitete, faktische Fragmentierung gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "virtuelle Fragmentierung",
        "solution": "true"
      },
      {
        "text": "vertikale Fragmentierung",
        "solution": "false"
      },
      {
        "text": "horizontale Fragmentierung",
        "solution": "false"
      },
      {
        "text": "faktische Fragmentierung",
        "solution": "false"
      },
      {
        "text": "abgeleitete Fragmentierung",
        "solution": "false"
      },
      {
        "text": "diagonale Fragmentierung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2396,
    "category": 5,
    "difficulty": 3,
    "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema. Dabei wird nur für jeden Subtypen eine Relation erstellt. Welche Art der Fragmentierung ist das?",
    "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp gehören, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch.\n\nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enthält alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschlüssel mit dem Supertyp verbunden und haben den gleichen Primärschlüssel wie der Supertyp. Außerdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\n\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.\n\nBegriffe wie diagonale, abgeleitete, faktische Fragmentierung gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "virtuelle Fragmentierung",
        "solution": "false"
      },
      {
        "text": "vertikale Fragmentierung",
        "solution": "false"
      },
      {
        "text": "horizontale Fragmentierung",
        "solution": "true"
      },
      {
        "text": "faktische Fragmentierung",
        "solution": "false"
      },
      {
        "text": "abgeleitete Fragmentierung",
        "solution": "false"
      },
      {
        "text": "diagonale Fragmentierung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2397,
    "category": 5,
    "difficulty": 2,
    "text": "Betrachten Sie eine Abbildung eines EERM mit Subtypen und Supertyp auf ein relationales Datenbankschema. Dabei wird für jeden Subtypen und für den Supertypen eine Relation erzeugt. Welche Art der Fragmentierung ist das?",
    "explanation": "Bei der virtuellen Fragmentierung wird die Universalrelation nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben. Alle Attribute, die nur zu einem Subtyp gehören, sind dann nicht obligatorisch, also sind NULL-Werte erlaubt. Die Attribute des Supertyps sind je nach Semantik entweder optional oder obligatorisch. \nBei der vertikalen Fragmentierung wird die Universalrelation auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enthält alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschlüssel mit dem Supertyp verbunden und haben den gleichen Primärschlüssel wie der Supertyp. Außerdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\nBei der horizontalen Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.\nBegriffe wie diagonale, abgeleitete, faktische Fragmentierung gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "virtuelle Fragmentierung",
        "solution": "false"
      },
      {
        "text": "vertikale Fragmentierung",
        "solution": "true"
      },
      {
        "text": "horizontale Fragmentierung",
        "solution": "false"
      },
      {
        "text": "faktische Fragmentierung",
        "solution": "false"
      },
      {
        "text": "abgeleitete Fragmentierung",
        "solution": "false"
      },
      {
        "text": "diagonale Fragmentierung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2399,
    "category": 9,
    "difficulty": 2,
    "text": "Welche Eigenschaften hat eine objektrelationale Tabelle?",
    "explanation": "Welche Tabellenformen kann es in einem ORDBMS geben?\n\nDefinitionsart: untypisiert vs. typisiert \n- Untypisiert: die Struktur ergibt sich direkt aus den Attributstrukturen (RM)\n- Typisiert: Tabellendefinition basiert auf benutzerdefinierten Typ (OR)\n\nZeilentyp: tupelwertig vs. objektwertig \n- Tupelwertig: keine Methodenaufrufe für ein konkretes Tupel (RM)\n- Objektwertig: Methodenaufrufe des zugehörigen Objekttyps direkt über die Zeilenvariable (OR)\n\nReferenzierbarkeit: nicht referenzierbar vs. referenzierbar  \n- Nicht referenzierbar: Zeilen sind nicht referenzierbar (RM)\n- Referenzierbar: Zeilen sind mittels Referenzspalten (OIDs) referenzierbar; setzt OIDs voraus (OR)\n\n\nRelationale Tabellen sind: \n- tupelwertig, \n- untypisiert, \n- nicht referenzierbar\n\nObjektorientierte/objektrelationale Klassen/Tabellen sind: \n- objektwertig, \n- typisiert, \n- referenzierbar",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typisiert",
        "solution": "true"
      },
      {
        "text": "Untypisiert",
        "solution": "false"
      },
      {
        "text": "Tupelwertig",
        "solution": "false"
      },
      {
        "text": "Objektwertig",
        "solution": "true"
      },
      {
        "text": "Referenzierbar",
        "solution": "true"
      },
      {
        "text": "Nicht referenzierbar",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2400,
    "category": 7,
    "difficulty": 3,
    "text": "Das Problem der Stabilität der OID tritt auf bei:",
    "explanation": "RICHTIG ist, dass das Problem der OID-Stabilität bei objektgenerierenden Objektsichten aufritt.\n\n     \n\n    Welche unterschiedlichen Sichten gibt es im OR-Kontext?\n\n    Relational: Tupelsichten\n\n    \n        Tupelsicht über beliebige Tabellen und Sichten\n    \n        Zeilen stellen Tupel dar\n\n\n    Objektrelational: Typisierte Sichten\n\n    \n        Basiert auf einem Strukturdatentyp\n    \n        Mittel der Zugriffskontrolle;\n    \n        ermöglicht logische Datenunabhängigkeit\n    \n        Objektgenerierend:\n    \n        Typisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\n    \n        OID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\n    \n        Objektrelationale Darstellung relationaler Daten\n    \n        Objekterhaltend:\n    \n        Typisierte Sicht, deren Zeilen bestehende Objekte darstellen\n    \n        Verallgemeinernde sowie spezialisierende Darstellungen möglich\n    \n        Bessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen\n    \n        FROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\n    \n        Kann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Relationalen Tabellen",
        "solution": "false"
      },
      {
        "text": "Objektrelationalen Tabellen",
        "solution": "false"
      },
      {
        "text": "Relationalen Sichten",
        "solution": "false"
      },
      {
        "text": "Objektgenerierenden objektrelationalen Sichten",
        "solution": "true"
      },
      {
        "text": "Objekterhaltenden objektrelationalen Sichten",
        "solution": "false"
      },
      {
        "text": "Das Problem gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2456,
    "category": 3,
    "difficulty": 3,
    "text": "Wie heißt die Eigenschaft einer Subtypen-Beziehung, wenn es Tupel geben soll, die nur der Super-Entity-Menge angehören? Wenn es diese Eigenschaft nicht gibt, schreiben Sie \"gibt es nicht\".",
    "explanation": "Das ist die  Definition eines nicht vollständigen Systems.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "nicht vollständig"
      }
    ]
  },
  {
    "id": 2345,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussagen über Indexe sind wahr?",
    "explanation": "\n    Die Lösung ergibt sich aus der Definition eines Index.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Index ist eine separate Speicherstruktur, die zusätzlich zur Tabelle angelegt wird.",
        "solution": "true"
      },
      {
        "text": "Für eine Tabelle kann nur ein Index angelegt werden.",
        "solution": "false"
      },
      {
        "text": "Einfügen und Löschen von Datensätzen sind aufwändiger, als bei Tabellen ohne Index.",
        "solution": "true"
      },
      {
        "text": "Indexe beschleunigen die Suche von Datensätzen, weil bei ihnen in der Regel mit jedem lesen-dem Zugriff auf einen physischen Block mehr Suchinformationen in den Hauptspeicher geladen wird.",
        "solution": "true"
      },
      {
        "text": "Indexe beschleunigen die Suche von Datensätzen, weil sie sortiert werden können und damit optimierte Suchalgorithmen ausgeführt werden können.",
        "solution": "true"
      },
      {
        "text": "Indexe haben den Vorteil, dass man für eine Tabelle mehrere anlegen kann und damit nach verschiedenen Spalten optimiert suchen kann.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2393,
    "category": 9,
    "difficulty": 3,
    "text": "Zu dem Problem der Stabilität der OID lässt sich folgendes sagen:",
    "explanation": "Welche unterschiedlichen Sichten gibt es im OR-Kontext?\n  \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht über beliebige Tabellen und Sichten \nZeilen stellen Tupel dar \n \n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp \nMittel der Zugriffskontrolle;  \nermöglicht logische Datenunabhängigkeit \nObjektgenerierend:  \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen \nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet \nObjektrelationale Darstellung relationaler Daten \nObjekterhaltend: \nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen \nVerallgemeinernde sowie spezialisierende Darstellungen möglich \nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen  \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es tritt bei objekterhaltenden objektrelationalen Sichten auf.",
        "solution": "false"
      },
      {
        "text": "Für solche Sichten gibt es bei Oracle die Möglichkeit, benutzerdefinierte OIDs zu definieren.",
        "solution": "true"
      },
      {
        "text": "Für solche Sichten gibt es bei Oracle die Möglichkeit, abgeleitete OIDs zu definieren.",
        "solution": "true"
      },
      {
        "text": "Für solche Sichten gibt es bei Oracle die Möglichkeit, systemgenerierte OIDs zu definieren.",
        "solution": "false"
      },
      {
        "text": "Das Problem gibt es nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2449,
    "category": 5,
    "difficulty": 2,
    "text": "Welche der folgenden Aussagen über Normalformen sind wahr?",
    "explanation": "Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Relation in der 1NF kann Wiederholungsgruppen haben.",
        "solution": "false"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      },
      {
        "text": "Eine Relation in der 1NF kann keine Wiederholungsgruppen haben.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2453,
    "category": 3,
    "difficulty": 2,
    "text": "Wenn Sie im gesamten ERM ausschließlich Surrogate Keys als Primärschlüssel verwenden, sind folgende Aussagen richtig:",
    "explanation": "Bei Surrogate-Keys werden ausschließlich nicht-identifizierende 1:n-Beziehungen benutzt, um zusammengesetzte Schlüssel zu vermeiden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Identifizierende Beziehungen können in 1:n-Beziehungen nicht verwendet werden.",
        "solution": "true"
      },
      {
        "text": "Nicht-identifizierende Beziehungen können verwendet werden.",
        "solution": "true"
      },
      {
        "text": "Identifizierende und nicht-identifizierende Beziehungen können verwendet werden.",
        "solution": "false"
      },
      {
        "text": "Es gibt Entity-Mengen, die aufgrund von 1:n-Beziehungen Fremdschlüssel besitzen, die aus mehreren Spalten bestehen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2455,
    "category": 5,
    "difficulty": 3,
    "text": "Auf welche Art/en können Sub- und Super-Entity-Mengen eines EERM für die Implementierung fragmentiert werden? Wenn es so etwas nicht gibt, schreiben Sie keine, ansonsten die Typen in alphabetischer Reihenfolge und durch Kommas getrennt!",
    "explanation": "Zu solch einem System eines Supertyps mit verschiedenen Subtypen wird als Erstes eine Universaltabelle gebildet. Die Universaltabelle besteht aus allen Attributen der beteiligten Entity-Mengen.\n\n\n\nBei der virtuellen Fragmentierung wird die Universaltabelle nur virtuell zerlegt und der Subtyp durch eine diskriminierende Spalte beschrieben.\n\n\n\nBei der vertikalen Fragmentierung wird die Universaltabelle auf mehrere Entity-Mengen aufgeteilt. Eine Entity-Menge entspricht dem Supertyp und enthält alle Attribute, die allen Subtypen gemein sind. Die einzelnen Subtypen werden durch Fremdschlüssel mit dem Supertyp verbunden und haben den gleichen Primärschlüssel wie der Supertyp. Außerdem enthalten sie noch alle Attribute, die den Subtyp selbst beschreiben.\n\n\n\nBei dieser Art der Fragmentierung wird zu jedem Subtyp eine Relation gebildet, allerdings unter Verzicht des zugrunde liegenden Supertyps.",
    "type": "text",
    "answers": [
      {
        "text": "Das sind:",
        "solution": "horizontal, vertikal, virtuell"
      }
    ]
  },
  {
    "id": 2457,
    "category": 6,
    "difficulty": 1,
    "text": "Das SQL-Daten-Modell kann wie folgt definiert werden: SET ( ROW ( Basisdatentyp ) ) .",
    "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2458,
    "category": 6,
    "difficulty": 3,
    "text": "Ein Index",
    "explanation": "Für einen Primärschlüssel wird automatisch ein Index erstellt vom DBMS, weil man davon ausgeht, dass über diese Primärschlüsselspalten sehr häufig zugreift und dann soll es möglichst schnell gehen. \nEin Index ist kein Werkzeug der Integritätsprüfung sondern ein Mittel des Tunings. Seine Aufgabe ist es, Anfragen (SELECT) zu beschleunigen, mit dem kleinen Nachteil, dass Einfügungen, Änderungen und Löschungen (INSERT, UPDATE, DELETE) etwas langsamer werden. Neben der eigentlichen Datenmanipulation muss ja auch noch der Index aktualisiert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "wird immer für Primärschlüssel erstellt.",
        "solution": "true"
      },
      {
        "text": "beschleunigt das Einfügen von Daten.",
        "solution": "false"
      },
      {
        "text": "erleichtert die Integritätsprüfung.",
        "solution": "false"
      },
      {
        "text": "besteht aus wenigstens zwei Spalten der zugehörigen Tabelle.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2459,
    "category": 6,
    "difficulty": 3,
    "text": "Erstellen Sie einen Nummerngenerator \"beliebig_seq\", der nur gerade positive Zahlen generiert.",
    "explanation": "CREATE SEQUENCE beliebig_seq INCREMENT BY 2 START WITH 2; \nDer Zähler startet mit 2 und es wird jeweils zwei hochgezählt. Damit generiert die Sequenz nur gerade Zahlen: 2,4,6,8,...",
    "type": "text",
    "answers": [
      {
        "text": "Der Befehl lautet inclusive Semikolon am Ende:",
        "solution": "CREATE SEQUENCE beliebig_seq INCREMENT BY 2 START WITH 2;"
      }
    ]
  },
  {
    "id": 2460,
    "category": 6,
    "difficulty": 1,
    "text": "Wie heißt der CONSTRAINT, wenn eine Spalte Pflichteingabespalte ist?",
    "explanation": "Das SQL-Constraint für die Pflichteingabe heißt NOT NULL und ist als einziges Constraint ausschließlich als Spalten-Constraint definierbar und erzwingt für eine Spalte die Eingabe eines Wertes. Diese Spalte kann nicht leer sein (NULL).",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "NOT NULL"
      }
    ]
  },
  {
    "id": 2461,
    "category": 6,
    "difficulty": 3,
    "text": "Welche SQL-Befehle lösen eine Integritätsprüfung aus?",
    "explanation": "Ziel der Integritätsprüfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints genügen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erfüllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Prüfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE lösen also IMMEDIATE-Integritätsprüfung aus. \nCOMMIT beendet eine Transaktion und löst damit eine DEFERRED-Integritätsprüfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie rückgängig gemacht wird. Eine Integritätsprüfung ist daher unnötig und wird nicht ausgeführt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was dafür sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integritätsprüfung auslösen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Prüfung wird damit nicht ausgelöst.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ROLLBACK",
        "solution": "false"
      },
      {
        "text": "DELETE",
        "solution": "true"
      },
      {
        "text": "SELECT",
        "solution": "false"
      },
      {
        "text": "INSERT",
        "solution": "true"
      },
      {
        "text": "CHECK",
        "solution": "false"
      },
      {
        "text": "UPDATE",
        "solution": "true"
      },
      {
        "text": "COMMIT",
        "solution": "true"
      },
      {
        "text": "SAVE",
        "solution": "false"
      },
      {
        "text": "ALTER",
        "solution": "true"
      },
      {
        "text": "DROP",
        "solution": "true"
      },
      {
        "text": "CREATE",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2462,
    "category": 6,
    "difficulty": 3,
    "text": "Welche SQL-Constraints bieten die Möglichkeit zur Fehlerkorrektur?",
    "explanation": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Prüfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Prüfung die ganze Transaktion zurückgerollt wird. Dieses Verhalten wird für Integritätsfehler ausschließlich bei NOT NULL, PRIMARY KEY, UNIQUE ausgeführt. \n\nLediglich die Fremdschlüssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabhängig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik,wenn Masterdatensätze gelöscht werden, für die noch abhängige Detail-Datensätze bestehen. Es besteht dann die Möglichkeit, z.B. die abhängigen Detaildatensätze ebenfalls zu löschen (CASCADE) oder deren Fremdschlüsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CHECK (Bedingung)",
        "solution": "false"
      },
      {
        "text": "PRIMARY KEY",
        "solution": "false"
      },
      {
        "text": "FOREIGN KEY",
        "solution": "true"
      },
      {
        "text": "NOT NULL",
        "solution": "false"
      },
      {
        "text": "UNIQUE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2463,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Constraints sind DEFERRED definierbar?",
    "explanation": "Alle fünf SQL-Constraints NULL, CHECK, FOREIGN KEY, PRIMARY KEY, UNIQUE sind unabhängig davon, ob sie Spalten- oder Tabellen-Constraint sind, als DEFERRED definierbar. Der Prüfungszeitpunkt \"DEFERRED\" (verzögert) bezeichnet den Zeitpunkt zum Transaktionsende, also dann, wenn COMMIT eingegeben wird. \n\nAus dem Syntax-Diagramm wird dies ersichtlich, weil für jeden Spalten-/Tabellenbedingungsausdruck die <CONSTRAINT Chraketristika> gelten und hinter denen verbergen sich u.a. die Optionen DEFERRED und IMMEDIATE.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NULL",
        "solution": "true"
      },
      {
        "text": "Foreign Key",
        "solution": "true"
      },
      {
        "text": "Primary Key",
        "solution": "true"
      },
      {
        "text": "Unique",
        "solution": "true"
      },
      {
        "text": "Check",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1789,
    "category": 1,
    "difficulty": 2,
    "text": "ANSI-3-Ebenen-Modell: In einem Anwendungssystem werden neue Daten gespeichert oder bestehende gelöscht.",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Keine Ebene ist betroffen.",
        "solution": "true"
      },
      {
        "text": "Diese Änderung betrifft die interne Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft die konzeptionelle Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft die externe Ebene.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1766,
    "category": 1,
    "difficulty": 1,
    "text": "Wann entstand das relationale Datenmodell?",
    "explanation": "Grundlagen des relationalen Datenmodells wurden vor allem mit den klassischen Arbeiten von E.F. Codd (1970 und 1972) gelegt. Dafür wurde er 1999 mit dem Turing-Award ausgezeichnet. Das Entity-Relationship- Modell basiert auf einer Arbeit von P.P. Chen aus dem Jahre 1976. Die heute als B-Bäume relevanten Speicherstrukturen wurden von Bayer 1972 eingeführt. Das Transaktionskonzept ist erstmals in Arbeiten zum System R3, einem Vorläufer von SQL (1976), beschrieben. Eine erste Analyse und systematische Darstellung von Transaktionen findet man in der Arbeit von Gray von 1981. Die 1970er Jahre kann man daher als eine Phase der wissenschaftlichen Formulierung der relationalen Datenbanktheorie bezeichnen, deren Umsetzung in die breite Anwendung erst in den 1980er Jahren erfolgte.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "50er Jahre",
        "solution": "false"
      },
      {
        "text": "60er Jahre",
        "solution": "false"
      },
      {
        "text": "70er Jahre",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2429,
    "category": 7,
    "difficulty": 3,
    "text": "Wann heißt eine (äußere) SELECT-Abfrage mit einer Unterabfrage (innerer SELECT) korreliert?",
    "explanation": "Korreliert bedeutet, dass die Spalten der äußeren Anweisung mit der innneren SELECT-Anweisung durch eine WHERE-Klausel verknüpft werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Anzahl der Spalten in der Unterabfrage ist kleiner als die Anzahl der Spalten in der äußeren SELECT-Anweisung",
        "solution": "false"
      },
      {
        "text": "Die äußere SELECT-Anweisung ist durch einen Join-Operator mit der inneren Select-Anweisung verbunden.",
        "solution": "true"
      },
      {
        "text": "Die äußere SELECT-Anweisung ist nicht durch einen Join-Operator mit der inneren Select-Anweisung verbunden.",
        "solution": "false"
      },
      {
        "text": "In der WHERE-Bedingung der Unterabfrage werden Spalten der äußeren SELECT-Anweisung mit den Spalten der inneren SELECT-Anweisung verknüpft.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2475,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Constraints sind IMMEDIATE definierbar?",
    "explanation": "Alle fünf SQL-Constraints NULL, CHECK, FOREIGN KEY, PRIMARY KEY, UNIQUE sind unabhängig davon, ob sie Spalten- oder Tabellen-Constraint sind, als IMMEDIATE definierbar. Der Prüfungszeitpunkt \"IMMEDIATE\" (unmittelbar) bezeichnet die Prüfung unmittelbar, wenn die Datenmanipulation (INSERT, UPDATE, DELETE) eingegeben wird. \n\nAus dem Syntax-Diagramm wird dies ersichtlich, weil für jeden Spalten-/Tabellenbedingungsausdruck die <CONSTRAINT Chraketristika> gelten und hinter denen verbergen sich u.a. die Optionen DEFERRED und IMMEDIATE.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PRIMARY KEY",
        "solution": "true"
      },
      {
        "text": "UNIQUE",
        "solution": "true"
      },
      {
        "text": "FOREIGN KEY",
        "solution": "true"
      },
      {
        "text": "NULL",
        "solution": "true"
      },
      {
        "text": "CHECK",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2165,
    "category": 5,
    "difficulty": 2,
    "text": "Gegeben sei eine Relation R(A, B, C) mit den funktionalen Abhängigkeiten A -> B, C und B -> C. Welche Zerlegung entspricht einer verlustfreien und abhängigkeitstreuen Zerlegung in die 3NF?",
    "explanation": "In der 3. NF werden für jede funktionale Abhängigkeit eine eigene Relation erstellt, plus eine für den Primärschlüssel der 1.NF, sollte dieser nicht bereits Teil einer der Relationen sein.\n\n    \n\n    Da es sich oben um eine transitive Abhängigkeit handelt, muss das transitiv abhängige Attribut C aus der einen Relation entfernt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "R={A,B,C}",
        "solution": "false"
      },
      {
        "text": "R1={A,B,C} und R2 ={A,C}",
        "solution": "false"
      },
      {
        "text": "R1={A,B,C} und R2 ={B,C}",
        "solution": "false"
      },
      {
        "text": "R1={A,B} und R2 ={B,C}",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2177,
    "category": 14,
    "difficulty": 2,
    "text": "Es ist folgende Tabelle mit zwei persistent gespeicherten Datensätzen gegeben:\nCREATE TABLE trans_tab (s1  NUMBER(3) PRIMARY KEY INITIALLY IMMEDIATE, \n                        s2  VARCHAR2(20) UNIQUE INITIALLY DEFERRED);\nINSERT INTO trans_tab VALUES (1, 'Mustermann');\nINSERT INTO trans_tab VALUES (2, 'Musterfrau');\nCOMMIT;\n\nSchauen Sie sich nachfolgende Anweisungen an und geben Sie an, welche Datensätze zum Zeitpunkt a) mit der SELECT-Anfrage angezeigt werden. \n\nSELECT * FROM trans_tab;                -- Zeitpunkt a)\nINSERT INTO trans_tab VALUES (3, 'Schmitt');\nINSERT INTO trans_tab VALUES (4, 'Schmidt');\nINSERT INTO trans_tab VALUES (4, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                -- Zeitpunkt b)\nINSERT INTO trans_tab VALUES (5, 'Schmitzchen');\nINSERT INTO trans_tab VALUES (6, 'Schmitzchen');\n\nSELECT * FROM trans_tab;                 -- Zeitpunkt c)\nCOMMIT;\n\nSELECT * FROM trans_tab;                -- Zeitpunkt d)",
    "explanation": "Nach dem CREATE-TABLE werden zwei Datensätze eingefügt, die keines der Constraints verletzt, und anschließend mit COMMIT persistent gespeichert, so dass folgender Inhalt beim a)-SeELECT gegen ist. \n        S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt\n         5 Schmitzchen\n         6 Schmitzchen",
        "solution": "false"
      },
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau\n         3 Schmitt\n         4 Schmidt",
        "solution": "false"
      },
      {
        "text": "S1 S2\n---------- --------------------\n         1 Mustermann\n         2 Musterfrau",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2623,
    "category": 6,
    "difficulty": 3,
    "text": "Erstellen Sie einen Nummerngenerator \"beliebig_seq\", der nur ungerade positive Zahlen generiert.",
    "explanation": "CREATE SEQUENCE beliebig_seq INCREMENT BY 2 START WITH 1; \nDer Zähler startet mit 1 und es wird jeweils zwei hochgezählt und somit generiert er nur ungerade Zahlen: 1,3,5,7,...",
    "type": "text",
    "answers": [
      {
        "text": "Der Befehl lautet inclusive Semikolon am Ende:",
        "solution": "CREATE SEQUENCE beliebig_seq INCREMENT BY 2 START WITH 1;"
      }
    ]
  },
  {
    "id": 2625,
    "category": 6,
    "difficulty": 3,
    "text": "Welche SQL-Befehle lösen eine DEFERRED-Integritätsprüfung aus?",
    "explanation": "Ziel der Integritätsprüfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints genügen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erfüllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Prüfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE lösen also IMMEDIATE-Integritätsprüfung aus. \nCOMMIT beendet eine Transaktion und löst damit eine DEFERRED-Integritätsprüfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie rückgängig gemacht wird. Eine Integritätsprüfung ist daher unnötig und wird nicht ausgeführt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was dafür sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integritätsprüfung auslösen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Prüfung wird damit nicht ausgelöst.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ROLLBACK",
        "solution": "false"
      },
      {
        "text": "DELETE",
        "solution": "false"
      },
      {
        "text": "SELECT",
        "solution": "false"
      },
      {
        "text": "INSERT",
        "solution": "false"
      },
      {
        "text": "CHECK",
        "solution": "false"
      },
      {
        "text": "UPDATE",
        "solution": "false"
      },
      {
        "text": "COMMIT",
        "solution": "true"
      },
      {
        "text": "SAVE",
        "solution": "false"
      },
      {
        "text": "CREATE",
        "solution": "true"
      },
      {
        "text": "ALTER",
        "solution": "true"
      },
      {
        "text": "DROP",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2627,
    "category": 6,
    "difficulty": 2,
    "text": "Wann ist ein Constraint nicht erfüllt in SQL? D.h. wann schlägt die Integritätsprüfung fehl?",
    "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\nEin Constraint in SQL ist erfüllt wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal geprüft und damit über der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt würde, könnte der CREATE TABLE gar nicht ausgeführt werden. Der andere Punkt sind die (potentiell) leeren Spalten für die die Constraints trotzdem erfüllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschlüsselspalte leer sein oder UNIQUE-Spalten dürfen leer sein, ohne dass das Constraint gleich verletzt ist. ...\n\n\nAchtung: Bei SELECT-Anfragen ist es anders, da wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wurde. Bei UNKNOWN oder FALSE wird der Datensatz \"fallen gelassen\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenn es zu FALSE ausgewertet wird.",
        "solution": "true"
      },
      {
        "text": "Wenn es zu UNKNOWN ausgewertet wird.",
        "solution": "false"
      },
      {
        "text": "Wenn es zu TRUE ausgewertet wird.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2628,
    "category": 7,
    "difficulty": 1,
    "text": "Wann wird ein Datensatz in die Ergebnismenge einer SQL-Anfrage aufgenommen?",
    "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\n\n\nBei SELECT-Anfragen wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedinung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\n\nAchtung: Bei der Integritätsprüfung ist das etwas anders:\n\nEin Constraint in SQL ist erfüllt wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\n\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal geprüft und damit über der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt würde, könnte der CREATE TABLE gar nicht ausgeführt werden. Der andere Punkt sind die (potentiell) leeren Spalten für die die Constraints trotzdem erfüllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschlüsselspalte leer sein oder UNIQUE-Spalten dürfen leer sein, ohne dass das Constraint gleich verletzt ist. ...",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenn die WHERE-Bedingung zu FALSE ausgewertet wird.",
        "solution": "false"
      },
      {
        "text": "Wenn die WHERE-Bedingung zu UNKNOWN ausgewertet wird.",
        "solution": "false"
      },
      {
        "text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2629,
    "category": 7,
    "difficulty": 2,
    "text": "Wann wird ein Datensatz nicht in die Ergebnismenge einer SQL-Anfrage aufgenommen?",
    "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\". \n\n\nAchtung: Bei der Integritätsprüfung ist das etwas anders: \nEin Constraint in SQL ist erfüllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal geprüft und damit über der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt würde, könnte der CREATE TABLE gar nicht ausgeführt werden. Der andere Punkt sind die (potentiell) leeren Spalten für die die Constraints trotzdem erfüllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschlüsselspalte leer sein oder UNIQUE-Spalten dürfen leer sein, ohne dass das Constraint gleich verletzt ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenn die WHERE-Bedingung zu FALSE ausgewertet wird.",
        "solution": "true"
      },
      {
        "text": "Wenn die WHERE-Bedingung zu UNKNOWN ausgewertet wird.",
        "solution": "true"
      },
      {
        "text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2901,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussagen über Views (Sichten) sind wahr?",
    "explanation": "Zu dem View -Begriff (sicht ) bitte im DB-Wiki unter   <a target=\"\" title=\"Änderbare Sicht\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht nachschlagen!",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine View, in der Spaltenabkürzungen benutzt werden (create view  as select spalt1 as neue_Spalte) erlaubt kein UPDATE der Daten.",
        "solution": "false"
      },
      {
        "text": "Eine View, mit einer SELECT-Anweisung, die DISTINCT enthält, erlaubt kein UPDATE der Daten.",
        "solution": "true"
      },
      {
        "text": "Wenn man in einer virtuellen View Daten löscht, bleiben diese Daten in der zugrundeliegenden Tabelle enthalten.",
        "solution": "false"
      },
      {
        "text": "Mit CREATE OR REPLACE view wird eine VIEW erst gelöscht (DROP) und dann wieder angelegt.",
        "solution": "true"
      },
      {
        "text": "Mit der ORACLE-Option \"WITH CHECK OPTION\" kann man die in einer View enthaltenen Spalten einschränken.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2383,
    "category": 9,
    "difficulty": 3,
    "text": "Wozu braucht man objektrelationale Sichten?",
    "explanation": "Alle Antworten sind richtig \nbis auf die eine: \"um mittels virtueller objektrelationale Sichten die Daten redundant zu speichern und somit einen schnelleren Zugriff zu gewährleisten.\" \nGenau wie im relationalen Modell werden auch bei virtuellen objektrelationalen Sichten keine Datensätze gespeichert und somit auch kein Zugriff beschleunigt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Um Beschränkungen der Benutzersichten realisieren zu können.",
        "solution": "true"
      },
      {
        "text": "Um eine differenziertere Rechteverwaltung realisieren zu können.",
        "solution": "true"
      },
      {
        "text": "Um relationaler Tabellen verwenden zu können, als wenn es Objekttabellen wären.",
        "solution": "true"
      },
      {
        "text": "um mittels virtueller objektrelationale Sichten die Daten redundant zu speichern und somit einen schnelleren Zugriff zu gewährleisten.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2384,
    "category": 9,
    "difficulty": 3,
    "text": "Objekterhaltende Sichten ermöglichen eine objektrelationale Darstellung relationaler Daten.",
    "explanation": "Objekterhaltende Sichten können keine objektrelationale Darstellung relationaler Daten sein, da ihnen ja ein Objekt zugrunde liegen muss, dass sie dann nur noch \"erhalten\" müssen.\nAnders sieht es bei objektgenerierenden Sichten aus, dort werden relationale Daten \"zu Objekten gemacht\", in dem ihnen u.a. eine OID gegeben wird u.v.m.\n  \nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n- Tupelsicht über beliebige Tabellen und Sichten \n- Zeilen stellen Tupel dar  \n\nObjektrelational: Typisierte Sichten\n- Basiert auf einem Strukturdatentyp \n- Mittel der Zugriffskontrolle;  \n- ermöglicht logische Datenunabhängigkeit \n- Objektgenerierend:  \n- Typisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen \n- OID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet \n- Objektrelationale Darstellung relationaler Daten \n- Objekterhaltend: \n- Typisierte Sicht, deren Zeilen bestehende Objekte darstellen \n- Verallgemeinernde sowie spezialisierende Darstellungen möglich \n- Bessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht.",
        "solution": "true"
      },
      {
        "text": "stimmt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2386,
    "category": 9,
    "difficulty": 2,
    "text": "Objekterhaltende Sichten haben ein Problem der Stabilität der OID.",
    "explanation": "Diese Aussage stimmt nicht, es sind die objektgenerierenden Sichten, die Probleme mit der Objektstabilität haben.\n  \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht über beliebige Tabellen und Sichten \nZeilen stellen Tupel dar \n \n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp \nMittel der Zugriffskontrolle;  \nermöglicht logische Datenunabhängigkeit \nObjektgenerierend:  \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen \nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet \nObjektrelationale Darstellung relationaler Daten \nObjekterhaltend: \nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen \nVerallgemeinernde sowie spezialisierende Darstellungen möglich \nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen  \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2388,
    "category": 9,
    "difficulty": 1,
    "text": "Objektrelationale Sichten sind ein Hilfsmittel für die logische Datenunabhängigkeit.",
    "explanation": "Welche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht über beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nermöglicht logische Datenunabhängigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen möglich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2390,
    "category": 9,
    "difficulty": 1,
    "text": "Die Definition einer objektrelationalen Sicht basiert auf einem Strukturdatentyp, also einem benutzerdefinierten Datentyp.",
    "explanation": "Welche unterschiedlichen Sichten gibt es im OR-Kontext?\n  \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht über beliebige Tabellen und Sichten \nZeilen stellen Tupel dar \n \n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp \nMittel der Zugriffskontrolle;  \nermöglicht logische Datenunabhängigkeit \nObjektgenerierend:  \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen \nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet \nObjektrelationale Darstellung relationaler Daten \nObjekterhaltend: \nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen \nVerallgemeinernde sowie spezialisierende Darstellungen möglich \nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen  \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2391,
    "category": 9,
    "difficulty": 2,
    "text": "Es gibt folgende objektrelationale Sichten:",
    "explanation": "FALSCH sind: objektmodifizierend und objektlöschend. \n\nRICHTIG sind: objekterhaltend und objektgenerierend \nobjektgenerierend\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nupelsicht über beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nermöglicht logische Datenunabhängigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen möglich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "objektgenerierend",
        "solution": "true"
      },
      {
        "text": "objektmodifizierend",
        "solution": "false"
      },
      {
        "text": "objektlöschend",
        "solution": "false"
      },
      {
        "text": "objekterhaltend",
        "solution": "true"
      },
      {
        "text": "Keine dieser Antworten ist richtig.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3170,
    "category": 13,
    "difficulty": 1,
    "text": "In Oracle-Instead-Of-Triggern können die Transitionsvariablen :NEW.spaltenname beschrieben werden.",
    "explanation": "Die Transitionsvariablen :NEW.spaltenname können unter Oracle-PL/SQL bei INSTEAD-OF-Triggern zwar gelesen, aber nicht beschrieben werden. Die :OLD.Transitionsvariablen können nie beschrieben werden, das sie einen alten Zustand enthalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3171,
    "category": 13,
    "difficulty": 2,
    "text": "Bei welchen Oracle-Triggern können die Transitionsvariablen :OLD.spaltenname beschrieben werden?",
    "explanation": "Die :OLD.Transitionsvariablen könenn bei keinem Trigger-Typ beschrieben werden, da sie den Zustand vor einer Transaktion beinhalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BEFORE INSERT FOR EACH ROW...",
        "solution": "false"
      },
      {
        "text": "BEFORE UPDATE FOR EACH ROW...",
        "solution": "false"
      },
      {
        "text": "BEFORE DELETE FOR EACH ROW...",
        "solution": "false"
      },
      {
        "text": "STATEMENT-TRIGGER",
        "solution": "false"
      },
      {
        "text": "INSTEAD-OF-Trigger",
        "solution": "false"
      },
      {
        "text": "keiner von allen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3183,
    "category": 4,
    "difficulty": 1,
    "text": "Welcher Optimierungsvorgang transformiert einen algebraischen Ausdruck der relationalen Algebra auf einen semantisch äquivalenten Ausdruck?",
    "explanation": "Bei der logischen Optimierung wird ein algebraischer Ausdruck der relationalen Algebra auf einen semantisch äquivalenten Ausdruck transformiert, der weniger Laufzeit benötigt. Je weniger Tupel die Zwischenergebnismengen haben, umso schneller ist die Anfrageauswertung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "logische Optimierung",
        "solution": "true"
      },
      {
        "text": "physische Optimierung",
        "solution": "false"
      },
      {
        "text": "kein von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3362,
    "category": 3,
    "difficulty": 1,
    "text": "Um welchen Attributtyp handelt es sich hier?\n\n    Studiendauer eines Studenten",
    "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zusätzlich der Größe nach ordnen und können verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zusätzlich auch Multiplikation und  Division,  zulassen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Intervall",
        "solution": "true"
      },
      {
        "text": "Ordinal",
        "solution": "false"
      },
      {
        "text": "Nominal",
        "solution": "false"
      },
      {
        "text": "Zahl",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2155,
    "category": 7,
    "difficulty": 1,
    "text": "Die Duplikate der Ergebnismenge einer Anfrage sollen nur einmal angezeigt werden. Welches Schlüsselwort ist in der Anfrage dafür zuständig?",
    "explanation": "Anders als bei der Relationalen Algebra, in der Duplikate nicht zugelassen sind und daher automatisch eliminieren werden, sind in SQL Duplikate zugelassen. Um Duplikate in SQL zu unterdrücken, muss man in der SELECT-Anweisung explizit die Option DISTINCT verwenden: SELECT DISTINCT spaltenname, .... FROM ....; \n\nUNIQUE ist ein Constraint und zwar das für die Zweitschlüssel. \nASC/DESC sind die Schlüsselwörter für die ab-/aufsteigende Sortierung in der ORDER BY-Klausel von SELECT-Anfragen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DESC",
        "solution": "false"
      },
      {
        "text": "DISTINCT",
        "solution": "true"
      },
      {
        "text": "UNIQUE",
        "solution": "false"
      },
      {
        "text": "ASC",
        "solution": "false"
      },
      {
        "text": "Diese Problematik gibt es bei SQL nicht, da Duplikate nicht zugelassen sind und automatisch unterdrückt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3181,
    "category": 15,
    "difficulty": 1,
    "text": "Wie viele Einträge hat ein B-Baum vom Typ 1 der Höhe 1 maximal?",
    "explanation": "Wurzel: 2 Einträge\n\n    1. Ebene: 2+2+2=6 Einträge\n\n    Summe: 8",
    "type": "text",
    "answers": [
      {
        "text": "Die Anzahl ist",
        "solution": "8\r"
      }
    ]
  },
  {
    "id": 2598,
    "category": 5,
    "difficulty": 1,
    "text": "Eine Relation in der zweiten Normalform mit nur einer funktionalen\nAbhängigkeit ist immer in der dritten Normalform.",
    "explanation": "Mit nur einer funktionalen Abhängigkeit, wäre keine Möglichkeit zur Transitivitiät gegeben. z.B. a->b,c. \nAber mit zwei funktionalen Abhängigkeiten ist als Mindestvoraussetzung grundsätzlich die Möglichkeit gegeben, dass es sich dabei um transitive Abhängigkeiten handeln könnte. z.B. a->b,c. und b->c.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Dieser Sachverhalt spielt in diesem Zusammenhang keine Rolle.",
        "solution": "false"
      },
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3408,
    "category": 4,
    "difficulty": 1,
    "text": "Der Natural Join ist in der relationalen Algebra der einzige Join-Operator, der ohne Bedingung auskommt",
    "explanation": "Der Theta Join hat immer eine Bedingung und unterdrückt keine doppelten Spalten. Equi-Join und Outer-Joins bauen auf der Definition des Theta-Joins auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "false"
      },
      {
        "text": "stimmt",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2616,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über das Fehlerverhalten des SQL-Integritätsprüfungskonzepts sind wahr?",
    "explanation": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Prüfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Prüfung die ganze Transaktion zurückgerollt wird. Dieses Verhalten wird für Integritätsfehler ausschließlich bei NOT NULL, PRIMARY KEY, UNIQUE ausgeführt.\n\n    \n\n    Lediglich die Fremdschlüssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabhängig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik,wenn Masterdatensätze gelöscht werden, für die noch abhängige Detail-Datensätze bestehen. Es besteht dann die Möglichkeit, z.B. die abhängigen Detaildatensätze ebenfalls zu löschen (CASCADE) oder deren Fremdschlüsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)...\n\n    \n\n     ::=\n\n    REFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n    <Übereinstimmungstyp>\n\n    [ <fehlerkorrektur definition=\"\"> ]\n\n    \n\n    <fehlerkorrektur definition=\"\"> ::=\n\n    ON UPDATE <fehlerkorrektur aktion=\"\">\n\n    | ON DELETE <fehlerkorrektur aktion=\"\">\n\n    \n\n    <fehlerkorrektur aktion=\"\"> ::=\n\n    CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n\n    \n\n    Wenn man bedenkt, für welche Problemstellung die Fehlerkorrektur gedacht ist, dann kommt man schnell darauf, das es nur die beiden Klauseln \"ON UPDATE\" und \"ON DELETE\" geben kann.\n\n    Werden Fremdschlüssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datensätze, die noch von Detail-Datensätze referenziert werden, gelöscht oder deren Schlüsselwert geändert wird und das anschließend Detail-Datensätze existieren, für deren Fremdschlüsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt.\n\n    Das Einfügen von Master-Datensätzen ist immer unproblematisch, da eine Fremdschlüsselbedingung es zulässt, dass es Master-Datensätze gibt, für die es keine Detail-Datensätze gibt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Prüfung nur die fehlerhafte Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Prüfung die ganze Transaktion zurückgerollt wird.",
        "solution": "true"
      },
      {
        "text": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Prüfung die ganze Transaktion zurückgerollt wird bzw. bei einer DEFERRED-Prüfung nur die fehlerhafte Datenmanipulation abgebrochen wird.",
        "solution": "false"
      },
      {
        "text": "Das Fremdschlüsel-Constraint bietet die Option, dass das DBMS eine Fehlerkorrektur durchführt.",
        "solution": "true"
      },
      {
        "text": "Die Constraints PRIMARY KEY, FOREIGN KEY und UNIQUE bieten die Option, dass das DBMS eine Fehlerkorrektur durchführt.",
        "solution": "false"
      },
      {
        "text": "Für die Fehlerkorrektur wird im CREATE TABLE-Befehl eine PL/SQL-Prozedur angegeben, die im Fehlerfall auszuführen ist.",
        "solution": "false"
      },
      {
        "text": "Die Fehlerkorrektur ist auf einen Spezialfall beschränkt, der im Zusammenhang mit den Fremdschlüsseln auftreten kann, den sog. \"Dangling Tuples\".",
        "solution": "true"
      },
      {
        "text": "Für die Fehlerkorrektur stehen drei Anwendungsfälle zur Verfügung, wann eine Korrektur ausgeführt werden soll:\n\n<Fehlerkorrektur Definition> ::=\n  ON INSERT <Fehlerkorrektur Aktion>\n| ON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2619,
    "category": 6,
    "difficulty": 2,
    "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    \n\n    Es wird versucht, einen Datensatz in die leere Tabelle einzufügen:\n\n    INSERT INTO HIERACHIE (Hans, Emil);\n\n    Was ist das Ergebnis dieser INSERT-Anweisung?",
    "explanation": "Der Datensatz kann nicht eingefügt werden, weil die Fremdschlüsselbeziehung mit dem Wert \"Emil\" fehlschlägt. Es gibt ja noch keinen anderen Datensatz in der Tabelle.\n\n    \n\n    Fehlerbericht:\n\n    SQL-Fehler: ORA-02291: Integritäts-Constraint (SS_10.SYS_C0015753) verletzt - übergeordneter Schlüssel nicht gefunden\n\n    02291. 00000 - \"integrity constraint (%s.%s) violated - parent key not found\"\n\n    *Cause: A foreign key value has no matching primary key value.\n\n    *Action: Delete the foreign key or add a matching primary key.",
    "type": "text",
    "answers": [
      {
        "text": "Der Inhalt ist folgender: \n(für einen oder mehrere eingefügte Datensätze nur die beiden Namen mit Leerzeichen getrennt; für eine leere Tabelle das Wort: leer)",
        "solution": "leer"
      }
    ]
  },
  {
    "id": 2560,
    "category": 4,
    "difficulty": 2,
    "text": "Welche Operatoren der Relationalen Algebra sind binär?",
    "explanation": "Unär:  F1 : Rn -> Rm      mit n , m ∈ N \nBinär: F2 : Rn × Rm -> Rk mit n , m , k ∈ N\nUnäre Operatoren: Selektion, Projektion\nBinäre Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "false"
      },
      {
        "text": "Projektion",
        "solution": "false"
      },
      {
        "text": "Division",
        "solution": "true"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Join-Operatoren (Theta, Equi, Natural, Left Outer, Right Outer, Outer)",
        "solution": "true"
      },
      {
        "text": "Vereinigung",
        "solution": "true"
      },
      {
        "text": "Differenz",
        "solution": "true"
      },
      {
        "text": "Durchschnitt",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2573,
    "category": 4,
    "difficulty": 1,
    "text": "Bestimmen Sie den Full Outer-Join der folgenden beiden Relationen über R1.S1 = R2.S3!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z",
    "explanation": "Der Full Outer-Join (beidseitiger, vollständiger äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation und der linken Operation mit NULL-Werten aufgefüllt werden, die beim natürlichen Join herausfallen würden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z",
        "solution": "true"
      },
      {
        "text": "Keine dieser Ergebnismengen ist richtig.",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nC  Y  C  Y",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2626,
    "category": 6,
    "difficulty": 3,
    "text": "Wann ist ein Constraint erfüllt in SQL?",
    "explanation": "Achtung: SQL basiert auf einer drei-wertigen Logik!\n\nD.h. es gibt die drei Wahrheitwerte: TRUE, FALSE, UNKNOWN.\n\nEin Constraint in SQL ist erfüllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal geprüft und damit über der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt würde, könnte der CREATE TABLE gar nicht ausgeführt werden. Der andere Punkt sind die (potentiell) leeren Spalten für die die Constraints trotzdem erfüllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschlüsselspalte leer sein oder UNIQUE-Spalten dürfen leer sein, ohne dass das Constraint gleich verletzt ist. ...\n\n\nAchtung: Bei SELECT-Anfragen ist es anders, da wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wurde. Bei UNKNOWN oder FALSE wird der Datensatz \"fallen gelassen\".",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenn es zu FALSE ausgewertet wird.",
        "solution": "false"
      },
      {
        "text": "Wenn es zu UNKNOWN ausgewertet wird.",
        "solution": "true"
      },
      {
        "text": "Wenn es zu TRUE ausgewertet wird.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2476,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Möglichkeiten zur Fehlerkorrektur bieten Constraints im SQL-Standard 2003?",
    "explanation": "Diese drei Optionen gibt es beim Fremdschlüssel-Constraint, sowohl bei Spalten- als auch bei Tabellen-Constraint. Außerdem: \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n\nIhre Bedeutung sind: \nON DELETE Die definierte Fehlerkorrekturoption wird ausgeführt, wenn der referenzierte Master-Datensatz gelöscht wird.\nON UPDATE Die definierte Fehlerkorrekturoption wird ausgeführt, wenn der Wert des referenzierten Schlüsselattributs in der Master-Tabelle geändert wird.\nCASCADE Die Detaildatensätze, deren Fremdschlüssel den manipulierten Master-Datensatz referenzieren, werden ebenfalls gelöscht kaskadierendes Löschen) bzw. deren Schlüsselwert wird entsprechend geändert (kaskadierendes Ändern).\nSET DEFAULT Die Fremdschlüsselspalten des Detaildatensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf den für diese Spalte definierten DEFAULT-Wert gesetzt.\nSET NULL Die Fremdschlüsselspalten des Detail-Datensatzes, die den manipulierten Master-Datensatz referenzieren, werden auf NULL gesetzt.\nNO ACTION Auf den Integritätsfehler wird je nach Prüfungszeitpunkt mit dem Zurückrollen der gesamten Transaktion bzw. der fehlerhaften DML-Anweisung reagiert (Reaktion wie bei den anderen CONSTRAINTS auch).\nRESTRICT Diese Option ist analog zur NO ACTION-Funktionalität zu sehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CASCADE",
        "solution": "true"
      },
      {
        "text": "SET NULL",
        "solution": "true"
      },
      {
        "text": "SET DEFAULT",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2632,
    "category": 6,
    "difficulty": 1,
    "text": "Wie heißt der CONSTRAINT, wenn eine Spalte Fremdschlüssel ist?",
    "explanation": "Das Fremdschlüssel-Constraint heißt FOREIGN KEY.\n\n    \n\n    Die <font color=\"#000000\" face=\"Arial, Helvetica, Geneva, sans-serif\">übrigen vier  Constraints sind: UNIQUE, CHECK, PRIMARY KEY und NOT NULL.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "FOREIGN KEY"
      }
    ]
  },
  {
    "id": 2341,
    "category": 15,
    "difficulty": 3,
    "text": "Ein B+ -Baum hat folgende Eigenschaften:",
    "explanation": "RICHTIG sind: \n\"Der B+-Baum ist vollständig balanciert, d.h. jeder Weg von der Wurzel zum Blatt hat die gleiche Länge, die Höhe h.\" \nAlle inneren Knoten mit n Einträgen haben n+1 Nachfolger.\nJeder Knoten außer der Wurzel eines B+-Baumes vom Typ k hat zwischen k und 2k Einträge. \nDie Wurzel hat mindestens einen und höchstens 2k Einträge. \nDer B+-Baum hat in den inneren Knoten nur Schlüsselinformationen und Verweise auf die nachfolgenden Knoten.  \nDer B+-Baum speichert die Daten ausschließlich in den Blättern.  \nDas hier sind alles Eigenschaften des B+-Baumes - beim B-Baum sieht das etwas anders aus - aber darum geht es hier ja nicht. \n\n\n\nFALSCH sind:  \nJeder Knoten eines B+-Baumes vom Typ k hat zwischen k und 2k Einträge, denn diese Aussage gilt nicht die Wurzel des Baumes. Sie kann ggf. auch nur einen Eintrag enthalten. \nAlle inneren Knoten haben zwei Nachfolger. Dies gilt nur, wenn der innere Knoten nur einen Eintrag enthält, bei mehr Einträgen, gibt es auch mehr Nachfolgerknoten. \nDer Weg von der Wurzel zum Blatt hat die Länge h, h+1 oder h+2, wobei h die Höhe des Baumes ist. Da der Baum beliebig tief sein kann, ist die Höhe nicht auf h+2 beschränkt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der B+-Baum ist vollständig balanciert, d.h. jeder Weg von der Wurzel zum Blatt hat die gleiche Länge, die Höhe h.",
        "solution": "true"
      },
      {
        "text": "Der Weg von der Wurzel zum Blatt hat die Länge h, h+1 oder h+2, wobei h die Höhe des Baumes ist.",
        "solution": "false"
      },
      {
        "text": "Alle inneren Knoten haben zwei Nachfolger.",
        "solution": "false"
      },
      {
        "text": "Alle inneren Knoten mit n Einträgen haben n+1 Nachfolger.",
        "solution": "true"
      },
      {
        "text": "Jeder Knoten eines B+-Baumes vom Typ k hat zwischen k und 2k Einträge.",
        "solution": "false"
      },
      {
        "text": "Jeder Knoten außer der Wurzel eines B+-Baumes vom Typ k hat zwischen k und 2k Einträge.",
        "solution": "true"
      },
      {
        "text": "Die Wurzel hat mindestens einen und höchstens 2k Einträge.",
        "solution": "true"
      },
      {
        "text": "Der B+-Baum hat in den inneren Knoten nur Schlüsselinformationen und Verweise auf die nachfolgenden Knoten.",
        "solution": "true"
      },
      {
        "text": "Der B+-Baum speichert die Daten ausschließlich in den Blättern.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2349,
    "category": 9,
    "difficulty": 2,
    "text": "Benutzerdefinierte Typen mit Methodendefinitionen sind für Objekttabellen wie auch für relationale Tabellen verwendbar.",
    "explanation": "Benutzerdefinierte Typen mit ihren Methoden können auch in relationalen Tupeltabellen verwendet werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2350,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussagen über OIDs (object identifier) sind wahr?",
    "explanation": "Objektgenerierte OIDS sind nicht vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mit OIDs wird das OO-Paradigma der Zustandsunabhängigkeit realisiert.",
        "solution": "true"
      },
      {
        "text": "OIDs sind unveränderlich.",
        "solution": "true"
      },
      {
        "text": "Systemgenerierte OIDs werden automatisch beim Erzeugen einer Instanz vom DBS erzeugt.",
        "solution": "true"
      },
      {
        "text": "Abgeleitete OIDs basieren auf Werten von vorgegebenen Schlüsselspalten.",
        "solution": "true"
      },
      {
        "text": "Bei benutzerdefinierten OIDs gibt der Benutzer beim Erzeugen einer Instanz die zugehörige OID vor.",
        "solution": "true"
      },
      {
        "text": "Objektgenerierte OIDs werden bei Erzeugen einer Objekttabelle vom DBS automatisch erzeugt.",
        "solution": "false"
      },
      {
        "text": "OIDs aus dem OR-Modell würde man im relationalen Modell mittels künstlicher Primärschlüssel simulieren.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2352,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Aussagen über Referenzen im OR-Modell sind wahr?",
    "explanation": "RICHTIG sind: \n- Eine OID ohne SCOPE-Angabe beschränkt eine Referenz auf Objektinstanzen des angegebenen Typs unabhängig von den Objekttabellen, in denen sie gespeichert sind. \n\nMit der SCOPE-Klausel können die Wertebereiche auf Instanzen dieses Typs in einer bestimmten Objekttabelle referenziert werden. \n\n- Fremdschlüssel im Relationalen Modell sind besser geeignet, um eine SCOPE-Referenz zu simulieren, als eine Referenz ohne SCOPE-Spezifikation, denn Fremdschlüssel stellen ja ganz konkret Beziehungen zwischen zwei Tabellen her - genau wie die SCOPE-Referenz auch.\n\n\nFALSCH sind: \nEine SCOPE-Klausel für Referenzen gibt es gar nicht. Obige richtige Aussagen belegen ihre Funktionsweise. \n\n- Fremdschlüssel im Relationalen Modell sind besser geeignet, um eine Referenz ohne SCOPE-Spezifikation zu simulieren, als eine mit SCOPE-Spezifikation. Für das OR-Konzept Referenz ohne SCOPE gibt es kein Pendant im relationalen Modell.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine SCOPE-Klausel für Referenzen gibt es gar nicht.",
        "solution": "false"
      },
      {
        "text": "Eine OID ohne SCOPE-Angabe beschränkt eine Referenz auf Objektinstanzen des angegebenen Typs unabhängig von den Objekttabellen, in denen sie gespeichert sind.",
        "solution": "true"
      },
      {
        "text": "Mit der SCOPE-Klausel können die Wertebereiche auf Instanzen dieses Typs in einer bestimmten Objekttabelle referenziert werden.",
        "solution": "true"
      },
      {
        "text": "Fremdschlüssel im Relationalen Modell sind besser geeignet, um eine Referenz ohne SCOPE-Spezifikation zu simulieren, als eine mit SCOPE-Spezifikation.",
        "solution": "false"
      },
      {
        "text": "Fremdschlüssel im Relationalen Modell sind besser geeignet, um eine SCOPE-Referenz zu simulieren, als eine Referenz ohne SCOPE-Spezifikation.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2353,
    "category": 9,
    "difficulty": 2,
    "text": "Wie heißt bei Oracle die Klausel für systemgenerierte OIDs (object identifier)? Wenn es keine solche Klausel gibt, schreiben Sie \"gibt es nicht\".",
    "explanation": "Die OID-Generierung bietet zwei Möglichkeiten: SYSTEM GENERATED bedeutet,dass eine weltweit eindeutige OID erzeugt wird, PRIMARY KEY entspricht dem Konzept eines Primärschlüssels.",
    "type": "text",
    "answers": [
      {
        "text": "OBJECT IDENTIFIER IS",
        "solution": "SYSTEM GENERATED"
      }
    ]
  },
  {
    "id": 2354,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt bei Oracle die Klausel für abgeleitete OIDs (object identifier)? Wenn es keine solche Klausel gibt, schreiben Sie \"gibt es nicht\".",
    "explanation": "Die OID-Generierung bietet zwei Möglichkeiten: SYSTEM GENERATED bedeutet,dass eine weltweit eindeutige OID erzeugt wird, PRIMARY KEY entspricht dem Konzept eines Primärschlüssels als abgeleitete OID.",
    "type": "text",
    "answers": [
      {
        "text": "OBJECT IDENTIFIER IS",
        "solution": "PRIMARY KEY"
      }
    ]
  },
  {
    "id": 2355,
    "category": 9,
    "difficulty": 3,
    "text": "Wie heißt bei Oracle die Klausel für benutzerdefinierte OIDs (object identifier)? Wenn es keine solche Klausel gibt, schreiben Sie \"gibt es nicht\".",
    "explanation": "Die OID-Generierung bietet zwei Möglichkeiten: SYSTEM GENERATED bedeutet,dass eine weltweit eindeutige OID erzeugt wird, PRIMARY KEY entspricht dem Konzept eines Primärschlüssels. \n\nBenutzerdefinierte OIDs gibt es unter Oracle nicht.",
    "type": "text",
    "answers": [
      {
        "text": "OBJECT IDENTIFIER IS",
        "solution": "gibt es nicht"
      }
    ]
  },
  {
    "id": 2356,
    "category": 9,
    "difficulty": 3,
    "text": "Bei welchem/n Befehl/en wird  bei Oracle eine OID spezifiziert?",
    "explanation": "Einer CREATE OID-Befehl gibt es nicht und OIDs werden nicht bei Typen, sondern bei Tabellen deklariert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OID FOR <Tabellenname> ",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE <Tabellenname> OF <Typname> ",
        "solution": "true"
      },
      {
        "text": "CREATE TYPE <Typname> AS OBJECT ",
        "solution": "false"
      },
      {
        "text": "Mit keinem dieser Befehle.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2369,
    "category": 9,
    "difficulty": 2,
    "text": "Für jeden bei Oracle definierten benutzerdefinierten Typ wird automatisch ein Konstruktor definiert.",
    "explanation": "Der Typ kann auch als NOT INSTANTIABLE angelegt werden. Dann wird kein Konstruktor definiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2375,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei folgende Methodendefinition gegeben:\n  CREATE OR REPLACE TYPE BODY kdtm AS\n  MEMBER FUNCTION get_plzort RETURN VARCHAR2 IS \n  BEGIN      RETURN (SELF.plz || SELF.ort);      END;\n  END;\nMit welchem/n Befehl/en kann man bei Oracle diese Methode aufrufen?",
    "explanation": "SELECT k.get_plzort() FROM kunden k WHERE name = \"Meier\";  ist der korrekte Aufruf einer Member-Funktion.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT kdtm.get_plzort(k.plz,k.ort) FROM kunden k WHERE name = \"Meier\";",
        "solution": "false"
      },
      {
        "text": "SELECT k.get_plzort(k.plz, k.ort) FROM kunden k WHERE name = \"Meier\";",
        "solution": "false"
      },
      {
        "text": "SELECT k.get_plzort() FROM kunden k WHERE name = \"Meier\";",
        "solution": "true"
      },
      {
        "text": "SELECT k.get_plzort FROM kunden k WHERE name = \"Meier\";",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2378,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Eigenschaften hat eine relationale Sicht?",
    "explanation": "Welche Tabellen-/Sichtformen kann es in einem ORDBMS geben? \n\n* Definitionsart: untypisiert vs. typisiert \nUntypisiert: die Struktur ergibt sich direkt aus den Attributstrukturen (RM)\nTypisiert: Sicht-/Tabellendefinition basiert auf benutzerdefinierten Typ (OR)\n\n* Zeilentyp: tupelwertig vs. objektwertig \nTupelwertig: keine Methodenaufrufe für ein konkretes Tupel (RM)\nObjektwertig: Methodenaufrufe des zugehörigen Objekttyps direkt über die Zeilenvariable (OR)\n\n* Referenzierbarkeit: nicht referenzierbar vs. referenzierbar  \nNicht referenzierbar: Zeilen sind nicht referenzierbar (RM)\nReferenzierbar: Zeilen sind mittels Referenzspalten (OIDs) referenzierbar; setzt OIDs voraus (OR) \n\n\n* Relationale Sichten/Tabellen sind: \n- tupelwertig, \n- untypisiert, \n- nicht referenzierbar\n\n\n* Objektorientierte Sichten/Klassen/Tabellen sind: \n- objektwertig, \n- typisiert, \n- referenzierbar",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typisiert",
        "solution": "false"
      },
      {
        "text": "Untypisiert",
        "solution": "true"
      },
      {
        "text": "Tupelwertig",
        "solution": "true"
      },
      {
        "text": "Objektwertig",
        "solution": "false"
      },
      {
        "text": "Referenzierbar",
        "solution": "false"
      },
      {
        "text": "Nicht referenzierbar",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2381,
    "category": 9,
    "difficulty": 1,
    "text": "Es sei folgende Typdefinition gegeben: \nCREATE OR REPLACE TYPE kd_typ AS OBJECT \n   (kd_id NUMBER, name VARCHAR2(100), adresse VARCHAR2(200));\n\nWelche/r Befehl/e erzeugen bei Oracle eine Objekttabelle?",
    "explanation": "RICHTIG ist: \nCREATE TABLE kunden_ot OF kd_typ (kd_id PRIMARY KEY)  \n   OBJECT IDENTIFIER IS PRIMARY KEY;  \n  \nauf der Basis des folgenden Syntaxdiagramms: \n\n<CREATE typisierte Table Anweisung> ::=\nCREATE TABLE Tabellenname OF Typname [ UNDER Supertabellenname ]\n( [  ]\n  [ ,  ]\n  [ ,  ]\n);",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TABLE kunden_ot  (kd_typ,   kd_id PRIMARY KEY) \n   OBJECT IDENTIFIER IS PRIMARY KEY;",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE kunden_ot  (kunde    kd_typ,   kd_id PRIMARY KEY) \n   OBJECT IDENTIFIER IS PRIMARY KEY;",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE kunden_ot OF kd_typ (kd_id PRIMARY KEY) \n   OBJECT IDENTIFIER IS PRIMARY KEY;",
        "solution": "true"
      },
      {
        "text": "Keiner der Befehle ist richtig.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2414,
    "category": 13,
    "difficulty": 1,
    "text": "Ein Oracle-Trigger muss ein COMMIT oder ROLLBACK enthalten",
    "explanation": "Ein DML-Trigger ist selbst Bestandteil einer Haupttransaktion und kann daher weder COMMIT noch ROLLBACK enthalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt  nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2450,
    "category": 5,
    "difficulty": 1,
    "text": "Welche Arten von funktionalen Abhängigkeiten gibt es?",
    "explanation": "X und Y seien zwei Teilmengen von Attributen einer Relation R. \nY heißt funktional abhängig von X, wenn Folgendes gilt: \nFür alle Tupel r, s aus R gilt: \nAus ProjX(s) = ProjX(r) folgt stets: ProjY(s) = ProjY(r). \nDie funktionale Abhängigkeit wird mit X → Y abgekürzt geschrieben, was man auch \"X bestimmt Y\" (bzw. Y hängt von X ab) lesen kann. ProjX(s) bezeichnet die Projektion von s auf X. \nEine funktionale Abhängigkeit X → Y wird als volle funktionale Abhängigkeit bezeichnet, wenn jedes Element aus Y von der kompletten Menge X, nicht von einer echten Teilmenge von X, funktional abhängig ist. \nEine partielle funktionale Abhängigkeit besteht, wenn es ein Element y aus Y gibt, das nur von einer echten Teilmenge der Attribute aus X funktional abhängt. \n\nMit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet. \nZ heißt transitiv abhängig von X, wenn Y voll funktional abhängig von X und Z voll funktional abhängig von Y ist, aber X nicht voll funktional abhängig von Y ist. \nAlso X →Y →Z, aber nicht Y →X. \n\nDie übrigen Begriffe gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Volle funktionale Abhängigkeit",
        "solution": "true"
      },
      {
        "text": "Halbe funktionale Abhängigkeit",
        "solution": "false"
      },
      {
        "text": "Transitive funktionale Abhängigkeit",
        "solution": "true"
      },
      {
        "text": "Kommutative funktionale Abhängigkeit",
        "solution": "false"
      },
      {
        "text": "Distributive funktionale Abhängigkeit",
        "solution": "false"
      },
      {
        "text": "Partielle funktionale Abhängigkeit",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2451,
    "category": 3,
    "difficulty": 2,
    "text": "Über einen künstlichen Primärschlüssel sind folgende Aussagen wahr:",
    "explanation": "In der Praxis häufig sogenannte künstliche Schlüssel (surrogate keys) verwendet. Ein künstlicher Schlüssel ist ein zusätzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Zähler vom Datentyp Integer, der systemintern verwaltet wird, nach außen nicht sichtbar ist und ausschließlich für die Primär- und Fremdschlüsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und Ähnlichem zu unterscheiden, die nach außen sichtbar sind und im Schriftverkehr verwendet oder zur Identifikation beim Kunden erfragt werden. Wenn man sich für die Verwendung von künstlichen Primärschlüsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen für das gesamte Modell, unabhängig von den sonstigen Schlüsseln der Entity-Mengen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Er besteht aus nur einem Attribut.",
        "solution": "true"
      },
      {
        "text": "Er besteht aus einem oder mehreren Attributen.",
        "solution": "false"
      },
      {
        "text": "Sein Datentyp ist numerisch.",
        "solution": "true"
      },
      {
        "text": "Er enthält Schlüsselwerte, die aus verschiedenen Komponenten zusammengesetzt sind, z.B. wie bei einer EAN (Eurepean Article Number), wo man anhand der Nummer das Herkunftsland, den herstellenden Betrieb und die Artikelnummer ablesen kann.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2504,
    "category": 7,
    "difficulty": 2,
    "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte für einen Datensatz leer ist?   \n     \nSELECT gehalt*12 AS Jahresgehalt FROM Mitarbeiter;",
    "explanation": "Eine numerische Operation auf einem Nullwert ergibt immer einen Nullwert.",
    "type": "text",
    "answers": [
      {
        "text": "Das Ergebnis ist",
        "solution": "NULL"
      }
    ]
  },
  {
    "id": 2503,
    "category": 7,
    "difficulty": 3,
    "text": "Welche SELECT-Anweisungen beantworten die Frage, welche Busse  haben keine Einsätze absolviert, wobei die Relationen \"busse\" und \"einsatzplan\" die angegebenen Spalten haben?",
    "explanation": "SELECT b.kfz_knz \nFROM   busse b  \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e); \nSELECT b.kfz_knz \nFROM   busse b  \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e  \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id); \nDiese beiden Anfragen sind syntaktisch falsch: IN ist ein binärer Operator. Es fehlt der linke Operand.  \n \nSELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);\nist semantisch falsch: Es fehlt die Korrelation zwischen Busse und Einsatzplan. So liefert die Anfrage immer die leere Menge als Ergebnis, sobald in der Einsatzplan-Tabelle irgendein Datensatz gespeichert ist.  \n\nSELECT b.kfz_knz\nFROM   busse b \nWHERE  EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e); \nist doppelt:-) semantisch falsch: Es fehlt das NOT vor EXISTS und es fehlt die Korrelation zwischen Busse und Einsatzplan.\n\nSELECT b.kfz_knz\nFROM   busse b natural join einsatzplan;\nist semantisch falsch: Das sind die Busse, die einen Einsatz gefahren sind. \n\nSELECT b.kfz_knz   FROM  busse b, einsatzplan e\nWHERE  e.fahrzeug_id <> b.fahrzeug_id; \nist unsinnig: So unsinnig, dass es schwer fällt, dazu eine Semantik zu finden. Technisch ausgedrückt: Es ist die Komplementmenge des Natural Joins zum kartesischen Produkt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  b.fahrzeug_id NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e);",
        "solution": "true"
      },
      {
        "text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e);",
        "solution": "false"
      },
      {
        "text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id);",
        "solution": "true"
      },
      {
        "text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT IN (SELECT e.fahrzeug_id FROM einsatzplan e \n                   WHERE  e.fahrzeug_id = b.fahrzeug_id);",
        "solution": "false"
      },
      {
        "text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  NOT EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);",
        "solution": "false"
      },
      {
        "text": "SELECT b.kfz_knz\nFROM   busse b \nWHERE  EXISTS (SELECT e.fahrzeug_id FROM einsatzplan e);",
        "solution": "false"
      },
      {
        "text": "SELECT b.kfz_knz\nFROM   busse b natural join einsatzplan;",
        "solution": "false"
      },
      {
        "text": "SELECT kfz_knz, COUNT(tag) as Anzahl_Einsätze\nFROM   busse LEFT OUTER JOIN einsatzplan USING  (fahrzeug_id)\nGROUP  BY kfz_knz\nhaving count(tag) = 0;",
        "solution": "true"
      },
      {
        "text": "SELECT b.kfz_knz   FROM  busse b, einsatzplan e\nWHERE  e.fahrzeug_id <> b.fahrzeug_id;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 1076,
    "category": 1,
    "difficulty": 2,
    "text": "ANSI-3-Ebenen-Modell: In einer Datenbank werden neue Masken auf dem bestehenden Datenbestand entwickelt.",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Änderung betrifft die interne Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft die konzeptionelle Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft keine Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft die externe Ebene.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 1077,
    "category": 1,
    "difficulty": 1,
    "text": "Wie viele Ebenen hat das ANSI-Modell der Datenmodellierung?",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "drei",
        "solution": "true"
      },
      {
        "text": "zwei",
        "solution": "false"
      },
      {
        "text": "vier",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2502,
    "category": 14,
    "difficulty": 3,
    "text": "Es ist die folgende leere Tabelle gegeben:  busfahrer(mita_id, stundenlohn), wobei mita_id eine Primärschlüsselspalte (Prüfungszeitpunkt: IMMEDIATE) ist und stundenlohn eine Pflichteingabespalte (Prüfungszeitpunkt: DEFERRED). Es ist folgende Transaktion gegeben:\n\n    INSERT INTO busfahrer VALUES (4711, 6);\n\n    INSERT INTO busfahrer VALUES (4711, 8);\n\n    SELECT mita_id FROM busfahrer;-- 1. SELECT\n\n    INSERT INTO busfahrer VALUES (4712, 0);\n\n    SELECT mita_id FROM busfahrer;-- 2. SELECT\n\n    INSERT INTO busfahrer VALUES (4713, NULL);\n\n    SELECT mita_id FROM busfahrer;-- 3. SELECT\n\n    COMMIT;\n\n    SELECT mita_id FROM busfahrer;-- 4. SELECT\n\n    Geben Sie für jede SELECT-Anweisung an, welche Ergebnismenge angezeigt wird, wobei mehrere Datensätze durch ein Semikolon getrennt sind und schreiben Sie NO ROWS, falls der SELECT keine Zeilen liefert!",
    "explanation": "1. SELECT: 4711\n\n    Der 2. INSERT (4711,8) wird unmittelbar abgebrochen, weil er die Primärschlüsselbedingung verletzt.\n\n    \n\n    2. SELECT: 4711; 4712\n\n    Die Einfügung (4712,0) verletzt keine Constraints.\n\n    \n\n    3. SELECT: 4711; 4712; 4713\n\n    Die Einfügung (4713,NULL) verletzt das Pflichteingabe-Constraint für die 2. Spalte, wird jedoch erst einmal ausgeführt, da dieses Constraint mit dem Prüfungszeitpunkt DEFERRED definiert ist. Diese Bedingung erst also zum COMMIT geprüft.\n\n    \n\n    4. SELECT: NO ROWS\n\n    Vor diesem SELECT wird ein COMMIT ausgeführt und damit die gesamte Transaktion, die mit dem ersten INSERT gestartet wurde, abgeschlossen. Abschließen heißt: erst einmal alle DEFERRED-Constraints prüfen und im Fehlerfall - wie hier, weil die Pflichteingabe für den 3. Datensatz verletzt ist - die gesamte Transaktion zurückrollen.",
    "type": "text",
    "answers": [
      {
        "text": "Ergebnis 1.SELECT",
        "solution": "4711"
      },
      {
        "text": "Ergebnis 2.SELECT",
        "solution": "4711; 4712"
      },
      {
        "text": "Ergebnis 3.SELECT:",
        "solution": "4711; 4712; 4713"
      },
      {
        "text": "Ergebnis 4.SELECT:",
        "solution": "NO ROWS"
      }
    ]
  },
  {
    "id": 2515,
    "category": 15,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation mit drei Spalten. \nWie viele Indizes kann man  anlegen?",
    "explanation": "Die Reihenfolge der Attribute spielt ja eine Rolle, daher 15 Kombinationsmöglichkeiten bei drei Spalten a, b, c: \na, b, c, \nab, ac, ba, bc, ca, cb, \nabc, acb, bac, bca, cab, cba,",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "1",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "false"
      },
      {
        "text": "5",
        "solution": "false"
      },
      {
        "text": "9",
        "solution": "false"
      },
      {
        "text": "15",
        "solution": "true"
      },
      {
        "text": "18",
        "solution": "false"
      },
      {
        "text": "7",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2631,
    "category": 7,
    "difficulty": 1,
    "text": "Es wird eine DELETE-Anweisung mit WHERE-Bedingung ausgeführt?",
    "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\nAchtung: Bei der Integritätsprüfung ist das etwas anders: \nEin Constraint in SQL ist erfüllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal geprüft und damit über der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt würde, könnte der CREATE TABLE gar nicht ausgeführt werden. Der andere Punkt sind die (potentiell) leeren Spalten für die die Constraints trotzdem erfüllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschlüsselspalte leer sein oder UNIQUE-Spalten dürfen leer sein, ohne dass das Constraint gleich verletzt ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die, für die die WHERE-Bedingung zu FALSE ausgewertet wird.",
        "solution": "false"
      },
      {
        "text": "Die, für die die WHERE-Bedingung zu UNKNOWN ausgewertet wird.",
        "solution": "false"
      },
      {
        "text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2600,
    "category": 5,
    "difficulty": 2,
    "text": "Gegeben sei eine Relation R(A, B, C) mit den funktionalen Abhängigkeiten A -> B, C und B -> C. Um welche funktionale Abhängigkeit handelt es sich hier? Bitte vervollständigen Sie die Antwort.",
    "explanation": "Hier ist C von B und B von A abhängig und damit ist C transitiv von A abhängig.\n\n    Mit X, Y und Z seien paarweise verschiedene Attributkombinationen einer Relation R = R(A1, A2,...,An) bezeichnet.\n\n    Z heißt transitiv abhängig von X, wenn Y voll funktional abhängig von X und Z voll funktional abhängig von Y ist, aber X nicht voll funktional abhängig von Y ist.\n\n    Also X → Y → Z, aber nicht Y → X.",
    "type": "text",
    "answers": [
      {
        "text": "Um eine ...",
        "solution": "transitive"
      }
    ]
  },
  {
    "id": 2601,
    "category": 5,
    "difficulty": 2,
    "text": "Gegeben sei eine Relation R(A, B, C, D) mit den mit funktionalen Abhängigkeiten A, B -> C, D und B -> C. Um welche funktionale Abhängigkeit handelt es sich hier? Bitte vervollständigen Sie die Antwort!",
    "explanation": "Eine partielle funktionale Abhängigkeit besteht, wenn es ein Element y aus Y gibt, das nur von einer echten Teilmenge der Attribute aus X funktional abhängt.",
    "type": "text",
    "answers": [
      {
        "text": "Um eine ... funktionale Abhängigkeit",
        "solution": "partielle"
      }
    ]
  },
  {
    "id": 2526,
    "category": 12,
    "difficulty": 1,
    "text": "Wenn eine PL/SQL-Prozedur einen IN-Parameter hat, muss sie auch einen OUT-Parameter haben.",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2525,
    "category": 12,
    "difficulty": 1,
    "text": "Mit SET SERVEROUTPUT ON SIZE 80000 kann man",
    "explanation": "Mit diesem Befehl kann man das Ergebnis von DBMS_OUTPUT.PUT_LINE ()sichtbar machen und die Bildschirmbuffergröße ändern. Ohne SET SERVEROUTPUT ON ist das Ergebnis einer PL/SQL-Prozedur unsichtbar.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "nur das Ergebnis von DBMS_OUTPUT.PUT_LINE ()sichtbar machen",
        "solution": "false"
      },
      {
        "text": "nur die Bildschirmbuffergröße ändern",
        "solution": "false"
      },
      {
        "text": "das Ergebnis von DBMS_OUTPUT.PUT_LINE ()sichtbar machen und die Bildschirmbuffergröße ändern.",
        "solution": "true"
      },
      {
        "text": "keine der Antworten ist richtig",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2599,
    "category": 5,
    "difficulty": 3,
    "text": "Gegeben sei eine Relation R(A, B, C) mit den funktionalen Abhängigkeiten A -> B, C und B -> C. Welche Zerlegung entspricht einer verlustfreien und abhängigkeitstreuen Zerlegung in die 2NF?",
    "explanation": "In der 2.NF werden partielle funktionale Abhängigkeiten aufgelöst. Hier handelt es sich jedoch um eine transitive funktionale Abhängigkeit, die jedoch erst in der 3.NF aufgelöst wird. Daher gilt hier 1.NF=2.NF.\n\n    \n\n    Eine Relation R ist in der ersten Normalform (1NF), wenn alle Attribute nur atomare Werte (keine mengenwertigen Datentypen) enthalten.\n\n    Eine Relation R mit Primärschlüssel S befindet sich in der zweiten Normalform (2NF), wenn sie (1NF) ist und jedes Nichtschlüsselattribut voll funktional abhängig vom Primärschlüssel S ist.\n\n    Eine Relation R ist in der dritten Normalform (3NF), wenn sie sich in der ersten und der zweiten Normalform befindet und kein Nichtschlüsselattribut transitiv abhängig von einem Schlüsselattribut ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "R={A,B,C}",
        "solution": "true"
      },
      {
        "text": "R1={A,B,C} und R2 ={A,C}",
        "solution": "false"
      },
      {
        "text": "R1={A,B,C} und R2 ={B,C}",
        "solution": "false"
      },
      {
        "text": "R1={A,B} und R2 ={B,C}",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2603,
    "category": 6,
    "difficulty": 2,
    "text": "Was muss man tun, damit eine mit einer CREATE-Anweisung neu erzeugtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) in der Datenbank existiert?",
    "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausführung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl \"ALTER TABLE tabellenname persistent\" gibt es nicht und ebenso wenig die CREATE-Option PERSISTENT.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nach der CREATE-Anweisung ein COMMIT absetzen.",
        "solution": "false"
      },
      {
        "text": "Gar nichts, weil bei der Ausführung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgeführt wird.",
        "solution": "true"
      },
      {
        "text": "Die Option PERSISTENT beim CREATE-Befehl verwenden.",
        "solution": "false"
      },
      {
        "text": "Für jedes DB-Objekt gibt es einen ALTER-Befehl, der für die dauerhafte Speicherung sorgt. Hier z.B. für eine Tabelle:\nALTER TABLE tabellenname persistent;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2605,
    "category": 6,
    "difficulty": 2,
    "text": "Was muss man tun, damit eine mit einer ALTER-Anweisung gelöschtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) in der Datenbank geändert vorliegt?",
    "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausführung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl ALTER mit einer Option PERSISTENT gibt es gar nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nach der ALTER-Anweisung ein COMMIT absetzen.",
        "solution": "false"
      },
      {
        "text": "Gar nichts, weil bei der Ausführung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgeführt wird.",
        "solution": "true"
      },
      {
        "text": "Die Option PERSISTENT beim ALTER-Befehl verwenden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2545,
    "category": 9,
    "difficulty": 2,
    "text": "Welcher Typkonstruktor aus dem SQL-Standard SQL2003 entspricht ORACLE den Nested Tables?",
    "explanation": "VARRAY gehört nicht zu SQL2003-Standard und ARRAY kann nur eine Kollektion von Werten, nicht eine komplette eingebettete Tabelle , aufnehmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ARRAY",
        "solution": "false"
      },
      {
        "text": "MULTISET",
        "solution": "true"
      },
      {
        "text": "VARRAY",
        "solution": "false"
      },
      {
        "text": "Solch einen Typkonstruktur gibt es nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2546,
    "category": 9,
    "difficulty": 3,
    "text": "Welcher Typkonstruktor kann auch als unbenannter Typkonstruktor unter ORACLE-SQL verwendet werden?",
    "explanation": "Den Typkonstruktur ARRAY gibt es im Oracle-SQL nicht. Außer REF müssen alle Typkonstruktoren explizit mit CREATE TYPE angelegt werden, d.h. ein Befehl wie\n\n CREATE TABLE test (NR number, ARRAY[2]Bezeichnung ) \nist unter Oracle/SQL nicht vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ARRAY",
        "solution": "false"
      },
      {
        "text": "VARRAY",
        "solution": "false"
      },
      {
        "text": "REF",
        "solution": "true"
      },
      {
        "text": "TABLE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2553,
    "category": 4,
    "difficulty": 2,
    "text": "Jemand schlägt vor, als Primärschlüssel einer Auftragspositionen-Relation nicht die Kombination von AuftragsNr und und ArtikelNr (wie bisher) zu wählen, sondern nur die ArtikelNr. Was würde das bedeuten?",
    "explanation": "Ist nur die ArtikelNr Primärschlüsselattribut, so kann in der Auftragspositionen-Relation jede ArtikelNr nur einmal vorkommen, mit der Konsequenz, dass jeder Artikel nur einmal verkauft werden kann.\nGrund dafür ist die Eigenschaft der Eindeutigkeit der (Primär-)Schlüssel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Auftrag besteht höchsten aus einem Artikel.",
        "solution": "false"
      },
      {
        "text": "Ein Artikel kann insgesamt nur einmal bestellt werden.",
        "solution": "true"
      },
      {
        "text": "Es macht keinen Unterschied zur anderen Lösung.",
        "solution": "false"
      },
      {
        "text": "Keine dieser Antworten ist korrekt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2607,
    "category": 6,
    "difficulty": 1,
    "text": "Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden nur alle neu eingefügten Datensätze und alle zukünftigen Datenänderungen und -löschungen in und aus dieser Tabelle geprüft, ob sie den CONSTRAINT erfüllen. Die bereits gespeicherten Daten werden nicht geprüft.",
    "explanation": "Falsch, das Constraint-Konzept bietet einen 100% Schutz. Das Wort \"nur\" stimmt hier nicht. Wenn man in der ORACLE-DBA-View USER_CONSTRAINTS sieht, dass ein Constraint erzeugt und aktiviert ist, dann kann man absolut sicher sein, dass alle gespeicherten Daten unabhängig vom Zeitpunkt der Speicherung korrekt sind. Sobald ein CONSTRAINT erzeugt und aktiviert wird, werden zurückwirkend alle in der Datenbank vorhanden Daten geprüft, ob sie dem CONSTRAINT genügen. Falls dies nicht der Fall ist, kann der CONSTRAINT nicht erzeugt werden.\n\n    \n\n    Das ist einer der Punkte, bei dem sich Integritätsprüfung mit Constraints und mit Triggern unterscheiden. Werden Trigger verwendet besteht diese Sicherheit nicht. Es werden nur für alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung überprüft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2595,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Typkonstruktoren sind inhomogen?",
    "explanation": "Homogene Elemente lassen nur Elemente gleichen Typs zu, dazu gehören: ARRAY, LIST, MULTISET, SET. \nInhomogene Elemente lassen nur Elemente unterschiedlichen Typs zu, dazu gehören: ROW, UNION",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SET",
        "solution": "false"
      },
      {
        "text": "ROW",
        "solution": "true"
      },
      {
        "text": "UNION",
        "solution": "true"
      },
      {
        "text": "ARRAY",
        "solution": "false"
      },
      {
        "text": "LIST",
        "solution": "false"
      },
      {
        "text": "MULTISET",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2608,
    "category": 6,
    "difficulty": 1,
    "text": "Welcher CONSTRAINT-Typ kann sich nur auf eine Spalte beziehen?",
    "explanation": "Je nach Art ihrer Definition werden die COLUMN CONSTRAINTS (Spaltenbedingung) und die TABLE CONSTRAINTS (Tabellenbedingung)\ndifferenziert. Die Spaltenbedingungen werden direkt bei der Spaltendefinition des CREATE TABLE-Befehls programmiert und können sich nur auf eine, die gerade definierte Spalte beziehen. Tabellenbedingungen werden auch beim CREATE TALBE-Befehl definiert, sind aber nicht Teil einer Spaltenspezifikation und können sich somit auf mehrere Spalten beziehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ein TABLE CONSTRAINT",
        "solution": "false"
      },
      {
        "text": "ein COLUMN CONSTRAINT",
        "solution": "true"
      },
      {
        "text": "keiner von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2609,
    "category": 4,
    "difficulty": 2,
    "text": "Um welchen Typ einer Integritätsbedingung handelt es sich hier?\n\nBei Privatkunden darf der Rabatt 15 Prozent nicht überschreiten.",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingung",
        "solution": "true"
      },
      {
        "text": "dynamische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, temporale Bedingung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2610,
    "category": 4,
    "difficulty": 2,
    "text": "Um welchen Typ einer Integritätsbedingung handelt es sich hier?\n\nEine Rechnung muss einen positiven Gesamtbetrag aufweisen, eine Gutschrift einen negativen.",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingung",
        "solution": "true"
      },
      {
        "text": "dynamische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, temporale Bedingung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2611,
    "category": 4,
    "difficulty": 2,
    "text": "Um welchen Typ einer Integritätsbedingung handelt es sich hier?\n\nDer Einkaufspreis eines Produkts darf innerhalb eines Jahres nicht um mehr als 10 % steigen.",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingung",
        "solution": "true"
      },
      {
        "text": "statische, temporale Bedingung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2554,
    "category": 4,
    "difficulty": 1,
    "text": "Bei einer Projektion wird eine n-stellige Relation auf eine n+m-stellige Relation abgebildet, mit m>0.",
    "explanation": "Die Projektion kann die Anzahl der Attribute nicht vergrößern, also keine Attribute hinzufügen. Sie kann lediglich die Ergebnismenge auf einzelne Attribute aus einer Relation beschränken.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2556,
    "category": 4,
    "difficulty": 3,
    "text": "Wie viele Attribute hat die Ergebnismenge des kartesischen Produkts von zwei Relationen, die über 15 bzw. 25 Attribute verfügen, wobei es in der einen Relation drei Attribute gibt, die gleich heißen wie in der anderen?",
    "explanation": "Die Struktur der Ergebnismenge des Kartesischen Produkts verfügt über alle Attribute aus beiden beteiligten Relationen: 15+25= 40 Attribute. \nDass drei Attribute in beiden Relationen gleich heißen, spielt keine Rolle für das Kartesische Produkt, sondern lediglich für den Natural Join.",
    "type": "text",
    "answers": [
      {
        "text": "Das kartesische Produkt hat ... Attribute.",
        "solution": "40"
      }
    ]
  },
  {
    "id": 2561,
    "category": 4,
    "difficulty": 1,
    "text": "Über welche Eigenschaften verfügt ein binärer Operator in der relationalen Algebra?",
    "explanation": "Unär:  F1 : Rn -> Rm      mit n , m ∈ N\nBinär: F2 : Rn × Rm -> Rk mit n , m , k ∈ N\nUnäre Operatoren: Selektion, Projektion\nBinäre Operatoren: Kartesisches Produkt, alle Join-Operatoren, alle Mengenoperatoren, Division",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Er liefert zwei Ergebnisdatenmengen.",
        "solution": "false"
      },
      {
        "text": "Er verarbeitet zwei Eingangsdatenmengen.",
        "solution": "true"
      },
      {
        "text": "Die Ergebnisdatenmenge verfügt über zwei Attribute.",
        "solution": "false"
      },
      {
        "text": "Die Eingangsdatenmengen verfügen über zwei Attribute.",
        "solution": "false"
      },
      {
        "text": "Die Operation wird nur auf zwei Attributen ausgeführt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2562,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Aussagen über die relationalen Algebra sind wahr?",
    "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen können, diese automatisch eliminiert werden. Zu diesen Operatoren gehören Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: später bei SQL sind Duplikate zugelassen, aber nicht in der RA. In SQL heißt das Schlüsselwort zur Duplikatelimination in SELECT-Anfragen DISTICNT.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Relationen und Ergebnisdatenmengen sind Multimengen, was heißt, dass doppelte Tupel erlaubt sind.",
        "solution": "false"
      },
      {
        "text": "Relationen und Ergebnisdatenmengen sind Mengen, was heißt, dass doppelte Tupel nicht erlaubt sind.",
        "solution": "true"
      },
      {
        "text": "Zur Unterdrückung doppelter Tupel gibt es eine eigene Operation: DISTINCT.",
        "solution": "false"
      },
      {
        "text": "Die Unterdrückung doppelter Tupel erfolgt automatisch. Bei den Operatoren, bei denen Duplikate auftreten können (Projektion, Vereinigung, Durchschnitt, Division) werden diese automatisch eliminiert.",
        "solution": "true"
      },
      {
        "text": "Es gibt keine Operatoren, bei denen Duplikate auftreten können.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2563,
    "category": 4,
    "difficulty": 1,
    "text": "Die Relationale Algebra basiert auf einem",
    "explanation": "Eine zentrale Eigenschaft der Relationalen Algebra ist es, dass die Relationen Mengen von Tupeln sind. Daraus folgt, dass auch die Ergebnisse von Operatoren wiederum Mengen sind. Was zur Folge hat, dass Operatoren, bei denen Duplikate entstehen können, diese automatisch eliminiert werden. Zu diesen Operatoren gehören Projektion, Vereinigung, Durchschnitt und Division. \nAchtung: später bei SQL sind Duplikate zugelassen, aber nicht in der RA.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mengenverständnis für Relationen (Duplikate nicht erlaubt).",
        "solution": "true"
      },
      {
        "text": "Multimengenverständnis für Relationen (Duplikate erlaubt).",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2564,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Prioritätenreihenfolge habe die logischen Operatorn der Relationalen Algebra? \nTragen Sie bitte 1, 2, 3 oder 4 ein!",
    "explanation": "Prioritätenreihenfolge der Operatoren (es ist die gleiche wie bei SQL)\nPriorität Operator\n1         Alle Vergleichsoperatoren\n2         NOT\n3         AND\n4         OR",
    "type": "text",
    "answers": [
      {
        "text": "OR",
        "solution": "4"
      },
      {
        "text": "Vergleichssoperatoren",
        "solution": "1"
      },
      {
        "text": "AND",
        "solution": "3"
      },
      {
        "text": "NOT",
        "solution": "2"
      }
    ]
  },
  {
    "id": 2527,
    "category": 4,
    "difficulty": 2,
    "text": "Welche Join-Operatoren sind immer verlustfrei?",
    "explanation": "Eine Join-Operation zwischen R und S heißt verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis. Bei allen Join-Operatoren bis auf den Full-Outer -Join können Tupel, die  in der verknüpften Operation kein Gegenüber haben, wegfallen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Theta-Join",
        "solution": "false"
      },
      {
        "text": "Equi-Join",
        "solution": "false"
      },
      {
        "text": "Left Outer Join",
        "solution": "false"
      },
      {
        "text": "Right Outer Join",
        "solution": "false"
      },
      {
        "text": "Natural Join",
        "solution": "false"
      },
      {
        "text": "Full Outer Join",
        "solution": "true"
      },
      {
        "text": "Keiner von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2528,
    "category": 4,
    "difficulty": 1,
    "text": "Welche Join-Operatoren gibt es in der relationalen Algebra nicht?",
    "explanation": "Außer Flat Join und Blank Join sind alle Join-Typen in der relationalen Algebra vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Theta-Join",
        "solution": "false"
      },
      {
        "text": "Equi-Join",
        "solution": "false"
      },
      {
        "text": "Left Outer Join",
        "solution": "false"
      },
      {
        "text": "Right Outer Join",
        "solution": "false"
      },
      {
        "text": "Natural Join",
        "solution": "false"
      },
      {
        "text": "Full Outer Join",
        "solution": "false"
      },
      {
        "text": "Flat Join",
        "solution": "true"
      },
      {
        "text": "Blank Join",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2529,
    "category": 12,
    "difficulty": 1,
    "text": "Parameter in PL/SQL-Prozeduren müssen einen Datentyp (VARCHAR, NUMBER etc.) haben.",
    "explanation": "Parameter unter PL/SQL müssen einen Datentyp habe, allerdings in allgemeiner Form, d.h. ohne Längenangabe. So ist z.B. varchar2(50) nicht zulässig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Stimmt",
        "solution": "true"
      },
      {
        "text": "Stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2530,
    "category": 13,
    "difficulty": 2,
    "text": "Welche Datenstrukturen sind in Oracle-Triggern beschreibbar?",
    "explanation": "Wenn man die Werte von OLD-Variablen ändert, wirft Oracle eine Exception (ORA-04085). Die Werte von NEW-Variablen lassen sich dagegen sehr wohl ändern.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NEW",
        "solution": "true"
      },
      {
        "text": "OLD",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2565,
    "category": 7,
    "difficulty": 3,
    "text": "Welche der folgenden SQL-Operatoren  müssen der Anforderung genügen, \"vereinigungskonform\" zu sein?",
    "explanation": "Die Forderung in SQL <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt für alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) müssen die gleichen Spaltendefinitionen aufweisen, d.h.: \n\nDie Anzahl der Spalten muss übereinstimmen. \nDie Datentypen der der Spalten müssen gleich sein.  \nDie Reihenfolge der Spalten muss übereinstimmen.\n\nAchtung: In der RA mussten die Spalten auch noch gleich heißen, das ist hier in SQL nicht mehr notwendig. Es werden in SQL die Spaltennamen der links vom Operator stehenden Tabelle verwendet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Projektion (SELECT-Klausel)",
        "solution": "false"
      },
      {
        "text": "Selektion (WHERE-Klausel)",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt (FROM-Klausel ohne WHERE-Bedingung)",
        "solution": "false"
      },
      {
        "text": "Join (NATURAL, THETA, EQUI, )",
        "solution": "false"
      },
      {
        "text": "OUTER JOIN (LEFT, RIGHT, FULL)",
        "solution": "false"
      },
      {
        "text": "UNION",
        "solution": "true"
      },
      {
        "text": "MINUS / EXCEPT",
        "solution": "true"
      },
      {
        "text": "INTERSECTION",
        "solution": "true"
      },
      {
        "text": "Es gibt keine solche Anforderung in SQL.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2567,
    "category": 4,
    "difficulty": 3,
    "text": "Welche Anforderungen muss ein \"vereinigungskonformer\" Operator der relationalen Algebra erfüllen? (relevant für die Durchführung von Mengenoperationen)",
    "explanation": "Die Forderung in der Relationalen Algebra <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt für alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Relationen (Eingangsdatenmengen) müssen die gleichen Attributdefinitionen aufweisen: \nDie Anzahl der Attribute muss übereinstimmen. \nDie Attribute müssen gleich heißen. \nDie Datentypen der der Attribute müssen gleich sein.  \nDie Reihenfolge der Attribute muss übereinstimmen. \nAchtung: In SQL müssen die Spalten nicht auch noch gleich heißen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Attribute müssen gleich heißen.",
        "solution": "true"
      },
      {
        "text": "Die Anzahl der Attribute muss übereinstimmen.",
        "solution": "true"
      },
      {
        "text": "Die Datentypen der der Attribute müssen gleich sein.",
        "solution": "true"
      },
      {
        "text": "Die Reihenfolge der Attribute muss übereinstimmen.",
        "solution": "true"
      },
      {
        "text": "Es gibt keine solche Anforderung in der RA.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2571,
    "category": 4,
    "difficulty": 1,
    "text": "Der Right Outer Join ist kommutativ.",
    "explanation": "Der rechte Outer-Join (rechter äußerer Join) zweier Relationen R1 und R2 ist ein Join-Operator, bei dem alle Tupel der rechten Relation, hier R2, die im Natural-Join unterdrückt werden, als Tupel mit aufgeführt und in den Attributen, die zu R1 gehören, mit NULL-Werten aufgefüllt werden.\n\nDie rechten und linken Outer-Joins sind nicht kommutativ, da entweder nur die rechte oder nur die linke Relation vollständig mit allen Tupeln in die Ergebnismenge aufgenommen werden. \nDer Full-Outer-Join (beidseitiger, vollständiger äußerer Join) zweier Relationen R1 und R2 ist ist jedoch kommutativ, da bei ihn sowohl die rechte als aich die linke Relation vollständig mit allen Tupeln in die Ergebnismenge aufgenommen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2576,
    "category": 4,
    "difficulty": 1,
    "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2!\n\nR1:\nS1  S2     \nA    W\nC    Y\n\nR2:\nS1  S2\nC    Y\nD    Z",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft.",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie die Attributwerte in Großbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.",
        "solution": "C Y"
      }
    ]
  },
  {
    "id": 2578,
    "category": 4,
    "difficulty": 2,
    "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attriguten S1, S2, S3, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS3  S4 \nC    Y\nD    Z",
    "explanation": "Keine dieser Ergebnismengen ist richtig, weil bei R1 und R2 keine Attribute gleich heißen. \nBei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft. Heißen keine Attribute gleich, so wird die leere Menge zurück geliefert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y\n?  ?  D  Z",
        "solution": "false"
      },
      {
        "text": "Keine dieser Ergebnismengen ist richtig.",
        "solution": "true"
      },
      {
        "text": "S1 S2 S3 S4\nC  Y  C  Y",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nA  W  ?  ?\nC  Y  C  Y",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nC  Y  C  Y\n?  ?  D  Z",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2583,
    "category": 4,
    "difficulty": 3,
    "text": "Wie heißen Programmiersprachen, bei denen der Programmierer die Lösung beschreibt, aber nicht den Lösungsweg im Detail programmieren muss?",
    "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.",
    "type": "text",
    "answers": [
      {
        "text": "Die Programmiersprachen heißen: (Kleinbuchstaben)",
        "solution": "deklarativ"
      }
    ]
  },
  {
    "id": 2574,
    "category": 4,
    "difficulty": 2,
    "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4!\n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft. Heißen keine Attribute gleich, so wird die leere Menge zurückgeliefert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "S1 S2 S2 S3 S4\nC  Y  ?  ?  ?\nA  W  W  D  Z\n?  ?  V  C  Y",
        "solution": "false"
      },
      {
        "text": "Keine dieser Ergebnismengen ist richtig.",
        "solution": "false"
      },
      {
        "text": "S1 S2 S2 S3 S4\nC  Y  W  D  Z\nC  Y  V  C  Y\nA  W  W  D  Z\nA  W  V  C  Y",
        "solution": "false"
      },
      {
        "text": "S1 S2 S2 S3 S4\nA  W  W  D  Z",
        "solution": "false"
      },
      {
        "text": "S1 S2 S3 S4\nA  W  D  Z",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2577,
    "category": 4,
    "difficulty": 2,
    "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS1  S4 \nC    Y\nD    Z",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft. Heißen keine Attribute gleich, so wird die leere Menge zurück geliefert.",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie die Attributwerte in Großbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.",
        "solution": "C Y Y"
      }
    ]
  },
  {
    "id": 2581,
    "category": 4,
    "difficulty": 2,
    "text": "Es sind die folgenden beiden Relationen R1, R2 mit den Attributen S1, S2, S3, S4 gegeben: \n\nR1: \nS1  S2       \nC    Y \nA    W\n\nR2: \nS2 S3  S4 \nV    C    Y\nW   D    Z",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft.",
    "type": "text",
    "answers": [
      {
        "text": "Welche Operation der Relationalen Algebra hat folgende Ergebnismenge? \n(englischsprachige Bezeichnung, nur Kleinbuchstaben, Wörter durch ein Leerzeichen getrennt, keine Bindestriche etc.)\n\nS1 S2 S3 S4\nA  W  D  Z",
        "solution": "natural join"
      }
    ]
  },
  {
    "id": 2585,
    "category": 4,
    "difficulty": 1,
    "text": "Welcher Programmiersprachen sind deklarativ?",
    "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Java",
        "solution": "false"
      },
      {
        "text": "C++",
        "solution": "false"
      },
      {
        "text": "SQL",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2959,
    "category": 3,
    "difficulty": 2,
    "text": "Wie heißt eine Beziehung, die mit beiden Enden die gleiche Entity-Menge verbindet?",
    "explanation": "Eine rekursive Beziehung ist eine Beziehung, die mit beiden Enden auf die gleiche Entity-Menge verweist.",
    "type": "text",
    "answers": [
      {
        "text": "So eine Beziehung heißt:",
        "solution": "rekursiv"
      }
    ]
  },
  {
    "id": 2926,
    "category": 9,
    "difficulty": 3,
    "text": "Die beiden weitgehend unverändert dem objektrelationalen Modell zugrunde liegenden Modelle des SQL-92-Standards sowie des Basisobjektmodells werden beim SQL-2003-Standard um drei Typkonstruktoren erweitert. Nennen Sie die Namen ohne Sonderzeichen und in alphabetischer Reihenfolge.",
    "explanation": "Die beiden grundlegenden Konzepte, die im objektrelationalen SQL2003 zusammengeführt wurden sind: SQL-92 und das Basisobjektmodell. (vgl. auch Türker/Saake in \"Objektrelationale Datenbanken\", dpunkt-Verlag, 2006, Kap.3, insbesondere S.95) Diese beiden Modelle werden zudem um drei Typkonstruktoren erweitert:\n\nin SQL: REF, MULTISET, ARRAY \nbei Oracle REF, (NESTED) TABLE, VARRAY \n\nZu beachten ist insbesondere, dass sowohl bei Oracle wie auch beim SQL2003-Standard nicht das relationalen Modell mit seiner Mengensemantik sondern das SQL-92-Modell mit seinem Verständnis einer Tabelle als Multimenge zugrunde liegt.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist zum einen ...",
        "solution": "REF"
      },
      {
        "text": "Das ist zum zweiten ...",
        "solution": "MULTISET"
      },
      {
        "text": "Und zum dritten das ...",
        "solution": "ARRAY"
      }
    ]
  },
  {
    "id": 2904,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussage(n) über Unterabfragen sind wahr?",
    "explanation": "Wenn ein Wert kleiner ist als irgendein Wert des Ergebnis einer Unterabfrage, ist er insbesondere auch kleiner als das Maximum der Werte der Unterabfrage. Wenn ein Wert kleiner als das Maximum des Ergebnises einer Unterbafrage ist, ist er auch kleiner als ein beliebiger Wert des Ergebnises der Unterabfrage.\n\n    Wenn ein Wert kleiner ist als jeder Wert des Ergebnis einer Unterabfrage, ist er insbesondere auch kleiner als das Minimum der Werte der Unterabfrage. Wenn ein Wert kleiner als das Minimum des Ergebnises einer Unterabfrage ist, ist er auch kleiner als alle Werte der Unterabfrage.\n\n    Die Aussage (< ANY(Unterabfrage)) ist schwächer als < ALL(Unterabfrage) und genauso ist das die Aussage (kleiner als das Maximum) schwächer als (kleiner als das Minimum).\n\n    siehe Erklärungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "< ANY(Unterabfrage) ist äquivalent zu kleiner als das Maximum.",
        "solution": "true"
      },
      {
        "text": "< ANY(Unterabfrage) ist äquivalent zu kleiner als das Minimum.",
        "solution": "false"
      },
      {
        "text": "< ALL(Unterabfrage) ist äquivalent zu kleiner als das Minimum.",
        "solution": "true"
      },
      {
        "text": "< ALL(Unterabfrage) ist äquivalent zu kleiner als das Maximum.",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3479,
    "category": 8,
    "difficulty": 1,
    "text": "Identische SQL-Anweisungen werden in der Oracle-DB in der SGA (Hauptspeicherbereich)  zwischengespeichert, samt Query-Execution-Plan  und sorgen dabei für eine höhere Performance.\n\nZwei SQL-Anweisungen sind in diesem Sinne identisch, wenn",
    "explanation": "Der Oracle-Server betrachtet zwei SQL-Anweisungen nicht als identisch, wenn sie sich auch nur geringfügig unterscheiden, z.B. durch Leerzeichen oder Groß/Kleinschreibung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "sie in allen Zeichen übereinstimmen, wobei Groß/Kleinschreibung eine Rolle spielt.",
        "solution": "true"
      },
      {
        "text": "sie auch bei den Leerzeichen hinsichtlich Anzahl und Position übereinstimmen.",
        "solution": "true"
      },
      {
        "text": "Die Leerzeichen spielen bei dieser Frage keine Rolle.",
        "solution": "false"
      },
      {
        "text": "sie in allen Zeichen übereinstimmen, wobei Groß/Kleinschreibung keine Rolle spielt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2698,
    "category": 12,
    "difficulty": 2,
    "text": "Wie wird eine Prozedur mit dem Bezeichner prozedurname aufgerufen?",
    "explanation": "Beispiele für Prozeduraufrufe sind: \nSQL-Plus \nEXECUTE prozedurname(var_y, var_x)\nIm PL/SQL-Programm:\nprozedurname(var_y, var_x) \n\nSELECT/DML-Anweisung, IF-Bedingung und Zuweisungen sind Aufrufformen für Funktionen.\n\nUnd Trigger werden \"durch ein eingetretenes Ereignis\" gefeuert und zu einem \"einen eingetretenen Ausführungszeitpunkt\" ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Im PL/SQL-Programm einfach nur mit dem prozedurname",
        "solution": "true"
      },
      {
        "text": "Durch einen eingetretenen Ausführungszeitpunkt",
        "solution": "false"
      },
      {
        "text": "In SELECT- und DML-Anweisungen durch Verwendung von   prozedurname",
        "solution": "false"
      },
      {
        "text": "In IF-Bedingungen",
        "solution": "false"
      },
      {
        "text": "In Zuweisungen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2703,
    "category": 13,
    "difficulty": 3,
    "text": "Woran kann man rein syntaktisch erkennen, das ein Mutating Table-Problem in einem Oracle-Trigger vorliegt?",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Im Aktionsteil wird mit SELECT und/oder INSERT, UPDATE, DELETE auf eine beliebige Tabelle des Schemas zugegriffen.",
        "solution": "false"
      },
      {
        "text": "Im Aktionsteil wird mit SELECT und/oder INSERT, UPDATE, DELETE auf eine Tabelle zugegriffen, die mittels Fremdschlüssel verbunden ist mit der Tabelle des Triggers.",
        "solution": "false"
      },
      {
        "text": "Im Aktionsteil wird mit SELECT und/oder INSERT, UPDATE, DELETE auf die Tabelle zugegriffen, für die der Trigger definiert wurde.",
        "solution": "true"
      },
      {
        "text": "Im Aktionsteil wird ein COMMIT oder ROLLBACK ausgeführt.",
        "solution": "false"
      },
      {
        "text": "Es ist ein zeilenorientierter ORACLE-Trigger.",
        "solution": "true"
      },
      {
        "text": "Es ist ein befehlsorientierter orientierter ORACLE-Trigger.",
        "solution": "false"
      },
      {
        "text": "Es ist ein befehls- oder zeilenorientierter orientierter ORACLE-Trigger.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2720,
    "category": 6,
    "difficulty": 1,
    "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle:\n\n    CREATE TABLE Zeitschrift\n\n    ( Zeitschrift_id INTEGER NOT NULL,\n\n    Namen VARCHAR2(20) NULL,\n\n    PRIMARY KEY (Zeitschrift_id));\n\n    \n\n    CREATE TABLE Aufsatz\n\n    ( Aufsatz_id INTEGER NOT NULL,\n\n    Titel VARCHAR2(20) NULL,\n\n    Zeitschrift_id INTEGER NOT NULL,\n\n    PRIMARY KEY (Aufsatz_id),\n\n    FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);\n\n    Auf welcher der beiden Tabellen ist ein ON DELETE CASCADE möglich, mit dem Zweck, dass zu einer Zeitschrift auch die zuhörigen Aufsätze gelöscht werden?",
    "explanation": "ON DELETE CASCADE ist eine Option des Fremdschlüssel-Constraints und da bei der Zeitschriften-Tabelle gar kein Fremdschlüssel definiert ist, kann auch kein ON DELETE CASCADE spezifiziert werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zeitschrift",
        "solution": "false"
      },
      {
        "text": "Aufsatz",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2728,
    "category": 10,
    "difficulty": 2,
    "text": "Welche Parametertypen müssen registriert werden?",
    "explanation": "Anders als bei IN-Parametern, müssen OUT- und INOUT-Parameter explizit registriert werden, damit der Datentyp des Parameters im Programm bekannt ist. Bei IN-Parametern ist der Datentyp über den Übergabewert beim Aufruf bekannt und wird nur für den Aufruf benötigt. Für die Rückgabe von Werten nach der Prozedur-/Funktionsausführung müssen jedoch die Datentypen der OUT- und INOUT-Parameter explizit bekannt gemacht werden. \n\n\nHier ein Beispiel:\n\nCREATE OR REPLACE PROCEDURE gibAnzahlEintraege(anzahl OUT INTEGER) \nBEGIN\n   SELECT COUNT( * )INTO anzahl FROM person;\nEND;\n\n\nCallableStatement cstmt = \n     con.prepareCall(\"{call gibAnzahlEintraege(?)}\"); \n//OUT- (und INOUT-) Parameter: Festlegung des Datentyps\ncstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n//Abfrage ausführen\ncstmt.executeQuery();\n//Wert auslesen\nSystem.out.println(\"Anzahl der Einträge: \"+ cstmt.getInt(1));",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "false"
      },
      {
        "text": "OUT",
        "solution": "true"
      },
      {
        "text": "INOUT",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2730,
    "category": 10,
    "difficulty": 1,
    "text": "Zu wie vielen verschiedenen Datenbanken können in einem Java-Programm  Verbindungen aufgebaut werden?",
    "explanation": "Ein Java-Programm kann eine oder mehrere Verbindungen zu einer oder mehreren Datenbanken unterhalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1",
        "solution": "false"
      },
      {
        "text": "2",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "false"
      },
      {
        "text": "keine",
        "solution": "false"
      },
      {
        "text": "mehrere",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2731,
    "category": 10,
    "difficulty": 3,
    "text": "Mit welchem Methodenaufruf wird Transaktionsverarbeitung möglich, die ein explizites COMMIT oder ROLLBACK von der Anwendung erfordern? Wenn es die Default-Einstellung ist, schreiben Sie \"default\". Wenn ein Methodenaufruf notwendig ist, rufen Sie die Methode für das Verbindungsobjekt \"con\".",
    "explanation": "Nach Verbindungsaufbau ist der Modus defaultmäßig auf \n       Auto-Commit-Modus = true  \ngesetzt. D.h. jede einzelne SQL-Anweisung wird als Transaktion \u000b      behandelt, und nach dem Ausführen automatisch festgeschrieben.\n\nUm mehr als eine SQL-Anweisung als Transaktion zu erlauben, muss der Auto-Commit-Modus ausgeschaltet werden:\n\n    verbindung.setAutoCommit(false);\nIn diesem Modus muss die Java-Anwendung selbst die Transaktionen mit COMMIT oder ROLLBACK abschließen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ...",
        "solution": "con.setAutoCommit(FALSE)"
      }
    ]
  },
  {
    "id": 2742,
    "category": 9,
    "difficulty": 3,
    "text": "Ausgehend von der Klassifikation von Stonebraker und Morre sind objektorientierte DBS für welche Art von Anwendungen gut geeignet?\n\nQuelle: \nStonebraker, M., Morre, D.: \"Objektrelationale Datenbanken  Die nächste große Welle\", Hanser, München, 1999",
    "explanation": "Stonebraker und Morre haben in ihrem Buch \"Objektrelationale Datenbanken  Die nächste große Welle\" 1999 folgende Klassifikation postuliert, die sich gut bewährt hat. Interessant wird es, wenn es um Anwendungen geht, die mehrere dieser Eigenschaften abdecken. \n\n* Einfache Daten und wenig Anfragen erfordern Dateisysteme\n* Einfache Daten und viele Anfragen erfordern relationale DBMS\n* Komplexe Daten und viele Anfragen erfordern objektrelationale DBMS\n* Komplexe Daten und wenig Anfragen erfordern objektorientierte DBMS\n\nBei objektorientierten Datenbanksystemen bestehen \"Anfragen\" in der Regel aus Spezialoperationen, die mittels Methoden implementiert sind z.B. bei Geo-Informationssystemen: schneiden sich zwei Straßen, haben zwei Orte die gleichen Höhenmeter, überlagern sich zwei Gesteinsformationen etc. ... \nund kaum aus Mengenanfragen, wie man es aus der relationalen Welt gewohnt ist.\nBei objektrelationalen Datenbanksystemen möchte man komplexere Objektstrukturen analog zur Realität abbilden können und nicht wie im relationalen Modell Objekte ggf. über mehrere Relationen verteilen. Es stehen weiterhin die Mengenanfragen zur Verfügung aber auch über die Methoden die Programmierung beliebige Spezialoperationen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "einfache Daten und wenige Anfragen",
        "solution": "false"
      },
      {
        "text": "einfache Daten und viele Anfragen",
        "solution": "false"
      },
      {
        "text": "komplexe Daten und viele Anfragen",
        "solution": "false"
      },
      {
        "text": "komplexe Daten und wenig Anfragen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2744,
    "category": 9,
    "difficulty": 1,
    "text": "Welcher Befehl ist richtig, um einen benutzerdefinierten Datentyp \"strasse\" bestehend aus den beiden Informationen \"strassenname\" (50 alphanumerische Zeichen) und  \"hausnummer\" (5 alphanumerische Zeichen) anzulegen?",
    "explanation": "Die richtig Syntax ist: \n\nCREATE OR REPALCE TYPE strasse AS OBJECT \n(strassenname   VARCHAR2(50), \n hausnummer     VARCHAR2(5)\n);",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPALCE TYPE strasse \n(strassenname   VARCHAR2(50), \n hausnummer     VARCHAR2(5)\n);",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPALCE strasse AS TYPE \n(strassenname   VARCHAR2(50), \n hausnummer     VARCHAR2(5)\n);",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPALCE TYPE strasse AS OBJECT \n(strassenname   VARCHAR2(50), \n hausnummer     VARCHAR2(5)\n);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2746,
    "category": 9,
    "difficulty": 1,
    "text": "Welche Arten von Tabellen lassen sich mit einer Referenzspalte REF referenzieren?",
    "explanation": "Eine Referenz kann nur auf eine Objekttabelle (Oracle) / Typisierte Tabelle (SQL) verweisen, da für den Verweis eine OID benötigt wird, die in relationalen Tabellen nicht gegeben ist.  \n\nAndererseits kann die Referenz aus einer relationalen wie auch objektrelationale Tabelle (Objekttabelle (Oracle)/Typisierte Tabelle (SQL)) erfolgen,  d.h. eine relationale Tabelle kann eine Spalte aufweisen, deren Datentyp REF ist und auf eine  Objekttabelle (Oracle)/Typisierte Tabelle (SQL) verweist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "relationale Tabellen (Tupeltabellen)",
        "solution": "false"
      },
      {
        "text": "Objekttabellen (Oracle) / Typisierte Tabellen (SQL)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2708,
    "category": 12,
    "difficulty": 2,
    "text": "Folgende Prozedur sei gegeben:\n\n    CREATE OR REPLACE PROCEDURE test_proc (p1 IN NUMBER, p2 INOUT NUMBER) ... ;\n\n    Wie kann diese Prozedur innerhalb eines PL/SQL-Programms aufgerufen werden?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist.\n\n    \n\n    Beim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. Daher sind als Aufrufparameter Konstanten und Variablen zulässig.\n\n    Beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten.\n\n    Beim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann. Daher sind als Aufrufparameter keine Konstanten sondern nur Variablen zulässig.\n\n    Der Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann. Daher sind als Aufrufparameter keine Konstanten sondern nur Variablen zulässig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "test_proc (4711, 4122);",
        "solution": "false"
      },
      {
        "text": "test_proc (4711, var2);",
        "solution": "true"
      },
      {
        "text": "test_proc (var1, 4122);",
        "solution": "false"
      },
      {
        "text": "test_proc (var1, var2);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2709,
    "category": 12,
    "difficulty": 3,
    "text": "Es sei eine Funktion test_check(sp1 IN NUMBER) RETURN BOOLEAN ; gegeben. Welche Aufrufe sind richtig?",
    "explanation": "Da der Rückgabewert (RETURN-Wert) vom Typ BOOLEAN ist, ist eine Verwendung innerhalb von Bedingungen z.B. von WHILE-Schleifen oder IF-Anweisungen sehr komfortabel möglich. Mit EXECUTE können Prozeduren ausgeführt werden und zwar  nicht innerhalb von PL/SQL-Programmen (dort nur durch Verwendung des Prozedurnamens) sondern in Tools wie  SQL-Developer. Bei Funktionen muss zusätzlich der Return-Wert verarbeitet werden.  Die Anweisung \"SELECT funktionsname FROM DUAL;\" eignet sich hervorragend für den Aufruf von Funktionen mit nur IN-Parametern, solange für sie nicht BOOLEAN als RETURN-Wert definiert ist. Der Grund ist, im SQL-Kontext kennt Oracle leider immer noch nicht den Datentyp BOOLEAN sondern nur in PL/SQL-Programmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "EXECUTE test_check(123);",
        "solution": "false"
      },
      {
        "text": "IF test_check(var_x) THEN  END IF;",
        "solution": "true"
      },
      {
        "text": "SELECT test_check(sp1) FROM DUAL;",
        "solution": "false"
      },
      {
        "text": "WHILE test_check(var_y) LOOP  ;",
        "solution": "true"
      },
      {
        "text": "v_rueck := test_check(123);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2705,
    "category": 13,
    "difficulty": 3,
    "text": "Welches Konzept bei den DML-Triggern ermöglicht die Prüfung transitionaler Integritätsbedingungen?",
    "explanation": "Mittels der in den ROW-Triggern verfügbaren Transitionsvariablen :OLD.Spaltenname / :NEW.Spaltenname ist es möglich, den alten und den neuen Zustand von Spalten zu vergleichen. Dies stellt einen Zustandsübergangsvergleich dar, wie er in transitionalen Bedingungen formuliert wird.",
    "type": "text",
    "answers": [
      {
        "text": "Es sind die ...",
        "solution": "Transitionsvariablen"
      }
    ]
  },
  {
    "id": 2707,
    "category": 12,
    "difficulty": 2,
    "text": "Folgende Prozedur sei gegeben: \n\n  CREATE OR REPLACE PROCEDURE \n         test_proc (p1 IN NUMBER, p2 OUT NUMBER) ... ;\n\nWie kann diese Prozedur innerhalb eines PL/SQL-Programms aufgerufen werden?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. Daher sind als Aufrufparameter Konstanten und Variablen zulässig. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann. Daher sind als Aufrufparameter keine Konstanten sondern nur Variablen zulässig.  \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann. Daher sind als Aufrufparameter keine Konstanten sondern nur Variablen zulässig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "test_proc (4711, 4122);",
        "solution": "false"
      },
      {
        "text": "test_proc (4711, var2);",
        "solution": "true"
      },
      {
        "text": "test_proc (var1, 4122);",
        "solution": "false"
      },
      {
        "text": "test_proc (var1, var2);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2726,
    "category": 9,
    "difficulty": 3,
    "text": "Die beiden weitgehend unverändert dem objektrelationalen Modell zugrunde liegenden Modelle des SQL-92-Standards sowie des Basisobjektmodells werden beim SQL-2003-Standard um drei Typkonstruktoren erweitert. Nennen Sie die Namen ohne Sonderzeichen und in alphabetischer Reihenfolge.",
    "explanation": "Die beiden grundlegenden Konzepte, die im objektrelationalen SQL2003 zusammengeführt wurden sind: SQL-92 und das Basisobjektmodell. (vgl. auch Türker/Saake in \"Objektrelationale Datenbanken\", dpunkt-Verlag, 2006, Kap.3, insbesondere S.95) Diese beiden Modelle werden zudem um drei Typkonstruktoren erweitert:\n\nin SQL: ARRAY, MULTISET, REF\nbei Oracle REF, (NESTED) TABLE, VARRAY \n\nZu beachten ist insbesondere, dass sowohl bei Oracle wie auch beim SQL2003-Standard nicht das relationale Modell mit seiner Mengensemantik sondern das SQL-92-Modell mit seinem Verständnis einer Tabelle als Multimenge zugrunde liegt.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist zum einen das ...",
        "solution": "ARRAY"
      },
      {
        "text": "Das ist zum anderen das ...",
        "solution": "MULTISET"
      },
      {
        "text": "",
        "solution": "REF"
      }
    ]
  },
  {
    "id": 2727,
    "category": 10,
    "difficulty": 3,
    "text": "Was muss in einem JDBC-Programm beim Aufruf von gespeicherten Prozeduren und Funktionen mittels CallableStatement-Objekten mit OUT- und INOUT-Parametern zusätzlich gemacht werden, was für IN-Parameter nicht durchgeführt werden muss?",
    "explanation": "Anders als bei IN-Parametern, müssen OUT- und INOUT-Parameter explizit registriert werden, damit der Datentyp des Parameters im Programm bekannt ist. Bei IN-Parametern ist der Datentyp über den Übergabewert beim Aurfuf bekannt und wird nur für den Aufruf benötigt. Für die Rückgabe von Werten nach der Prozedur-/Funktionsausführung müssen jedoch die Datentypen der OUT- und INOUT-Parameter explizit bekannt gemacht werden. \n\n\nHier ein Beispiel:\n\nCREATE OR REPLACE PROCEDURE gibAnzahlEintraege(anzahl OUT INTEGER) \nBEGIN\n   SELECT COUNT( * )INTO anzahl FROM person;\nEND;\n\n\nCallableStatement cstmt = \n     con.prepareCall(\"{call gibAnzahlEintraege(?)}\"); \n//OUT- (und INOUT-) Parameter: Festlegung des Datentyps\ncstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n//Abfrage ausführen\ncstmt.executeQuery();\n//Wert auslesen\nSystem.out.println(\"Anzahl der Einträge: \"+ cstmt.getInt(1));",
    "type": "text",
    "answers": [
      {
        "text": "OUT- und INOUT-Parameter müssen ______ werden.",
        "solution": "\r\n    registriert\r"
      }
    ]
  },
  {
    "id": 2732,
    "category": 10,
    "difficulty": 1,
    "text": "Welcher Status ist die Defaulteinstellung für den Auto-Commit-Modus bei Transaktionen für Datenbankverbindungen, die unter JDBC aufgebaut werden?",
    "explanation": "Nach Verbindungsaufbau ist der Modus defaultmäßig auf \n       Auto-Commit-Modus = true  \ngesetzt. D.h. jede einzelne SQL-Anweisung wird als Transaktion \u000b      behandelt, und nach dem Ausführen automatisch festgeschrieben.\n\nUm mehr als eine SQL-Anweisung als Transaktion zu erlauben, muss der Auto-Commit-Modus ausgeschaltet werden:\n\n    verbindung.setAutoCommit(false);\nIn diesem Modus muss die Java-Anwendung selbst die Transaktionen mit COMMIT oder ROLLBACK abschließen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "TRUE",
        "solution": "true"
      },
      {
        "text": "FALSE",
        "solution": "false"
      },
      {
        "text": "UNKNOWN",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2736,
    "category": 9,
    "difficulty": 2,
    "text": "Das relationale Modell kann wie folgt definiert werden:   \nMULTISET ( ROW ( Basisdatentyp ) )",
    "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt  nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2740,
    "category": 9,
    "difficulty": 1,
    "text": "Ausgehend von der Klassifikation von Stonebraker und Morre sind objektrelationale DBS für welche Art von Anwendungen gut geeignet?\n\nQuelle: \nStonebraker, M., Morre, D.: \"Objektrelationale Datenbanken  Die nächste große Welle\", Hanser, München, 1999",
    "explanation": "Stonebraker und Morre haben in ihrem Buch \"Objektrelationale Datenbanken  Die nächste große Welle\" 1999 folgende Klassifikation postuliert, die sich gut bewährt hat. Interessant wird es, wenn es um Anwendungen geht, die mehrere dieser Eigenschaften abdecken. \n\n* Einfache Daten und wenig Anfragen erfordern Dateisysteme\n* Einfache Daten und viele Anfragen erfordern relationale DBMS\n* Komplexe Daten und viele Anfragen erfordern objektrelationale DBMS\n* Komplexe Daten und wenig Anfragen erfordern objektorientierte DBMS\n\nBei objektorientierten Datenbanksystemen bestehen \"Anfragen\" in der Regel aus Spezialoperationen, die mittels Methoden implementiert sind z.B. bei Geo-Informationssystemen: schneiden sich zwei Straßen, haben zwei Orte die gleichen Höhenmeter, überlagern sich zwei Gesteinsformationen etc. ... \nund kaum aus Mengenanfragen, wie man es aus der relationalen Welt gewohnt ist.\nBei objektrelationalen Datenbanksystemen möchte man komplexere Objektstrukturen analog zur Realität abbilden können und nicht wie im relationalen Modell Objekte ggf. über mehrere Relationen verteilen. Es stehen weiterhin die Mengenanfragen zur Verfügung aber auch über die Methoden die Programmierung beliebige Spezialoperationen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "einfache Daten und wenige Anfragen",
        "solution": "false"
      },
      {
        "text": "einfache Daten und viele Anfragen",
        "solution": "false"
      },
      {
        "text": "komplexe Daten und viele Anfragen",
        "solution": "true"
      },
      {
        "text": "komplexe Daten und wenig Anfragen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2741,
    "category": 9,
    "difficulty": 2,
    "text": "Ausgehend von der Klassifikation von Stonebraker und Morre sind relationale DBS für welche Art von Anwendungen gut geeignet?\n\nQuelle: \nStonebraker, M., Morre, D.: \"Objektrelationale Datenbanken  Die nächste große Welle\", Hanser, München, 1999",
    "explanation": "Stonebraker und Morre haben in ihrem Buch \"Objektrelationale Datenbanken  Die nächste große Welle\" 1999 folgende Klassifikation postuliert, die sich gut bewährt hat. Interessant wird es, wenn es um Anwendungen geht, die mehrere dieser Eigenschaften abdecken. \n\n* Einfache Daten und wenig Anfragen erfordern Dateisysteme\n* Einfache Daten und viele Anfragen erfordern relationale DBMS\n* Komplexe Daten und viele Anfragen erfordern objektrelationale DBMS\n* Komplexe Daten und wenig Anfragen erfordern objektorientierte DBMS\n\nBei objektorientierten Datenbanksystemen bestehen \"Anfragen\" in der Regel aus Spezialoperationen, die mittels Methoden implementiert sind z.B. bei Geo-Informationssystemen: schneiden sich zwei Straßen, haben zwei Orte die gleichen Höhenmeter, überlagern sich zwei Gesteinsformationen etc. ... \nund kaum aus Mengenanfragen, wie man es aus der relationalen Welt gewohnt ist.\nBei objektrelationalen Datenbanksystemen möchte man komplexere Objektstrukturen analog zur Realität abbilden können und nicht wie im relationalen Modell Objekte ggf. über mehrere Relationen verteilen. Es stehen weiterhin die Mengenanfragen zur Verfügung aber auch über die Methoden die Programmierung beliebige Spezialoperationen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "einfache Daten und wenige Anfragen",
        "solution": "false"
      },
      {
        "text": "einfache Daten und viele Anfragen",
        "solution": "true"
      },
      {
        "text": "komplexe Daten und viele Anfragen",
        "solution": "false"
      },
      {
        "text": "komplexe Daten und wenig Anfragen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3117,
    "category": 13,
    "difficulty": 3,
    "text": "Sie möchten einen Trigger schreiben, der angestoßen wird, nachdem Zeilen aus einer Tabelle gelöscht werden und es sollen dabei die Anzahl der verbliebenen Zeilen der Tabelle angezeigt werden. Welchen Triggertyp benötigen Sie?",
    "explanation": "Der Ausführungszeitpunkt AFTER ist wichtig, da ein BEFORE-Trigger bei DELETE keinen Sinn macht. Ein zeilenorientierter Trigger würde das Mutating-Table-Problem auslösen.\n\n    Nach dem Ausführungsmodell von zeilenorientierten Triggern werden diese nur angestoßen, wenn sich tatsächlich Daten in der Datenbank verändert haben. (siehe < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\"target = \"_blank\"> zeilenorientierten Trigger.. Die verbliebenen Datensätze werden nur beim Ausführungszeitpunkt AFTER angezeigt (siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\" target=\"_blank\"> CREATE-TRIGGER )",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Einen zeilenorientierten Trigger",
        "solution": "false"
      },
      {
        "text": "Einen befehlsorientierten Trigger",
        "solution": "true"
      },
      {
        "text": "Einen AFTER-Trigger",
        "solution": "true"
      },
      {
        "text": "Einen BEFORE-Trigger",
        "solution": "false"
      },
      {
        "text": "Das kann ein Trigger zum Ausführungszeitpunkt  \"AFTER\" oder \"BEFORE\" sein.",
        "solution": "false"
      },
      {
        "text": "Das kann ein zeilenorientierter oder ein befehlsorientierter  Trigger  sein.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3137,
    "category": 12,
    "difficulty": 2,
    "text": "Betrachten Sie den folgenden PL/SQL-Block:\n\n    SET SERVEROUTPUT ON\n\n    DECLARE\n\n    ang_rec angestellte%ROWTYPE\n\n    BEGIN\n\n    SELECT * into ang_rec from angestellte where ang_nr = 12:\n\n    IF SQL%NOTFOUND\n\n    THEN DBMS_OUTPUT:PUT_LINE (\"Keine Daten gefunden!\");\n\n    ELSE DBMS_OUTPUT:PUT_LINE (ang_rec.nachname);\n\n    \n\n    END IF ;\n\n    END;\n\n    \n\n    Welche Antwort(en) ist korrekt?",
    "explanation": "PL/SQL-Blöcke werfen einen Fehler, wenn eine SELECT-Anweisung keine Datensätze liefert. Dieser Fehler muss mit NO_ROWS_FOUND abgefangen werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der Block wirft einen Fehler, wenn der Angestellte mit der ang_nr 12 nicht existiert.",
        "solution": "true"
      },
      {
        "text": "Der Block wird ausgeführt und gibt NULL aus, wenn der Angestellte mit der ang_nr 12 nicht existiert.",
        "solution": "false"
      },
      {
        "text": "Es wird ein Fehler geworfen, weil SELECT INTO keinen Record füllen kann",
        "solution": "false"
      },
      {
        "text": "Der Block wird ausgeführt und gibt NO DATA FOUND aus.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3138,
    "category": 12,
    "difficulty": 1,
    "text": "Welche Aussage ist wahr über Transaktionen in PL/SQL-Blöcken?",
    "explanation": "PL/SQL-Blocke können als Bestandteil einer Transaktion geschrieben werden. Daher kann eine Transaktion auch mehrere Blöcke umfassen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Transaktion kann mehrere Blocke umfassen..",
        "solution": "true"
      },
      {
        "text": "Ein Block kann immer nur eine einzelne Transaktion enthalten",
        "solution": "false"
      },
      {
        "text": "Mit dem Schlüsselwort END wird ein PL/SQL-Block nicht nur beendet, sondern auch automatisch die zugehörige Transaktion mit einem COMMIT abgeschlossen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3151,
    "category": 8,
    "difficulty": 3,
    "text": "Welche Tipps sollte man beim SQL-Tuning unter ORACLE verwenden, um die Performance zu steigern?",
    "explanation": "siehe ORACLE-<a target=\"_blank\" title=\"ORACLE-SQL-Tuning-Guide\" href=\"http://www.orafaq.com/tuningguide/\">SQL-Tuning-Guide",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * vermeiden",
        "solution": "true"
      },
      {
        "text": "Indizes verwenden, falls möglich",
        "solution": "true"
      },
      {
        "text": "Unterabfragen  verwenden statt Joins",
        "solution": "false"
      },
      {
        "text": "vollständig qualifizierte Spaltennamen",
        "solution": "true"
      },
      {
        "text": "Die Reihenfolge der Tabellen in der FROM-Klausel ist irrelevant",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3116,
    "category": 13,
    "difficulty": 2,
    "text": "Welche Aussagen über zeilenorientierter Trigger und befehlsorientierte Trigger sind richtig?",
    "explanation": "Nach dem Ausführungsmodell von zeilenorientierten Triggern werden diese \nnur angestoßen, wenn sich tatsächlich Daten in der Datenbank verändert \nhaben. (siehe <a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\"target = \"_blank\"> zeilenorientierten Triggern  , bei befehlsorientierten Triggern ist das anders.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein zeilenorientierter Trigger feuert immer mindestens einmal, sogar \nwenn keine Zeilen im feuernden DML-Ereignis (INSERT, UPDATE oder DELETE)\n verändert werden.",
        "solution": "false"
      },
      {
        "text": "Ein befehlsorientierter Triggern feuert immer mindestens einmal, sogar \nwenn keine Zeilen im feuernden DML-Ereignis (INSERT, UPDATE oder DELETE)\n verändert werden.",
        "solution": "true"
      },
      {
        "text": "Zeilenorientierter Trigger sind sinnvoll, wenn man auf Änderungen in einzelnen Datensätzen reagieren möchte.",
        "solution": "true"
      },
      {
        "text": "Befehlsorientierte Triggern sind sinnvoll, wenn man auf Änderungen in einzelnen Datensätzen reagieren möchte.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3118,
    "category": 12,
    "difficulty": 1,
    "text": "Betrachten Sie den folgenden anonymen PL-SQL-Block: <font face=\"courier new\">SET SERVEROUTPUT ON;\n\n    DECLARE\n\n    v_alter NUMBER;\n\n    BEGIN\n\n    IF v_alter < 14 THEN\n\n    DBMS_OUTPUT.PUT_LINE(\"Ich bin ein Kind!\");\n\n    ELSE\n\n    DBMS_OUTPUT.PUT_LINE(\"Ich bin kein Kind mehr!\");\n\n    END;\n\n    Welche Aussagen sind wahr?",
    "explanation": "In der dreiwertigen Logik ergibt der Vergleich von einem Null Wert mit einem numerischen Wert UNKNOWN und die Ausgabe springt in der IF-Anweisung  in den ELSE-Ast (siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/IF\" target=\"_blank\">IF ).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der anonyme Block wird ausgeführt und gibt nichts aus.",
        "solution": "false"
      },
      {
        "text": "Der anonyme Block wirft einen Fehler, weil v_alter kein Wert zugewiesen wird.",
        "solution": "false"
      },
      {
        "text": "Der anonyme Block wird ausgeführt und springt in den ELSE-Ast.",
        "solution": "true"
      },
      {
        "text": "Der anonyme Block wird ausgeführt und führt den THEN-Ast aus.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3100,
    "category": 8,
    "difficulty": 2,
    "text": "Welche Join-Operator ist für größere Datenmengen geignet, wenn kein Equi-Join vorliegt?",
    "explanation": "Das ist der Sort Merge Join, \nsiehe <a ==\"\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#MERGE_JOIN\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#MERGE_JOIN  .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Cartesian Join",
        "solution": "false"
      },
      {
        "text": "Nested Loop Join",
        "solution": "false"
      },
      {
        "text": "Hash Join",
        "solution": "false"
      },
      {
        "text": "Sort Merge Join",
        "solution": "true"
      },
      {
        "text": "Outer Join",
        "solution": "false"
      },
      {
        "text": "Index Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3087,
    "category": 8,
    "difficulty": 1,
    "text": "In welcher Reihenfolge arbeitet der Cost-Based-Optimizer (CBO) von Oracle verschiedene Tabellen in der FROM-Klausel ab?",
    "explanation": "Während der RBO (Ruled Based Optimizer) noch selbständig die richtige Reihenfolge bestimmt, ist das beim CBO nicht mehr der Fall, \nsiehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\" target = \"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer . Die Abarbeitungsreihenfolge ist beim CBO von rechts nach links",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Abarbeitungsreihenfolge von rechts nach links",
        "solution": "true"
      },
      {
        "text": "Abarbeitungsreihenfolge von links nach rechts",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3096,
    "category": 8,
    "difficulty": 2,
    "text": "Welche Tabellenzugriffsmethode liest bei Oracle alle Datensätze einer Tabelle sortiert ein?",
    "explanation": "Der Full Table Scan liest alle Zeilen einer Tabelle sortiert ein, siehe \n<a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen , beim Index Full Scan werden die Daten zusätzlich sortiert über den Index",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "RowidScan",
        "solution": "false"
      },
      {
        "text": "Full Table Scan",
        "solution": "false"
      },
      {
        "text": "Index Full Scan",
        "solution": "true"
      },
      {
        "text": "Hash Scan",
        "solution": "false"
      },
      {
        "text": "Cluster Scan",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3103,
    "category": 8,
    "difficulty": 1,
    "text": "Wie kann man einen Ausführungsplan unter Oracle beeinflussen?",
    "explanation": "Hints sind Hinweise für den Oracle-<a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\">Optimizer, wie er den <a class=\"wikilink\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Ausfuehrungsplan-einer-SQL-Abfrage\">Ausführungsplan erstellen und die SQL-Abfrage ausführen soll. Ein Hint kann bestimmen, welche <a class=\"wikilink\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Ausfuehrungsplanoperationen\">Operation der <a class=\"wikilink\" href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\">Optimizer auswählen und verwenden soll. ",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Durch das Setzen von Hints",
        "solution": "true"
      },
      {
        "text": "Durch das Löschen von Statistiken",
        "solution": "false"
      },
      {
        "text": "Durch den Umstieg auf den RBO (Rule Based Optimizer)",
        "solution": "false"
      },
      {
        "text": "Durch Erhöhung der Systemprivilegien",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3127,
    "category": 13,
    "difficulty": 2,
    "text": "Welche Aussage über PL/SQL-Variable ist wahr?",
    "explanation": "Einfach Ausprobieren, ist allerdings auch logisch. Eine Variable mit dem NOT NULL CONSTRAINT muss einen Wert haben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mit NOT NULL deklarierte Variablen müssen initialisiert werden.",
        "solution": "true"
      },
      {
        "text": "Mit NOT NULL deklarierte Variablen müssen nicht initialisiert werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2634,
    "category": 6,
    "difficulty": 2,
    "text": "Wie heißt der CONSTRAINT, dessen Semantik durch den Programmierer festgelegt wird?",
    "explanation": "Das Zweitschlüssel-Constraint heißt UNIQUE.\n\n    \n\n    Die übrigen vier Constraints sind: FOREIGN KEY, CHECK, PRIMARY KEY und NOT NULL.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "CHECK"
      }
    ]
  },
  {
    "id": 3077,
    "category": 8,
    "difficulty": 1,
    "text": "Was versteht man unter Selektivität?",
    "explanation": "Unter der Selektivität versteht man das Verhältnis der zu findendenden Datensätze gegenüber ihrer Gesamtzahl. Eine hohe Selektivität bedeutet also viele unterschiedliche Werte in einer Spalte.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Verhältnis zu findender Datensätze gegenüber ihrer Gesamtzahl.",
        "solution": "true"
      },
      {
        "text": "Differenz aus der Anzahl der Datensätze in einer Spalte minus der Gesamtzahl von Spalten in einer Tabelle",
        "solution": "false"
      },
      {
        "text": "Produkt aus der Gesamtzahl der gefundenen Datensätze dividiert durch die Gesamtzahl der Datensätze in einer Spalte",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2889,
    "category": 5,
    "difficulty": 2,
    "text": "Das Versicherungsbüro Schutzengel hat die Daten über Versicherungspolicen in einer Relation \nVertraege(Vertrags_Nr, Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision) \ngespeichert, wobei die Vertrags_Nr der Primärschlüssel dieser Relation ist.\n\nBei der Überführung in eine Normalform entstehen die Relationen Kunden, Vertraege und Vertragsarten.",
    "explanation": "Aus der Relation lassen Vertraege(Vertrags_Nr, Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision) lassen sich folgende funktioanle Abhängigkeiten ableiten: \nVertrags_Nr -> Vertragsart, Betrag, Kunden_NR, Kundenname, Kundenadresse, Abschlussprovision \nweil Vertrags_Nr einziges Primärschküsselattribut ist \nKunden_NR -> Kundenname, Kundenadresse  \nVertragsart -> Abschlussprovision \nBei den beiden Abhängigkeiten von Kunden_NR und Vertragsart handelt es sich um transitive Abhängigkeiten, da diese wiederum von Kunden_NR abhängig sind. \nUnd daraus ergeben sich dann folgende drei Relationen: \nKunden (Kunden_NR (PK), Kundenname, Kundenadresse)  \nVertragsarten (Vertragsart (PK), Abschlussprovision) \nVertraege (Vertrags_Nr (PK), Vertragsart, Betrag, Kunden_NR)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es handelt sich um eine Überführung in die 1NF.",
        "solution": "false"
      },
      {
        "text": "Es handelt sich um eine Überführung in die 3NF.",
        "solution": "true"
      },
      {
        "text": "Es handelt sich um eine Überführung in die 2NF.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2604,
    "category": 6,
    "difficulty": 2,
    "text": "Was muss man tun, damit eine mit einer DROP-Anweisung gelöschtes Datenbankobjekt (z.B. TABLE, SEQUENCE, INDEX, ...) auch wirklich dauerhaft (persistent) aus der Datenbank entfernt ist?",
    "explanation": "RICHTIG ist: \nEs muss gar nichts weiter gemacht werden, alle SQL-DDL-Befehle (CREATE, ALTER, DROP) beinhalten die automatische Ausführung eines COMMITs, damit die neuen DB-Objekte persistent gespeichert sind.   \nDen Befehl \"ALTER TABLE tabellenname DROP persistent\" gibt es nicht und ebenso wenig die DROP-Option PERSISTENT.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nach der DROP-Anweisung ein COMMIT absetzen.",
        "solution": "false"
      },
      {
        "text": "Gar nichts, weil bei der Ausführung einer SQL-DDL-Anweisung immer implizit ein COMMIT ausgeführt wird.",
        "solution": "true"
      },
      {
        "text": "Die Option PERSISTENT beim DROP-Befehl verwenden.",
        "solution": "false"
      },
      {
        "text": "Für jedes DB-Objekt gibt es einen ALTER-Befehl, der für die dauerhafte Löschung sorgt. Hier z.B. für eine Tabelle:\nALTER TABLE tabellenname DROP persistent;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3172,
    "category": 13,
    "difficulty": 2,
    "text": "Bei welchen Oracle-Triggern können die Transitionsvariablen :NEW.spaltenname beschrieben werden?",
    "explanation": "Die NEW-Transitionsvariablen könenn nur bei Zeilentriggern und zwar beim Ereignis \"INSERT\" und  UPDATE,  beschrieben werden. Beim Ereignis \"DELETE\"\" existiert keine NEW-Transitionsvariable. Statement-Trigger (Befehlstrigger) haben generell  keinen Zugriff auf  Transitionsvariable. INSTEAD-OF-Trigger können zwar Transitionvariable lesen, aber nicht ändern.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BEFORE INSERT FOR EACH ROW...",
        "solution": "true"
      },
      {
        "text": "BEFORE UPDATE FOR EACH ROW...",
        "solution": "true"
      },
      {
        "text": "BEFORE DELETE FOR EACH ROW...",
        "solution": "false"
      },
      {
        "text": "STATEMENT-TRIGGER",
        "solution": "false"
      },
      {
        "text": "INSTEAD-OF-Trigger",
        "solution": "false"
      },
      {
        "text": "keiner von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2620,
    "category": 6,
    "difficulty": 1,
    "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    Es wird versucht, folgenden Datensatz einzufügen in die leere Tabelle einzufügen:\n\n    INSERT INTO hierarchie VALUES (\"Hugo\",NULL);\n\n    Geben Sie den Inhalt der Tabelle nach dem Einfügen des Datensatzes an!",
    "explanation": "Der Datensatz kann nicht eingefügt werden, weil das Pflichteingabe-Constraint (NOT NULL) der Spalte Vorgesetzter fehl schlägt.",
    "type": "text",
    "answers": [
      {
        "text": "Der Inhalt ist folgender: \n(für einen oder mehrere eingefügte Datensätze nur die beiden Namen mit Leerzeichen getrennt; für eine leere Tabelle das Wort: leer)",
        "solution": "leer"
      }
    ]
  },
  {
    "id": 2624,
    "category": 6,
    "difficulty": 3,
    "text": "Welche SQL-Befehle lösen eine IMMEDIATE-Integritätsprüfung aus?",
    "explanation": "Ziel der Integritätsprüfung sind ja semantisch korrekte Daten, d.h. Daten, die allen definierten Constraints genügen. Sind Constraints definiert und aktiviert, dann sind in der Datenbasis nur solche Daten persistent gespeichert, die die Constraints erfüllen, so dass man mit 100%-iger Sicherheit sagen kann, alle Daten sind korrekt. Problematische Aktionen in diesem Zusammenhang sind dann alle Datenmanipulationen, also INSERT, UPDATE, DELETE. Anfragen (SELECTs) sind in diesem Zusammenhang unkritische Aktionen, die keine Prüfung erfordern - es soll ja nichts gespeichert werden, nur angezeigt. \n\nDie drei DML-Befehle INSERT, UPDATE, DELETE lösen also IMMEDIATE-Integritätsprüfung aus. \nCOMMIT beendet eine Transaktion und löst damit eine DEFERRED-Integritätsprüfung aus. \nROLLBACK beendet zwar auch eine Transaktion, jedoch indem sie rückgängig gemacht wird. Eine Integritätsprüfung ist daher unnötig und wird nicht ausgeführt. \nDDL-Anweisungen (CREATE, ALTER, DROP) beinhalten ein implizites COMMIT, was dafür sorgt, dass jede DDL-Anweisung unmittelbar in die DICTIONARY-Tabellen eingetragen wird. Dieses implizite COMMIT hat zur Folge, dass DDL-Anweisungen immer auch eine Transaktion beenden und eine DEFERRED-Integritätsprüfung auslösen.  \nSAVE, CHECK sind keine SQL-Befehle. Es gibt wohl das CHECK-Constraint, aber eine Prüfung wird damit nicht ausgelöst.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ROLLBACK",
        "solution": "false"
      },
      {
        "text": "DELETE",
        "solution": "true"
      },
      {
        "text": "SELECT",
        "solution": "false"
      },
      {
        "text": "INSERT",
        "solution": "true"
      },
      {
        "text": "CHECK",
        "solution": "false"
      },
      {
        "text": "UPDATE",
        "solution": "true"
      },
      {
        "text": "COMMIT",
        "solution": "false"
      },
      {
        "text": "SAVE",
        "solution": "false"
      },
      {
        "text": "DROP",
        "solution": "false"
      },
      {
        "text": "CREATE",
        "solution": "false"
      },
      {
        "text": "ALTER",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2630,
    "category": 7,
    "difficulty": 1,
    "text": "Wann wird eine UPDATE-Anweisung mit WHERE-Bedingung ausgeführt?",
    "explanation": "Achtung: SQL basiert auf einer dreiwertigen Logik!\n\nD.h. es gibt die drei Wahrheitswerte: TRUE, FALSE, UNKNOWN.\n\nBei SELECT-Anfragen bzw. UPDATE/DELETE mit WHERE-Klausel wird UNKNOWN wie FALSE behandelt und ein Datensatz kommt nur in die Ergebnismenge, wenn die WHERE-Bedingung zu TRUE ausgewertet wird. Wird die WHERE-Bedingung zu UNKNOWN oder FALSE ausgewertet, dann wird der Datensatz \"fallen gelassen\".\n\n\nAchtung: Bei der Integritätsprüfung ist das etwas anders: \nEin Constraint in SQL ist erfüllt, wenn es zu TRUE oder zu UNKNOWN ausgewertet wird.\nGrund ist: Die Constraints werden bereits beim CREATE TABLE das erste Mal geprüft und damit über der leeren Tabelle. Wenn jetzt UNKNOWN wie FALSE behandelt würde, könnte der CREATE TABLE gar nicht ausgeführt werden. Der andere Punkt sind die (potentiell) leeren Spalten für die die Constraints trotzdem erfüllt sein sollen. Z.B. kann bei einem Detail-Datensatz eine Fremdschlüsselspalte leer sein oder UNIQUE-Spalten dürfen leer sein, ohne dass das Constraint gleich verletzt ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die, für die die WHERE-Bedingung zu FALSE ausgewertet wird.",
        "solution": "false"
      },
      {
        "text": "Die, für die die WHERE-Bedingung zu UNKNOWN ausgewertet wird.",
        "solution": "false"
      },
      {
        "text": "Wenn die WHERE-Bedingung zu TRUE ausgewertet wird.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2633,
    "category": 6,
    "difficulty": 2,
    "text": "Wie heißt der CONSTRAINT, wenn eine Spalte Zweitschlüssel ist?",
    "explanation": "Das Zweitschlüssel-Constraint heißt UNIQUE.\n\n    \n\n    Die übrigen vier Constraints sind: FOREIGN KEY, CHECK, PRIMARY KEY und NOT NULL.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "UNIQUE"
      }
    ]
  },
  {
    "id": 3739,
    "category": 6,
    "difficulty": 1,
    "text": "Welche(s) Datenbankobjekte(e) sind/ ist unabhängig von einer Tabelle?",
    "explanation": "Sequenzen  können auch in mehreren Tabellen verwendet werden, auch wenn das in der Regel wenig Sinn macht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SEQUENCE",
        "solution": "true"
      },
      {
        "text": "CONSTRAINT",
        "solution": "false"
      },
      {
        "text": "INDEX",
        "solution": "false"
      },
      {
        "text": "VIEW",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3740,
    "category": 6,
    "difficulty": 1,
    "text": "Für welche Datenbankobjekte gibt es einen CREATE-Befehl?",
    "explanation": "Constraints werden mit der Tabelle angelegt, alle anderen Objekte mittels CREATE ....",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SEQUENCE",
        "solution": "true"
      },
      {
        "text": "CONSTRAINT",
        "solution": "false"
      },
      {
        "text": "INDEX",
        "solution": "true"
      },
      {
        "text": "VIEW",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2618,
    "category": 6,
    "difficulty": 2,
    "text": "Betrachten Sie die folgende Definition einer Sequence:\nCREATE SEQUENCE Kun_seq\n        INCREMENT BY 2\n    START WITH 3\n    NOMAXVALUE\n    NOCYCLE\n    CACHE 10;",
    "explanation": "Die Sequenz startet mit 3, zählt immer 2 hoch, daher: 3 5 7 9 11 \nDie Caching-Option steuert das Zwischenspeichern von Sequenznummer, eine interne Optimierung und spielt bei der Nummernvergabe keine Rolle.",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie die ersten 5 Ziffern in Folge und nur mit Leerzeichen getrennt an, die diese Sequenz erzeugt.",
        "solution": "3 5 7 9 11"
      }
    ]
  },
  {
    "id": 2555,
    "category": 4,
    "difficulty": 1,
    "text": "Bei einer Projektion wird eine n-stellige Relation auf eine (n-m)-stellige Relation abgebildet, mit m>=0.",
    "explanation": "Die Projektion ist die Operation der RA, die die Ergebnismenge auf einzelne Attribute aus einer Relation beschränken kann.  \nListet man bei der Projektion alle Attributnamen der Relation auf, so wäre das der Fall, dass m=0 ist (eine recht überflüssige Operation, da die Eingangstupelmenge identisch ist mit der Ergebnismenge). Listet man hingegen nur einige Attributnamen auf, so ist m>0.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2566,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Anforderungen muss ein \"vereinigungskonformer\" SQL-Operator  erfüllen? (relevant für die Durchführung von Mengenoperationen)",
    "explanation": "Die Forderung in SQL \"<a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Vereinigungskonform\"> vereinigungskonform  zu sein, gilt für alle drei Mengenoperatoren (Vereinigung, Differenz, Durchschnitt). \nDie beteiligten Tabellen (Eingangsdatenmengen) müssen die gleichen Spaltendefinitionen aufweisen, d.h.:\n\nDie Anzahl der Spalten muss übereinstimmen.\nDie Datentypen der der Spalten müssen gleich sein. \nDie Reihenfolge der Spalten muss übereinstimmen.\n\nAchtung: In der RA mussten die Spalten auch noch gleich heißen, das ist hier in SQL nicht mehr notwendig. Es werden in SQL die Spaltennamen der links vom Operator stehenden Tabelle verwendet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Anzahl der Spalten muss übereinstimmen.",
        "solution": "true"
      },
      {
        "text": "Die Spalten müssen gleich heißen.",
        "solution": "false"
      },
      {
        "text": "Die Datentypen der der Spalten müssen gleich sein.",
        "solution": "true"
      },
      {
        "text": "Die Reihenfolge der Spalten muss übereinstimmen.",
        "solution": "true"
      },
      {
        "text": "Es gibt keine solche Anforderung in SQL.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2568,
    "category": 4,
    "difficulty": 3,
    "text": "Mit welchen Operatoren aus der relationalen Algebra lässt sich der Divisions-Operator simulieren?",
    "explanation": "Die Division lässt sich aus den relationalen Grundoperationen Selektion, Projektion, kartesisches Produkt und Differenz ableiten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Selektion",
        "solution": "true"
      },
      {
        "text": "Projektion",
        "solution": "true"
      },
      {
        "text": "Theta-Join",
        "solution": "false"
      },
      {
        "text": "Natural Join",
        "solution": "false"
      },
      {
        "text": "Kartesisches Produkt",
        "solution": "true"
      },
      {
        "text": "Outer Join (Left, Right, Full)",
        "solution": "false"
      },
      {
        "text": "Vereinigung",
        "solution": "false"
      },
      {
        "text": "Durchschnitt",
        "solution": "false"
      },
      {
        "text": "Differenz",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2569,
    "category": 7,
    "difficulty": 3,
    "text": "Eine Menge von Tabellen besitzt die Eigenschaft, dass jede Tabelle einen Primärschlüssel besitzt.",
    "explanation": "Eine Menge von Tabellen R1,...,Rk besitzt die Entity-Integrität, wenn jede Tabelle einen Primärschlüssel besitzt.",
    "type": "text",
    "answers": [
      {
        "text": "Diese Eigenschaft heißt",
        "solution": "Entity-Integrität"
      }
    ]
  },
  {
    "id": 2575,
    "category": 4,
    "difficulty": 2,
    "text": "Bestimmen Sie den Natural Join der folgenden beiden Relationen R1 und R2 mit den Attributen S1, S2, S4!\n\nR1: \nS1  S2       \nA    W\nC    Y \n\nR2: \nS1  S4 \nC    Y\nD    Z",
    "explanation": "Bei einem Natural Join werden automatisch alle Attribute der beiden Relationen, die gleich heißen, auf Gleichheit verglichen und im Ergebnis werden diese Attribute nur einmal aufgelistet. Heißen mehrere Attribute gleich, so werden die einzelnen Gleichheitsvergleiche mit AND verknüpft.",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie die Attributwerte in Großbuchstaben ohne Attributnamen und nur durch ein Leerzeichen getrennt an.",
        "solution": "C Y Y"
      }
    ]
  },
  {
    "id": 2639,
    "category": 7,
    "difficulty": 1,
    "text": "Der Ausdruck \"SELECT Vorname FROM KUNDEN ORDER BY Nachname ASC\"",
    "explanation": "Die Sortierung kann ausgeführt werden, weil die ORDER BY-Klausel als vorletzte Klausel ausgeführt wird, unmittelbar vor der letzten Klausel der SELECT-Klausel. Daher kann auch über Spalten sortiert werden, die anschließend mittels der SELECT-Klausel \"weg projiziert\" werden.\n\n    Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ist nicht ausführbar, da über eine Spalte \"Nachname\" sortiert wird, die gar nicht angezeigt wird.",
        "solution": "false"
      },
      {
        "text": "bewirkt eine absteigende Sortierung über den Nachnamen",
        "solution": "false"
      },
      {
        "text": "bewirkt eine aufsteigende Sortierung über den Nachnamen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2640,
    "category": 7,
    "difficulty": 1,
    "text": "Der Ausdruck \"SELECT Vorname FROM KUNDEN ORDER BY Nachname DESC\"",
    "explanation": "Die Sortierung kann ausgeführt werden, weil die ORDER BY-Klausel als vorletzte Klausel ausgeführt wird, unmittelbar vor der letzten Klausel der SELECT-Klausel. Daher kann auch über Spalten sortiert werden, die anschließend mittels der SELECT-Klausel \"weg projiziert\" werden.\n\n    Die ORDER BY-Klausel mit der Option ASC sortiert aufsteigend, mit DESC absteigend. ASC ist die Default-Option, so dass bei fehlender Option immer aufsteigend sortiert wird.\n\n    Wird gar keine ORDER BY-Klausel angegeben, so erfolgt auch keine Sortierung.\n\n    Eine Gruppierung erfolgt nur mit einer GROUP BY-Klausel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ist nicht ausführbar, da über eine Spalte \"Nachname\" sortiert wird, die gar nicht angezeigt wird.",
        "solution": "false"
      },
      {
        "text": "bewirkt eine absteigende Sortierung über den Nachnamen",
        "solution": "true"
      },
      {
        "text": "bewirkt eine aufsteigende Sortierung über den Nachnamen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2641,
    "category": 7,
    "difficulty": 1,
    "text": "Welche Semantik hat folgender SELECT-Ausdruck? \n\nSELECT  Nachname, Ort \nFROM    Kunden\nWHERE     Ort = 'Köln'\nOR    NOT (Ort = 'Gummersbach')",
    "explanation": "Der Begriff Semantik meint die Aufgabenstellung, die zu dieser SELECT-Anfrage gehört. \nDie Semantik obiger Anfrage ist: \"Zeigen Sie die Kunden, die nicht in Gummersbach wohnen oder in Köln leben?\"",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Welche Kunden wohnen weder in Gummersbach noch in Köln?",
        "solution": "false"
      },
      {
        "text": "Welche Kunden wohnen nicht in Gummersbach aber in Köln?",
        "solution": "false"
      },
      {
        "text": "Welche Kunden wohnen nicht in Gummersbach oder in Köln?",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2584,
    "category": 4,
    "difficulty": 2,
    "text": "Wie heißen Programmiersprachen, bei denen der Programmierer den Lösungsweg im Detail und Schritt für Schritt programmmieren muss?",
    "explanation": "Programmiersprachen der dritten Generation, wie JAVA, PASCAL, C, C++ oder FORTRAN sind prozedurale Sprachen, die dadurch gekennzeichnet sind, dass sehr genau beschrieben wird, wie ein bestimmtes Problem in der Sprache abgebildet wird. \nProgrammiersprachen der vierten Generation sind einfacher zu bedienen und der Programmierer kann sich mehr darauf konzentrieren, was das Programm leisten soll. Und SQL ist eine solche deklarative Sprache der 4. Generation.",
    "type": "text",
    "answers": [
      {
        "text": "Die Programmiersprachen heißen: (Kleinbuchstaben)",
        "solution": "prozedural"
      }
    ]
  },
  {
    "id": 3683,
    "category": 14,
    "difficulty": 1,
    "text": "Welche Arten von Sperren gibt es in SQL?",
    "explanation": "Lesesperren (read lock, shared lock oder SLOCK) auf Objekt und Schreibsperren (write lock, exclusive lock oder XLOCK)\n\n    gehören zum SQL-Standard.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Lesesperre",
        "solution": "true"
      },
      {
        "text": "Schreibsperre",
        "solution": "true"
      },
      {
        "text": "COMMIT-Sperre",
        "solution": "false"
      },
      {
        "text": "ROLLBACK-Sperre",
        "solution": "false"
      },
      {
        "text": "Transaktionssperre",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3684,
    "category": 14,
    "difficulty": 1,
    "text": "Welche Aussagen über Sperren in SQL sind wahr?",
    "explanation": "Lesesperren (read lock, shared lock oder SLOCK) auf Objekt und Schreibsperren (write lock, exclusive lock oder XLOCK)\n\n    gehören zum SQL-Standard. Lesesperren könen mehrfach auf eine Objekt ausgeführt werden, Schreibsperren nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mehrere Lesesperren auf dem gleichen Objekt x sind erlaubt.",
        "solution": "true"
      },
      {
        "text": "Mehrere Schreibsperren auf dem gleichen Objekt x  sind erlaubt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3686,
    "category": 14,
    "difficulty": 1,
    "text": "Aus welchen Phasen besteht das 2PL-Sperrprotokoll?",
    "explanation": "In der Wachstumspahse werden alle Sperren gesetzt, danach die Änderungn durchgeführt und in der Schrumpfungsphase werden alle Sperren aufgehoben.",
    "type": "text",
    "answers": [
      {
        "text": "Bitte in alpahabetischer Reihenfolge ohne Komma aufschreiben!",
        "solution": "\r\n    Schrumpfungsphase Wachstumsphase\r"
      }
    ]
  },
  {
    "id": 2612,
    "category": 6,
    "difficulty": 2,
    "text": "Um welchen Typ einer Integritätsbedingung handelt es sich hier?\n\nInnerhalb eines Jahres dürfen die Ausgaben der Abteilung nicht stärker steigen, als die vom Bundesministrium prognostizierte Preissteigerungsrate.",
    "explanation": "Die Integritätsbedingungen können statisch oder dynamisch sein, wobei der Begriff der dynamischen Bedingungen sich nochmals unterteilt in transitionale und temporale Bedingungen. \nStatische Integritätsbedingungen beschreiben einen Zustand, der von einer Datenbasis immer erfüllt sein muss, z.B. das ein Gehalt nicht eine bestimmte Grenze übersteigen darf. Dazu gehören die Entity-Integrität und die referentielle Integrität. Sie können mit den SQL-Konzepten Constraints und Trigger programmiert werden. \nTransitionale dynamische Integritätsbedingungen beschreiben, welche Bedingungen beim Übergang eines Zustands in einen anderen erfüllt sein müssen. Ein Beispiel wäre, dass das Gehalt eines Angestellten nur erhöht, aber nicht gesenkt werden kann. Solche Bedingungen lassen sich bislang nur über Datenbanktrigger realisieren. \nTemporale dynamische Integritätsbedingungen sind Anforderungen, die an eine Folge von Zustandsübergängen gestellt werden. Eine solche Bedingung könnte für die obige Relation sein, dass der Einkaufspreis innerhalb eines Jahres um nicht mehr als 10% insgesamt steigen darf. Solche Bedingungen werden derzeit nicht von den gängigen SQL-Konzepten unterstützt. Die Lösung dieses Problems müsste ein Programmierer mit Hilfe von Triggern, Tabellen u.v.m. angehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "statische Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "statische, transitionale Bedingung",
        "solution": "false"
      },
      {
        "text": "dynamische, temporale Bedingung",
        "solution": "true"
      },
      {
        "text": "statische, temporale Bedingung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2621,
    "category": 6,
    "difficulty": 3,
    "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Hierarchie\n\n    ( Angestellter VARCHAR2(20) NOT NULL,\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Angestellter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Hierarchie (Angestellter) ON DELETE CASCADE);\n\n    \n\n    Welche Aussagen sind wahr?",
    "explanation": "Das Problem hier ist: Die leere Tabelle Hierarchie kann gar nicht gefüllt werden mit Datensätzen.\n\n    \n\n    Fügt man erst (\"Emil\", \"Hugo\") ein, so schlägt dies fehl, weil die Fremdschlüsselbeziehung verletzt ist. Es gibt keinen Master-Datensatz mit Hugo als Angestellten z.B.: (\"Hugo\", ...).\n\n    \n\n    Fügt man erst (\"Hugo\", NULL) ein, so schlägt dies fehl, weil die NOT NULL-Bedingung für die Vorgesetzten-Spalte verletzt ist.\n\n    \n\n    Da beide Constraints als IMMEDIATE definiert sind (Default, wenn eine Angabe des Prüfungszeitpunkts fehlt) macht es keinen Unterschied, ob man beide Einfügungen in einer Transaktion ablaufen lässt.\n\n    \n\n    Wenn man beide Constraints als DEFERRED definiert hätte, dann wäre es jedoch unerheblich, ob erst der eine oder erst der andere Satz eingefügt würde, dann würden also beide Einfügereihenfolgen funktionieren. Es würde ja erst zum COMMIT-Zeitpunkt geprüft, ob der Endzustand ok ist und keine Zwischenzustände.\n\n    \n\n    Der Datensatz kann nicht eingefügt werden, weil das Pflichteingabe-Constraint (NOT NULL) der Spalte Vorgesetzter fehl schlägt. Der Datensatz kann nicht eingefügt werden, weil die Fremdschlüsselbeziehung mit dem Wert \"Emil\" fehlschlägt. Es gibt ja noch keinen anderen Datensatz in der Tabelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der Datensatz ('Emil', 'Hugo') kann in die leere Tabelle eingefügt werden. ",
        "solution": "false"
      },
      {
        "text": "Der Datensatz ('Hugo', NULL) kann in die leere Tabelle eingefügt werden. \nNULL bezeichnet die leere Spalte.",
        "solution": "false"
      },
      {
        "text": "Innerhalb einer Transaktion können die beiden Datensätze ('Hugo', NULL) ('Emil', 'Hugo') in dieser Reihenfolge in die leere Tabelle eingefügt werden. ",
        "solution": "false"
      },
      {
        "text": "Innerhalb einer Transaktion können die beiden Datensätze ('Emil', 'Hugo') ('Hugo', NULL) in dieser Reihenfolge in die leere Tabelle eingefügt werden. ",
        "solution": "false"
      },
      {
        "text": "Es kann gar kein Datensatz in die leere Tabelle eingefügt werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2622,
    "category": 6,
    "difficulty": 3,
    "text": "Betrachten Sie folgenden CREATE TABLE-Befehl:\n\n    CREATE TABLE Vorgesetzte\n\n    ( Mitarbeiter VARCHAR2(20),\n\n    Vorgesetzter VARCHAR2(20) NOT NULL,\n\n    PRIMARY KEY (Mitarbeiter),\n\n    FOREIGN KEY (Vorgesetzter) REFERENCES Vorgesetzte (Mitarbeiter) ON DELETE CASCADE);\n\n    Diese Tabelle hat ein Problem: Es können keine Datensätze eingefügt werden. Überlegen Sie, warum! Welche Aktionen, jede einzeln für sich, könnten dieses Problem lösen?",
    "explanation": "Das Einfüge-Problem besteht darin, dass kein Mitarbeiter-Datensatz mit Vorgesetztem (z.B. (\"Hugo\",\"Anton\")) als erste eingefügt werden kann, weil dann die Fremdschlüsselbeziehung verletzt ist. Es fehlt ein Master-Datensatz für den Anton.\n\n    Wird hingegen versucht, den Datensatz des obersten Chefs, der ja keinen Vorgesetzten hat (z.B. (\"Anton\", NULL)), einzufügen, dann verweigert das NOT NULL-Constraint auf der Vorgesetzten-Spalte den Datensatz.\n\n    \n\n    Jede der folgenden Aktionen löst das Einfüge-Problem der Tabelle Vorgesetzter:\n\n    - Die Spalte Vorgesetzter als NULL-Spalte definieren.\n\n    - Die Spalte Vorgesetzter ohne FOREIGN KEY definieren.\n\n    - Wenigstens eines der Constraints als DEFERRED programmieren.\n\n    \n\n    Irgendein oder mehrere Constraints als IMMEDIATE zu programmieren hilft nicht weiter, das sind die Constraints bereits. IMMEDIATE ist der Default-Prüfungszeitpunkt, wenn nichts programmiert ist.\n\n    Wird hingegen eines oder auch mehrere Constraints als DEFERRED programmiert, so wird dieses bzw. diese erst dann geprüft, wenn die Transaktion mit COMMIT abgeschlossen wird. Etwaige fehlerhafte Zwischenzustände würden dann nicht bemerkt. Aber hier würde es bereits genügen, wenn eines der problematischen Constraints als DEFERRED definiert würde.\n\n    \n\n    Der Verzicht auf die ON DELETE CASCADE-Klausel hilft überhaupt nicht weiter, weil sie mit dem Problem nichts zu tun hat.\n\n    \n\n    Gleiches gilt für das PRIMARY KEY-Constraint.\n\n    \n\n    Auf die REFERENCES-Klausel zu verzichten geht rein syntaktisch nicht, weil sonst die FOREIGN KEY-Klausel nicht mehr richtig wäre.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenigstens eines der Constraints als IMMEDIATE programmieren.",
        "solution": "false"
      },
      {
        "text": "Es müssen beide Constraints als IMMEDIATE programmiert werden.",
        "solution": "false"
      },
      {
        "text": "Die Spalte Vorgesetzter ohne ON DELETE CASCADE-Klausel definieren.",
        "solution": "false"
      },
      {
        "text": "Die Spalte Vorgesetzter als NULL-Spalte definieren.",
        "solution": "true"
      },
      {
        "text": "Die Spalte Vorgesetzter ohne FOREIGN KEY definieren.",
        "solution": "true"
      },
      {
        "text": "Die Spalte Vorgesetzter ohne REFERENCES-Klausel definieren.",
        "solution": "false"
      },
      {
        "text": "Die Spalte Mitarbeiter ohne PRIMARY KEY definieren.",
        "solution": "false"
      },
      {
        "text": "Wenigstens eines der Constraints als DEFERRED programmieren.",
        "solution": "true"
      },
      {
        "text": "Es müssen beide Constraints als DEFERRED programmiert werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2829,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie eine Tabelle Kunden (K_ID, Nachname, Vorname, Kontonummer, BLZ, ....) .\n\nMit welcher SELECT-Anweisung kann mann die Anzahl der Kunden bestimmen, deren BLZ (Bankleitzahl) leer, das heißt NULL ist?",
    "explanation": "Alle Antworten sind syntaktisch richtg, aber nur die Antwort \n\nSELECT COUNT(NVL(BLZ, 0))\nFROM KUNDEN \nWHERE BLZ IS NULL;\n\nliefert das gewünschte Ergebnis. \n\nNull-Werte werden nicht mit = NULL abgefragt. Die DISTINCT-Abfrage liefert die falsche Zahl. Die Funktion NVL ist hier notwendig, da sonst COUNT(BLZ) = 0 ist, wenn eine BLZ in der Spalte den Wert NULL hat",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT COUNT(BLZ)\nFROM KUNDEN \nWHERE BLZ IS NULL;",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(BLZ)\nFROM KUNDEN \nWHERE BLZ = NULL;",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(DISTINCT BLZ)\nFROM KUNDEN \nWHERE BLZ IS NULL;",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(NVL(BLZ, 0))\nFROM KUNDEN \nWHERE BLZ IS NULL;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2540,
    "category": 13,
    "difficulty": 2,
    "text": "Es ist für die Linien-Tabelle folgender Constraint gegeben: ALTER TABLE linien ADD CONSTRAINT linien_typ_check CHECK (UPPER(linien_typ) IN (\"BA\", \"BU\", \"SB\")) INITIALLY DEFERRED; Kann dieser Constraint auch mit Triggern gelöst werden?",
    "explanation": "Nein, weil es sich um eine DEFERRED-Prüfung handelt und dafür fehlt ein BEFORE-COMMIT-Trigger.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ja",
        "solution": "false"
      },
      {
        "text": "nein",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2541,
    "category": 9,
    "difficulty": 1,
    "text": "Betrachten Sie die folgende Typdefinition:\n\nCREATE OR REPLACE TYPE adresse_t\nAS\n   OBJECT (Ort varchar2 (50),\n           PLZ integer,\n           strasse varchar2 (50),\n           hausnummer integer);\n\nIst diese Typedefinition ORACLE-spezifisch?",
    "explanation": "Die Klausel \"AS OBJECT\" gehört nicht zum SQL-Standard.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ja",
        "solution": "true"
      },
      {
        "text": "nein",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2606,
    "category": 6,
    "difficulty": 3,
    "text": "Ein Tabellen-Constraint (TABLE CONSTRAINT) kann folgende Klauseln haben:",
    "explanation": "FALSCH ist:\nDie REFERENCES-Klausel gibt es nur bei den Spalten-Constraints, als Tabellen-Constraint heißt diese Funktion FOREIGN KEY. Die NULL-Klausel gibt es ausschließlich als Spalten-Constraint.\n\n ::= \n[ CONSTRAINT Constraintname ] \n[ <CONSTRAINT Characteristika> ]\n\n\n ::= \nPRIMARY KEY ( Spaltenname [ , Spaltenname ]... )\n| UNIQUE ( Spaltenname [ , Spaltenname ]... )\n| FOREIGN KEY ( Spaltenname [ , Spaltenname ]... )\n\n| CHECK (  )\n\n\n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ]\n\n[ <Fehlerkorrektur Definition> ]",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NULL",
        "solution": "false"
      },
      {
        "text": "CHECK",
        "solution": "true"
      },
      {
        "text": "UNIQUE",
        "solution": "true"
      },
      {
        "text": "PRIMARY KEY",
        "solution": "true"
      },
      {
        "text": "FOREIGN KEY",
        "solution": "true"
      },
      {
        "text": "REFERENCES",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2642,
    "category": 7,
    "difficulty": 2,
    "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Leiter_Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr}\n\nAbteilungen hat den Primärschlüssel Abt_nr und den Fremdschlüssel Leiter_Ang_Nr.\nAngestellte hat den Primärschlüssel Ang_nr und den Fremdschlüssel Abt_Nr.\n\nWelche der folgenden SELECT-Anweisungen liefern das gleiche Ergebnis?",
    "explanation": "RICHTIG sind: \nSELECT *\nFROM Angestellte NATURAL JOIN Abteilungen; \n und \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr; \n\ndenn der NATURAL JOIN verknüpft alle Spalten, die gleich heißen, Abt_NR und Ort, auf Gleichheit und mit AND.\n \nDie Semantik ist: \"Welche Mitarbeiter arbeiten in \nAbteilungen, die im Wohnort des Mitarbeiters liegen?\"\n\n\nFALSCH ist: \nSELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;\nweil nur über eine der beiden gleich lautenden Spalte verknüpft wird und nicht über beide.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Abt_Nr = Abteilungen.Abt_Nr;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM Angestellte, Abteilungen\nWHERE Angestellte.Ort = Abteilungen.Ort\nAND Angestellte.Abt_Nr = Abteilungen.Abt_Nr;",
        "solution": "true"
      },
      {
        "text": "SELECT *\nFROM Angestellte NATURAL JOIN Abteilungen;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2613,
    "category": 6,
    "difficulty": 3,
    "text": "Welches SQL-Constraint bietet die Möglichkeit zur Fehlerkorrektur?",
    "explanation": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Prüfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Prüfung die ganze Transaktion zurückgerollt wird. Dieses Verhalten wird für Integritätsfehler ausschließlich bei NOT NULL, PRIMARY KEY, UNIQUE ausgeführt. \n\nLediglich die Fremdschlüssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabhängig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik, wenn Masterdatensätze gelöscht werden, für die noch abhängige Detail-Datensätze bestehen. Es besteht dann die Möglichkeit, z.B. die abhängigen Detaildatensätze ebenfalls zu löschen (CASCADE) oder deren Fremdschlüsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION",
    "type": "text",
    "answers": [
      {
        "text": "Bitte geben Sie den deutschsprachigen Namen ein (ohne Zusätze wie Bedignung oder Constraint):",
        "solution": "Fremdschlüssel"
      }
    ]
  },
  {
    "id": 2617,
    "category": 6,
    "difficulty": 1,
    "text": "Betrachten Sie die folgende Definition einer Sequence:\nCREATE SEQUENCE Kun_seq\n        INCREMENT BY 1\n    START WITH 1\n    NOMAXVALUE\n    NOCYCLE\n    CACHE 10;",
    "explanation": "Die Sequenz startet mit 1, zählt immer 1 hoch, daher: 1 2 3 4 5 6 7 8 9 10 \nDie Caching-Option steuert das Zwischenspeichern von Sequenznummer, eine interne Optimierung und spielt bei der Nummernvergabe keine Rolle.",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie die ersten 10 Ziffern in Folge und nur mit Leerzeichen getrennt an, die diese Sequenz erzeugt.",
        "solution": "1 2 3 4 5 6 7 8 9 10"
      }
    ]
  },
  {
    "id": 2643,
    "category": 7,
    "difficulty": 3,
    "text": "In welcher Reihenfolge werden die Klauseln eines SELECT-Befehls ausgeführt bzw. geparst? (Geben Sie Zahlen von 1 bis 6 an!)",
    "explanation": "Die Reihenfolge Ausführung der Klauseln einer SELECT-Anfrage sind:\n\n    6. SELECT ...\n\n    1. FROM ...\n\n    2. [ WHERE ... ]\n\n    3. [ GROUP BY ... ]\n\n    4. [ HAVING ... ]\n\n    5. [ ORDER BY ... ]\n\n    Die eckigen Klammern geben die Optionalität der Klauseln an.",
    "type": "text",
    "answers": [
      {
        "text": "WHERE",
        "solution": "2"
      },
      {
        "text": "FROM",
        "solution": "1"
      },
      {
        "text": "ORDER BY",
        "solution": "5"
      },
      {
        "text": "HAVING",
        "solution": "4"
      },
      {
        "text": "GROUP BY",
        "solution": "3"
      },
      {
        "text": "SELECT",
        "solution": "6"
      }
    ]
  },
  {
    "id": 2649,
    "category": 7,
    "difficulty": 1,
    "text": "Welche der beiden folgenden SELECT-Anweisungen ist liefert das gleiche Ergebnis, wenn die Tabelle TEST die Spalte \"Spalte1\" hat?",
    "explanation": "Eine ORDER_BY-Klausel kann in zwei SELECTs, die mit UNION verknüpft werden, nicht verwendet werden.\n\nBei einem UNION werden doppelte Tupel unterdrückt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT Spalte1 FROM TEST",
        "solution": "true"
      },
      {
        "text": "SELECT Spalte_1 FROM TEST ORDER BY Spalte1\nUNION\nSELECT Spalte_2 FROM TEST ORDER BY Spalte1",
        "solution": "false"
      },
      {
        "text": "SELECT Spalte1 FROM TEST\nUNION\nSELECT Spalte1 FROM TEST",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2614,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über das Fehlerverhalten des SQL-Integritätsprüfungskonzepts sind wahr?",
    "explanation": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Prüfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Prüfung die ganze Transaktion zurückgerollt wird. Dieses Verhalten wird für Integritätsfehler ausschließlich bei NOT NULL, PRIMARY KEY, UNIQUE ausgeführt. \n\nLediglich die Fremdschlüssel-Constraints bieten neben diesem \"Normalverhalten\" eine Option zur Fehlerkorrektur und zwar unabhängig davon, ob als Spalten- oder Tabellen-Constraint definiert. Die Fehlerkorrekturen betrifft die sog. \"Dangling Tuples\"-Problematik, wenn Masterdatensätze gelöscht werden, für die noch abhängige Detail-Datensätze bestehen. Es besteht dann die Möglichkeit, z.B. die abhängigen Detaildatensätze ebenfalls zu löschen (CASCADE) oder deren Fremdschlüsselwert auf einen vorgegebenen Wert bzw. auf NULL zu setzen (DEFAULT/NULL)... \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Im Falle eines Integritätsfehlers wird mit einer Warnmeldung reagiert, die Datenmanipulation persistent in der Datenbasis gespeichert.",
        "solution": "false"
      },
      {
        "text": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und die Datenmanipulation abgebrochen wird.(IMMEDIATE sowie DEFERRED)",
        "solution": "false"
      },
      {
        "text": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Prüfung die Datenmanipulation abgebrochen wird bzw. bei einer DEFERRED-Prüfung die ganze Transaktion zurückgerollt wird.",
        "solution": "true"
      },
      {
        "text": "Das \"Normalverhalten\" bei einem Integritätsfehler in SQL ist, dass dieser Fehler angezeigt wird und bei einer IMMEDIATE-Prüfung die ganze Transaktion zurückgerollt wird bzw. bei einer DEFERRED-Prüfung die Datenmanipulation abgebrochen wird.",
        "solution": "false"
      },
      {
        "text": "Das Fremdschlüsel-Constraint bietet die Option, dass das DBMS eine Fehlerkorrektur durchführt.",
        "solution": "true"
      },
      {
        "text": "Die Constraints PRIMARY KEY, FOREIGN KEY und UNIQUE bieten die Option, dass das DBMS eine Fehlerkorrektur durchführt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2549,
    "category": 15,
    "difficulty": 2,
    "text": "Betrachten Sie eine Relation mit drei Spalten. Wie viele Indizes kann man anlegen?",
    "explanation": "Die Reihenfolge der Attribute spielt ja eine Rolle, daher 15 Kombinationsmöglichkeiten bei drei Spalten a, b, c:\n\n    a, b, c,\n\n    ab, ac, ba, bc, ca, cb,\n\n    abc, acb, bac, bca, cab, cba",
    "type": "text",
    "answers": [
      {
        "text": "Bitte tragen Sie eine Zahl ein:",
        "solution": "15"
      }
    ]
  },
  {
    "id": 2552,
    "category": 15,
    "difficulty": 3,
    "text": "Welche Aussagen über Indexe sind wahr?",
    "explanation": "Die Lösung ergibt sich aus der Definition von Indizes.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Indexe sind separate Speicherstrukturen, die zusätzlich zur Tabelle angelegt werden.",
        "solution": "true"
      },
      {
        "text": "Für eine Tabelle kann nur ein Index angelegt werden",
        "solution": "false"
      },
      {
        "text": "Einfügen und Löschen von Datensätzen in Tabellen mit Indizes sind aufwändiger, als bei Tabellen ohne Index.",
        "solution": "true"
      },
      {
        "text": "Indexe beschleunigen die Suche von Datensätzen, weil sie sortiert werden können und damit optimierte Suchalgorithmen ausgeführt werden können.",
        "solution": "true"
      },
      {
        "text": "Indexe haben den Vorteil, dass man für eine Tabelle mehrere anlegen kann und damit nach verschiedenen Spalten optimiert suchen kann.",
        "solution": "true"
      },
      {
        "text": "Indexe beschleunigen immer den lesenden Zugriff.",
        "solution": "false"
      },
      {
        "text": "Indexe verlangsamen den lesenden Zugriff, wenn die Tabelle so klein ist, dass alle Daten in einen physischen Block passen und so mit einer Schreiblese-Operation gelesen werden können",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2596,
    "category": 4,
    "difficulty": 1,
    "text": "Einen Operatorbaum liest man",
    "explanation": "Um Anfragen an einen Datenbestand zu formulieren, können Operationen der relationalen Algebra beliebig ineinander geschachtelt werden. Bei komplexen Anfragen ist daher die oben verwendete sogenannte \"Inline-Notation\" schwer lesbar. Für diesen Zweck verwendet man Operatorbäume statt der Inline-Notation. Bei dieser grafischen Darstellung erstellt und liest man die Abfrage von unten nach oben. Operationen, die miteinander verknüpft sind, sind durch Kanten im Graphen miteinander verbunden. Gestartet wird mit den relvanten Relationen als unterster Teil des OP-Baumes.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "von unten nach oben",
        "solution": "true"
      },
      {
        "text": "von oben nach unten",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2699,
    "category": 12,
    "difficulty": 2,
    "text": "Wozu kann man den Befehl execute unter Oracle-SQL benutzen?",
    "explanation": "Beispiele für Prozeduraufrufe sind in SQL*PLus\n\nEXECUTE prozedurname(var_y, var_x)\nIm PL/SQL-Programm:\nprozedurname(var_y, var_x) Funktionen brauchen einen Return-Wert und können daher nicht diekt mit excute aufgerufen werden",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zum direkten Aufruf einer Funktion",
        "solution": "false"
      },
      {
        "text": "Zum direkten Aufruf einer Prozedur",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2615,
    "category": 6,
    "difficulty": 3,
    "text": "Die Fehlerkorrektur beim Fremdschlüssel bietet welche Klauseln an?",
    "explanation": "Wenn man bedenkt, für welche Problemstellung die Fehlerkorrektur gedacht ist, dann kommt man schnell darauf, das es nur die beiden Klauseln \"ON UPDATE\" und \"ON DELETE\" geben kann.  \nWerden Fremdschlüssel verwendet, so kann es zur sog. \"Dangling Tuples\"-Problematik kommen, bei der es darum geht, dass Master-Datensätze, die noch von Detail-Datensätze referenziert werden, gelöscht oder deren Schlüsselwert geändert wird und das anschließend Detail-Datensätze existieren, für deren Fremdschlüsselwerte es dann keinen passenden Datensatz in der Master-Tabelle mehr gibt. \nDas Einfügen von Master-Datensätzen ist immer unproblematisch, da eine Fremdschlüsselbedingung es zuläßt, dass es Master-Datensätze gibt, für die es keine Detail-Datensätze gibt. \n\n ::=\nREFERENCES Tabellenname [ ( Spaltenname [ , Spaltenname ]... ) ] \n\n[ <Fehlerkorrektur Definition> ]\n\n<Fehlerkorrektur Definition> ::=\nON UPDATE <Fehlerkorrektur Aktion>\n| ON DELETE <Fehlerkorrektur Aktion>\n<Fehlerkorrektur Aktion> ::=\nCASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ON INSERT <Fehlerkorrektur Aktion>",
        "solution": "false"
      },
      {
        "text": "ON UPDATE <Fehlerkorrektur Aktion>",
        "solution": "true"
      },
      {
        "text": "ON DELETE <Fehlerkorrektur Aktion>",
        "solution": "true"
      },
      {
        "text": "Es gibt gar keine Fehlerkorrektur bei den Fremdschlüsseln in SQL.",
        "solution": "false"
      },
      {
        "text": "Es gibt zwar eine Fehlerkorrektur bei den Fremdschlüsseln in SQL, die Klauseln heißen aber ganz anders.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2786,
    "category": 7,
    "difficulty": 2,
    "text": "In einem Spaltenausdruck einer SELECT-Klausel können Gruppenfunktionen mit Single-Row-Funktionen gemischt werden",
    "explanation": "In einem Spaltenausdruck können keine Gruppenfunktionen mit Single-Row-Funktionen gemischt werden, da sich Gruppenfunktionen auf mehrere Tupel beziehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2767,
    "category": 7,
    "difficulty": 2,
    "text": "Welcher der folgenden Mengenoperatoren hat die höchste Priorität?",
    "explanation": "Die Mengenoperatoren union, intersect und minus haben unter SQL keine Prioritätsreihenfolge, sondern werden in der Reihenfolge abgearbeitet, in der sie in der SELECT-Abfrage stehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "union",
        "solution": "false"
      },
      {
        "text": "intersect",
        "solution": "false"
      },
      {
        "text": "minus",
        "solution": "false"
      },
      {
        "text": "Keiner von allen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2739,
    "category": 9,
    "difficulty": 3,
    "text": "Ausgehend von den Basisdatentypen und den zugelassenen Typkonstruktoren lässt sich das Basisobjektmodell in inline-Notation wie folgt beschreiben: (nur der zum relationalen Modell und zu SQL92 \"quasi analoge\" Ausschnitt)",
    "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben. Und das Basisobjektmodell entspricht an dieser Stelle der Grundstruktur SET ( OBJECT ( Basisdatentyp ) ). Diese Beschreibung ist jedoch noch sehr unvollständig.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "SET(OBJECT(Basisdatentyp))"
      }
    ]
  },
  {
    "id": 2783,
    "category": 7,
    "difficulty": 1,
    "text": "Was bewirken Klammern in einem Ausdruck einer SELECT-Anweisung?",
    "explanation": "In SQL gilt wie in der Mathematik die Merkregel  \"Punktrechnung geht vor Strichrechnung\". Durch Klammern kann man diese Reihenfolge überschreiben. (siehe <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Operator\"> Operatoren in SQL )",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Man kann in SQL reservierte Wörter als Spaltennamen benutzen.",
        "solution": "false"
      },
      {
        "text": "Das ist eine Matrix-Schreibweise für komplexe Vektoren.",
        "solution": "false"
      },
      {
        "text": "Damit kann man die Prioritätsreihenfolge numerischer Operatoren überschreiben.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2710,
    "category": 12,
    "difficulty": 3,
    "text": "Es sei eine Funktion \n\n     test_check(sp1 IN NUMBER) RETURN NUMBER ; \n\ngegeben. Welche Aufrufe sind richtig?",
    "explanation": "Da der Rückgabewert (RETURN-Wert) vom Typ NUMBER ist, ist eine Verwendung wie innerhalb der Bedingung dieser IF-Anweisung unzulässig, da diese Syntax keine zu einem Wahrheitswert auswertbare Bedingung darstellt. \n\nAnders sieht es bei der Bedingung der WHILE-Schleifen aus. Aufgrund des Vergleichs ist dies eine auswertbare Bedingung mit einem Wahrheitswert. \n\nMit EXECUTE können nur Prozeduren ausgeführt werden und das auch nicht innerhalb von PL/SQL-Programmen (dort nur durch Verwendung des Prozedurnamens) sondern in Tools wie SQL-Plus oder SQL-Developer etc.\n\nDie Anweisung \"SELECT funktionsname FROM DUAL;\" eignet sich hervorragend für den Aufruf von Funktionen mit nur IN-Parametern, solange für sie nicht BOOLEAN als RETURN-Wert definiert ist. Der Grund ist, im SQL-Kontext kennt Oracle leider immer noch nicht den Datentyp BOOLEAN sondern nur in PL/SQL-Programmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "EXECUTE test_check(123);",
        "solution": "false"
      },
      {
        "text": "IF test_check(var_x) THEN  END IF;",
        "solution": "false"
      },
      {
        "text": "SELECT test_check(sp1) FROM DUAL;",
        "solution": "true"
      },
      {
        "text": "WHILE ( test_check(var_y) < var_z ) LOOP  ;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2711,
    "category": 13,
    "difficulty": 2,
    "text": "Mit welchem/n PL/SQL-Konzept/en können Informationen zwischen Triggern ausgetauscht werden?",
    "explanation": "Um zwischen ORACLE-Trigger Informationen austauschen zu können, steht das PL/SQL-Konzept der public Package-Variablen zur Verfügung. Die privaten Package-Variablen scheiden aus, weil sie ja eh nur innerhalb des Packages verwendbar sind. \n\nEin Trigger verfügt über keine Parameter. Dieses Konzept ist nur bei Funktionen und Prozeduren bekannt. \n\nDer Informationsaustausch über die Zwischenspeicherung in Tabellen stellt eine alternative Austauschform dar. Sie hat jedoch das Problem, dass der Mehrbenutzerbetrieb explizit vom Entwickler gelöst werden muss (USER-Kennung mitspeichern, etc.). Während bei den Package-Variablen jeder angemeldete User seine eigene Instanziierung dieser Variable bekommt und es zu keinen Mehrbenutzerproblemen kommt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Public Package-Variable",
        "solution": "true"
      },
      {
        "text": "Private Package-Variable",
        "solution": "false"
      },
      {
        "text": "Dies geht nicht als PL/SQL-Lösung sondern nur in SQL mittels einer Tabelle, die vom einen Trigger gefüllt und vom anderen ausgelesen werden.",
        "solution": "false"
      },
      {
        "text": "Paramterübergabe",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2542,
    "category": 9,
    "difficulty": 3,
    "text": "Betrachten Sie die folgenden Typdefinitionen unter Oracle-SQL:\n\nCREATE OR REPLACE TYPE adresse_t\nAS\n   OBJECT (Ort varchar2 (50),\n           PLZ integer,\n           strasse varchar2 (50),\n           hausnummer integer);\n\nCREATE OR REPLACE TYPE DATUM_T\nAS\n   OBJECT (gekauft_am DATE,\n           VERKAUFT_AM DATE);\n           \nCREATE OR REPLACE TYPE autos_t\nAS\n   OBJECT (fahrzeug_nummer varchar2 (50), datum datum_t);\n\nCREATE OR REPLACE TYPE verkaufen_t as table of autos_t;\n\n\nWelche CREATE-Table-Anweisung ist korrekt?",
    "explanation": "Der Name der NESTED-Table muss mit dem Namen der Spalte, hier autos übereinstimmen und NESTED TABLE ist das erste Schlüsselwort nach der schließenden Klammer.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TABLE kunde_NT\n(Name varchar2(50),\n adresse adresse_t,\n autos verkaufen_t) NESTED TABLE autos STORE as verkauf_table;",
        "solution": "true"
      },
      {
        "text": "CREATE TABLE kunde_NT\n(Name varchar2(50),\n adresse adresse_t,\n autos verkaufen_t) NESTED TABLE autos_t STORE as verkauf_table;",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE kunde_NT\n(Name varchar2(50),\n adresse adresse_t,\n autos verkaufen_t) STORE as NESTED TABLE autos verkauf_table;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2548,
    "category": 15,
    "difficulty": 3,
    "text": "Es sei folgender Index über zwei Spalten gegeben: \n    CREATE INDEX namens_idx (Nachname, Vorname). \nÜber welche Spalten kann schnell gesucht werden?",
    "explanation": "Da der Index so aufgebaut ist, dass der Nachname als erster Eintrag berücksichtigt wird, kann man nicht schnell zugreifen, wenn der Vorname die Einstigsspalte ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nachname",
        "solution": "true"
      },
      {
        "text": "Vorname",
        "solution": "false"
      },
      {
        "text": "Nachname, Vorname",
        "solution": "true"
      },
      {
        "text": "Vorname, Nachname",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2550,
    "category": 15,
    "difficulty": 2,
    "text": "Wie viele Einträge sind in einem B-Baum vom Typ k mit der Höhe h in der Wurzel mindestens enthalten?",
    "explanation": "Das ist die Definition eines B-Baumes.",
    "type": "text",
    "answers": [
      {
        "text": "Bitte tragen sie eine Zahl ein!",
        "solution": "1"
      }
    ]
  },
  {
    "id": 2551,
    "category": 15,
    "difficulty": 3,
    "text": "Wie viele Einträge sind in einem B-Baum vom Typ k mit der Höhe h in den inneren Knoten mindestens enthalten?",
    "explanation": "Das ist die Definition eines B-Baums.",
    "type": "text",
    "answers": [
      {
        "text": "Bitte tragen sie eine Zahl ein!",
        "solution": "k"
      }
    ]
  },
  {
    "id": 2760,
    "category": 12,
    "difficulty": 1,
    "text": "Welche Aussagen über eine PL/SQL-Funktion bzw. Prozedur sind korrekt?",
    "explanation": "Mit EXECUTE können direkt Prozeduren ausgeführt werden und das auch nicht innerhalb von PL/SQL-Programmen (dort nur durch Verwendung des Prozedurnamens). Bei Funktioen muss zusätzlich der RETURN-Wert verarbeitet werden. \n\nDie Anweisung \"SELECT funktionsname FROM DUAL;\" eignet sich hervorragend für den Aufruf von Funktionen mit nur IN-Parametern, solange für sie nicht BOOLEAN als RETURN-Wert definiert ist. Der Grund ist, im SQL-Kontext kennt Oracle leider immer noch nicht den Datentyp BOOLEAN sondern nur in PL/SQL-Programmen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine PL/SQL-Prozedur kann mit EXECUTE prozedurname innerhalb eines PL/SQL-Programms aufgerufen werden.",
        "solution": "true"
      },
      {
        "text": "Eine PL/SQL-Funktion kann mit EXECUTE functionname innerhalb eines PL/SQL-Programms aufgerufen werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2724,
    "category": 9,
    "difficulty": 3,
    "text": "Auf welchen grundlegenden Datenmodellen basiert das objektrelationale Modell des SQL2003-Standards bzw. Oracle im wesentlichen, also abgesehen von einigen kleineren Änderungen? Nennen Sie die Namen ohne Sonderzeichen und in aphabetischer Reihenfolge. Beide Namen enden auf \"modell\".",
    "explanation": "Die beiden grundlegenden Konzepte, die im objektrelaitonalen SQL2003 zusammengeführt wurden sind: SQL-92 und das Basisobjektmodell. (vgl. auch Türker/Saake in \"Objektrelationale Datenbanken\", dpunkt-Vderlag, 2006, Kap.3, insbesondere S.95) Diese beiden Modelle werden zudem um drei Typkonstruktoren erweitert:\n\nin SQL: REF, MULTISET, ARRAY \nbei Oracle REF, (NESTED) TABLE, VARRAY \n\nZu beachten ist insbesondere, dass sowohl bei Oracle wie auch beim SQL2003-Standard nicht das relationalen Modell mit seiner Mengensemantik sondern das SQL-92-Modell mit seinem Verständnis einer Tabelle als Multimenge zugrunde liegt.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist zum einen das ...",
        "solution": "Basisobjektmodell"
      },
      {
        "text": "Das ist zum anderen das ...",
        "solution": "SQL92Modell"
      }
    ]
  },
  {
    "id": 2747,
    "category": 9,
    "difficulty": 3,
    "text": "Aus welchen Arten von Tabellen lassen sich mit einer Referenzspalte REF Objekte referenzieren?",
    "explanation": "Eine Referenz kann nur auf eine Objekttabelle (Oracle) / Typisierte Tabelle (SQL) verweisen, da für den Verweis eine OID benötigt wird, die in relationalen Tabellen nicht gegeben ist. \n\nAndererseits kann die Referenz aus einer relationalen wie auch objektrelationale Tabelle (Objekttabelle (Oracle)/Typisierte Tabelle (SQL)) erfolgen,  d.h. eine relationale Tabelle kann eine Spalte aufweisen, deren Datentyp REF ist und auf eine  Objekttabelle (Oracle)/Typisierte Tabelle (SQL) verweist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "relationale Tabellen (Tupeltabellen)",
        "solution": "true"
      },
      {
        "text": "Objekttabellen (Oracle) / Typisierte Tabellen (SQL)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2776,
    "category": 6,
    "difficulty": 2,
    "text": "Betrachten Sie den folgenden CREATE-TABLE-Befehl: \n\nCREATE TABLE Person (\nID NUMBER PRIMARY KEY,\nNACHNAME VARCHAR2(20) PRIMARY KEY,\nTYP CHAR(1));\n\nWelche Aussage/n sind/ist korrekt?",
    "explanation": "Eine Tabelle kann nur einen PRIMRY KEY haben, der die physische Struktur der Tabelle festlegt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil eine Tabelle nur eine PRIMARY KEY haben kann.",
        "solution": "true"
      },
      {
        "text": "Der CREATE-TABLE -Befehl wirft keinen Fehler.",
        "solution": "false"
      },
      {
        "text": "Der CREATE-TABLE -Befehl wirft keinen Fehler, aber es wird nur der erste PRIMARY KEY erzeugt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2779,
    "category": 6,
    "difficulty": 2,
    "text": "Betrachten Sie die folgenden SQL-Befehl: \n\nCREATE TABLE Person (\nID NUMBER PRIMARY KEY,\nNACHNAME VARCHAR2(20),\nTYP CHAR(1));\n\n\nINSERT INTO PERSON (1, NULL, NULL);\nINSERT INTO PERSON (2, WILLI, 'B');\n\nUPDATE PERSON\n  SET TYP = 'A' WHERE TYP = 'B';\nCOMMIT;\n\nWelche Aussage/n sind/ist korrekt?\n\n",
    "explanation": "Die WHERE-Klausel 'WHERE TYP = 'B' greift nur, wenn der TYP keinen Nullwert hat.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Zeile wird verändert.",
        "solution": "true"
      },
      {
        "text": "Zwei Zeilen werden verändert.",
        "solution": "false"
      },
      {
        "text": "Keine Zeile wird verändert.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2787,
    "category": 7,
    "difficulty": 2,
    "text": "Welchen Wert gibt die SQL-Gruppenfunktionen auf einer Tabelle test wieder, wnn diese Tabelle keine Zeilen enthält?\n\nSELECT COUNT(*) FROM test;",
    "explanation": "COUNT gibt immer einen numerischen Wert zurück. Dieser ist 0,  wenn die Tabelle keine Tupel enthält",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "0",
        "solution": "true"
      },
      {
        "text": "NULL",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2788,
    "category": 7,
    "difficulty": 3,
    "text": "Bis zu welcher Tiefe können Gruppenfunktionen (COUNT, MIN, MAX , SUM, AVG) in Oracle -SQL verschachtelt werden?",
    "explanation": "Gruppenfunktionen können mit Single-Row-Funktionen  oder untereinander verschachtelt werden, wenn die Datentypen passen. Es ist auch möglich, Gruppenfunktionen untereinander zu verschachteln, allerdings nur bis zur Stufe 2.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "1",
        "solution": "false"
      },
      {
        "text": "2",
        "solution": "true"
      },
      {
        "text": "3",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2700,
    "category": 12,
    "difficulty": 2,
    "text": "Welche/r Parametertyp/en erfordern eine Variable beim Aufruf der Routine (Prozedur oder Funktion) ?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "IN",
        "solution": "false"
      },
      {
        "text": "INOUT",
        "solution": "true"
      },
      {
        "text": "OUT",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2701,
    "category": 12,
    "difficulty": 3,
    "text": "Overloading-Routinen werden unterschieden durch ",
    "explanation": "Beim Overloading in PL/SQL können Paketroutinen gleich heißen:   Gleichnamige Prozeduren oder Funktionen werden durch eine unterschiedliche Anzahl, eine unterschiedliche Reihenfolge von Parametern oder durch unterschiedliche Datentypen der Parameter unterschieden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Datentyp der Parameter.",
        "solution": "true"
      },
      {
        "text": "Reihenfolge unterschiedlicher Datentypen der Parameter.",
        "solution": "true"
      },
      {
        "text": "unterschiedliche Parameternamen.",
        "solution": "false"
      },
      {
        "text": "unterschiedliche Variablennamen.",
        "solution": "false"
      },
      {
        "text": "unterschiedliche Prozedur-/Funktionsnamen.",
        "solution": "false"
      },
      {
        "text": "Anzahl der Parameter.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2702,
    "category": 12,
    "difficulty": 3,
    "text": "Unter welchen Voraussetzungen kann bei der Programmierung von SELECT INTO-Anweisungen auf die eine oder andere EXCEPTION, die üblicherweise immer im Zusammenhang mit SELECT-INTOs zu programmieren sind, ganz sicher verzichtet werden?",
    "explanation": "SELECT INTO übergibt genau einen Datensatz oder Wert an die INTO-Variable, die nur genau einen Wert oder Datensatz aufnehmen kann. Mehrere bzw. keine Datensätze als Ergebnis des SELECTS werfen die Exception TOO_MANY_ROWS bzw. NO_DATA_FOUND, wenn das Resultat des SELECTS leer ist. Eine Alternative ist die Verwendung eines Cursors, der auch mehrere Datensätze verarbeiten kann.\n\n    \n\n    Es reicht nicht aus, wenn in Tabellen Datensätze vorhanden sind. Relevant ist, dass immer wdenigstens ein Datensatz gefunden wird, um auf die NO_DATA_FOUND verzichten zu können.\n\n    \n\n    Werden Anfragen über Primär- oder Eindeutigkeitsschlüssel an eine einzige Tabelle formuliert, steht fest, dass es keine TOO_MANY_ROWS geben kann.\n\n    \n\n    Werden Anfragen über Primär- oder Eindeutigkeitsschlüssel an die Detail-Tabelle von Joins formuliert, die mittels Fremdschlüsseln verknpüft sind, so steht fest, dass es keine TOO_MANY_ROWS geben kann.\n\n    \n\n    Aggregatfunktionen haben die Eigenschaft, dass sie je Gruppe nur einen Ergenbisdatensatz liefern. Steht also zwingend fest, dass es nur eine Gruppe gibt - z.B. bei fehlender Gruppierung nur über die GEsamtmenge - dann kann auch auf die TOO_MANY_ROWS verzichtet werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenigstens eine der beteiligten Tabellen enthält Datensätze.",
        "solution": "false"
      },
      {
        "text": "Die Anfrage liefert immer wenigstens einen Datensatz.",
        "solution": "true"
      },
      {
        "text": "Es wird bei Anfragen ohne JOINs in der WHERE-Klausel über die Primärschlüssel der beteiligten Tabelle zugegriffen.",
        "solution": "true"
      },
      {
        "text": "Es wird bei Anfragen mit JOINs in der WHERE-Klausel über die Fremdschlüssel verknüpft und über die Primärschlüssel bei den Detail-Tabellen eingeschränkt.",
        "solution": "true"
      },
      {
        "text": "Es wird bei Anfragen ohne JOINs in der WHERE-Klausel über die UNIQUE-Schlüssel der beteiligten Tabelle zugegriffen.",
        "solution": "true"
      },
      {
        "text": "Alle beteiligten Tabellen enthalten Datensätze.",
        "solution": "false"
      },
      {
        "text": "Es wird bei Anfragen mit JOINs in der WHERE-Klausel über die Fremdschlüssel verknüpft und über die UNIQUE-Schlüssel der Detail-Tabellen eingeschränkt.",
        "solution": "true"
      },
      {
        "text": "Wenn in der SELECT-Klausel Aggregatfunktionen ohne Gruppierung verwendet werden.",
        "solution": "true"
      },
      {
        "text": "Wenn in der SELECT-Klausel Aggregatfunktionen verwendet werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2704,
    "category": 13,
    "difficulty": 3,
    "text": "Die Einhaltung welchen Paradigmas des relationalen Modells und der relationalen Datenbanksysteme hat das Mutating Table-Problem zur Folge?",
    "explanation": "Das Mutating-Table-Problem tritt in Oracle PL/SQL auf, wenn ein Zeilentrigger mit DML-Anweisungen oder auch SELECT auf die den Trigger definierende Tabelle selber zugreift. Grund ist das Ausführungsmodell von Oracle, in dem auch DML-Anweisungen in Zeilentriggern zugelassen werden.  \n\nEs soll die Reihenfolgeunabhängigkeit des Resultats einer Änderungsanweisung sichergestellt werden.\n\nBei Befehlstriggern (Statement-Trigger) tritt das Mutating-Table-Problem nicht auf.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist die ...",
        "solution": "Reihenfolgeunabhängigkeit"
      }
    ]
  },
  {
    "id": 2706,
    "category": 12,
    "difficulty": 3,
    "text": "Folgende Prozedur sei gegeben: \n\n  CREATE OR REPLACE PROCEDURE \n         test_proc (p1 IN NUMBER, p2 OUT NUMBER) ... ;\n\nWelche Parameterverwendungen im Programm sind korrekt?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist. <br > \nBeim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. Daher nicht in Zuweisungen verwendbar sondern nur in Bedingungen etc. \n\nBeim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. \n\nBeim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt\nzurückgeben kann Daher in Zuweisungen, Bedingungen, etc. verwendbar. \n\nDer Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann. Daher in Zuweisungen, Bedingungen etc. verwendbar.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "p1 := 1234;",
        "solution": "false"
      },
      {
        "text": "p2 := 6543;",
        "solution": "true"
      },
      {
        "text": "WHILE p2 < 345 LOOP ;",
        "solution": "true"
      },
      {
        "text": "IF p1 = 456 THEN ;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2763,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über Fremdschlüssel (Foreign Keys) sind wahr?",
    "explanation": "Für die Definition eines Fremdschlüssels reicht ein UNIQUE-Constraint auf der referenzierten Spalte aus. Ein Primärschlüssel ist hinreichend, aber nicht notwendig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Syntax eines Foreign-Key-Constraints setzt voraus, dass auf der referenzierten Spalte ein Primärschlüssel definiert ist.",
        "solution": "false"
      },
      {
        "text": "Die Syntax eines Foreign-Key-Constraints setzt voraus, dass auf der referenzierten Spalte ein UNIQUE-Constraint oder ein Primärschlüssel definiert ist.",
        "solution": "true"
      },
      {
        "text": "Keine von bedien Antworten ist richtig.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2762,
    "category": 7,
    "difficulty": 1,
    "text": "Welcher Operator unterdrückt doppelte Datensätze?",
    "explanation": "UNION unterdrückt mehrfach vorkommende Datensätze, bei UNION ALL bleiben sie erhalten. UNION ANY gibt es in SQL nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "UNION ALL",
        "solution": "false"
      },
      {
        "text": "UNION ANY",
        "solution": "false"
      },
      {
        "text": "UNION",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2713,
    "category": 13,
    "difficulty": 3,
    "text": "Wenn innerhalb eines DML-Triggers einer Spalte des aktuell eingefügten oder geänderten Datensatzes ein Wert zugewiesen werden soll, sollte am besten welcher Trigger verwendet werden?",
    "explanation": "AFTER-ROW/STATEMENT-Trigger funktionieren gar nicht, da diese ja erst ausgeführt werden, wenn der Datensatz in der DB eingefügt bzw. geändert wurde, BEFORE-STATEMENT-Trigger nicht, da sie über keine Transitionsvariablen verfügen.\n\n    Am besten geht es mit den BEFORE-ROW-Triggern und den darin verfügbaren Transitionsvariablen. Die NEW.Transitionsvariablen bekommen einfach den neuen Wert zugewiesen und anschließend wird der manipulierte Datensatz mit den Werten der NEW-Transitionsvarialben in die DB eingefügt bzw. geändert,  z.B.: :NEW.eingefuegt_am := SYSDATE;\n\n    Auch INSTEAD OF-Trigger eignen sich auch - nur etwas anders. Sie sind für Sichten (VIEWs) definierbar und nicht für Tabellen. Es gibt sie nur als ROW-Variante - nicht als STATEMENT-Trigger.  Und die Transitionsvariablen können nur gelesen, aber nicht geändert werden. Die Inhalte der Transitionsvariablen können dann per INSERT/UPDATE-Anweisung in eine oder mehrere Tabellen umgeleitet werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "AFTER-ROW-Trigger",
        "solution": "false"
      },
      {
        "text": "BEFORE-ROW-Trigger",
        "solution": "true"
      },
      {
        "text": "AFTER-STATEMENT-Trigger",
        "solution": "false"
      },
      {
        "text": "BEFORE-STATEMENT-Trigger",
        "solution": "false"
      },
      {
        "text": "INSTEAD OF-ROW-Trigger",
        "solution": "true"
      },
      {
        "text": "INSTEAD OF-STATEMENT-Trigger",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2725,
    "category": 9,
    "difficulty": 3,
    "text": "Auf welchen grundlegenden Datenmodellen basiert das objektrelationale Modell des SQL2003-Standards bzw. Oracle im wesentlichen, also abgesehen von einigen kleineren Änderungen? Nennen Sie die Namen ohne Sonderzeichen und in aphabetischer Reihenfolge. Beide Namen enden auf \"modell\".",
    "explanation": "Die beiden grundlegenden Konzepte, die im objektrelaitonalen SQL2003 zusammengeführt wurden sind: SQL-92 und das Basisobjektmodell. (vgl. auch Türker/Saake in \"Objektrelationale Datenbanken\", dpunkt-Vderlag, 2006, Kap.3, insbesondere S.95) Diese beiden Modelle werden zudem um drei Typkonstruktoren erweitert:\n\nin SQL: REF, MULTISET, ARRAY \nbei Oracle REF, (NESTED) TABLE, VARRAY \n\nZu beachten ist insbesondere, dass sowohl bei Oracle wie auch beim SQL2003-Standard nicht das relationalen Modell mit seiner Mengensemantik sondern das SQL-92-Modell mit seinem Verständnis einer Tabelle als Multimenge zugrunde liegt.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist zum einen das ...",
        "solution": "Basisobjektmodell"
      },
      {
        "text": "Das ist zum anderen das ...",
        "solution": "SQL92Modell"
      }
    ]
  },
  {
    "id": 2733,
    "category": 10,
    "difficulty": 3,
    "text": "Welche Methode des Interfaces ResultSet prüft, ob der letzte gelesene Wert NULL war? Gibt es keine solche Methode, schreiben Sie \"keine\", sonst schreiben Sie den Methodennamen mit den Klammern.",
    "explanation": "Mit der Methode boolean wasNull() des Interface ResutlSet kann nachgeprüft werden, ob der letzte ausgelesene Wert einer Spalte NULL war oder nicht. Dazu muss vorher eine getXXX()-Methode für die Spalte aufgerufen werden.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ...",
        "solution": "wasNull()"
      }
    ]
  },
  {
    "id": 2734,
    "category": 10,
    "difficulty": 2,
    "text": "Welche Aussagen über das Konzept des ResultSets bei JDBC und das des Cursors bei PL/SQL sind wahr?",
    "explanation": "Das Konzept des Cursors bei PL/SQL und das des ResultSet bei JDBC stellt in beiden Fällen einen Speicherbereich für die Eregebnisdatensätze einer SELECT-Anfrage dar. \n\nIn Cursorn kann nur immer vorwärts eine Datensatz nach dem anderen eingelesen werden in die PL/SQL-Variablen. \n\nBei ResultSets kann beliebig innerhalb der Ergebnismenge navigiert werden mit Methoden wie: next(), previous(), absolute(), relative(), first(), last(), ...",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Beide Konzepte haben nichts miteinander zu tun.",
        "solution": "false"
      },
      {
        "text": "Beide Konzepte sind prinzipiell analog, wobei der Cursor funktional umfangreicher ist.",
        "solution": "false"
      },
      {
        "text": "Beide Konzepte sind prinzipiell analog, wobei das ResultSet funktional umfangreicher ist.",
        "solution": "true"
      },
      {
        "text": "Beide Konzepte sind prinzipiell identisch von der Funktionsweise und dem Funktionsumfang.",
        "solution": "false"
      },
      {
        "text": "Zwischen den Datensätzen eines Cursors kann komfortabel hin und her navigiert werden.",
        "solution": "false"
      },
      {
        "text": "Zwischen den Datensätzen eines ResultSet kann komfortabel hin und her navigiert werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2743,
    "category": 9,
    "difficulty": 2,
    "text": "Wie heißt das Problem, das speziell bei objektgenerierenden Sichten auftritt?",
    "explanation": "RICHTIG ist, dass das Problem der OID-Stabilität bei objektgenerierenden Objektsichten auftritt.  \n\nWelche unterschiedlichen Sichten gibt es im OR-Kontext?\nRelational: Tupelsichten\n\nTupelsicht über beliebige Tabellen und Sichten\nZeilen stellen Tupel dar\n\n\nObjektrelational: Typisierte Sichten\nBasiert auf einem Strukturdatentyp\nMittel der Zugriffskontrolle; \nermöglicht logische Datenunabhängigkeit\nObjektgenerierend: \nTypisierte Sicht, deren Zeilen neu erzeugte Objekte darstellen\nOID-Erzeugung: systemgeneriert, benutzerdefiniert, abgeleitet\nObjektrelationale Darstellung relationaler Daten\nObjekterhaltend:\nTypisierte Sicht, deren Zeilen bestehende Objekte darstellen\nVerallgemeinernde sowie spezialisierende Darstellungen möglich\nBessere Strukturierung der DB u. Wiederverwendbarkeit von Datentypen \nFROM-Klausel mit typischerweise nur einer typisierten Tabelle oder Sicht, wobei diese aber aus mehreren mit Mengenoperationen zusammengesetzten typisierten Tabellen und Sichten bestehen kann.\nKann bei Unterstützung des Substituierbarkeitsprinzips zur Darstellung der Subtypobjekte als Instanzen des Supertyps genutzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es gibt kein solches Problem.",
        "solution": "false"
      },
      {
        "text": "Stabilität der OID",
        "solution": "true"
      },
      {
        "text": "Stabilität der Daten",
        "solution": "false"
      },
      {
        "text": "Vereinigungskonformität",
        "solution": "false"
      },
      {
        "text": "Reihenfolgeunabhängigkeit",
        "solution": "false"
      },
      {
        "text": "Äquivalenz der Daten",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2712,
    "category": 13,
    "difficulty": 3,
    "text": "Welchen Unterschied macht es, ob eine Integritätsprüfung in einem BEFORE- oder AFTER-Trigger durchgeführt wird?",
    "explanation": "Wenn kein Fehler auftritt, ist es eigentlich egal, ob erst geprüft (BEFORE-Trigger) und dann manipiliert wird, oder ob erst manipuliert und dann geprüft wird (AFTER-Trigger).\n\nEs macht wohl einen Unterschied wenn ein Fehler auftritt - in der Fehlerreaktion und seiner Laufzeit. \n\nWird in einem BEFORE-Trigger der Fehler erkannt, sind bislang nur ggf. einige andere BEFORE-Trigger ausgeführt worden, die rückgängig gemacht werden müssen. \n\nWird erst in einem AFTER-Trigger der Fehler erkannt, sind alle BEFORE-Trigger mit ihren Aktionen wieder rückgnängig zu machen, die Manipulation des Datensatzes selbst und auch noch die bislang ausgeführten AFTER-Trigger mit ihren Aktionen. Das kann dann etwas länger dauern.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Keinen Unterschied.",
        "solution": "false"
      },
      {
        "text": "Wenn kein Fehler auftritt, dann macht es keinen Unterschied.",
        "solution": "true"
      },
      {
        "text": "Wenn ein Fehler auftritt macht es keinen Unterschied.",
        "solution": "false"
      },
      {
        "text": "Wenn ein Fehler bei einer Prüfung in einem AFTER-Trigger auftritt, wird die bereits in der Datenbasis vorgenommene Manipulation des Datensatzes wieder rückgängig gemacht.",
        "solution": "true"
      },
      {
        "text": "Wenn ein Fehler bei einer Prüfung in einem AFTER-Trigger auftritt, werden alle BEFORE-Trigger rückgängig gemacht.",
        "solution": "true"
      },
      {
        "text": "Wenn ein Fehler bei einer Prüfung in einem AFTER-Trigger auftritt, werden alle AFTER-Trigger rückgängig gemacht, die bis dahin bereits ausgeführt wurden.",
        "solution": "true"
      },
      {
        "text": "Wenn ein Fehler bei einer Prüfung in einem BEFORE-Trigger auftritt, wird die bereits in der Datenbasis vorgenommene Manipulation des Datensatzes wieder rückgängig gemacht.",
        "solution": "false"
      },
      {
        "text": "Wenn ein Fehler bei einer Prüfung in einem BEFORE-Trigger auftritt, werden alle BEFORE-Trigger rückgängig gemacht, die bis dahin bereits ausgeführt wurden.",
        "solution": "true"
      },
      {
        "text": "Wenn ein Fehler bei einer Prüfung in einem BEFORE-Trigger auftritt, werden alle AFTER-Trigger rückgängig gemacht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2745,
    "category": 9,
    "difficulty": 3,
    "text": "Was wird bei Oracle im TYPE-Body programmiert?",
    "explanation": "Einen CREATE METHOD-Befehl gibt es bei Oracle nicht. Die Methoden-Deklaration und -Definition wird im CREATE TYPE-Befehl vorgenommen analog zum Package-Konzept und zwar die Deklaration des Methoden-Kopfs im CREATE TYPE und die Definition mit Programmcode im CREATE TYPE BODY. \n\nCREATE [OR REPLACE] TYPE  AS OBJECT\u000b\n(  )\u000b\n[[NOT] FINAL] \u000b[[NOT] INSTANTIABLE] \n\u000b[]\n\nCREATE [OR REPLACE] TYPE BODY  AS \n[]",
    "type": "text",
    "answers": [
      {
        "text": "Wenn es dieses Konzept nicht gibt, schreiben Sie \"gibt es nicht\", sonst die Antwort im Plural eingeben.",
        "solution": "Methoden"
      }
    ]
  },
  {
    "id": 2748,
    "category": 9,
    "difficulty": 3,
    "text": "Welche Arten typisierter Sichten (Objektsichten) basieren typischer Weise auf nur einer typisierten Tabelle (Objekttabelle)?",
    "explanation": "Objektklassifizerende typisierte Sichten gibt es gar nicht. \n  \nDie objektgenerierenden typisierten Sichten erzeugen in der Regel Objekte aus relationalen Daten. Deren Daten können in beliebig komplexen SELECT-Anfragen zusammengestellt werden.  \n  \nDie objekterzeugenden typisierten Sichten erzeugen eine andere Sicht auf ein bereits bestehendes Objekt in einer typisierten Tabelle bzw. typisierten Sicht (Objekttabelle/-sicht), dies kann heißen, dass nur einige Attribute des Objekts angezeigt werden und/oder, dass nur eine Teilmenge der Objekte angezeigt wird und/oder verschiedene Objektmengen gleichen Typs mittels UNION vereinigt werden. Bei allen Möglichkeiten steht in der SELECT-Anfrage eine typisierten Tabelle bzw. typisierten Sicht (Objekttabelle/-sicht).  \n\nerstellen Spezialformen von",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Objektgenerierende typisierte Sicht",
        "solution": "false"
      },
      {
        "text": "Objekterhaltende typisierte Sicht",
        "solution": "true"
      },
      {
        "text": "Diese Restriktion gilt für keine der typisierten Sichten.",
        "solution": "false"
      },
      {
        "text": "Objektklassifizerende typisierte Sicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2749,
    "category": 9,
    "difficulty": 2,
    "text": "Für die sog. nicht änderbaren typisierten Sichten (Objektsichten) gibt es folgende Lösungen, um trotzdem Änderungen der Sichtdaten an die Basisdaten der zugrunde liegenden Tabellen weiterleiten zu können?",
    "explanation": "Das Problem der nicht änderbaren Sichten gibt es doch. Nur Sichten mit sehr einfachen SELECT-Anfragen (i.d.R. nur eine Tabelle und alle Pflichtspalten sind in der Sicht, ...) sind automatisch vom DBMS änderbar. Auf allen anderen Sichten kann der Anwender trotzdem DML-Operationen ausführen, es muss nur ein INSTEAD-OF-Trigger programmiert sein, der die für diese Sichtdatenänderungen relevanten DML-Anweisungen mit Änderungen der zugrunde liegenden Tabellendaten enthält, die dann anstelle der Sicht-DML-Operation ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BEFORE-Trigger",
        "solution": "false"
      },
      {
        "text": "AFTER-Trigger",
        "solution": "false"
      },
      {
        "text": "STATEMENT-Trigger",
        "solution": "false"
      },
      {
        "text": "INSTEAD-OF-Trigger",
        "solution": "true"
      },
      {
        "text": "DDL-Trigger",
        "solution": "false"
      },
      {
        "text": "Dieses Problem gibt es nicht. Für alle Sichten sind Datenänderungen vom DBMS automatisch in Basisdatenänderungen transformierbar.",
        "solution": "false"
      },
      {
        "text": "Dieses Problem gibt es nicht, da DML-Operationen nicht auf Sichten ausführbar sind, sondern nur auf Tabellen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2752,
    "category": 9,
    "difficulty": 3,
    "text": "Es sei eine typisierte Tabelle (Objekttabelle) kunden_ot gegeben. Es soll bei DML-Anweisungen auf diese Tabelle objektorientiert zugegriffen werden, also kein relationaler Zugriff. Für die Tabelle wird der Tabellenalias kdot in der DML-Anweisung vergeben. Wie heißt die für diesen instanzierten Zugriff relevante Funktion?",
    "explanation": "Welche Betrachtungsweisen gibt es für Objekttabellen? \n\nRelational / Multi-Column: \nAls mehrspaltige Tabelle, in der jedes Attribut des object types die Anwendung von relationalen Operationen erlaubt.\u000b\n\nObjektorientiert / Single-Column: \nAls einspaltige Tabelle, in der jeder Datensatz ein Objekt darstellt, die die Anwendung von OO-Operationen erlaubt.\nVALUE-Funktion:\u000b \nArgument: Tabellenalias einer object table:\n \u000b     VALUE (table_alias)\u000b\nRückgabewerte:    Objektinstanzen, die den Datensätzen der Objekttabelle entsprechen. Der Typ der Objektinstanz ist der Typ der Objekttabelle.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ... (alles in Großbuchstaben)",
        "solution": "VALUE(KDOT)"
      }
    ]
  },
  {
    "id": 2754,
    "category": 15,
    "difficulty": 3,
    "text": "Erstellen Sie einen B-Baum vom Typ 1 für folgende Eingabewerte: 1, 15, 22, 4, 17, 3. \n\nGeben Sie die Zahlen für jeden Knoten mit Komma und Leerzeichen getrennt in der richtigen Reihenfolge an.",
    "explanation": "Hier die einzelnen Schritte: \n* 1\n* 1, 15\nBei Typ 1 ist mit 2 Einträgen der Knoten gefüllt und muss gesplittet werden für das Einfügen von 22. \nlinker Knoten:  1 \nWurzel:         15\nrechter Knoten: 22\n\nEinfügen von 4 und 17:\nlinker Knoten:  1, 4\nWurzel:         15\nrechter Knoten: 17, 22\n\nEinfügen von 3:\nlinker Knoten:     1\nmittlerer Knoten:  4\nWurzel:            3, 15\nrechter Knoten:    17, 22",
    "type": "text",
    "answers": [
      {
        "text": "Linker Knoten",
        "solution": "1"
      },
      {
        "text": "Wurzel",
        "solution": "3, 15"
      },
      {
        "text": "rechter Knoten",
        "solution": "17, 22"
      },
      {
        "text": "mittlerer Knoten",
        "solution": "4"
      }
    ]
  },
  {
    "id": 2769,
    "category": 7,
    "difficulty": 3,
    "text": "Wenn man eine SELECT-Abfrage, die aus mehrere Mengenoperatoren (UNION, INTERSECT, MINUS)  besteht, sortieren will, welche ORDER By-Form kann man benutzen?",
    "explanation": "Da die Spaltennamen nicht eindeutig festliegen, kann man nur ORDER BY POSITION (z.B. ORDER BY 3) benutzen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ORDER by Spaltenname",
        "solution": "false"
      },
      {
        "text": "ORDER BY postion",
        "solution": "true"
      },
      {
        "text": "Das geht überhaupt nicht.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2784,
    "category": 8,
    "difficulty": 1,
    "text": "Mit welchem Datenbankobjekt kann man eine SELECT-Abfrage beschleunigen?",
    "explanation": "Indizes werden genau zu dem Zweck in der Datenbank abgelegt, nämlich um Abfragen zu beschleunigen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ROWID",
        "solution": "false"
      },
      {
        "text": "VIEW",
        "solution": "false"
      },
      {
        "text": "INDEX",
        "solution": "true"
      },
      {
        "text": "SEQUENCE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2789,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie die folgende SELECT-Abfrage gegen eine Angestellten-Tabelle, wobei die entsprechenden Spalten vorhanden sein sollten:\n\n SELECT Abt_nr, SUM(gehalt) \n FROM Angestellte\n\nWelche Aussagen sind korrekt?",
    "explanation": "Alle Spalten, die in der SELECT-Klausel kein GRPOUB-BY haben, hier Abt_nr, müssen in der GROUP-BY-Klasuel vorhanden sein.\n\nsiehe < href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Gruppenfunktionen\"> Gruppenfunktionen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Abfrage wirft einen Fehler, da skalare und aggregierte Daten vermischt werden.",
        "solution": "true"
      },
      {
        "text": "Dieser SELECT-Anweisung fehlt eine GROUP-BY-Klausel",
        "solution": "true"
      },
      {
        "text": "Die Anweisung wirft keinen Fehler.",
        "solution": "false"
      },
      {
        "text": "Die Anweisung wirft keine Fehler, gibt aber keine Daten aus.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2737,
    "category": 9,
    "difficulty": 3,
    "text": "Das SQL-Daten-Modell kann wie folgt definiert werden: \nSET ( ROW ( Basisdatentyp ) ) .",
    "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "true"
      },
      {
        "text": "stimmt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2790,
    "category": 7,
    "difficulty": 3,
    "text": "Eine SQL-Gruppenfunktion(SUM, MIN, MAX, etc..)  kann aufgerufen werden",
    "explanation": "Eine SELECT-Klausel kann Gruppenfunktionen beinhalten. Eine INSERT-Anweisung  hat keine SELECT-Klausel, eine DELETE hat keinen .\n\nsiehe < href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Gruppenfunktionen\" > Gruppenfunktionen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "aus der HAVING-Klausel einer SELECT-Anweisung",
        "solution": "true"
      },
      {
        "text": "aus der ORDER-BY--Klausel einer SELECT-Anweisung",
        "solution": "true"
      },
      {
        "text": "aus einem Ausdruck in einer DELETE-Anweisung",
        "solution": "false"
      },
      {
        "text": "innerhalb einer SELECT-Klausel in einer SELECT-Anweisung",
        "solution": "true"
      },
      {
        "text": "an keiner Stelle von allen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2750,
    "category": 13,
    "difficulty": 3,
    "text": "Für die nicht änderbaren typisierten Sichten (Objektsichten) wie auch relationalen Sichten gibt es folgende Lösungen, um trotzdem Änderungen der Sichtdaten an die Basisdaten der zugrunde liegenden Tabellen weiterleiten zu können.",
    "explanation": "Das Problem der nicht änderbaren Sichten gibt es schon. Nur Sichten mit sehr einfachen SELECT-Anfragen (i.d.R. nur eine Tabelle und alle Pflichtspalten sind in der Sicht, ...) sind automatisch vom DBMS änderbar. Auf allen anderen Sichten kann der Anwender DML-Operationen ausführen, es muss nur ein INSTEAD-OF-Trigger programmiert sein, der die für diese Sichtdatenänderungen relevanten DML-Anweisungen mit Änderungen der zugrunde liegenden Tabellendaten enthält, die dann anstelle der Sicht-DML-Operation ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BEFORE-Trigger",
        "solution": "false"
      },
      {
        "text": "AFTER-Trigger",
        "solution": "false"
      },
      {
        "text": "STATEMENT-Trigger",
        "solution": "false"
      },
      {
        "text": "INSTEAD-OF-Trigger",
        "solution": "true"
      },
      {
        "text": "DDL-Trigger",
        "solution": "false"
      },
      {
        "text": "Dieses Problem gibt es nicht. Für alle Sichten sind Datenänderungen vom DBMS automatisch in Basisdatenänderungen transformierbar.",
        "solution": "false"
      },
      {
        "text": "Dieses Problem gibt es nicht, da DML-Operationen nicht auf Sichten ausführbar sind, sondern nur auf Tabellen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2751,
    "category": 9,
    "difficulty": 2,
    "text": "Für die  nicht änderbaren Sichten  gibt es folgende Lösungen, um Änderungen der Sichtdaten an die Basisdaten der zugrunde liegenden Tabellen weiterleiten zu können:",
    "explanation": "Das Problem der nicht änderbaren Sichten gibt es schon. Nur Sichten mit sehr einfachen SELECT-Anfragen (i.d.R. nur eine Tabelle und alle Pflichtspalten sind in der Sicht, ...) sind automatisch vom DBMS änderbar. Auf allen anderen Sichten kann der Anwender trotzdem DML-Operationen ausführen, es muss nur ein INSTEAD-OF-Trigger programmiert sein, der die für diese Sichtdatenänderungen relevanten DML-Anweisungen mit Änderungen der zugrunde liegenden Tabellendaten enthält, die dann anstelle der Sicht-DML-Operation ausgeführt wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BEFORE-Trigger",
        "solution": "false"
      },
      {
        "text": "AFTER-Trigger",
        "solution": "false"
      },
      {
        "text": "STATEMENT-Trigger",
        "solution": "false"
      },
      {
        "text": "INSTEAD-OF-Trigger",
        "solution": "true"
      },
      {
        "text": "DDL-Trigger",
        "solution": "false"
      },
      {
        "text": "Dieses Problem gibt es nicht. Für alle Sichten sind Datenänderungen vom DBMS automatisch in Basisdatenänderungen transformierbar.",
        "solution": "false"
      },
      {
        "text": "Dieses Problem gibt es nicht, da DML-Operationen nicht auf Sichten ausführbar sind, sondern nur auf Tabellen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2753,
    "category": 15,
    "difficulty": 2,
    "text": "Erstellen Sie einen B-Baum vom Typ 2 für folgende Eingabewerte: 1, 15, 22, 4, 17, 3. \n\nGeben Sie die Zahlen für jeden Knoten mit Komma und Leerzeichen getrennt in der richtigen Reihenfolge an.",
    "explanation": "Hier die einzelnen Schritte: \n* 1\n* 1, 15\n* 1, 15, 22\n* 1,  4, 15, 22\n\nDa Typ 2 ist mit 4 Einträgen der Knoten gefüllt und muss gesplittet werden für das Einfügen von 17. \nlinker Knoten:  1, 4\nWurzel:         15\nrechter Knoten: 17, 22\n\nEinfügen von 3:\nlinker Knoten:  1, 3, 4\nWurzel:         15\nrechter Knoten: 17, 22",
    "type": "text",
    "answers": [
      {
        "text": "Linker Knoten",
        "solution": "1, 3, 4"
      },
      {
        "text": "Wurzel",
        "solution": "15"
      },
      {
        "text": "rechter Knoten",
        "solution": "17, 22"
      }
    ]
  },
  {
    "id": 2755,
    "category": 15,
    "difficulty": 2,
    "text": "Welche Speicherstrukturen  können aufgrund von Überlaufseiten langsamer werden? (nur die Kürzel in Großbuchstaben und in alphabetischer Reihenfolge)",
    "explanation": "Überlaufseiten verlangsamen den Lesezugriff bei ISAM und HASH, da die ursprüngliche Speicherstruktur zu einer linearen Liste ausarten kann, die sequentiell beim Lesen durchsucht werden muss.\n\n    \n\n    Die anderen Speicherstrukturen haben keine Überlaufseiten.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist einmal bei ...",
        "solution": "HASH"
      },
      {
        "text": "und dann noch bei ...",
        "solution": "ISAM"
      }
    ]
  },
  {
    "id": 2756,
    "category": 15,
    "difficulty": 3,
    "text": "Bei welchen Speicherstrukturen  werden Bereichsvergleiche wie z.B. <, >, >=, >= über den Schlüssel schlecht unterstützt? (Kürzel in Großbuchstaben und in alphabetischer Reihenfolge)",
    "explanation": "Bei HEAP werden die Datensätze unsortiert in der Reihenfolge der Eingabe gespeichert und dann auch wieder gelesen.\n\n    \n\n    Bei HASH wird ein in der Regel numerischer Schlüsselwert in eine Art logischer Seitennummer umgerechnet (z.B. Modulo-Verfahren). Benachbarte Nummern können somit in völlig unterschiedlichen Seiten gespeichert werden.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist einmal:",
        "solution": "\r\n    HASH\r"
      },
      {
        "text": "und zum anderen ...",
        "solution": "HEAP"
      }
    ]
  },
  {
    "id": 2761,
    "category": 12,
    "difficulty": 2,
    "text": "Welche  der folgenden Code-Abschnitte aus PL/SQL sind syntaktisch korrekt?",
    "explanation": "Funktionen müssen in PL/SQL einen Rückgabewert haben, PL/SQL-Prozeduren haben dagegen keinen Rückgabewert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "\n\nCREATE OR REPLACE FUNCTION durchschnitt_berechnen \n  (p_wert1  IN  NUMBER, p_wert2  IN  NUMBER)\n  RETURN number\nIS \nBEGIN\n  RETURN (p_wert1 + p_wert2) / 2;\nEND;",
        "solution": "true"
      },
      {
        "text": "\n\nCREATE OR REPLACE FUNCTION durchschnitt_berechnen \n  (p_wert1  IN  NUMBER, p_wert2  IN  NUMBER)\n  RETURN number\nIS \nBEGIN\n  p_wert1 + p_wert2 / 2;\nEND;",
        "solution": "false"
      },
      {
        "text": "\n\nCREATE OR REPLACE procedure durchschnitt_berechnen \n  (p_wert1  IN  NUMBER, p_wert2  IN  NUMBER)\n  RETURN number\nIS \nBEGIN\n  RETURN (p_wert1 + p_wert2) / 2;\nEND;",
        "solution": "false"
      },
      {
        "text": "\n\nCREATE OR REPLACE procedure durchschnitt_berechnen \n  (p_wert1  IN  NUMBER, p_wert2  IN  NUMBER)\nIS \n  ergebnis number;\nBEGIN\n  ergebnis := (p_wert1 + p_wert2) / 2;\nEND;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2765,
    "category": 6,
    "difficulty": 2,
    "text": "Welche CONSTRAINTS können als Spalten-Constraint definiert werden?",
    "explanation": "Alle 5 Constraint-Typen können als Spaltenbedingung formuliert werden. NOT NULL ist der einzige CONSTRAINT-Typ, der nicht als Tabellenbedingung geschrieben werden kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NOT NULL",
        "solution": "true"
      },
      {
        "text": "PRIMARY KEY",
        "solution": "true"
      },
      {
        "text": "CHECK",
        "solution": "true"
      },
      {
        "text": "UNIQUE",
        "solution": "true"
      },
      {
        "text": "REFERENCES",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2768,
    "category": 6,
    "difficulty": 3,
    "text": "Welche abhängigen Objekte werden unter ORACLE-SQL gelöscht, wenn eine Tabelle gelöscht wird, für die dieses Objekt definiert ist?",
    "explanation": "Synonyme und Views bleiben bestehen, allerdings wird der Status auf INVALID gesetzt. Nur abhängige Indizes werden gelöscht, z.B. der Primärschlüssel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "VIEWS",
        "solution": "false"
      },
      {
        "text": "SYNONYME",
        "solution": "false"
      },
      {
        "text": "INDIZES",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2770,
    "category": 14,
    "difficulty": 2,
    "text": "Betrachten Sie die folgenden Anweisungen in Oracle-SQL:\n\n    COMMIT; SAVEPOINT POINT_A;\n\n    CREATE TABLE CLASSES CLASS_ID NUMBER(13) PRIMARY KEY, INSTRUCTOR_ID NUMBER(13));\n\n    INSERT INTO CLASSES VALUES (1,1);\n\n    INSERT INTO CLASSES VALUES (2,2);\n\n    SAVEPOINT POINT_B; INSERT INTO CLASSES VALUES (3,3);\n\n    ROLLBACK WORK TO POINT_A; INSERT INTO CLASSES VALUES (4,4);\n\n    ROLLBACK WORK TO POINT_B; COMMIT;\n\n    Wieviele Datensätze stehen nach diesen Anweisungen in der Tabelle CLASSES?",
    "explanation": "CREATE TABLE bewirkt ein implizites COMMIT, so dass der SAVEPOINT A aufgehoben wird. Die Datensätze 3 und 4 werden dagegen vor dem endgültigen COMMIT zurückgerollt.",
    "type": "text",
    "answers": [
      {
        "text": "Tragen Sie eine Zahl ein!",
        "solution": "\r\n    2\r"
      }
    ]
  },
  {
    "id": 2771,
    "category": 6,
    "difficulty": 2,
    "text": "Verursachen die folgenden SQL-Befehle unter ORACLE einen Fehler? \n\n    CREATE TABLE TEST (nr number);\n\n    CREATE VIEW TEST AS SELECT * FROM TEST;",
    "explanation": "Unter Oracle-SQL können nicht zwei Objekte mit dem gleichen Namen angelegt werden, auch wenn sie unterschiedlichen Typs, wie Tabellen und Sichten sind. Alle Objekte, auf die ein Benutzer Zugriff hat, findet man in der Dictionary-View USER_OBJECTS.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2772,
    "category": 7,
    "difficulty": 2,
    "text": "Welche SELECT-Abfrage mit DISTINCT filtert aus einer Tabelle(Spalte1, Spalte2) alle Werte heraus, dies sowohl in der Spalte1 als auch in der Spalte2 verschiedene Werte haben?",
    "explanation": "Das Schlüsselwort DISTINCT kann nur einmal in der SELECT-Klausel vorkommen, und zwar vor dem ersten Spaltennamen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT DISTINCT SPALTE1, SPALTE2\nFROM Tabelle;",
        "solution": "true"
      },
      {
        "text": "SELECT DISTINCT SPALTE1, DISTINCT SPALTE2\nFROM Tabelle;",
        "solution": "false"
      },
      {
        "text": "SELECT SPALTE1, DISTINCT SPALTE2\nFROM Tabelle;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2735,
    "category": 9,
    "difficulty": 3,
    "text": "Ausgehend von den Basisdatentypen und den zugelassenen Typkonstruktoren lässt sich das SQL-92-Modell in inline-Notation wie folgt beschreiben:",
    "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "MULTISET(ROW(Basisdatentyp))"
      }
    ]
  },
  {
    "id": 2764,
    "category": 6,
    "difficulty": 3,
    "text": "Welche CONSTRAINTS können nicht als Tabellen-Constraint definiert werden?",
    "explanation": "NOT NULL ist der einzige CONSTRAINT-Typ, der nicht als Tabellenbedingung geschrieben werden kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "NOT NULL",
        "solution": "true"
      },
      {
        "text": "PRIMARY KEY",
        "solution": "false"
      },
      {
        "text": "CHECK",
        "solution": "false"
      },
      {
        "text": "UNIQUE",
        "solution": "false"
      },
      {
        "text": "REFERENCES",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2773,
    "category": 6,
    "difficulty": 3,
    "text": "Welche SQL-Anweisung einhält ein implizites COMMIT?",
    "explanation": "Alle DDL-Anweisungen(CREATE, DROP, ALTER..)  beinhalten ein implizites COMMIT, im Gegensatz zu den DML-Anweisungen INSERT, UPDATE und DELETE.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DROP TABLE",
        "solution": "true"
      },
      {
        "text": "INSERT",
        "solution": "false"
      },
      {
        "text": "UPDATE",
        "solution": "false"
      },
      {
        "text": "DELETE",
        "solution": "false"
      },
      {
        "text": "SELECT",
        "solution": "false"
      },
      {
        "text": "CREATE TABLE",
        "solution": "true"
      },
      {
        "text": "CREATE VIEW",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2774,
    "category": 6,
    "difficulty": 2,
    "text": "Welchem Schemaobjekt kann man ein CONSTRAINT zuweisen?",
    "explanation": "CONSTRAINTS sind immer an eine Tabelle angehängt und können mit CREATE TABLE oder ALTER TABLE.. erzeugt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "TABLE",
        "solution": "true"
      },
      {
        "text": "VIEW",
        "solution": "false"
      },
      {
        "text": "INDEX",
        "solution": "false"
      },
      {
        "text": "SEQUENCE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2775,
    "category": 6,
    "difficulty": 2,
    "text": "Betrachten Sie den folgenden CREATE-TABLE-Befehl:\n\n    CREATE TABLE Person (\n\n    ID NUMBER,\n\n    NACHNAME VARCHAR2,\n\n    TYP CHAR);\n\n    \n\n    Welche Aussage/n sind/ist korrekt?",
    "explanation": "NUMBER und CHAR kommen ohne Längenangabe aus, NUMBER ist eine Fließkommazahl, CHAR ein Textfeld der Länge 1.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil NUMBER ohne Nachkommastellen nicht zugelassen ist.",
        "solution": "false"
      },
      {
        "text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil CHAR eine Länge , z.B. CHAR(10) haben muss.",
        "solution": "false"
      },
      {
        "text": "Der CREATE-TABLE -Befehl wirft einen Fehler, weil VARCHAR2 eine Länge , z.B. VARCHAR(10) haben muss.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2777,
    "category": 14,
    "difficulty": 3,
    "text": "Mit welchem Schlüsselwort kann man eine Stelle definieren, bis zu der ein ROLLBACK zurückrollen soll?",
    "explanation": "SAVEPOINT ist ein SQL-Befehl, der angibt, bis zu welcher SQL-DML-Anweisung ein ROLLBACK zurückrollen soll.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist ein",
        "solution": "\r\n    SAVEPOINT\r"
      }
    ]
  },
  {
    "id": 2778,
    "category": 7,
    "difficulty": 2,
    "text": "Welche Klauseln muss ein UPDATE-STATEMENT haben?",
    "explanation": "Ein UPDATE ohne WHERE ist zulässig und ändert alle Tupel der Tabelle. UPDATE selber und SET sind notwendig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "UPDATE",
        "solution": "true"
      },
      {
        "text": "SET",
        "solution": "true"
      },
      {
        "text": "WHERE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2738,
    "category": 9,
    "difficulty": 3,
    "text": "Ausgehend von den Basisdatentypen und den zugelassenen Typkonstruktoren lässt sich das relationale Modell in inline-Notation wie folgt beschreiben:",
    "explanation": "MULTISET ( ROW ( Basisdatentyp ) ) beschreibt das Datenmodell von SQL, das relationale Datenmodell der relationalen Algebra wird durch SET ( ROW ( Basisdatentyp ) ) beschrieben.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist:",
        "solution": "SET(ROW(Basisdatentyp))"
      }
    ]
  },
  {
    "id": 2780,
    "category": 6,
    "difficulty": 2,
    "text": "SEQUENZEN sind immer automatisch mit einer Tabelle verbunden und dienen dazu, Werte in einer Spalte beim Einfügen von Daten automatisch zu erhöhen.",
    "explanation": "SEQUENZEN werden mit einem CREATE SEQUENCE(...) -Befehl angelegt und sind damit als eigenständige Datenbankobjekte nicht mit einer Tabelle verknüpft. Theoretisch können Sie daher zum Generieren von fortlaufenden Nummern in mehreren Tabellen verwendet werden, auch wenn das aus Gründen der Übersichtlichkeit nicht empfehlenswert ist.  \n\nsiehe <a  href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-SEQUENCE\"> SEQUENCE im DB-Wiki",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2785,
    "category": 7,
    "difficulty": 1,
    "text": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX)",
    "explanation": "Die SQL-Gruppenfunktionen (COUNT, SUM, AVG, MIN, MAX) gehören zum SQL-Standard und fassen Werte aus unterschiedlichen Tupeln zu genau einem Wert zusammen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "geben immer genau einen Wert zurück.",
        "solution": "true"
      },
      {
        "text": "Können auch mehrere Werte zurückgeben.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2674,
    "category": 14,
    "difficulty": 1,
    "text": "Welcher Prüfungszeitpunkt (CONSTRAINT_CHARACTERISTICA) führt dazu, dass beim Erkennen eines Fehlers nur die fehlerhafte DML-Anweisung zurückgesetzt wird und die übrigen Datensätze der laufenden Transaktion nicht betroffen sind?",
    "explanation": "Werden Datenänderungen ausgeführt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integritätsbedingung geprüft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung rückgängig gemacht. Die übrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl löst das Transaktionsende aus und damit die Prüfung aller CONSTRAINTs (Integritätsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \n\nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden während einer Transaktion erst mal akzeptiert und er zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs geprüft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, führt dies zur Anzeige einer Fehlermeldung und zum Zurückrollen der gesamten Transaktion.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INITIALLY DEFERRED",
        "solution": "false"
      },
      {
        "text": "INITIALLY IMMEDIATE",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2659,
    "category": 7,
    "difficulty": 3,
    "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte folgende Werte enthält: 3000, 4000, NULL, 2000, 4000.    \n     \nSELECT SUM(gehalt*12) Jahresgehalt FROM Mitarbeiter;",
    "explanation": "Die numerische Operation gehalt*12 liefert für den NULL-Datensatz zwar als Ergebnis wieder NULL, der SUM-Oerator ignoriert hingegen die NULL-Werte und kommt zu dem Ergebnis: 3000+4000+2000+4000 = 13000.",
    "type": "text",
    "answers": [
      {
        "text": "Das Ergebnis ist:",
        "solution": "156000"
      }
    ]
  },
  {
    "id": 2662,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle:\nCREATE TABLE Zeitschrift (\n       Zeitschrift_id           INTEGER NOT NULL,\n       Namen                    VARCHAR2(20) NULL,\n       PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz (\n       Aufsatz_id              INTEGER NOT NULL,\n       Titel                      VARCHAR2(20) NULL,\n       Zeitschrift_id            INTEGER NOT NULL,\n       PRIMARY KEY (Aufsatz_id), \n       FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift);      \n\nDie Tabellen enthalten folgende Datensätze: \nZeitschrift (1, 'DB-Spektrum');\nZeitschrift (2, 'Informatik-Spektrum');\n\nAufsatz (1, 'Tuning', 1); \nAufsatz (2, 'DWH', 1); \n\nKann es problematisch werden, wenn Aufsatz-Datensätze gelöscht werden?",
    "explanation": "Es ist kein Problem, weil Aufsatz die Detail-Tabelle ist. \nProblematisch wäre es, wenn Master-Datensätze (hier Zeitschrift) gelöscht werden, weil dann vor dem Löschen geprüft wird, ob es abhängige Datensätze (Detail: Aufsatz) mit einem passenden Fremdschlüsselwert gibt. Wenn ja, wird nicht gelöscht. Nur wenn nicht, wird der Master-Datensatz gelöscht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ja",
        "solution": "false"
      },
      {
        "text": "nein",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2663,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie die beiden folgenden CREATE-Table_Befehle: \nCREATE TABLE Zeitschrift (\n       Zeitschrift_id           INTEGER NOT NULL,\n       Namen                    VARCHAR2(20) NULL,\n       PRIMARY KEY (Zeitschrift_id));\n\nCREATE TABLE Aufsatz (\n       Aufsatz_id              INTEGER NOT NULL,\n       Titel                      VARCHAR2(20) NULL,\n       Zeitschrift_id            INTEGER NOT NULL,\n       PRIMARY KEY (Aufsatz_id), \n       FOREIGN KEY (Zeitschrift_id) REFERENCES Zeitschrift); Die Tabellen enthalten folgende Datensätze: Zeitschrift (1, \"DB-Spektrum\"); Zeitschrift (2, \"Informatik-Spektrum\"); Aufsatz (1, \"Tuning\", 1); Aufsatz (2, \"DWH\", 1); Kann es problematisch werden, wenn Zeitschrift-Datensätze gelöscht werden?",
    "explanation": "Es kann ein Problem sein, weil Zeitschrift die Master-Tabelle ist.\n\n    Wenn Master-Datensätze (hier Zeitschrift) gelöscht werden wird vor dem Löschen geprüft, ob es abhängige Datensätze (Detail: Aufsatz) mit einem passenden Fremdschlüsselwert gibt. Wenn ja, wird nicht gelöscht. Nur wenn nicht, wird der Master-Datensatz gelöscht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ja",
        "solution": "true"
      },
      {
        "text": "nein",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2687,
    "category": 1,
    "difficulty": 1,
    "text": "ANSI-3-Ebenen-Modell: Die Organisation der physischen Speicherung wird geändert.",
    "explanation": "Schon 1975 verabschiedete ANSI/SPARC6 einen Standard, nach dem sich die Architektur von Datenbanken richtet. Das Architekturmodell unterscheidet drei Abstraktionsebenen oder Sichten:\n\nExterne Ebene \nDie externe Ebene enthält die Benutzersichten auf die Daten bzw. den Ausschnitt aus den Gesamtdaten, den spezielle Benutzergruppen benötigen. Diese Ebene wird vom Datenbankentwickler verwaltet.\n\nKonzeptionelle Ebene\nDiese Ebene hat die logische Darstellung der Gesamtsicht der Daten in einem speziellen Datenmodell, z.B. dem relationalen Datenmodell zum Inhalt. Man differenziert hier zwischen dem konzeptionellen Schema, wie dem ER-Modell, welches noch unabhängig vom konkret eingesetzten Datenmodell ist, und dem logischen Datenbankschema, welches schon auf das Modell eines bestimmten Datenbanktyps angepasst ist. Diese Ebene wird primär vom Datenbankentwickler verwaltet.\n\nInterne Ebene\nInformation über die Art und den Aufbau der Datenstrukturen auf dem physikalischen Speicher und Zugriffsmechanismen sind Bestandteil der internen Ebene. Diese Ebene wird vom Datenbankadministrator verwaltet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Diese Änderung betrifft die interne Ebene.",
        "solution": "true"
      },
      {
        "text": "Diese Änderung betrifft die externe Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft die konzeptionelle Ebene.",
        "solution": "false"
      },
      {
        "text": "Diese Änderung betrifft keine Ebene.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2652,
    "category": 15,
    "difficulty": 2,
    "text": "Die Anordnung der Schlüsselwerte in einem B-Baum hängt von der Reihenfolge der Eingabe der Werte ab, d.h. z.B. {1,2,3,4,5,6,7,8,9} ergibt einen anderen B-Baum als [9,8,7,6,5,4,3,2,1}.",
    "explanation": "Es gibt verschiedene B-Bäume mit den gleichen Werten, aber unterschiedlichem Aufbau. Dies hängt mit der Konstruktionsvorschrift für B-Bäume zusammen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2653,
    "category": 14,
    "difficulty": 3,
    "text": "Es ist die folgende leere Tabelle gegeben: busfahrer(mita_id, stundenlohn), wobei mita_id eine Primärschlüsselspalte (Prüfungszeitpunkt: IMMEDIATE) ist und stundenlohn eine Pflichteingabespalte (Prüfungszeitpunkt: DEFERRED).\n\n    Es sind folgende Transaktionen gegeben:\n\n    INSERT INTO busfahrer VALUES (4711, 6);\n\n    INSERT INTO busfahrer VALUES (4712, 0);\n\n    SELECT mita_id FROM busfahrer; -- 1. SELECT\n\n    INSERT INTO busfahrer VALUES (4711, 8);\n\n    SELECT mita_id FROM busfahrer; -- 2. SELECT\n\n    COMMIT;\n\n    SELECT mita_id FROM busfahrer; -- 3.SELECT\n\n    INSERT INTO busfahrer VALUES (4713, NULL);\n\n    SELECT mita_id FROM busfahrer; -- 4. SELECT\n\n    INSERT INTO busfahrer VALUES (4714, 9);\n\n    SELECT mita_id FROM busfahrer; -- 5. SELECT\n\n    COMMIT;\n\n    SELECT mita_id FROM busfahrer; -- 6. SELECT\n\n    Geben Sie für jedes SELECT-Anweisung an, welche Ergebnismenge angezeigt wird, wobei mehrere Datensätze durch ein Semikolon getrennt sind und schreiben Sie NO ROWS, falls der SELECT keine Zeilen liefert!",
    "explanation": "1. SELECT: 4711; 4712\n\n    \n\n    2. SELECT: 4711; 4712\n\n    Der 3. INSERT (4711,8) wird unmittelbar abgebrochen, weil er die Primärschlüsselbedingung verletzt.\n\n    \n\n    3. SELECT: 4711; 4712\n\n    COMMIT beendet die 1. Transaktion und da durch die beiden Datensätze das DEFERRED-Constraint nicht verletzt ist, werden die beiden Datensätze persistent gespeichert und können durch kein Zurückrollen von Transaktionen mehr entfernt werden.\n\n    \n\n    4. SELECT: 4711; 4712\n\n    Mit der Einfügung (4713, NULL) startet die 2. Transaktion. Sie verletzt das Pflichteingabe-Constraint für die 2. Spalte, wird jedoch erst einmal eingefügt, da dieses Constraint mit dem Prüfungszeitpunkt DEFERRED definiert ist. Diese Bedingung erst also zum COMMIT geprüft.\n\n    \n\n    5. SELECT: 4711; 4712; 4713; 4714\n\n    Die Einfügung (4714, 9) verletzt keine Constraints.\n\n    \n\n    6. SELECT: 4711; 4712 Dieses 2. COMMIT schließt die 2. Transaktion mit einer DEFERRED-Integritätsptügung ab, stellt einen Fehler fest für (4713, NULL) und rollt diese 2. Transaktion bis zum 1. COMMIT zurück, so dass nur noch die Datensätze der 1. Transaktion persistent in der DB gespeichert sind.",
    "type": "text",
    "answers": [
      {
        "text": "Ergebnis 1.SELECT",
        "solution": "4711; 4712"
      },
      {
        "text": "Ergebnis 2.SELECT",
        "solution": "4711; 4712"
      },
      {
        "text": "Ergebnis 3.SELECT:",
        "solution": "4711; 4712"
      },
      {
        "text": "Ergebnis 4.SELECT:",
        "solution": "4711; 4712; 4713"
      },
      {
        "text": "Ergebnis 5. SELECT:",
        "solution": "4711; 4712; 4713; 4714"
      },
      {
        "text": "Ergebnis 6. SELECT:",
        "solution": "4711; 4712"
      }
    ]
  },
  {
    "id": 2676,
    "category": 14,
    "difficulty": 3,
    "text": "Wie nennt man das folgende Problem:\nWährend einer Transaktion A wird eine Anfrage mehrmals gestellt und zwischenzeitlich werden durch andere Transaktionen neue Datensätze eingefügt.",
    "explanation": "LOST UPDATE (verlorene Änderungen) ist das Problem, das auf dem Überschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgeführter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn Änderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zuückgerollt werden (ROLLBACK, Integritätsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgeführte Transaktionen die Daten zwischenzeitlich geändert bzw. gelöscht haben (NON REPEATABLE READ) oder neue Datensätze eingefügt wurden (PHANTOME).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DIRTY READ",
        "solution": "false"
      },
      {
        "text": "PHANTOM",
        "solution": "true"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "false"
      },
      {
        "text": "LOST UPDATE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2677,
    "category": 14,
    "difficulty": 2,
    "text": "Wie nennt man das folgende Problem:\nWährend einer Transaktion A wird eine Anfrage mehrmals gestellt und zwischenzeitlich werden durch andere Transaktionen Datensätze gelöscht bzw. ihre Werte geändert.",
    "explanation": "LOST UPDATE (verlorene Änderungen) ist das Problem, das auf dem Überschreiben von nicht gelesenen Aktualisierungen zwischenzeitlich ausgeführter anderer Transaktionen basiert. \nDIRTY READ (unsauberes Lesen) ist das Problem, das sich ergibt, wenn Änderungen, die zwischenzeitlich bereits durch andere Transaktionen verarbeitet wurden, zuückgerollt werden (ROLLBACK, Integritätsfehler beim COMMIT, etc.).\nPHANTOME und NON REPEATABLE READ (nicht wiederholbares Lesen) sind verwandte Probleme, bei denen es darum geht, dass bei wiederholtem Lesen innerhalb einer Transaktion unterschiedliche Ergebnismengen ermittelt werden, weil parallel ausgeführte Transaktionen die Daten zwischenzeitlich geändert bzw. gelöscht haben (NON REPEATABLE READ) oder neue Datensätze eingefügt wurden (PHANTOME).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DIRTY READ",
        "solution": "false"
      },
      {
        "text": "PHANTOM",
        "solution": "false"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "true"
      },
      {
        "text": "LOST UPDATE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2673,
    "category": 14,
    "difficulty": 1,
    "text": "Bei welchem Prüfungszeitpunkt (= CONSTRAINT_CHARACTERISTICA ) wird die Datenprüfung sofort nach einer Datenänderung (INSERT, UPDATE, DELETE) durchgeführt?",
    "explanation": "Werden Datenänderungen ausgeführt, die CONSTRAINTs mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY IMMEDIATE\" betreffen, dann wird unmittelbar im Anschluss an die DML-Anweisung die Integritätsbedingung geprüft. \nTritt ein Fehler auf, so wird eine Meldung angezeigt und nur diese eine fehlerhafte Anweisung rückgängig gemacht. Die übrigen Anweisungen der laufenden Transaktion sind nicht von diesem Fehler betroffen. \n\n\nDer COMMIT-Befehl löst das Transaktionsende aus und damit die Prüfung aller CONSTRAINTs (Integritätsbedingungen), die mit dem CONSTRAINT_CHARACTERISTICA \"INITIALLY DEFERRED\" definiert wurden. \nAnweisungen mit Fehlern, die DEFERRED-CONSTRAINTs betreffen, werden während einer Transaktion erst mal akzeptiert und er zum COMMIT-Zeitpunkt werden die entsprechenden DEFERRED-CONSTRAINTs geprüft und die Fehler erkannt. \nWenn ein DEFERRED-Fehler auftritt, führt dies zur Anzeige einer Fehlermeldung und zum Zurückrollen der gesamten Transaktion.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INITIALLY IMMEDIATE",
        "solution": "true"
      },
      {
        "text": "INITIALLY DEFERRED",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2660,
    "category": 7,
    "difficulty": 3,
    "text": "Was ist das Ergebnis der folgenden SELECT-Klausel, wenn die Gehaltsspalte folgende Werte enthält: 1000, 4000, NULL, 3000, 2000.    \n     \nSELECT AVG(gehalt*12) Durchschnitt_Jahresgehalt FROM Mitarbeiter;",
    "explanation": "Die numerische Operation gehalt*12 liefert für den NULL-Datensatz zwar als Ergebnis wieder NULL, der AVG-Operator ignoriert hingegen, die Datensätze mit NULL-Werten und kommt zu dem Ergebnis: (1000+4000+3000+2000)/4 = 10000/4 = 2500.",
    "type": "text",
    "answers": [
      {
        "text": "Das Ergebnis ist:",
        "solution": "30000"
      }
    ]
  },
  {
    "id": 2661,
    "category": 7,
    "difficulty": 3,
    "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank:\n\nAbteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Ang_Nr}\nAngestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr }\n\nWelche SELECT-Abfrage entspricht dem natürlichen Join?",
    "explanation": "RICHTIG wäre: \nSELECT * FROM Angestellte, Abteilungen \nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr\nAND   Angestellte.ORT = Abteilungen.ORT\nAND   Angestellte.ANG_Nr = Abteilungen.ANG_NR;\" \nweil ein Natural Join, über alle Spalten dieser Tabellen, die gleich heißen, Abt_Nr, Ort, Ang_Nr, auf Gleichheit verglichen werden und die Teilbedingungen mit AND verknüpft werden. \noder diese Anfrage: \nSELECT * FROM Angestellte NATURAL JOIN Abteilungen;\n\n\nDie Semantik dieses natürlichen Joins heißt: \"Welche Mitarbeiter arbeiten in Abteilungen, deren Leiter sie sind und deren Abteilung an ihrem Wohnort liegt.\"\n\n\nFALSCH sind: \nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen;\" ist das kartesische Produkt und verknüpft jeden Datensatz der Angestellten mit jedem Datensatz der Abteilungen ohne irgendwelche Vergleiche. \n\nDie Anfrage \"SELECT * FROM Angestellte, Abteilungen WHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;\" \nist kein NATURAL JOIN weil nur über eine der drei gleich lautenden Spalten verknüpft wird und nicht über alle drei!",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM Angestellte, Abteilungen;",
        "solution": "false"
      },
      {
        "text": "SELECT * FROM     Angestellte, Abteilungen\nWHERE Angestellte.ABT_Nr = Abteilungen.ABT_Nr;",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2667,
    "category": 14,
    "difficulty": 3,
    "text": "Wie nennt man das Verfahren, das nach folgender Methode verfährt:\n\n- Man nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden.\n- Lesende Zugriffe (SELECT) lösen keine Sperren aus.\n- Jeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird.\n- Bei Änderungen wird zunächst geprüft, ob der Zeitstempel unverändert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unverändert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.",
    "explanation": "Passive und dynamische Sperrverfahren gibt es nicht.\n\nOptimistisches Sperrverfahren \nMan nimmt an, dass wenige schreibende Zugriffe auf der Datenbank stattfinden. Lesende Zugriffe (SELECT) lösen keine Sperren aus.\nJeder Datensatz hat ein Feld \"Zeitstempel\", das bei jedem lesenden oder schreibenden Zugriff aktualisiert wird. Bei Änderungen wird zunächst geprüft, ob der Zeitstempel unverändert ist. Ist dies nicht der Fall, wird der Benutzer aufgefordert, den Datensatz noch einmal zu lesen. Wenn der Zeitstempel unverändert ist, wird der Datensatz mit einem auf das Systemdatum aktualisierten Zeitstempel abgespeichert.\n\nPessimistisches Sperrverfahren\nMan nimmt an, dass viele schreibende Zugriffe auf der Datenbank stattfinden.Auch lesende Zugriffe (SELECT FOR UPDATE statt SELECT) lösen Sperren für andere Benutzer aus.Die Daten werden erst wieder freigegeben, wenn alle Änderungen abgespeichert sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "optimistisch",
        "solution": "true"
      },
      {
        "text": "pessimistisch",
        "solution": "false"
      },
      {
        "text": "dynamisch",
        "solution": "false"
      },
      {
        "text": "passiv",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2679,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Probleme sind Probleme der Nebenläufigkeitskontrolle?",
    "explanation": "Bei der Nebenläufigkeitskontrolle geht es darum, dass mehrere Transaktionen parallel ausgeführt werden und das Ergebnis das gleiche wie im \"Single User-Betrieb\" ist, die Transaktionen sich also nicht gegenseitig beeinflussen. Es ist das I der ACID-Eigenschaften (I für Isolation).\n\nDaraus resultieren im wesentlichen zwei Probleme:\n\n\"Lost Update\" ist ein Problem der Nebenläufigkeitskontrolle weniger der Lesekonsistenz. \n\"Dirty Read\" ist ein Problem, das beiden Aufgabenstellungen, Nebenläufigkeitskontrolle wie auch Lesekonsistenz betrifft. \n\n\"Phantome\" und \"Non Repeatable Reads\" sind vorrangig Probleme der Lesekonsistenz.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LOST UPDATE",
        "solution": "true"
      },
      {
        "text": "DIRTY READ",
        "solution": "true"
      },
      {
        "text": "PHANTOM",
        "solution": "false"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2678,
    "category": 14,
    "difficulty": 3,
    "text": "Welche Probleme sind Probleme der Lesekonsistenz?",
    "explanation": "Lesekonsistenz ist ein weiteres Problem, welches beim Mehrbenutzerbetrieb auftritt. Bei länger andauernden Transaktionen stellt sich die Frage, auf welchem Datenbankzustand die Anfragen eigentlich ausgewertet werden, wenn parallel andere Benutzer die zu lesenden Daten ändern.\n\nDaraus resultieren mehrere Probleme: \n\nBei innerhalb einer Transaktion wiederholten Anfragen können bei der Wiederholung Datensätze angezeigt werden, die vorher nicht da waren, also \"Phantome\", bzw. es werden Datensätze nicht mehr angezeigt oder mit geänderten Inhalt, also \"nicht wiederholbares Lesen\".  Grund dafür sind jeweils andere Transaktionen, die ihre Änderungen persistent gespeichert haben (COMMIT).\n\nEin anderes Problem stellt sich bei langandauernden Anfragen, was passiert mit den Änderungen parallel ausgeführter Transaktionen, die zwischenzeitlich ihre Änderungen persistent gespeichert haben. (COMMIT).\n\n\"Dirty Read\" ist ein Problem, das beiden Aufgabenstellungen, Nebenläufigkeitskontrolle wie auch Lesekonsistenz betrifft.\n\n\"Lost Update\" ist ein Problem der Nebenläufigkeitskontrolle weniger der Lesekonsistenz.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "LOST UPDATE",
        "solution": "false"
      },
      {
        "text": "DIRTY READ",
        "solution": "true"
      },
      {
        "text": "PHANTOM",
        "solution": "true"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2937,
    "category": 3,
    "difficulty": 1,
    "text": "In obligatorischen Attributen (ER-Modell) sind NULL-Werte erlaubt.",
    "explanation": "Obligatorisch bedeutet, dass das Attribut einen Wert haben muss, also nicht NULL sein darf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3159,
    "category": 13,
    "difficulty": 1,
    "text": "INSTEAD-OF-TRIGGER  gehören zum SQL-Standard.",
    "explanation": "INSTEAD-OF-Trigger sind ein ORACLE-Feature, das nur für Views definert ist und damit Views änderbar macht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3160,
    "category": 7,
    "difficulty": 2,
    "text": "INSTEAD-OF-TRIGGER  können unter Oracle-SQL definiert werden",
    "explanation": "INSTEAD-OF.Trigger sind ein ORACLE-Feature, das nur für Views definert ist und damit Views änderbar macht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "auf Tabellen",
        "solution": "false"
      },
      {
        "text": "auf views",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3182,
    "category": 4,
    "difficulty": 1,
    "text": "Welcher Join-Operator ist immer verlustfrei?",
    "explanation": "Eine Join-Operation zwischen R und S heißt verlustfrei, wenn alle Tupel von R und S am Verbund teilnehmen. Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis. Bei allen Join-Operatoren bis auf den Full-Outer-Join können Tupel, die in der verknüpften Operation kein Gegenüber haben, wegfallen.",
    "type": "text",
    "answers": [
      {
        "text": "Das ist der:",
        "solution": "Full Outer Join"
      }
    ]
  },
  {
    "id": 3084,
    "category": 8,
    "difficulty": 1,
    "text": "Jahr ist eine Spalte vom Typ DATE. Welche der WHERE-Bedingungen ist die kostengünstigeste/schnellste?",
    "explanation": "Die Konvertierungsfunktionen TO_NUMBER und TO_CHAR sind für die Spalte Jahr programmiert und werden somit in diesem Beispiel für jeden Spaltenwert ausgeführt, also für jeden Datensatz. Die TO_DATE-Funktion hingegen ist hier für einen String programmiert und wird daher nur einmal bei der Kompilierung der Anweisung ausgeführt. Je mehr Datensätze die Tabelle hat, umso mehr Zeit spart die TO_DATE-Funktion mit dem String als Parameter.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "WHERE TO_CHAR(Jahr, 'RRRR') BETWEEN '2010' AND '2012'",
        "solution": "false"
      },
      {
        "text": "WHERE Jahr BETWEEN TO_DATE('01.01.2010', 'DD.MM.RRRR') AND TO_DATE('31.12.2012', 'DD.MM.RRRR')",
        "solution": "true"
      },
      {
        "text": "WHERE TO_NUMBER(Jahr) BETWEEN 2010 AND 2012",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3115,
    "category": 12,
    "difficulty": 3,
    "text": "Betrachten Sie den folgenden PL/SQL-Programm-Code:\n\nCREATE OR REPLACE ang_insert(\n  p_ang_nr number,p_nachname varchar) is\nBEGIN\n  INSERT INTO mitarbeiter values (p_ang_nr, p_nachname)\nEND;\n\nDie obige Prozedur wird von Benutzer Hugo angelegt, auch Paul soll die Prozedur ausführen.\n\nWelche Aussagen sind korrekt?",
    "explanation": "Unter Oracle-PL/SQL werden Prozeduren und Funktionen per Definition mit den Objektprivilegien des Prozedureigentümers ausgeführt.\n(siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/GRANT#EXECUTE\" target=\"_blank\"> GRANT EXECUTE ).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Hugo muss Paul nur einen GRANT EXCEUTE auf der Prozedur ang_insert erteilen.",
        "solution": "true"
      },
      {
        "text": "Hugo muss Paul einen GRANT EXCEUTE auf der Prozedur ang_insert und einen GRANT INSERT auf mitarbeiter erteilen",
        "solution": "false"
      },
      {
        "text": "Die Prozedur ang_insert wird mit den Objektpriviliegien des Benutzer Hugo ausgeführt.",
        "solution": "true"
      },
      {
        "text": "Die Prozedur ang_insert  wird mit den Objektpriviliegien des Benutzer Paul ausgeführt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3129,
    "category": 12,
    "difficulty": 2,
    "text": "Ein PL/SQL CURSOR enthält immer eine SELECT-Anweisung mit einer INTO-Klausel.",
    "explanation": "Ein CURSOR ersetzt gerade die INTO -Klausel einer SELECT-.Abweisung. SELECT mit INTO deklariert einen impliziten CURSOR. Der Grund dafür ist, dass Sie im deklarativen Bereich nur einen Cursor definieren, aber keine Zeilen in den Cursor abrufen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3488,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussage über Unterabfragen ist wahr?\n\n    Unterabfragen mit ALL und ANY können verneint werden, d.h. eine Unterabfrage der Form\n\n    SELECT  Nachname, Gehalt\n\n    FROM  Angestellte\n\n    WHERE  Gehalt > NOT ALL\n\n    (SELECT  Gehalt\n\n    FROM  Angestellte a, Abteilungen b\n\n    WHERE  a.Abt_Nr = b.Abt_Nr  AND Leiter = 4);\n\n    ist syntaktisch korrekt.",
    "explanation": "Unterabfragen mit ANY oder All könen leider nicht verneint werden.\n\n    siehe Erklärungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3478,
    "category": 8,
    "difficulty": 1,
    "text": "Welche Aussage über den Query-Executen-Plan bei Oracle ist wahr?",
    "explanation": "Wenn man unter Oracle z.B. mit \"EXPLAIN PLAN SET ..sql_anweisung...\" den Query-Executen-Plan erzeugt, wird für die genannte SQL-Anweisung nur der Query-Executen-Plan erzeugt und in der plan_tabelle abgespeichert. Die Anweisung selber wird dabei nicht ausgeführt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wenn man den Oracle-Query-Executen-Plan erzeugt, wird nur der Query-Executen-Plan  erzeugt und die SQL-Anweisung selber nicht ausgeführt.",
        "solution": "true"
      },
      {
        "text": "Wenn man den Oracle-Query-Executen-Plan erzeugt, wird der Query-Executen-Plan erzeugt und die SQL-Anweisung selber ausgeführt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2915,
    "category": 5,
    "difficulty": 1,
    "text": "Für die Festlegung der 2NF braucht man einen Primärschlüssel",
    "explanation": "Die Definition der 2NF lautet:Eine Relation R mit Primärschlüssel S befindet sich in der zweiten \nNormalform (2NF), wenn sie (1NF) ist und jedes Nichtschlüsselattribut \nvoll funktional abhängig vom Primärschlüssel S ist.  Daher kann man die 2NF nur festlegen, wenn man vorher den Primärschlüssel kennt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2899,
    "category": 5,
    "difficulty": 2,
    "text": "Jede Überführung in eine Normalform (1NF, 2NF odr 3NF) verringert Redundanz in der Datenbank.",
    "explanation": "Die Überführung einer Relation in die 1NF erhöht in der Regel die Redundanz.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3099,
    "category": 8,
    "difficulty": 2,
    "text": "Welcher Join-Operator ist für größere Datenmengen und Equi-Joins geeignet?",
    "explanation": "Das ist der Hash Join, siehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#HASH_JOIN\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#HASH_JOIN",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Cartesian Join",
        "solution": "false"
      },
      {
        "text": "Nested Loop Join",
        "solution": "false"
      },
      {
        "text": "Hash Join",
        "solution": "true"
      },
      {
        "text": "Sort Merge Join",
        "solution": "false"
      },
      {
        "text": "Outer Join",
        "solution": "false"
      },
      {
        "text": "Index Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2878,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie die folgenden SQL-Anweisungen:\n\n    CREATE TABLE test (spalte varchar2(10));\n\n    INSERT INTO TEST VALUES (\"Ja\");\n\n    INSERT INTO TEST VALUES (\"Nein\");\n\n    INSERT INTO TEST VALUES (NULL);\n\n    COMMIT;\n\n    SELECT * FROM TEST WHERE Spalte in (\"Ja\", \"Nein\");\n\n    Welches Ergebnis hat diese SELECT-Abfrage?",
    "explanation": "Wegen der <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Dreiwertige-Logik\"> dreiwertigen Logik  in SQL liefert der Vergleich mit einem NULL-Wert den Wahrheitswert UNKNOWN, der in der WHERE-Klauesel zu FALSE ausgewertet wird. Es werden daher in der SELECT-Abfrage die Zeilen mit \"Ja\" und \"Nein\" ausgegeben.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die beiden Tupel mit den Werten 'Ja' und 'Nein'",
        "solution": "true"
      },
      {
        "text": "Keine Zeilen (no Rows)",
        "solution": "false"
      },
      {
        "text": "Diese Abfrage wirft einen Fehler.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3412,
    "category": 5,
    "difficulty": 2,
    "text": "Aus wie vielen Attributen muss ein Primärschlüssel einer Relation bestehen, damit es partielle funktionale Abhängigkeiten geben kann?",
    "explanation": "Falls der Primärschlüsel nur aus einem Attribut besteht, kann es keine partiellen Abhängigkeiten geben, da der Primärschlüssel nicht weiter aufgespalten werden kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ein Attribut",
        "solution": "false"
      },
      {
        "text": "Dies ist unabhängig voneinander",
        "solution": "false"
      },
      {
        "text": "zwei Attribute",
        "solution": "true"
      },
      {
        "text": "drei Attribute",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3360,
    "category": 3,
    "difficulty": 1,
    "text": "Um welchen Attributtyp handelt es sich hier primär?\n\n    Die Noten einer Hochschule können die Werte 1.0, 1.3, 1,7, ... ,5.0 annehmen.",
    "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zusätzlich der Größe nach ordnen und können verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zusätzlich auch Multiplikation und  Division,  zulassen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Zahl",
        "solution": "false"
      },
      {
        "text": "Intervall",
        "solution": "false"
      },
      {
        "text": "Ordinal",
        "solution": "true"
      },
      {
        "text": "Nominal",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3409,
    "category": 4,
    "difficulty": 1,
    "text": "Der Natural Join ist in der relationalen Algebra der einzige Join-Operator, der die Join-Spalten nur einmal ausgibt",
    "explanation": "Der Theta Join hat immer eine Bedingung und unterdrückt keine doppelten Spalten. Equi-Join und Outer-Joins bauen auf der Definition des Theta-Joins auf.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "false"
      },
      {
        "text": "stimmt",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3067,
    "category": 5,
    "difficulty": 3,
    "text": "Eine 1:1/1:c1-Beziehung zwischen zwei Entity-Mengen kann auf wie viele Relationen im Datenmodell abgebildet werden?",
    "explanation": "Für 1:1 bzw. 1:c1-Beziehungen gilt, dass die beiden Entity-Mengen entweder auf zwei Relationen abgebildet werden oder eben zu einer zusammengefasst werden. Das Zusammenfassen ist problemlos möglich, da beide Entity-Mengen über den gleichen Primärschlüssel verfügen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "nicht abbildbar",
        "solution": "false"
      },
      {
        "text": "1 Relation",
        "solution": "true"
      },
      {
        "text": "2 Relationen",
        "solution": "true"
      },
      {
        "text": "3 Relationen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3070,
    "category": 5,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C und den folgenden funktionalen Abhängigkeiten. Welche Arten funktionaler Abhängigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abhängigkeit als Antwort eintragen, also volle, partielle oder transitive.",
    "explanation": "B, D, E sind voll funktional vom gesamten Primärschlüssel A,C abhängig.\n\n    F ist von C abhängig, also nur von einem Teil des Primärschlüssels und damit ist F partiell von A,C abhängig.\n\n    E ist von D abhängig und D von A,C und damit ist E transitiv von A,C abhängig.",
    "type": "text",
    "answers": [
      {
        "text": "A, C -> B, D, E",
        "solution": "volle"
      },
      {
        "text": "D -> E",
        "solution": "transitive"
      },
      {
        "text": "C -> F",
        "solution": "partielle"
      }
    ]
  },
  {
    "id": 3072,
    "category": 3,
    "difficulty": 1,
    "text": "Wie werden n:m-/cn:cm-Beziehungen mit eigenen Attributen in einem ERD in ERwin dargestellt?",
    "explanation": "Im ERD-Zeichentool ERwin der Firma CA wird eine n:m-/cn:cm-Beziehung  mit eigenen Attributen als eine Zuordnungs-Entity-Menge dargestellt, die mit zwei 1:n/1:cn-Beziehungen mit den bestehenden Entiy-Mengen verknüpft wird.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es gibt keine Attribute für n:m-/cn:cm-Beziehungen.",
        "solution": "false"
      },
      {
        "text": "Es wird eine Zuordnungs-Entity-Menge erstellt, die mit zwei 1:n/1:cn-Beziehungen mit den bestehenden Entiy-Mengen verknüpft wird.",
        "solution": "true"
      },
      {
        "text": "Es wird eine Zuordnungs-Entity-Menge erstellt, die mit zwei n:m-/cn:cm-Beziehungen mit den bestehenden Entiy-Mengen verknüpft wird.",
        "solution": "false"
      },
      {
        "text": "Es wird eine Zuordnungs-Entity-Menge erstellt, die mit zwei 1:1/1:c1-Beziehungen mit den bestehenden Entiy-Mengen verknüpft wird.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3095,
    "category": 8,
    "difficulty": 1,
    "text": "Welche Tabellenzugriffsmethode liest bei Oracle alle Datensätze einer Tabelle unsortiert ein?",
    "explanation": "Der Full Table Scan liest alle Zeilen einer Tabelle sortiert ein, siehe \n<a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen  beim Index Full Scan werden die Daten zusätzlich sortiert über den Index",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "RowidScan",
        "solution": "false"
      },
      {
        "text": "Full Table Scan",
        "solution": "true"
      },
      {
        "text": "Index Full Scan",
        "solution": "false"
      },
      {
        "text": "Hash Scan",
        "solution": "false"
      },
      {
        "text": "Cluster Scan",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3097,
    "category": 8,
    "difficulty": 2,
    "text": "Welche Tabellenzugriffsmethoden gibt es bei Oracle?",
    "explanation": "Alle aufgeführten Zugriffsmethoden gibt es bei Oracle,  siehe \n<a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "RowidScan",
        "solution": "true"
      },
      {
        "text": "Full Table Scan",
        "solution": "true"
      },
      {
        "text": "Index Full Scan",
        "solution": "true"
      },
      {
        "text": "Hash Scan",
        "solution": "true"
      },
      {
        "text": "Cluster Scan",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3098,
    "category": 8,
    "difficulty": 1,
    "text": "Welcher Join-Operator ist für kleinere Datenmengen geeignet und enthält ineinander verschachtelte Schleifen?",
    "explanation": "Das ist der Nested Loop Join, \nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#NESTED_LOOPS\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#NESTED_LOOPS  .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Cartesian Join",
        "solution": "false"
      },
      {
        "text": "Nested Loop Join",
        "solution": "true"
      },
      {
        "text": "Hash Join",
        "solution": "false"
      },
      {
        "text": "Sort Merge Join",
        "solution": "false"
      },
      {
        "text": "Outer Join",
        "solution": "false"
      },
      {
        "text": "Index Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3102,
    "category": 8,
    "difficulty": 1,
    "text": "Welcher Join-Operator sollte in der Regel vermieden werden, da er bei großen Datenmengen einen \"OUT OF MEMORY ERROR\" verursachen kann?",
    "explanation": "Das ist der Cartesian Join, der jeden Datensatz der einen Tabelle mit dem der anderen Tabelle verknüpft und daher die Datenmengen immens vergrößert, \nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#MERGE_JOIN_CARTESIAN\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#MERGE_JOIN_CARTESIAN  .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Cartesian Join",
        "solution": "true"
      },
      {
        "text": "Nested Loop Join",
        "solution": "false"
      },
      {
        "text": "Hash Join",
        "solution": "false"
      },
      {
        "text": "Sort Merge Join",
        "solution": "false"
      },
      {
        "text": "Outer Join",
        "solution": "false"
      },
      {
        "text": "Index Join",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3126,
    "category": 13,
    "difficulty": 3,
    "text": "Sie möchten einen Trigger schreiben, der angestoßen wird, nachdem Zeilen aus einer Tabelle gelöscht werden oder eingefügt werden. Und es sollen dabei die Anzahl der verbliebenen Zeilen der Tabelle angezeigt werden. Welchen Triggertyp benötigen Sie?",
    "explanation": "Der Ausführungszeitpunkt AFTER ist wichtig, da ein BEFORE-Trigger bei DELETE keinen Sinn macht. Die verbliebenen Datensätze werden nur beim Ausführungszeitpunkt AFTER angezeigt.\n\n    Ein zeilenorientierter Trigger würde das Mutating-Table-Problem auslösen.\n\n    Nach dem Ausführungsmodell von zeilenorientierten Triggern werden diese nur angestoßen, wenn sich tatsächlich Daten in der Datenbank verändert haben. (siehe < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\"target = \"_blank\"> zeilenorientierten Trigger. (siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\" target=\"_blank\"> CREATE-TRIGGER )",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE OR REPLACE TRIGGER LOESCHE_ANGESTELLTE\n\n    AFTER INSERT OR DELETE  ON ANGESTELLTE\n\n    DECLARE\n\n    num_rows NUMBER;\n\n    BEGIN\n\n    SELECT COUNT(*) INTO num_rows FROM angestellte ;\n\n    dbms_output.put_line(\"Die Anzahl der Angestellten ist \" || to_char(num_rows));\n\n    END;",
        "solution": "true"
      },
      {
        "text": "CREATE OR REPLACE TRIGGER LOESCHE_ANGESTELLTE\n\n    BEFORE INSERT OR DELETE  ON ANGESTELLTE\n\n    DECLARE\n\n    num_rows NUMBER;\n\n      BEGIN\n\n    \n\n    SELECT COUNT(*) INTO num_rows FROM angestellte ;\n\n    dbms_output.put_line(\"Die Anzahl der Angestellten ist \" || to_char(num_rows));\n\n    END;\n\n    /",
        "solution": "false"
      },
      {
        "text": "CREATE OR REPLACE TRIGGER LOESCHE_ANGESTELLTE\n\n    BEFORE INSERT OR DELETE ON ANGESTELLTE\n\n    FOR EACH ROW\n\n    DECLARE\n\n    num_rows NUMBER;\n\n    BEGIN\n\n    SELECT COUNT(*) INTO num_rows FROM angestellte ;\n\n    dbms_output.put_line(\"Die Anzahl der Angestellten ist \" || to_char(num_rows));\n\n    END;\n\n    /",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3135,
    "category": 12,
    "difficulty": 3,
    "text": "Sie möchten in PL/SQL Daten unterschiedlichen Typs in einer Variable eines PL/SQL-Blocks speichern. Welcher Kollektionstyp ist dafür geeignet?",
    "explanation": "Das ist die Definition einen PL/SQL-Records, siehe auch  im <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/PL-SQL-RECORD\" title=\"PL/SQL-Record\" target=\"_blank\">DB-Wiki.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "VARRAY",
        "solution": "false"
      },
      {
        "text": "Nested Table",
        "solution": "false"
      },
      {
        "text": "PL/SQL-Record",
        "solution": "true"
      },
      {
        "text": "PL/SQL-Tabellen (Assoziative Arrays)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3361,
    "category": 3,
    "difficulty": 1,
    "text": "Um welchen Attributtyp handelt es sich hier primär?\n\n    Länderkürzel weltweit, wie \"D\" für Deutschland",
    "explanation": "Nominale Attribute unterscheiden sich nur durch ihren Namen, ordinale Attribute lassen sich zusätzlich der Größe nach ordnen und können verglichen werden. Intervallattribute beschreiben einen Intervallbereich und lassen sich addieren bzw. subtrahieren. Numerische Attribute beschreiben Zahlen, die alle vier Grundrechnenarten, also zusätzlich auch Multiplikation und  Division,  zulassen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Intervall",
        "solution": "false"
      },
      {
        "text": "Ordinal",
        "solution": "false"
      },
      {
        "text": "Nominal",
        "solution": "true"
      },
      {
        "text": "Zahl",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3425,
    "category": 6,
    "difficulty": 2,
    "text": "Auf welchen Spalten ist ein Verweis über einen Fremdschlüssel möglich?",
    "explanation": "Fremdschlüssel können auf Spalten verweisen, die einen Primärschlüssel oder einen Zweitschlüssel haben. Ein Zweitschlüssel wird in SQL durch einen UNIQUE-Constraint oder einen CREATE UNIQUE INDEX .. implementiert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Auf Spalten, die als Zweitschlüssel (UNIQUE CONSTRAINT) definiert sind.",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "Auf Spalten, die als Primärschlüssel (Primary Key) definiert sind.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2797,
    "category": 5,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C und den folgenden funktionalen Abhängigkeiten Welche Arten funktionaler Abhängigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abhängigkeit als Antwort eintragen, also volle, partielle oder transitive.",
    "explanation": "B, D, E, F sind voll funktional vom gesamten Primärschlüssel A,C abhängig.\n\n    F ist von B abhängig und B von A,C und damit ist F transitiv von A,C abhängig.\n\n    E ist von D abhängig und D von A,C und damit ist E transitiv von A,C abhängig.",
    "type": "text",
    "answers": [
      {
        "text": "A, C -> B, D, E, F",
        "solution": "volle"
      },
      {
        "text": "D -> E",
        "solution": "transitive"
      },
      {
        "text": "B -> F",
        "solution": "transitive"
      }
    ]
  },
  {
    "id": 2799,
    "category": 3,
    "difficulty": 2,
    "text": "Welche Aussagen über eine IS-A-Beziehung sind richtig?",
    "explanation": "Eine \"IS-A-Beziehung\" ist eine Beziehung zwischen einem Supertyp und einem Subtyp \n Die Subtypen erben alle Attribute des Supertyps\n Die Attribute des Subtyps können um eigene Attribute und Methoden ergänzt werden.\n Supertyp und Subtyp besitzen den gleichen Primärschlüssel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine IS-A-Beziehung ist eine andere Bezeichnung für eine identifizierende 1:n-Beziehung.",
        "solution": "false"
      },
      {
        "text": "Eine IS-A-Beziehung ist eine andere Bezeichnung für eine nicht-identifizierende 1:n-Beziehung.",
        "solution": "false"
      },
      {
        "text": "Eine IS-A-Beziehung ist eine Beziehung zwischen einem Supertyp und einem Subtyp.",
        "solution": "true"
      },
      {
        "text": "Bei einer IS-A-Beziehung werden alle Attribute des Subtypen an den Supertyp vererbt.",
        "solution": "false"
      },
      {
        "text": "Supertyp und Subtyp haben die gleichen Primärschlüsselattribute und auch -werte.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3074,
    "category": 8,
    "difficulty": 1,
    "text": "Wo liegen die größten Tuning-Potentiale?",
    "explanation": "Nach einer Studie von Forrester-Research liegt das größte Potential im SQL-Tuning,\nsiehe: <a href = \"http://www.dailymotion.com/video/xtpc8a_researching-sql-performance-tuning-tips_school\" target=\"_blank\"> http://www.dailymotion.com/video/xtpc8a_researching-sql-performance-tuning-tips_school",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SQL-Tuning, insbesondere von SELECT-Anweisungen",
        "solution": "true"
      },
      {
        "text": "Erzeugen von zusätzlichen Indizes in der Datenbank",
        "solution": "false"
      },
      {
        "text": "Änderungen an den Parametern der Datenbankinstance",
        "solution": "false"
      },
      {
        "text": "Verbesserungen des Netzwerks",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3079,
    "category": 8,
    "difficulty": 2,
    "text": "Welche der folgenden SELECT-Abfragen haben in der Regel eine schlechte Performance und können daher getunt werden?",
    "explanation": "SELECT * muss alle Spalten der Tabelle ermitteln, was zusätzliche Zeit kostet. Ein Sortiervorgang bedeutet bei großen Tabellen eine schlechte Performance und muss auch bei DISTINCT erfolgen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * FROM Tabelle;",
        "solution": "true"
      },
      {
        "text": "SELECT t.Spalte FROM Tabelle t;",
        "solution": "false"
      },
      {
        "text": "SELECT Spalte FROM Tabelle ORDER BY Spalte;",
        "solution": "true"
      },
      {
        "text": "SELECT DISTINCT Spalte FROM Tabelle;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3086,
    "category": 8,
    "difficulty": 1,
    "text": "Welcher Anfragetyp ist schneller?",
    "explanation": "Falls die Spaltennamen ohne Tabellennamen angegeben werden, muss das Datenbanksystem zusätzlich ermitteln, in welchen Tabellen die Spalten enthalten sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine SELECT-Anweisung mit vollständig qualifizierten Spaltennamen, also in der Form Tabellennamen.Spaltennamen",
        "solution": "true"
      },
      {
        "text": "Eine SELECT-Anweisung ohne vollständig qualifizierte Spaltennamen, also in der Form Spaltennamen",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3088,
    "category": 8,
    "difficulty": 2,
    "text": "Welche Datenbankoperationen kosten in der Regel unnötige Zeit?",
    "explanation": "Bei UNION wird zusätzlich eine DISTINCT-Operation ausgeführt, um Duplikate zu eliminieren, bei UNION ALL ist das nicht der Fall. Funktionsaufrufe wie UPPER() , LOWER() oder andere können den \nzugehörigen Index auf einer Spalte nicht nutzen, wenn er nicht ein funktionsbasierter Index ist. Dies ist auch bei Typkonvertierungen der Fall. (siehe \n< a href \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Funktionsbasierter-Index\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Funktionsbasierter-Index ).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Typkonvertierungen",
        "solution": "true"
      },
      {
        "text": "Funktionsaufrufe wie UPPER, LOWER, etc",
        "solution": "true"
      },
      {
        "text": "UNION",
        "solution": "true"
      },
      {
        "text": "UNION ALL",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2792,
    "category": 5,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C \nund den folgenden funktionalen Abhängigkeiten \nA, C -> D, E, F\nD-> E\nC -> B\n\nWelche Aussagen sind richtig?",
    "explanation": "D, E, F sind voll funktional vom gesamten Primärschlüssel A,C abhängig. \nB ist nur partiell funktional vom gesamten Primärschlüssel A,C abhängig, nämlich nur von einem Teil des Schlüssel, von C. \n\nE ist von D abhängig und D von A,C und damit ist E transitiv von A,C abhängig. \n\nDamit gibt es hier eine partielle Abhängigkeit, die bei der 2. NF zu berücksichtigen ist und es gibt eine transitive Abhängigkeit, die erst bei der 3. NF aufzulösen ist. Damit sind 2. und 3. NF verschieden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die 2. NF ist von der 3. NF verschieden.",
        "solution": "true"
      },
      {
        "text": "Die 2. NF und die 3. NF sind gleich.",
        "solution": "false"
      },
      {
        "text": "Diese Aussagen lassen sich mit diesen Informationen so nicht ziehen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2793,
    "category": 5,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C \nund den folgenden funktionalen Abhängigkeiten \nA, C -> D, E, F\nD-> E\nC -> B\n\nWie sieht die 2. NF aus? Welche Relationen gehören dazu?",
    "explanation": "D, E, F sind voll funktional vom gesamten Primärschlüssel A,C abhängig. \nB ist nur partiell funktional vom gesamten Primärschlüssel A,C abhängig, nämlich nur von einem Teil des Schlüssel, von C. \n\nE ist von D abhängig und D von A,C und damit ist E transitiv von A,C abhängig. \n\nDaraus ergeben sich folgende Relationen für die 2. NF, wo ja nur partielle Abhängigkeit aufgelöst wird: \nT(C (PK), B)\nR(A (PK), C (PK, FK), D, E, F)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "R(A (PK), C (PK, FK), B, D (FK), F)",
        "solution": "false"
      },
      {
        "text": "S(D (PK), E)",
        "solution": "false"
      },
      {
        "text": "T(C (PK), B)",
        "solution": "true"
      },
      {
        "text": "R(A (PK), C (PK), B, D, E, F)",
        "solution": "false"
      },
      {
        "text": "R(A (PK), C (PK, FK), D, E, F)",
        "solution": "true"
      },
      {
        "text": "R(A (PK), C (PK, FK), D (FK), F)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2794,
    "category": 5,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C \nund den folgenden funktionalen Abhängigkeiten \nA, C -> D, E, F\nD-> E\nC -> B\n\nWie sieht die 3. NF aus? Welche Relationen gehören dazu?",
    "explanation": "D, E, F sind voll funktional vom gesamten Primärschlüssel A,C abhängig. \nB ist nur partiell funktional vom gesamten Primärschlüssel A,C abhängig, nämlich nur von einem Teil des Schlüssel, von C. \n\nE ist von D abhängig und D von A,C und damit ist E transitiv von A,C abhängig. \n\nDaraus ergeben sich folgende Relationen für die 3. NF, ausgehend von der Auflösung der partiellen Abhängigkeit für die 2. NF nun auch die transitive Abhängigkeit aufgelöst wird: \nT(C (PK), B)\nR(A (PK), C (PK, FK), D (FK), F)\nS(D (PK), E)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "R(A (PK), C (PK), B, D, F)",
        "solution": "false"
      },
      {
        "text": "S(D (PK), E)",
        "solution": "true"
      },
      {
        "text": "T(C (PK), B)",
        "solution": "true"
      },
      {
        "text": "R(A (PK), C (PK, FK), B, D, E, F)",
        "solution": "false"
      },
      {
        "text": "R(A (PK), C (PK, FK), D, E, F)",
        "solution": "false"
      },
      {
        "text": "R(A (PK), C (PK, FK), D (FK), F)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2791,
    "category": 5,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C und den folgenden funktionalen Abhängigkeiten Welche Arten funktionaler Abhängigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abhängigkeit als Antwort eintragen, also volle, partielle oder transitive.",
    "explanation": "D, E, F sind voll funktional vom gesamten Primärschlüssel A,C abhängig.\n\n    B ist nur partiell funktional vom gesamten Primärschlüssel A,C abhängig, nämlich nur von einem Teil des Schlüssel, von C.\n\n    E ist von D abhängig und D von A,C und damit ist E transitiv von A,C abhängig.",
    "type": "text",
    "answers": [
      {
        "text": "A, C -> D, E, F",
        "solution": "volle"
      },
      {
        "text": "D-> E",
        "solution": "transitive"
      },
      {
        "text": "C -> B",
        "solution": "partielle"
      }
    ]
  },
  {
    "id": 2798,
    "category": 5,
    "difficulty": 2,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C \nund den folgenden funktionalen Abhängigkeiten \nA, C -> B, D, E, F\nD -> E\nB -> F\n\nWelche Aussagen sind richtig?",
    "explanation": "B, D, E, F sind voll funktional vom gesamten Primärschlüssel A,C abhängig. \nF ist von B abhängig und B von A,C und damit ist F transitiv von A,C abhängig. \nE ist von D abhängig und D von A,C und damit ist E transitiv von A,C abhängig. \n\nDamit gibt es hier keine partiellen Abhängigkeiten, die bei der 2. NF zu berücksichtigen wären, dafür gibt es aber zwei transitive Abhängigkeit, die erst bei der 3. NF aufzulösen ist. Damit sind 1. und 2. NF gleich.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die 1. NF und die 2. NF sind gleich.",
        "solution": "true"
      },
      {
        "text": "Die 1. NF ist von der 2. NF verschieden.",
        "solution": "false"
      },
      {
        "text": "Die 2. NF ist von der 3. NF verschieden.",
        "solution": "true"
      },
      {
        "text": "Die 2. NF und die 3. NF sind gleich.",
        "solution": "false"
      },
      {
        "text": "Diese Aussagen lassen sich mit diesen Informationen so nicht ziehen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2795,
    "category": 5,
    "difficulty": 2,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C \nund den folgenden funktionalen Abhängigkeiten \nA, C -> D, E, F\nA -> E\nC -> B\n\nWelche Aussagen sind richtig?",
    "explanation": "D, E, F sind voll funktional vom gesamten Primärschlüssel A,C abhängig. \nB ist nur partiell funktional vom gesamten Primärschlüssel A,C abhängig, nämlich nur von einem Teil des Schlüssel, von C. \nE ist nur partiell funktional vom gesamten Primärschlüssel A,C abhängig, nämlich nur von einem Teil des Schlüssel, von A. \n\n\nDamit gibt es hier nur partielle Abhängigkeiten, die bei der 2. NF zu berücksichtigen ist und es gibt keine transitiven Abhängigkeiten, die erst bei der 3. NF aufzulösen sind. Damit sind 2. und 3. NF gleich.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die 2. NF ist von der 3. NF verschieden.",
        "solution": "false"
      },
      {
        "text": "Die 2. NF und die 3. NF sind gleich.",
        "solution": "true"
      },
      {
        "text": "Diese Aussagen lassen sich mit diesen Informationen so nicht ziehen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2796,
    "category": 5,
    "difficulty": 3,
    "text": "Betrachten Sie eine Relation R(A, B, C, D, E, F) mit dem Primärschlüssel A, C und den folgenden funktionalen Abhängigkeiten Welche Arten funktionaler Abhängigkeiten liegen hier vor? Es ist ausreichend, wenn Sie nur die Eigenschaft \"XXX\" der funktionalen Abhängigkeit als Antwort eintragen, also volle, partielle oder transitive.",
    "explanation": "D, E, F sind voll funktional vom gesamten Primärschlüssel A,C abhängig.\n\n    B ist nur partiell funktional vom gesamten Primärschlüssel A,C abhängig, nämlich nur von einem Teil des Schlüssel, von C.\n\n    E ist nur partiell funktional vom gesamten Primärschlüssel A,C abhängig, nämlich nur von einem Teil des Schlüssel, von A.",
    "type": "text",
    "answers": [
      {
        "text": "A, C -> D, E, F",
        "solution": "volle"
      },
      {
        "text": "A -> E",
        "solution": "partielle"
      },
      {
        "text": "C -> B",
        "solution": "partielle"
      }
    ]
  },
  {
    "id": 2800,
    "category": 5,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation in der 2NF, die außer Primärschlüsselattributen nur ein einziges Nichtschlüsselattribut besitzt. Solch eine Relation ist immer automatisch in der 3NF.",
    "explanation": "Eine Relation, die nur ein Nichtschlüsselattribute hat, kann nie transitive Abhängigkeiten (siehe <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Transitive-Abhaengigkeit/\">DB-Wiki ) aufweisen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "true"
      },
      {
        "text": "stimmt nicht",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3093,
    "category": 8,
    "difficulty": 1,
    "text": "Welche Tabellenzugriffsmethode ist bei Oracle die schnellste, wenn man nur einen Datensatz lesen möchte?",
    "explanation": "Der Zugriff über die ROWID ist die schnellste Möglichkeit, um eine einzelne Zeile aus einer Tabelle zu lesen, weil die genaue Adresse der \nZeile in der Datenbank angegeben wird, \nsiehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zugriffsoperationen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "RowidScan",
        "solution": "true"
      },
      {
        "text": "Full Table Scan",
        "solution": "false"
      },
      {
        "text": "Index Scan",
        "solution": "false"
      },
      {
        "text": "Hash Scan",
        "solution": "false"
      },
      {
        "text": "Cluster Scan",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3094,
    "category": 8,
    "difficulty": 1,
    "text": "Welche Join-Operatoren gibt es bei Oracle?",
    "explanation": "Alle oben aufgeführten Join-Operatoren  gibt es bei Oracle.\nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen  .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Cartesian Join",
        "solution": "true"
      },
      {
        "text": "Nested Loop Join",
        "solution": "true"
      },
      {
        "text": "Hash Join",
        "solution": "true"
      },
      {
        "text": "Sort Merge Join",
        "solution": "true"
      },
      {
        "text": "Outer Join",
        "solution": "true"
      },
      {
        "text": "Index Join",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2813,
    "category": 4,
    "difficulty": 3,
    "text": "Es ist ein Datenmodell einer Auto-Vermietung gegeben mit einer Kunden-Relation (Primärschlüssel: Kunden_Nr), einer Fahrzeuge-Relation  (Primärschlüssel: KFZ-Nr) und einer Ausleihen-Relation, in der alle getätigten Ausleihen erfaßt werden. \nDie Ausleihen-Relation hat nun folgenden Primärschlüssel: \nKFZ_Nr, Kunden_Nr, ausgeliehen_am. \n\nEs ist nun angedacht, das Datum \"ausgeliehen_am\" aus dem Primärschlüssel herauszunehmen. Welche Konsequenzen hätte dies.",
    "explanation": "Die beiden richtigen Antworten beschreiben den gleichen Sachverhalt nur mal anders herum ausgedrückt. \n\nMit einem Primärschlüssel KFZ_Nr, Kunden_Nr, ausgeliehen_am \nsind folgende Daten möglich: \nKFZ_NR(PK), Kunden_Nr(PK), ausgeliehen_am(PK)\n1234,        4000,   14.09.2011\n1234,        4000,   06.10.2011\n\nSomit kann ein Fahrzeug von einem Kunden mehrfach zu verschiedenen Zeitpunkten gebucht werden. \n\nMit dem geänderten Primärschlüssel KFZ_Nr, Kunden_Nr \nsieht das schon ganz anders aus. Die folgenden Daten gehen dann nicht mehr, weil der Primärschlüssel nicht eindeutig ist: \nKFZ_NR(PK), Kunden_Nr(PK), ausgeliehen_am\n1234,        4000,   14.09.2011\n1234,        4000,   06.10.2011\n\nFür die Werte 1234, 4000, gibt es dann nur noch einen Datensatz und damit kann ein Kunde ein Fahrzeug nur noch einmal ausleihen. Andere Fahrzeuge kann er ruhig mehrfach ausleichen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Ein Fahrzeug (KFZ_Nr) kann nur einmal ausgeliehen werden.",
        "solution": "false"
      },
      {
        "text": "Ein Kunde (Kunden_Nr) kann nur einmal ausleihen.",
        "solution": "false"
      },
      {
        "text": "Ein Kunde kann nur einmal ein bestimmtes Fahrzeug ausleihen.",
        "solution": "true"
      },
      {
        "text": "Ein Fahrzeug kann nur einmal von einem bestimmten Kunden ausgeliehen werden.",
        "solution": "true"
      },
      {
        "text": "Diese Änderung hat gar keine Auswirkungen. Sie minimiert nur die Anzahl der Attribute des Primärschlüssels.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2814,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussagen über die GROUP-BY-Klausel sind wahr?",
    "explanation": "Siehe die Syntaxbeschreibung der SELECT -Anweisung im Datenbankwiki unter <a href =\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/SELECT\"> SELECT-Anweisung",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Man kann in einer GROUP-BY-Klausel Spaltenabkürzungen benutzen.",
        "solution": "false"
      },
      {
        "text": "Die WHERE-Klausel kann nach der GROUP-BY-Klausel stehen und Zeilen ausschließen, bevor gruppiert wird.",
        "solution": "false"
      },
      {
        "text": "Die WHERE-Klausel kann vor der GROUP-BY-Klausel stehen und Zeilen ausschließen, bevor gruppiert wird.",
        "solution": "true"
      },
      {
        "text": "Wenn die SELECT-Klausel Gruppenfunktionen (SUM, MIN, MAX, COUNT..) hat, dann müssen alle Spalten der SELECT-Klausel, die keine Gruppenfunktion haben, in der GROUP-BY-Klausel vorkommen.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2815,
    "category": 7,
    "difficulty": 3,
    "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\nCREATE TABLE Auftraege\n(AuftragsNr         NUMBER(38) NOT NULL,\n Auftrags_Typ         VARCHAR2(50) NOT NULL,\n Kun_Nr         NUMBER(38) NOT NULL,\n Ang_Nr         NUMBER(38),\n auftragssumme             NUMBER);\n\nCREATE TABLE Auftragspositionen\n(TNr             NUMBER(38) NOT NULL,\n AuftragsNr         NUMBER(38) NOT NULL,\n Menge             NUMBER);\n\nWelche DELETE-Anweisungen sind korrekt?",
    "explanation": "Mit der DELETE-Anweisung kann man keine einzelnen Werte in Spalten, sondern nur komplette Zeilen löschen. Siehe die Syntaxbeschreibung der DELETE-Anweisung im Datenbankwiki unter\n<a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/DELETE\"> DELETE-Anweisung",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "DELETE AuftragsNr FROM Auftraege WHERE auftragssumme < 1000;",
        "solution": "false"
      },
      {
        "text": "DELETE Auftraege WHERE auftragssumme < 1000;",
        "solution": "true"
      },
      {
        "text": "DELETE FROM Auftraege WHERE (SELECT AuftragsNr FROM Auftragspositionen);",
        "solution": "false"
      },
      {
        "text": "DELETE * FROM Auftraege, Auftragspositionen\nWHERE Auftraaege.auftragssumme < 1000\nAND Auftraege.AuftragsNr = Auftragspositionen.AuftragsNr;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2818,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welchem Befehl legt man einen CONSTRAINT nachträglich auf einer Tabelle an? Es soll nachträglich auf einer Tabelle Artikel die Spalte Verkaufspreis in NOT NULL verändert werden.",
    "explanation": "Constraints sind keine eigenen Datenbankobjekte, sie der gehören zu einer Tabelle und werden daher auch nicht mit einem eigenen DROP-Befehl gelöscht, sondern mit einem ALTER TABLE-Befehl. Die genaue Syntax finden Sie im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/ALTER-TABLE\"> ALTER-Table",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "ALTER  TABLE  artikel \nMODIFY verkaufspreis CONSTRAINT BEZ_NN NOT NULL;",
        "solution": "true"
      },
      {
        "text": "ALTER  TABLE  artikel \nADD CONSTRAINT BEZ_NN NOT NULL(verkaufspreis);",
        "solution": "false"
      },
      {
        "text": "ALTER TABLE XYZ DROP CONSTRAINT ...",
        "solution": "false"
      },
      {
        "text": "ALTER  TABLE  artikel \nMODIFY verkaufspreis CONSTRAINT BEZ_NN NOT NULL(Verkaufspreis);",
        "solution": "false"
      },
      {
        "text": "ALTER  TABLE  artikel \nADD verkaufspreis NUMBER  CONSTRAINT BEZ_NN NOT NULL;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2819,
    "category": 14,
    "difficulty": 2,
    "text": "Betrachten Sie die folgende Tabelle:\n\n    create table test (test_id INTEGER, text varchar2(15));\n\n    und die folgenden SQL-Befehle:\n\n    ALTER TABLE test ADD CONSTRAINT Test_pk primary KEY(test_id) DEFERRABLE INITIALLY DEFFERRED;\n\n    INSERT INTO test VALUES (1, \"Ute\"); -- Zeile 1\n\n    INSERT INTO test VALUES (1, \"Udo\"); -- Zeile 2\n\n    COMMIT;\n\n    SET CONSTRAINT Test_pk IMMEDIATE;\n\n    INSERT INTO test VALUES (1, \"Edda\"); -- Zeile 3\n\n    INSERT INTO test VALUES (2, \"Willi\");-- Zeile 4\n\n    COMMIT;\n\n    Welche Zeilen werden persistent in der Tabelle test gespeichert?",
    "explanation": "Bei INITIALLY DEFFERRED wird die ganze Transaktion zurückgerollt, wenn ein Fehler auftritt, so dass die Tabelle nach dem ersten COMMIT leer ist.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Keine der Zeilen, da die SQL-Syntax fehlerhaft ist.",
        "solution": "false"
      },
      {
        "text": "nur Zeile 4",
        "solution": "false"
      },
      {
        "text": "Zeile 2 und 4",
        "solution": "false"
      },
      {
        "text": "Zeile 3 und 4",
        "solution": "true"
      },
      {
        "text": "Zeile 1 und 4",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2820,
    "category": 6,
    "difficulty": 2,
    "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\n    CREATE TABLE Auftraege\n\n    (AuftragsNr NUMBER(38) PRIMARY KEY,\n\n    Auftrags_Typ VARCHAR2(50) NOT NULL,\n\n    Kun_Nr NUMBER(38) NOT NULL,\n\n    Ang_Nr NUMBER(38),\n\n    auftragssumme NUMBER);\n\n    \n\n    CREATE TABLE Auftragspositionen ,\n\n    (TNr NUMBER(38),\n\n    AuftragsNr NUMBER(38),\n\n    Menge NUMBER,\n\n    PRIMARY KEY Auftragspositionen(TNR, AuftragsNr));\n\n    \n\n    Welche CREATE-Index-Anweisungen sind korrekt?",
    "explanation": "Ein Index kann immer nur auf einer Tabelle definiert werden und auch nicht, wenn schon ein entsprechender Primärschlüssel mit den gleichen Spalten existiert. Siehe die Syntaxbeschreibung der CREATE-INDEX-Anweisung im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-INDEX\"> CREATE-INDEX-Anweisung.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE UNIQUE INDEX Auftr_INDEX ON Auftraege(TNr);",
        "solution": "false"
      },
      {
        "text": "CREATE UNIQUE INDEX Auftragspos_INDEX1 ON Auftragspositionen(TNr);",
        "solution": "true"
      },
      {
        "text": "CREATE UNIQUE INDEX Auftragspos_INDEX2 ON Auftragspositionen(AuftragsNr);",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2821,
    "category": 7,
    "difficulty": 2,
    "text": "Betrachten Sie den folgenden CREATE-Table-Befehl:\n\nCREATE TABLE Auftraege\n(AuftragsNr     NUMBER(38)   PRIMARY KEY\n Auftrags_Typ   VARCHAR2(50) NOT NULL,\n Kun_Nr         NUMBER(38)   NOT NULL,\n Ang_Nr         NUMBER(38),\n auftragssumme  NUMBER);\n\nFür welche Datenbankabfrage braucht man eine Unterabfrage?",
    "explanation": "Bei Abfragen vom Typ \"Berechnen Sie die Summe über alle Auftragssummen eines bestimmten Kunden, der vom Angestellten mit der ang_nr = 1 betreut wird!  \" braucht man eine SELECT-Anweisung mit GROUP BY kund_nr zusätzlichem WHERE oder HABING-Klausel, je nach Datenbankabfrage.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Berechnen Sie die Summe über alle Auftragssummen eines bestimmten Kunden!",
        "solution": "false"
      },
      {
        "text": "Berechnen Sie die Summe über alle Auftragssummen eines bestimmten Kunden, der vom Angestellten mit der ang_nr = 1 betreut wird!",
        "solution": "false"
      },
      {
        "text": "Geben Sie alle Auftrage aus, deren Auftragssumme höher ist als der Durchschnitt aller Auftragssummen aus der Tabelle Auftraege!",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2825,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Ausage(n) über Constraints ist wahr?",
    "explanation": "Die einzige Spaltenbedingung, die nicht als Tabellenbedingung fomuliert werden kann, ist der NOT NULL-Constraint. \n\nFOREIGN-KEY-Constraints und UNIQUE-Constraints können auch NULL -Werte enthalten. \n\nCONSTRAINTS werden auch bei UPDATE und DELETE überprüft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Spalte mit FOREIGN KEY-Constraint kann keine NULL-Werte enthalten.",
        "solution": "false"
      },
      {
        "text": "Eine Spalte mit UNIQUE-Constraint kann keine NULL-Werte enthalten.",
        "solution": "false"
      },
      {
        "text": "Ein Constraint wird nur bei einer INSERT-Anweisung überprüft.",
        "solution": "false"
      },
      {
        "text": "Ein Constraint kann unter Oracle auch DISABLED werden, wenn die Spalte Daten enthält.",
        "solution": "true"
      },
      {
        "text": "Jeder Spaltenbedingung kann auch als Tabellenbedingung formuliert werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2823,
    "category": 7,
    "difficulty": 3,
    "text": "In der Fahrrad-Datenbank Byce & Co. sind insbesondere folgende Tabellen enthalten:\n     Artikel(TNr, Bezeichnung, .....)\n     Auftrage(AuftragsNr, KundenNr, Auftragsdatum, ...)\n     Auftragspositionen(AuftragsNr, TNr, Menge,...)   \n\nDer Vertriebsleiter Dr. Guck der Firma Byce & Co. möchte herausfinden, für welche Artikel überhaupt Aufträge vorliegen. Er stellt folgende Abfrage an die Datenbank:\n\nSELECT  a.TNr, a.Bezeichnung\nFROM    Artikel a\nWHERE   NOT EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr <> b.TNr);\n\nWelche Aussage(n) sind korrekt?",
    "explanation": "Die korrekte Abfrage wäre\n\n SELECT  a.TNr, a.Bezeichnung\n FROM    Artikel a\n WHERE   NOT EXISTS (SELECT * FROM Auftragspositionen b \n        WHERE a.TNr = b.TNr);",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Abfrage wird ausgeführt und liefert das gewünschte Ergebnis.",
        "solution": "false"
      },
      {
        "text": "Die Abfrage wird ausgeführt und liefert nicht das gewünschte Ergebnis.",
        "solution": "true"
      },
      {
        "text": "Die Abfrage wird ausgeführt und liefert keine Zeilen als Ergebnis, da der Vergleichsoperator \"=\" in der inneren Abfrage an Stelle von \"<>\" genutzt werden muss.",
        "solution": "true"
      },
      {
        "text": "Die Abfrage wirft einen Fehler, da die WHERE-Klausel der äußeren Abfrage auf einen Spalte der inneren Abfrage verweisen muss.",
        "solution": "false"
      },
      {
        "text": "Die Abfrage wirft einen Fehler, da die WHERE-Klausel der äußeren Abfrage einen Vergleichsoperator enthalten muss.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2826,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussagen über Unterabfragen sind wahr?",
    "explanation": "siehe Erklärungen von Unterabfragen im Datenbankwiki unter <a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Unterabfrage\"> Unterabfragen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Unterabfrage kann Daten aus ein oder mehreren Tabellen oder Views auslesen.",
        "solution": "true"
      },
      {
        "text": "In einer SELECT-Anweisung können nur zwei Unterabfragen parallel genutzt werden.",
        "solution": "false"
      },
      {
        "text": "Falls eine Unterabfrage als Ergebnis 0 Zeilen hat, wird NULL zurückgegeben.",
        "solution": "true"
      },
      {
        "text": "Die Spalten einer Unterabfrage müssen immer einen Tabellennamen oder einen Tabellealias haben.",
        "solution": "false"
      },
      {
        "text": "In einer WHERE-Klausel können Unterabfragen höchstens dreimal ineinander geschachtelt werden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2827,
    "category": 7,
    "difficulty": 3,
    "text": "Gegeben sei folgender Ausschnitt eines relationalen Schemas einer Datenbank: Abteilungen: {Abt_Nr, Bezeichnung, Ort, Budget, Ang_Nr} Angestellte: {Ang_Nr, Nachname, Vorname, PLZ, Ort, Strasse, Gehalt, Abt_Nr } Es sollen alle Abteilungen mit den zugehörigen Angestellten ausgegeben werden, deren Budget mehr als 5000  beträgt. Es wird dazu das folgende SELECT-Statement abgesetzt:\n\n    SELECT abt_nr, Name, Budget, Nachname FROM abteilungen WHERE leiter > 2 JOIN angestellte USING (Abt_nr);\n\n    Welche der folgenden Aussagen ist wahr?",
    "explanation": "Auch in einer SELECT-Anweisung mit JOIN..... USING steht die WHERE-Klausel immer nach der FROM-Klausel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die SELECT-Abfrage wird ausgeführt und liefert das gewünschte Ergebnis.",
        "solution": "false"
      },
      {
        "text": "Die SELECT-Abfrage wird nicht ausgeführt, da eine ON-Klausel fehlt.",
        "solution": "false"
      },
      {
        "text": "Die SELECT-Abfrage wird nicht ausgeführt, da die WHERE-Klausel an der falschen Stelle der SELECT-Anweisung steht.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2828,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über Sequenzen (CREATE SEQUENCE....) sind wahr?",
    "explanation": "Siehe < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-SEQUENCE\"> CREATE SEQUENCE",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mit DELETE SEQUENCE <sequencename>; wird eine Sequenz wieder gelöscht.",
        "solution": "false"
      },
      {
        "text": "CURVAL enthält die zuletzt verwendete fortlaufende Nummer.",
        "solution": "true"
      },
      {
        "text": "Mit ALTER SEQUENCE ... kann eine Sequenz nachträglich verändert werden, wenn z.B. der MAXVALUE erreicht ist.",
        "solution": "true"
      },
      {
        "text": "Sequenzen können auch absteigende Nummern erzeugen.",
        "solution": "false"
      },
      {
        "text": "Sequenzen können nur in einer Tabelle genutzt werden.",
        "solution": "false"
      },
      {
        "text": "Sequenzen werden ausschließlich nur für künstliche Primärschlüssel verwendet.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2836,
    "category": 6,
    "difficulty": 3,
    "text": "Welche Aussagen über Constraints sind wahr?",
    "explanation": "Der einzige Spalten-Constraint, der nicht als Tabellenbedingung geschrieben werden kann, ist der NOT NULL CONSTRAINT.\nsiehe auch < a href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CONSTRAINT\"> CONSTRAINT im DB-Wiki.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine Foreign-Key-Spalte kann keine NULL-Werte enthalten.",
        "solution": "false"
      },
      {
        "text": "Eine UNIQUE-Spalte kann NULL-Werte enthalten.",
        "solution": "true"
      },
      {
        "text": "Ein Constraint wird wird nur bei Insert-Anweisungen überprüft.",
        "solution": "false"
      },
      {
        "text": "Ein Constraint kann unter Oracle-SQL auch disabled werden, wenn er Daten enthält",
        "solution": "true"
      },
      {
        "text": "Alle Spalten-Constraints können auch als Tabellen-Constraint dfdefiniert werden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3114,
    "category": 12,
    "difficulty": 2,
    "text": "Sie möchten zwei gespeicherte Prozeduren schreiben, die in Oracle PL/SQL das Überladen (Overloading) ermöglichen. \nWelche Regeln gelten unter PL/SQL für das Überladen?",
    "explanation": "Überladen (Overlaoding) ist in PL/SQL  nur in Routinen aus Packages, anonymen Blöcken und Objekttypen (member-Methoden) möglich. \nStandalone-ROUTINEN, die z.B. mit CREATE PROZEDURE(...) angelegt werden, können nicht überladen werden.\n(siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Overloading\" target=\"_blank\"> Overloading .)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die beiden Prozeduren können gepackt als Bestandteil eines Packages oder als  Stand-Alone-Prozedur definiert werden.",
        "solution": "false"
      },
      {
        "text": "Die beiden Prozeduren können als Bestandteil eines Packages definiert werden.",
        "solution": "true"
      },
      {
        "text": "Die beiden Prozeduren können jeweils als Stand-Alone-Prozeduren definiert werden.",
        "solution": "false"
      },
      {
        "text": "Die beiden Prozeduren müssen sich im Namen und dem Parametertyp unterscheiden",
        "solution": "false"
      },
      {
        "text": "Die beiden Prozeduren können den gleichen Namen haben, aber sich im Parametertyp oder der Anzahl der Parameter unterscheiden.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3092,
    "category": 8,
    "difficulty": 2,
    "text": "Welche Datenbankoperation ist in der Regel schneller?",
    "explanation": "SELECT COUNT(*) erfordert einen Zugriff auf alle Spalten der Tabelle und ist daher in der Regel langsamer. DISTINCT führt zusätzlich eine Sortierung durch.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "EXISTS mit\nSELECT c.Country \u000b  FROM Country c \u000b WHERE EXISTS            (SELECT \n1\u000b  FROM Language l \u000b  WHERE c.country = \nl.country);",
        "solution": "true"
      },
      {
        "text": "SELECT COUNT(*)...",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(Spaltenname)...",
        "solution": "true"
      },
      {
        "text": "DISTINCT mit SELECT DISTINCT Country FROM Language;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3480,
    "category": 7,
    "difficulty": 1,
    "text": "Betrachten Sie die folgenden SQL-Anweisungen:\n\n    CREATE TABLE test (spalte varchar2(10));\n\n    INSERT INTO TEST VALUES (\"Ja\");\n\n    INSERT INTO TEST VALUES (\"Nein\");\n\n    INSERT INTO TEST VALUES (NULL);\n\n    COMMIT;\n\n    SELECT * FROM TEST WHERE Spalte not in (\"Ja\", \"Nein\");\n\n    Welches Ergebnis hat diese SELECT-Abfrage?",
    "explanation": "Wegen der <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Dreiwertige-Logik\"> dreiwertigen Logik  in SQL liefert der Vergleich mit einem NULL-Wert den Wahrheitswert UNKNOWN, der in der WHERE-Klauesel zu FALSE ausgewertet wird.  Da UNKNOWN mit UNKNOWN  verneint wird, wird die Zeile mit dem NULL-Wert nicht ausgegeben,",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die beiden Tupel mit den Werten \"Ja\" und \"Nein\"",
        "solution": "false"
      },
      {
        "text": "Keine Zeilen (no Rows)",
        "solution": "true"
      },
      {
        "text": "Diese Abfrage wirft einen Fehler.",
        "solution": "false"
      },
      {
        "text": "Das Tupel mit dem Null-Wert in der Spalte",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2846,
    "category": 7,
    "difficulty": 3,
    "text": "Mit welcher Abfrage kann man ausgeben, wieviele Angestellte keine tel_nr haben (tel_nr ist NULL as Spalteneintrag)?",
    "explanation": "Einen NULL-Wert fragt man mit IS NULL ab. Wenn COUNT auf eine Spalte mit NULL trifft, ist das Ergebis COUNT(tel_nr) = 0, unabhängig davon, wie oft der NULL-Wert auftaucht. Daher ist die NVL-Funktion notwendig.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT COUNT(tel_nr)\nFROM angestellte\nWHERE tel_nr IS NULL:",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(tel_nr)\nFROM angestellte\nWHERE tel_nr = NULL:",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(DISTINCT tel_nr)\nFROM angestellte\nWHERE tel_nr IS NULL:",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(NVL(tel_nr, 0))\nFROM angestellte\nWHERE tel_nr IS NULL:",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2900,
    "category": 5,
    "difficulty": 2,
    "text": "Welche Normalform reduziert die Redundanz in einer relationalen Datenbank?",
    "explanation": "Die Überführung einer Relation in die 1NF erhöht in der Regel die Redundanz, bei der 2NF und der 3NF ist es umgekehrt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "3NF",
        "solution": "true"
      },
      {
        "text": "Jede der drei Normalfomen (1NF, 2NF und 3NF)",
        "solution": "false"
      },
      {
        "text": "1NF",
        "solution": "false"
      },
      {
        "text": "2NF",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2902,
    "category": 7,
    "difficulty": 2,
    "text": "Welche Aussagen sind wahr bezüglich der USING-Klausel eines SELECT-Statements?",
    "explanation": "Die  USING-Klausel setzt den EQUI-Join aus der relationalen Algebra um und kann alternativ zur ON-Klausel benutzt werden. (siehe  http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Tabelle )",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die  USING-Klausel kann nur bis zu drei Tabellen verknüpfen.",
        "solution": "false"
      },
      {
        "text": "Mit der USING-Klausel kann man Equi-Joins und allgemeine Theta-Joins (Vergleichopertaor z.B. >) abgebildet werden.",
        "solution": "false"
      },
      {
        "text": "Die USING-Klausel kann auf Spalten mit gleichem Namen und vergleichbarem Datentyp angewendet werden,.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3128,
    "category": 12,
    "difficulty": 3,
    "text": "Welche Aussagen über INDEX-By-Tabellen (assoziative Arrays) sind unter Oracle PL/SQL wahr?",
    "explanation": "Kollektionen mit Größenbeschränkung heißen unter Oracle PL/SQL ARRAYS.ein. Bei  INDEX BY-Tabellen sind die Schlüsseltypen BINARY_INTEGER , PLS_INTEGER und VARCHAR2-Typ\n vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "INDEX-By-Tabellen habe keine Größenbeschränkung",
        "solution": "true"
      },
      {
        "text": "INDEX BY-Tabellen sind Gruppen von Schlüsselwertpaaren",
        "solution": "true"
      },
      {
        "text": "Die Schlüssel INDEX BY-Tabellen können vom Typ BINARY_INTEGER , PLS_INTEGER oder VARCHAR2-Typ sein",
        "solution": "true"
      },
      {
        "text": "Die Schlüssel INDEX BY-Tabellen können nur vom Typ BINARY_INTEGER oder PLS_INTEGER sein",
        "solution": "false"
      },
      {
        "text": "INDEX-By-Tabellen habe eine Größenbeschränkung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3130,
    "category": 12,
    "difficulty": 1,
    "text": "Ein geöffneter CURSOR löst eine EXCEPTION aus, wenn eine FETCH- Anweisung keine Zeilen liefert.",
    "explanation": "Eine EXCEPTIOn wird nur bei einem impliziten CURSOR mit SELECT INTO... geworfen, wenn der SELECT keine Zeilen liefert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3131,
    "category": 12,
    "difficulty": 2,
    "text": "Die maximale Anzahl der geöffneten Cursor pro Session ist begrenzt",
    "explanation": "Die maximale Anzahl der geöffneten Cursor pro Session wird durch den \nOracle-Initialisierungsparameter OPEN_CURSORS eingestellt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "false"
      },
      {
        "text": "stimmt",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3139,
    "category": 12,
    "difficulty": 1,
    "text": "Betrachten Sie den folgenden anonymen PL/SQL-Block:\n\nSET SERVEROUTPUT ON \nDECLARE x NUMBER := 1000; \n  y NUMBER;\nBEGIN\n  IF x = y THEN\n  dbms_output.put_line('x=y');\n  ELSIF x<>y THEN\n     dbms_output.put_line('x<>y');\n  ELSE \n     dbms_output.put_line('nicht entscheidbar!'); END IF;\nEND; \n\n\nWelche Meldung gibt der Oracle-Server aus?",
    "explanation": "Der Vergleich zwischen einem Wert und einer NULL-Variablen wird unter PL/SQL wegen der dreiwertigen Logik immer mit falsch bewertet..",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "x <> y",
        "solution": "false"
      },
      {
        "text": "nicht entscheidbar!",
        "solution": "true"
      },
      {
        "text": "x=y",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3069,
    "category": 5,
    "difficulty": 3,
    "text": "Was wird benötigt, wenn eine 1:1- bzw. 1:c1-Beziehung auf zwei Relationen abgebildet wird?",
    "explanation": "Für 1:1 bzw. 1:c1-Beziehungen gilt, dass die beiden Entity-Mengen entweder auf zwei Relationen abgebildet werden oder eben zu einer zusammengefasst werden. Das Zusammenfassen ist problemlos möglich, da beide Entity-Mengen über den gleichen Primärschlüssel verfügen. \n\nBeim Abbilden auf zwei Relationen wird die 1:1/1:c1-Beziehung auf eine Fremdschlüsselbeziehung abgebildet. Da aber Fremdschlüsselbeziehungen eigentlich nur 1:n/1:cn-Beziehungen realisieren, muss für eine 1:1-Beziehung zusätzlich gewährleistet sein, dass die Primärschlüssel beider Relationen gleich sind, also aus dem/den gleichen Attributen bestehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Eigenschaft \"1:1/1:c1\" wird durch gemeinsame Zweitschlüssel (Alternate Key/UNIQUE KEY) realisiert.",
        "solution": "false"
      },
      {
        "text": "Eine Fremdschlüsselbeziehung zwischen den Relationen.",
        "solution": "true"
      },
      {
        "text": "Zwei Fremdschlüsselbeziehungen zwischen den Relationen jeweils entgegengesetzt.",
        "solution": "false"
      },
      {
        "text": "Das geht gar nicht, 1:1-Beziehungen werden immer nur auf eine Relation abgebildet.",
        "solution": "false"
      },
      {
        "text": "Die Primärschlüssel der beiden Relationen müssen gleich sein, also das bzw. die gleichen Attribute.",
        "solution": "true"
      },
      {
        "text": "Der Primärschlüssel des Master-Endes der 1:1-/1:c1-Beziehung muss Teil des Primärschlüssels der anderen Relation sein, d.h. dass  der Primärschlüssel des Detail-Endes über zumindest ein Attribut mehr im Primärschlüssel verfügen muss.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3152,
    "category": 8,
    "difficulty": 3,
    "text": "Welche Tipps sollte man beim SQL-Tuning unter ORACLE verwenden, um die Performance zu steigern?",
    "explanation": "siehe ORACLE-<a target=\"_blank\" title=\"ORACLE-SQL-Tuning-Guide\" href=\"http://www.orafaq.com/tuningguide/\">SQL-Tuning-Guide",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keine unnötigen Typkonvertierungen",
        "solution": "true"
      },
      {
        "text": "BETWEEN statt IN",
        "solution": "true"
      },
      {
        "text": "HAVING gegenüber WHERE bevorzugen, falls möglich",
        "solution": "false"
      },
      {
        "text": "Die Reihenfolge der Tabellen in der FROM-Klausel  ist irrelevant",
        "solution": "false"
      },
      {
        "text": "EXISTS statt distinct oder IN",
        "solution": "true"
      },
      {
        "text": "Kein count(*) verwenden",
        "solution": "true"
      },
      {
        "text": "CASE statt mehrere Anfragen",
        "solution": "true"
      },
      {
        "text": "UNION ALL statt UNION",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2957,
    "category": 3,
    "difficulty": 2,
    "text": "Über einen künstlichen Primärschlüssel sind folgende Aussagen wahr:",
    "explanation": "In der Praxis häufig sogenannte künstliche Schlüssel (surrogate keys) verwendet. Ein künstlicher Schlüssel ist ein zusätzliches Attribut einer Entity-Menge, das keine Entsprechung in der realen Welt hat. Es ist in der Regel ein einfacher Zähler vom Datentyp Integer, der systemintern verwaltet wird, nach außen nicht sichtbar ist und ausschließlich für die Primär- und Fremdschlüsselbeziehungen gebraucht wird. Er ist somit von einer Kundennummer, einer Artikelnummer und Ähnlichem zu unterscheiden, die nach außen sichtbar sind und im Schriftverkehr verwendet oder zur Identifikation beim Kunden erfragt werden. Wenn man sich für die Verwendung von künstlichen Primärschlüsseln entscheidet, dann trifft man aufgrund der Einheitlichkeit die Entscheidung im Allgemeinen für das gesamte Modell, unabhängig von den sonstigen Schlüsseln der Entity-Mengen.\nUnd da Primärschlüssel Pflichteingabespalten sind, sind es auch die künstlichen Primärschlüssel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Er ist Pflichteingabeattribut.",
        "solution": "true"
      },
      {
        "text": "Er besteht aus einem oder mehreren Attributen.",
        "solution": "false"
      },
      {
        "text": "Sein Datentyp ist beliebig (numerisch oder alphanumerisch oder ).",
        "solution": "false"
      },
      {
        "text": "Er enthält eine fortlaufende Nummer.",
        "solution": "true"
      },
      {
        "text": "Anfragen können mit seiner Hilfe schneller beantwortet werden.",
        "solution": "true"
      },
      {
        "text": "Fremdschlüssel können keine künstlichen Primärschlüssel referenzieren.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3071,
    "category": 6,
    "difficulty": 3,
    "text": "Mit welchen Befehlen werden Einträge im Data Dictionary verwaltet?",
    "explanation": "Die \"Daten\" im Data Dictionary sind die im Schema angelegten DB-Objekte wie Tabellen, Sichten, Indexe, Sequenzen, ... Dem entsprechend werden die Strukturbeschreibungen neuer Objekte mittels CREATE-Befehlen im Data Dictionary eingefügt, mittels ALTER-Befehlen geändert und DROP-Befehlen gelöscht.  \n\nDas Dictionary von Oracle umfasst eine Vielzahl von Tabellen bzw. Sichten. Sie sind in verschiedene Gruppen aufgeteilt, die im Namen deutlich werden:\nUSER_...: Sichten für alle DB-Objekte, die ein Benutzer selbst angelegt hat.\nALL_...: Sichten für alle DB-Objekte, die ein Benutzer selbst angelegt hat bzw. für die er von anderen Anwendern Zugriffsrechte bekommen hat.\nDBA_...: Sichten für alle DB-Objekte, die überhaupt in der Datenbank existieren. Auf diese Sichten hat nur ein Benutzer mit Administrationsrechten Zugriff.\nV$-Views: Sichten mit statistischen Informationen. \nUSER_CONSTRAINTS gibt Auskunft über die vom Anwender angelegten Constraints.\nUSER_CONS_COLUMNS gibt Auskunft über die von den Constraints betroffenen Spalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE",
        "solution": "true"
      },
      {
        "text": "ALTER",
        "solution": "true"
      },
      {
        "text": "DROP",
        "solution": "true"
      },
      {
        "text": "INSERT",
        "solution": "false"
      },
      {
        "text": "UPDATE",
        "solution": "false"
      },
      {
        "text": "DELETE",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3477,
    "category": 8,
    "difficulty": 1,
    "text": "Welcher Oracle-Optimizer entspricht der logischen Optimierung der relationalen Algebra?",
    "explanation": "Der CBO ist Standard bei Oracle-Versionen ab Version 10g und benutzt Statistiken, die in der Datenbank gespeichert sind.\n\n    Der RBO (Rule Based Optimizer) benutzt ähnliche Heuristiken (12 Regeln)  wie die Heuristiken der logischen Optimierung in der relationalen Algebra. Er war Standard bis Oracle 9i.\n\n    siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CBO  Cost Based Optimizer",
        "solution": "false"
      },
      {
        "text": "keiner von beiden.",
        "solution": "false"
      },
      {
        "text": "RBO  Rule Based Optimizer",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2816,
    "category": 6,
    "difficulty": 2,
    "text": "Betrachten Sie die beiden folgenden CREATE-Table-Befehle:\n\n    CREATE TABLE Auftraege\n\n    (AuftragsNr NUMBER(38) PRIMARY KEY,\n\n    Auftrags_Typ VARCHAR2(50) NOT NULL,\n\n    Kun_Nr NUMBER(38) NOT NULL,\n\n    Ang_Nr NUMBER(38),\n\n    auftragssumme NUMBER);\n\n    \n\n    CREATE TABLE Auftragspositionen ,\n\n    (TNr NUMBER(38),\n\n    AuftragsNr NUMBER(38),\n\n    Menge NUMBER,\n\n    PRIMARY KEY Auftragspositionen(TNR, AuftragsNr));\n\n    \n\n    Welche CREATE-Index-Anweisungen sind korrekt?",
    "explanation": "Ein Index kann immer nur auf einer Tabelle definiert werden und auch nicht, wenn schon ein entsprechender Primärschlüssel mit den gleichen Spalten existiert. Siehe die Syntaxbeschreibung der CREATE-INDEX-Anweisung im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/CREATE-INDEX\"> CREATE-INDEX-Anweisung",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE UNIQUE INDEX Auftr_INDEX ON Auftraege(TNr);",
        "solution": "false"
      },
      {
        "text": "CREATE UNIQUE INDEX Auftragspos_INDEX1 ON Auftragspositionen(TNr);",
        "solution": "true"
      },
      {
        "text": "CREATE UNIQUE INDEX Auftragspos_INDEX2 ON Auftragspositionen(AuftragsNr);",
        "solution": "true"
      },
      {
        "text": "CREATE UNIQUE INDEX Auftragspos_INDEX3 ON Auftraege, Auftragspositionen(AuftragsNr, Menge);",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2817,
    "category": 6,
    "difficulty": 3,
    "text": "Betrachten Sie die folgende CREATE-Table-Anweisung und die anschließende ALTER-Anweisung:\n\n    CREATE TABLE Artikel (TNr NUMBER(38) PRIMARY KEY,\n\n    Bezeichnung VARCHAR2(50) NOT NULL,\n\n    Artikel_Typ VARCHAR2(50) NOT NULL,\n\n    Verkaufspreis NUMBER,\n\n    Jahresumsatz NUMBER,\n\n    Zeitstempel DATE);\n\n     ALTER TABLE Artikel DROP COLUMN Jahresumsatz;\n\n    Welche Aussagen sind wahr?",
    "explanation": "ALTER-Table gehört zur DDL-Sprache und kann daher nicht zurückgerollt werden, da sie ein AUTOCOMMIT beinhaltet. Siehe auch <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/ALTER-TABLE\"> ALTER-TABLE",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Spalte Jahresumsatz wird gelöscht, auch wenn Daten enthalten sind.",
        "solution": "true"
      },
      {
        "text": "Die Spalte Jahresumsatz wird nur gelöscht, wenn keine Daten enthalten sind.",
        "solution": "false"
      },
      {
        "text": "Die Spalte Jahresumsatz wird nur gelöscht, wenn mindestens eine Spalte in der Tabelle verbleibt.",
        "solution": "true"
      },
      {
        "text": "Eine Alter-Table-Anweisung kann über die ROLLBACK-Anweisung wieder zurückgerollt werden.",
        "solution": "false"
      },
      {
        "text": "Die Spalte Jahresumsatz kann sogar gelöscht werden, wenn sie Bestandteil eines zusammengesetzten Primärschlüssels ist.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3136,
    "category": 13,
    "difficulty": 3,
    "text": "Betrachten Sie den folgenden Trigger:\n\nCREATE OR REPLACE  TRIGGER LOESCHE_ANGESTELLTE\nAFTER UPDATE ON   ANGESTELLTE\nDECLARE num_rows NUMBER; \nBEGIN      \n:NEW.zeitstempel := sysdate;      \n WHEN OTHERS THEN      \n DBMS_OUTPUT.PUT_LINE('Fehler aufgetreten!');\n            END;Welche Aussage(n) sind wahr?",
    "explanation": "Nur Zeilentrigger dürfen die Transitionsvariablem :NEW und :OLD verwenden  Dieser Fehler wird schon zur Übersetzungszeit erkannt (siehe <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Zeilenorientierter-Trigger\" title=\"Zeilentrigger\" target=\"_blank\">Zeilentrigger).",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es wird ein Übersetzungsfehler geworfen, da der Trigger kein Zeilentrigger ist.",
        "solution": "true"
      },
      {
        "text": "Es wird ein Übersetzungsfehler geworfen, da der Trigger keine EXCEPTION werfen darf.",
        "solution": "false"
      },
      {
        "text": "Es wird ohne Fehler übersetzt, aber der Trigger wirft einen Laufzeitfehler.",
        "solution": "false"
      },
      {
        "text": "Der Trigger wird übersetzt und funktioniert fehlerfrei.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 2824,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussage(n) über Unterabfragen sind wahr?",
    "explanation": "siehe Erklärungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der NOT-Operator kann zusammen mit IN, ALL oder ANY benutzt werden.",
        "solution": "false"
      },
      {
        "text": "NOT IN ist äquivalent zu IS NULL",
        "solution": "false"
      },
      {
        "text": "= ANY und = All haben die gleiche Funktionalität",
        "solution": "false"
      },
      {
        "text": "Der IN-Operator kann benutzt werden, wenn die Unterabfrage nur eine Zeile liefert.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2905,
    "category": 7,
    "difficulty": 2,
    "text": "Welche SELECT-Abfrage beantwortet die Frage :\n\n    \n\n    \"In welchem Land leben die meisten Menschen?\"\n\n    \n\n    auf der Tabelle country:\n\n    \n\n    CREATE TABLE Country\n\n    (Name VARCHAR2(35) NOT NULL UNIQUE,\n\n    COUNTRY VARCHAR2(4) CONSTRAINT CountryKey PRIMARY KEY,\n\n    Capital VARCHAR2(35),\n\n    Province VARCHAR2(35),\n\n    Population NUMBER);",
    "explanation": "Die Abfrage mit <> ALL ist syntaktisch korrekt, liefert aber nicht die gewünschten Länder.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT   country, Name, population    FROM   country  WHERE population <>  ALL (  SELECT   population from country);",
        "solution": "false"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "SELECT   country, Name, population    FROM   country  WHERE population >= ALL (  SELECT   population from country);",
        "solution": "true"
      },
      {
        "text": "SELECT   country, Name, population    FROM   country  WHERE population = (SELECT MAX(population) from country)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2927,
    "category": 15,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation mit drei Spalten. \nWie viele Indizes kann man  anlegen?",
    "explanation": "Bei vier Spalten berechnet sich die Anzahl der mögliche Indizes x nach der Formel: x = Summe [k=1..n] (n!/(n-k)!), wobei n! die Fakultät ist.Für n= 4 erhält man:    x = 4x3x2x1 + 4x3x2 + 4x3 + 4 = 64Für n= 3 bei drei Spalten entsprechend:    x = 3x2x1 + 3x2 + 3x1 = 15Das ist die Anzahl der möglichen nicht leeren geordneten Teilmengen einer vierelementigen Menge. Diese Mengen heißen in der Kombinatorik Variationen, siehe auch http://de.wikipedia.org/wiki/Abzählende_Kombinatorik.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "1",
        "solution": "false"
      },
      {
        "text": "3",
        "solution": "false"
      },
      {
        "text": "5",
        "solution": "false"
      },
      {
        "text": "9",
        "solution": "false"
      },
      {
        "text": "15",
        "solution": "true"
      },
      {
        "text": "18",
        "solution": "false"
      },
      {
        "text": "64",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3424,
    "category": 6,
    "difficulty": 2,
    "text": "Welche Auswirkung hat die folgende Anweisung?\n\n    \n\n    CREATE TABLE ist_mitglied\n\n    ( Staat_id          INTEGER NOT NULL,\n\n       Organisation_id   INTEGER NOT NULL,\n\n       TYPE              VARCHAR2 (20)\n\n             UNIQUE\n\n             CONSTRAINT TYPE_CHECK CHECK\n\n                (TYPE IN (\"Mitglied\", \"Anwärter\", \"Gast\", \"Beobachter\")),\n\n       PRIMARY KEY (Staat_id, Organisation_id) );",
    "explanation": "Durch das UNIQUE können die Werte \"Mitglied\", \"Anwärter\", \"Gast\", \"Beobachter\" nur genau enmal in die Tabelle eingefügt werden. Daher können höchsten vier Werte in die Tabelle Mitglied eingefügt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es wird geprüft, ob in der Spalte Type die Werte Mitglied, Anwärter, Gast oder Beobachter steht, wobei Großschreibung und Kleinschreibung keine Rolle spielen.",
        "solution": "false"
      },
      {
        "text": "In  die Tabelle ist_Mitglied können nicht mehr als vier  in Datensätze eingefügt werden.",
        "solution": "true"
      },
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "Es wird geprüft, ob in der Spalte Type die Werte Mitglied, Anwärter, Gast oder Beobachter steht, wobei Großschreibung und Kleinschreibung eine Rolle spielen.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3068,
    "category": 5,
    "difficulty": 3,
    "text": "Welche Aussagen über 1:1- bzw. 1:c1-Beziehungen zwischen zwei Entity-Mengen sind wahr?",
    "explanation": "Für 1:1 bzw. 1:c1-Beziehungen gilt, dass die beiden Entity-Mengen entweder auf zwei Relationen abgebildet werden oder eben zu einer zusammengefasst werden. Das Zusammenfassen ist problemlos möglich, da beide Entity-Mengen über den gleichen Primärschlüssel verfügen. \n\nBeim Abbilden auf zwei Relationen wird die 1:1/1:c1-Beziehung auf eine Fremdschlüsselbeziehung abgebildet. Da aber Fremdschlüsselbeziehungen eigentlich nur 1:n/1:cn-Beziehungen realisieren, muss für eine 1:1-Beziehung zusätzlich gewährleistet sein, dass die Primärschlüssel beider Relationen gleich sind, also aus dem/den gleichen Attributen bestehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sie können nur auf eine Relation abgebildet werden.",
        "solution": "false"
      },
      {
        "text": "Sie können auf eine oder zwei Relationen abgebildet werden.",
        "solution": "true"
      },
      {
        "text": "Bei der Abbildung auf zwei Relationen wird eine Fremdschlüsselbeziehung benötigt.",
        "solution": "true"
      },
      {
        "text": "Bei der Abbildung auf zwei Relationen müssen die beiden Primärschlüssel gleich sein.",
        "solution": "true"
      },
      {
        "text": "Bei der Abbildung auf zwei Relationen müssen gleiche Zweitschlüssel (UNIQUE KEY) definiert sein.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3075,
    "category": 8,
    "difficulty": 2,
    "text": "Welche Datenbank-Situationen können eine schlechte Performance mit langen Wartezeiten verursachen?",
    "explanation": "Bei einer View-Hierarchie muss das Datenbanksystem unter Umständen alle beteiligten Views parsen, was einen erhöhten Zeitaufwand bedeutet. Kartesische Produkte können zu einem sehr großen Datenvolumen führen, das von der Festplatte gelesen werden muss. Natural-Join sind in der Regel schnell, da Sie über die Primärschlüssel auf die Tabellen zugreifen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Die Anfrage bezieht sich auf eine View, die an oberster Stelle in ener View-Hierachie steht.",
        "solution": "true"
      },
      {
        "text": "Die SELECT-Anfrage enthält ein kartesisches Produkt.",
        "solution": "true"
      },
      {
        "text": "Die SELECT-Anfrage enthält einen Natural-Join.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3101,
    "category": 8,
    "difficulty": 1,
    "text": "Welcher Join-Operator passt, wenn alle Spalten in der Anfrage Index-Spalten sind?",
    "explanation": "Das ist der Index Join,\nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#INDEX _JOIN\" target=\"_blank\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Join-Operationen#INDEX _JOIN  .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Cartesian Join",
        "solution": "false"
      },
      {
        "text": "Nested Loop Join",
        "solution": "false"
      },
      {
        "text": "Hash Join",
        "solution": "false"
      },
      {
        "text": "Sort Merge Join",
        "solution": "false"
      },
      {
        "text": "Outer Join",
        "solution": "false"
      },
      {
        "text": "Index Join",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3078,
    "category": 8,
    "difficulty": 1,
    "text": "Welcher Optimizer wird bei Oracle seit Version 10g benutzt?",
    "explanation": "Der CBO ist Standard bei Oracle-Versionen ab Version 10g und benutzt Statistiken, die in der Datenbank gespeichert sind.\nsiehe <a = href = \"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer\" target=\"_blank\"> http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Optimizer .",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "RBO  Rule Based Optimizer",
        "solution": "false"
      },
      {
        "text": "CBO  Cost Based Optimizer",
        "solution": "true"
      },
      {
        "text": "keiner von beiden.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3083,
    "category": 8,
    "difficulty": 1,
    "text": "Es gibt eine Tabelle Nation mit den Spalten Nation_id, Name, Flagge und auf der Nation_id ist der Primärschlüssel definiert. Welcher Befehl ist der kostengünstigste/schnellste?",
    "explanation": "Da für einen Primärschlüssel automatisch ein Index definiert wird und die Anfrage auf keine weiteren Spalten zugreift, ist der COUNT über die Nation_id die kostengünstigste und schnellste Lösung. Die Anfrage kann so ausschließlich über den Index und ohne Zugriff auf die eigentlichen Datensätze ausgewertet werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT COUNT(*) FROM Nation n;",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(n.Name) FROM Nation n;",
        "solution": "false"
      },
      {
        "text": "SELECT COUNT(n.Nation_id) FROM Nation n;",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3104,
    "category": 12,
    "difficulty": 2,
    "text": "Betrachten Sie den folgenden PL/SQL-Code:\n\n    <font face=\"courier new\">create table ang_temp \n\n    <font face=\"courier new\">  (angid number not null primary key,\n\n       abtid number check (abtid between 100 and 500),\n\n       abtname varchar2(500) default \"test\");\n\n    \n\n    <font face=\"courier new\">declare\n\n    ang_c ang_temp%rowtype;\n\n    BEGIN\n\n    \n\n    ang_c.angid := NULL;\n\n    ang_c.abtid := 50;\n\n    dbms_output.PUT_LINE(\"Hallo\" || ang_c.abtname);\n\n    END;\n\n    /\n\n    \n\n    Welche Aussagen treffen zu?",
    "explanation": "Im Record -Typ ang_c <font face=\"courier new\">ang_temp%rowtype werden nur die  Datentypen übernommen, aber nicht die zugehörigen CONSTRAINTS der Tabelle ang_temp geprüft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der PL/SQL-Code wird ausgeführt und liefert das Ergebnis Hallo.",
        "solution": "true"
      },
      {
        "text": "Der PL/SQL-Code wird ausgeführt und liefert das Ergebnis test",
        "solution": "false"
      },
      {
        "text": "Der anonyme Block wird nicht ausgeführt sondern wirft einen Fehler, weil <font face=\"courier new\">ang_c.angid keinen NULL-Wert haben darf.",
        "solution": "false"
      },
      {
        "text": "Der anonyme Block wird nicht ausgeführt sondern wirft einen Fehler, weil ang_c.abtid den CHECK-Constraint der Tabelle ang_temp verletzt.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3090,
    "category": 8,
    "difficulty": 1,
    "text": "Welche Datenbankoperation ist in der Regel unter Oracle-SQL die langsamste?",
    "explanation": "EXISTS und BETWEEN haben in der Regel eine bessere Performance als IN.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "EXISTS",
        "solution": "false"
      },
      {
        "text": "BETWEEN",
        "solution": "false"
      },
      {
        "text": "IN",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3119,
    "category": 12,
    "difficulty": 3,
    "text": "Betrachten Sie den folgenden anonymen PL-SQL-Block auf der Tabelle\n\n    Angestellte(ang_nr, Name, abt_nr, gehalt, ....)\n\n    <font face=\"courier new\">SET SERVEROUTPUT ON; \n\n    <font face=\"courier new\">DECLARE\n\n       v_summe NUMBER;\n\n       abt_nr angestellte.ang_nr%TYPE = 5;\n\n    BEGIN\n\n       SELECT SUM(gehalt)\n\n       FROM angestellte v_summe INTO v_summe\n\n       WHERE abt_nr = abt_nr;\n\n       DBMS_OUTPUT.PUT_LINE(\"Die Gehaltssumme in Abteilung 5 ist \" || to_char(v_summe);\n\n    \n\n    END;\n\n    \n\n    Welche Aussagen sind wahr?",
    "explanation": "Ein anonymer PL/SQL-Block ignoriert leider in SQL-Angeweisungen Variablenamen, die gleich Spaltennamen sind. Es wird die Bedingung \"abt_nr = abt_nr\" geprüft, die immer wahr ist. Es wird daher die Summe über alle Gehälter über alle Abteilungen berechnet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Der anonyme Block wirft einen Fehler, weil Gruppenfunktionen (SUM) nicht in anonymen Blöcken genutzt werden dürfen.",
        "solution": "false"
      },
      {
        "text": "Der  anonyme Block wird ausgeführt und gibt die Summe über alle Gehälter in Abteilung 5 aus.",
        "solution": "false"
      },
      {
        "text": "Der  anonyme Block wird ausgeführt und gibt nicht die Summe über alle Gehälter in Abteilung 5 aus.",
        "solution": "true"
      },
      {
        "text": "Der anonyme Block wirft einen Fehler, weil der Variablenname in der SELECT-Anweisung gleich dem Spaltennamen ist.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3134,
    "category": 12,
    "difficulty": 2,
    "text": "Mit welchem Schleifentyp können Sie die Verarbeitung expliziter Cursor verkürzen?",
    "explanation": "FOR record_name IN cursor_name LOOP   \n  statement1;\n  statement2;\n  . . .\nEND LOOP;",
    "type": "text",
    "answers": [
      {
        "text": "Das sind:",
        "solution": "Cursor-FOR-Schleifen"
      }
    ]
  },
  {
    "id": 3073,
    "category": 8,
    "difficulty": 1,
    "text": "Was ist eine Grundanforderung beim SQL-Tuning, auf die man nicht verzichten kann?",
    "explanation": "Es geht nur um das SQL-Tuning, da bleibt die Datenbankinstance unverändert. Die  Semantik muss dabei erhalten bleiben, die Syntax nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Beibehalten der korrekten Semantik",
        "solution": "true"
      },
      {
        "text": "Beibehalten einer unveränderten Syntax der SQL-Anweisung",
        "solution": "false"
      },
      {
        "text": "Änderung an den Parametern der Datenbankinstance",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3423,
    "category": 6,
    "difficulty": 2,
    "text": "Welche Auswirkung hat die folgende Anweisung, wenn die Tabelle Mitglied die Spalte TYPE enthält?\n\n    \n\n    ALTER TABLE  Mitglied\n\n    ADD CONSTRAINT  TYPE_CHECK CHECK (UPPER(TYPE) IN (\"Mitglied\", \"Anwärter\", \"Gast\", \"Beobachter\"));",
    "explanation": "Da die Werte \"Mitglied\", \"Anwärter\" etc . nicht in Großbuchstaben geschrieben sind, kann die Check-Bedingung TYPE CHECK nie erfüllt sein. Daher  können keine Werte in die Tabelle Mitglied eingefügt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es wird geprüft, ob in der Spalte Type die Werte Mitglied, Anwärter, Gast oder Beobachter steht, wobei Großschreibung und Kleinschreibung keine Rolle spielen.",
        "solution": "false"
      },
      {
        "text": "In  die Tabelle Mitglied kann nie wieder ein Datensatz eingefügt werden.",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3487,
    "category": 7,
    "difficulty": 3,
    "text": "Welche Aussage(n) über Unterabfragen sind wahr?",
    "explanation": "Der In-Operator kann immer benutzt werden, unabhängig davon, wieviele Zeilen die Unterabfrage liefert.\n\n    siehe Erklärungen von Unterabfragen im Datenbankwiki unter <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Suchbedingung\"> Unterabfragen",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keine von allen",
        "solution": "false"
      },
      {
        "text": "Der IN-Operator kann auch benutzt werden, wenn die Unterabfrage nur eine Zeile liefert.",
        "solution": "true"
      },
      {
        "text": "Der IN-Operator kann auch benutzt werden, wenn die Unterabfrage mehr als eine Zeile liefert.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2866,
    "category": 6,
    "difficulty": 3,
    "text": "Welche abhängigen Objekte werden mit dem  DROP TABLE Befehl gelöscht?",
    "explanation": "Bis auf die Views werden alle abhängigen Objekte gelöscht. Die Views bleiben als Definition erhalten, sind aber erst wieder benutzbar, wenn die Tabelle neu angelegt wird. Unter Oracle wird der Status in user_objects auf 'invalid' gesetzt und die View muss neu übersetzt werden.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Indizes, die auf der Tabelle definiert sind",
        "solution": "true"
      },
      {
        "text": "Constraints, die auf der Tabelle definiert sind",
        "solution": "true"
      },
      {
        "text": "Views, die auf der Tabelle definiert sind",
        "solution": "false"
      },
      {
        "text": "Die Daten der Tabelle",
        "solution": "true"
      },
      {
        "text": "Trigger, die auf der Tabelle definiert sind.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 2868,
    "category": 13,
    "difficulty": 3,
    "text": "Auf einer Tabelle Test soll ein Oracle-Trigger geschrieben werden, der verhindert, dass mehr als 2 Datensätze in der Tabelle angelegt werden. Welcher Trigger erfüllt diese Aufgabe?\n\nCREATE TABLE test (\n       NR NUMBER ,\n       Bezeichnung VARCHAR2(20));",
    "explanation": "Der Trigger kann nicht als Zeilentrigger (FOR EACH ROW) definiert werden, da der SELECT das Mutating-Table-Problem auslösen würde.\n\nDer BEFORE-INSERT-Trigger wird zum falschen Zeitpunkt angestossen, da vor dem eigentlichen INSERT die Anzahl der Datensätze noch nicht bekannt ist, die nach dem INSERT in der Datenbank stehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "CREATE TRIGGER pruefen\nAFTER INSERT ON test\nDECLARE\nMY_VAR NUMBER;\nBEGIN\n      SELECT count(*) INTO MY_VAR FROM Test;        \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-20001, 'Zu viele Daten!');\n    END IF;\nEND;\n",
        "solution": "true"
      },
      {
        "text": "CREATE TRIGGER pruefen\nBEFORE INSERT ON test\nDECLARE\nMY_VAR NUMBER;\nBEGIN\n      SELECT count(*) INTO MY_VAR FROM Test;        \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-20001, 'Zu viele Daten!');\n    END IF;\nEND;",
        "solution": "false"
      },
      {
        "text": "CREATE TRIGGER pruefen\nBEFORE INSERT ON test\nFOR EACH ROW\nDECLARE\nMY_VAR NUMBER;\nBEGIN\n        SELECT count(*) INTO MY_VAR FROM Test;        \n    IF MY_VAR > 2\n    THEN\n       RAISE_Application_error(-20001, 'Zu viele Daten!');\n    END IF;\nEND;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3363,
    "category": 13,
    "difficulty": 1,
    "text": "In Oracle-Instead-Of-Triggern können die Transitionsvariablen :OLD.spaltenname beschrieben werden.",
    "explanation": "Die Transitionsvariablen :NEW.spaltenname können unter Oracle-PL/SQL bei INSTEAD-OF-Triggern zwar gelesen, aber nicht beschrieben werden. Die :OLD.Transitionsvariablen können nie beschrieben werden, das sie einen alten Zustand enthalten.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3192,
    "category": 7,
    "difficulty": 1,
    "text": "Welche Aussagen über Views (Sichten) sind wahr?",
    "explanation": "Den View -Begriff (änderbare Sicht)  bitte im DB-Wiki unter   <a href=\"http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht\" target=\"\" title=\"Änderbare Sicht\">http://wikis.gm.fh-koeln.de/wiki_db/Datenbanken/Aenderbare-Sicht nachschlagen!",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Eine View, in der Spaltenabkürzungen benutzt werden (create view  as select spalte1 as neue_Spalte) erlaubt kein UPDATE der Daten.",
        "solution": "false"
      },
      {
        "text": "Eine View, mit einer SELECT-Anweisung, die DISTINCT enthält, erlaubt kein UPDATE der Daten.",
        "solution": "true"
      },
      {
        "text": "Wenn man in einer virtuellen View Daten löscht, bleiben diese Daten in der zugrundeliegenden Tabelle enthalten.",
        "solution": "false"
      },
      {
        "text": "Mit CREATE OR REPLACE view wird eine VIEW erst gelöscht (DROP) und dann wieder angelegt.",
        "solution": "true"
      },
      {
        "text": "Mit der ORACLE-Option \"WITH CHECK OPTION\" kann man die in einer View enthaltenen Spalten einschränken.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3507,
    "category": 12,
    "difficulty": 3,
    "text": "Folgende Prozedur sei gegeben:\n\n    CREATE OR REPLACE PROCEDURE test_proc (p1   IN   NUMBER,  p2   IN OUT   NUMBER, p3   OUT    NUMBER) ... ;\n\n    Welche Parameterverwendungen im Programm sind korrekt?",
    "explanation": "PL/SQL unterschiedet drei Typen der Parameterübergabe: IN, OUT und IN OUT, wobei IN der Defaultwert ist.\n\n    \n\n    Beim Typ IN wird der Übergabewert beim Aufruf in das Programm übernommen, Dieser Typ verhält sich daher wie eine Konstante innerhalb eines Programms. Parameter vom Typ IN sind daher nicht in Zuweisungen verwendbar sondern nur in Bedingungen etc..\n\n    \n\n    Beim Typ OUT wird ein Wert aus dem Programm heraus an das aufrufende Programm übergeben und IN OUT ist eine Kombination aus beiden Möglichkeiten. Beim Typ OUT gibt es eine Wertübergabe in initialisierter Form an die Prozedur und Rückgabe eines veränderten Werts an das aufrufende Objekt. Dieser Typ verhält sich daher wie eine nicht initialisierte Variable, die nur einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann. Parameter vom Typ OUT  sind daher in Zuweisungen, Bedingungen, etc. verwendbar.\n\n    \n\n    Der Typ IN OUT verhält sich wie eine initialisierte Variable, die einen Wert aufnehmen und an das aufrufende Objekt zurückgeben kann. Parameter vom Typ IN OUT sind daher in Zuweisungen, Bedingungen etc. verwendbar.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "p1 := p2;",
        "solution": "false"
      },
      {
        "text": "p2 := p1;",
        "solution": "true"
      },
      {
        "text": "WHILE p2 < 345 LOOP ;",
        "solution": "true"
      },
      {
        "text": "IF p3 = 456 THEN ;",
        "solution": "true"
      },
      {
        "text": "p3:= p1;",
        "solution": "true"
      },
      {
        "text": "RETURN p3;",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3523,
    "category": 16,
    "difficulty": 1,
    "text": "Welche Aussagen zu PHP sind richtig?",
    "explanation": "PHP ist eine weit verbreitete Scriptsprache bei gut 80% aller Websites und seit vielen Jahren im Web etabliert. PHP ist einfach zu erlernen, aber dennoch sehr mächtig und performant. PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL möglich macht. PHP hat sich zu einem Quasi-Standard für Server-seitige Programmiersprachen von Webanwendungen entwickelt.\n\n    \n\n    Erfunden wurde sie 1994 von Rasmus Lerdorf (ursprünglich: Personal Home Page) und besteht aus einfachen Textdateien mit .php–Endung. Mittlerweilse steht das Akronym PFP: Hypertext Preprocessor. Die Ausgabe erfolgt vielfach im HTML-Format.  \n\n    \n\n    Seit PHP Version 5 ist objektorientiertesProgrammieren möglich. Somit ist eine Klassifizierung von Objekten der reelenWelt auf einen bestimmten Kontext umsetzbar.\n\n    –Vereinfacht: Funktionen/Methoden können in Klassen zusammengefasst werden, um unendlich viele Objekte (mit verschiedenen Ausprägungen) instanzierenzu können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PHP ist eine weit verbreitete Scriptsprache und seit vielen Jahren im Web etabliert.",
        "solution": "true"
      },
      {
        "text": "PHP ist einfach zu erlernen, weil sie nicht so mächtig ist.",
        "solution": "false"
      },
      {
        "text": "PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL möglich macht.",
        "solution": "true"
      },
      {
        "text": "Es sind einfache Textdateien mit .php-Endung.",
        "solution": "true"
      },
      {
        "text": "PHP unterstützt als Ausgabeformat leider kein HTML.",
        "solution": "false"
      },
      {
        "text": "PHP ist bislang immer noch eine rein prozedurale Programmiersprache.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3529,
    "category": 16,
    "difficulty": 2,
    "text": "<div style=\"margin-left:.38in;\">\n    In PHP gibt es interne Funktionen, die eine Verwendung von MySQL-Datenbanken einfach machen. Wie heißen sie?",
    "explanation": "<div style=\"margin-left:.38in;\">\n    In PHP gibt es interne Funktionen, die eine Verwendung von MySQL-Datenbanken einfach machen.\n<div style=\"margin-left:.81in;\">\n    –MySQLi (MySQL Improved Extension)\n<div style=\"margin-left:1.25in;\">\n    •<a href=\"http://www.php.net/manual/en/book.mysqli.php\">http://<a href=\"http://www.php.net/manual/en/book.mysqli.php\">www.php.net/manual/en/book.mysqli.php\n<div style=\"margin-left:.81in;\">\n    –PDO (PHP Data Objects)\n<div style=\"margin-left:1.25in;\">\n    •<a href=\"http://www.php.net/manual/de/book.pdo.php\">http://<a href=\"http://www.php.net/manual/de/book.pdo.php\">www.php.net/manual/de/book.pdo.php",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "MySQLphp",
        "solution": "false"
      },
      {
        "text": "MySQLi",
        "solution": "true"
      },
      {
        "text": "PHPConnect",
        "solution": "false"
      },
      {
        "text": "PDO",
        "solution": "true"
      },
      {
        "text": "MPC",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3579,
    "category": 13,
    "difficulty": 1,
    "text": "Sobald ein Trigger erzeugt und aktiviert wird, werden rückwirkend alle in der Datenbank vorhandenen Daten geprüft, ob sie dem Trigger  genügen. Falls dies nicht der Fall ist, kann der Trigger nicht erzeugt werden.",
    "explanation": "Genau das ist der Schutz, den Datenbanksysteme bei Constraints, aber nicht bei Triggerrn bieten. Werden Trigger verwendet, besteht diese Sicherheit nicht. Es werden nur alle Datenmanipulationen ab dem Zeitpunkt der Triggererzeugung überprüft.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt",
        "solution": "false"
      },
      {
        "text": "stimmt nicht",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3643,
    "category": 3,
    "difficulty": 1,
    "text": "Welche Einschränkungen hat das klassische ER-Modell?",
    "explanation": "Die Anzahl der Attribute sind weder in UML noch im ER-Modell beschränkt, nur in manchen konkreten Datenbanksystemen. Die anderen Eigenschaften sind gerade die wesentlichen n Einschränkungren des klasischen ER-Modells.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Mehrwertige Attribute fehlen",
        "solution": "true"
      },
      {
        "text": "Die Anzahl der Attribute ist beschränkt.",
        "solution": "false"
      },
      {
        "text": "Zusammengesetzte Attribute fehlen",
        "solution": "true"
      },
      {
        "text": "Es gibt keine Vererbung",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3682,
    "category": 14,
    "difficulty": 1,
    "text": "Bei welchem Problem werden nicht freigegebene Änderungen (ohne commit) überschrieben?",
    "explanation": "Beim LOST UPDATE Problem handelt es sich um das Überschreiben von geänderten Daten. Bei allen anderen Problemen werden nicht freigegebene Änderungen in unterschiedlicher Weise verwendet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PHANTOM",
        "solution": "false"
      },
      {
        "text": "LOST UPDATE",
        "solution": "true"
      },
      {
        "text": "DIRTY READ",
        "solution": "false"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3640,
    "category": 3,
    "difficulty": 1,
    "text": "Welche Beziehungstypen sieht das EERM (Erweitertes Entity-Relationship-Modell) vor?",
    "explanation": "Das ist die Definition des EERM!\n\n    Ein ER-Modell, das zusätzlich zu den klassischen Beziehungsarten und Attributen, IS-A-Beziehungen und Aggregation sowie, mehrwertige und zusammengesetzte Attribute vorsieht,  bezeichnen wir als EERM. \n\n    (min-max) Beziehungen mit numerisch exakter Kardinalität, wie z.B. 1-10-Beziehungen,. sind nur in UML vorgesehen.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Alle Beziehungstypen des klassischen ER-Modells können verwendet werden.",
        "solution": "true"
      },
      {
        "text": "IS-A-Beziehungen",
        "solution": "true"
      },
      {
        "text": "(Min-Max)-Beziehungen, bei denen die Kardinalität numerisch festgelegt werden kann, z.B- 1-10-Beziehungen",
        "solution": "false"
      },
      {
        "text": "Aggregationen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3518,
    "category": 13,
    "difficulty": 2,
    "text": "In welchen Triggern sind die Transitionsvariablen :OLD gefüllt?",
    "explanation": ":OLD-Transitionsvariablen sind nur in ROW-Triggern für DELETE und UPDATE gefüllt und unabhängig von AFTER und BEFORE, ebenso wie in INSTEAD-OF-Trigger für diese Ereignisse.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BEFORE UPDATE STATEMENT",
        "solution": "false"
      },
      {
        "text": "AFTER INSERT ROW",
        "solution": "false"
      },
      {
        "text": "INSTEAD OF UPDATE-Trigger",
        "solution": "true"
      },
      {
        "text": "AFTER DELETE ROW",
        "solution": "true"
      },
      {
        "text": "BEFORE UPDATE ROW",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3522,
    "category": 16,
    "difficulty": 1,
    "text": "Welche Aussagen zu MySQL sind richtig?",
    "explanation": "Während ORACLE den Markt im Enterprise-Segment anführt, führt MySQL im Web. MySQL ist eine etablierte und kostenfreie Alternative für „kleinere“ Datenbankanwendungen. MySQL ist einfach zu installieren und zu administrieren. MySQL gehört seit dem Verkauf von SUN Microsystems auch zum Unternehmen ORACLE, ist aber weiterhin OpenSource.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "MySQL ist einfach zu installieren und zu administrieren.",
        "solution": "true"
      },
      {
        "text": "MySQL ist eine etablierte und kostenfreie Alternative für „kleinere“ Datenbankanwendungen.",
        "solution": "true"
      },
      {
        "text": "MySQL führt den Markt im Enterprise-Segment an.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3524,
    "category": 16,
    "difficulty": 1,
    "text": "Welche Aussagen zu PHP sind richtig?",
    "explanation": "PHP ist eine weit verbreitete Scriptsprache bei gut 80% aller Websites und seit vielen Jahren im Web etabliert. PHP ist einfach zu erlernen, aber dennoch sehr mächtig und performant. PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL möglich macht. PHP hat sich zu einem Quasi-Standard für Server-seitige Programmiersprachen von Webanwendungen entwickelt.\n\n    \n\n    Erfunden wurde sie 1994 von Rasmus Lerdorf (ursprünglich: Personal Home Page) und besteht aus einfachen Textdateien mit .php–Endung. Mittlerweilse steht das Akronym PFP: Hypertext Preprocessor. Die Ausgabe erfolgt vielfach im HTML-Format.  \n\n    \n\n    Seit PHP Version 5 ist objektorientiertesProgrammieren möglich. Somit ist eine Klassifizierung von Objekten der reelenWelt auf einen bestimmten Kontext umsetzbar.\n\n    –Vereinfacht: Funktionen/Methoden können in Klassen zusammengefasst werden, um unendlich viele Objekte (mit verschiedenen Ausprägungen) instanzierenzu können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PHP ist eine weit verbreitete Datenbankprogrammiersprache für gespeicherte Routinen.",
        "solution": "false"
      },
      {
        "text": "PHP ist einfach zu erlernen, aber dennoch sehr mächtig und performant.",
        "solution": "true"
      },
      {
        "text": "MySQL bringt Methoden mit, die eine schnelle Implementierung mit php möglich macht.",
        "solution": "false"
      },
      {
        "text": "Es wird mindestens die Verwendung von Version 5.3 empfohlen.",
        "solution": "true"
      },
      {
        "text": "PHP erzeugt als Ausgabe i.d.R. HTML-Dateien.",
        "solution": "true"
      },
      {
        "text": "PHP ist bislang immer noch eine rein prozedurale Programmiersprache.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3525,
    "category": 16,
    "difficulty": 1,
    "text": "Welche Aussagen zu PHP sind richtig?",
    "explanation": "PHP ist eine weit verbreitete Scriptsprache bei gut 80% aller Websites und seit vielen Jahren im Web etabliert. PHP ist einfach zu erlernen, aber dennoch sehr mächtig und performant. PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL möglich macht. PHP hat sich zu einem Quasi-Standard für Server-seitige Programmiersprachen von Webanwendungen entwickelt.\n\n    \n\n    Erfunden wurde sie 1994 von Rasmus Lerdorf (ursprünglich: Personal Home Page) und besteht aus einfachen Textdateien mit .php–Endung. Mittlerweilse steht das Akronym PFP: Hypertext Preprocessor. Die Ausgabe erfolgt vielfach im HTML-Format.  \n\n    \n\n    Seit PHP Version 5 ist objektorientiertesProgrammieren möglich. Somit ist eine Klassifizierung von Objekten der reelenWelt auf einen bestimmten Kontext umsetzbar.  Vereinfacht: Funktionen/Methoden können in Klassen zusammengefasst werden, um unendlich viele Objekte (mit verschiedenen Ausprägungen) instanzierenzu können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Seit PHP Version 5 ist objektorientiertesProgrammieren möglich.",
        "solution": "true"
      },
      {
        "text": "PHP unterstützt als Ausgabeformat leider kein HTML.",
        "solution": "false"
      },
      {
        "text": "Die Idee und erste Realisierung stammt von Rasmus Lerdorf und bereits aus dem Jahr 1994.",
        "solution": "true"
      },
      {
        "text": "PHP ist eine weit verbreitete Script-Sprache mit mehr als 80% bei Web-Anwendungen.",
        "solution": "true"
      },
      {
        "text": "Es sind einfache Textdateien mit .phx-Endung.",
        "solution": "false"
      },
      {
        "text": "PHP ist ein Quasi-Standard für Client-seitige Programmiersprachen von Webanwendungen.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3520,
    "category": 13,
    "difficulty": 1,
    "text": "INSTEAD OF-Trigger sind definierbar als",
    "explanation": "INSTEAD OF-Trigger sind nur als ROW-Trigger definierbar.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "beides",
        "solution": "false"
      },
      {
        "text": "nur STATEMENT-Trigger",
        "solution": "false"
      },
      {
        "text": "nur ROW-Trigger",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3526,
    "category": 16,
    "difficulty": 1,
    "text": "Welche Aussagen zu PHP sind richtig?",
    "explanation": "PHP ist eine weit verbreitete Scriptsprache bei gut 80% aller Websites und seit vielen Jahren im Web etabliert. PHP ist einfach zu erlernen, aber dennoch sehr mächtig und performant. PHP bringt Methoden mit, die eine schnelle Implementierung mit MySQL möglich macht. PHP hat sich zu einem Quasi-Standard für Server-seitige Programmiersprachen von Webanwendungen entwickelt.\n\n    Erfunden wurde sie 1994 von Rasmus Lerdorf (ursprünglich: Personal Home Page) und besteht aus einfachen Textdateien mit .php–Endung. Mittlerweilse steht das Akronym PFP: Hypertext Preprocessor. Die Ausgabe erfolgt vielfach im HTML-Format.  \n\n    \n\n    Seit PHP Version 5 ist objektorientiertesProgrammieren möglich. Somit ist eine Klassifizierung von Objekten der reelen Welt auf einen bestimmten Kontext umsetzbar.  Vereinfacht: Funktionen/Methoden können in Klassen zusammengefasst werden, um unendlich viele Objekte (mit verschiedenen Ausprägungen) instanzierenzu können.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PHP ist eine junge Sprache, die Rasmus Lerdorf und erst im Jahr 2010.",
        "solution": "false"
      },
      {
        "text": "Es wird empfohlen für die Verwendung noch auf Version 1.0 zu warten.",
        "solution": "false"
      },
      {
        "text": "PHP erzeugt als Ausgabe i.d.R. HTML-Dateien.",
        "solution": "true"
      },
      {
        "text": "Es sind einfache Textdateien mit .php-Endung.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3545,
    "category": 8,
    "difficulty": 1,
    "text": "Bei welchen SQL-Lesezugriffen ist das Sortieren immer notwendig?",
    "explanation": "Außer bei Unterabfragen muss immer sortiert werden, um Duplikate zu erkennen.Das kostet Zeit!",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT mit Unterabfrage",
        "solution": "false"
      },
      {
        "text": "SELECT mit GROUP BY",
        "solution": "true"
      },
      {
        "text": "SELECT mit ORDER BY",
        "solution": "true"
      },
      {
        "text": "SELECT mit DISTINCT",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3589,
    "category": 6,
    "difficulty": 1,
    "text": "Mit welchen Konzepten können bei Oracle ab Version 12c Werte für künstliche Primärschlüssel generiert werden?",
    "explanation": "Neben den altbekanten Sequenzen ist bei Oracle 12c die Identity Column hinzu gekommen., siehe z.B.<a href=\"http://www.oracle.com/technetwork/database/database-technologies/rdb/0307-identity-columns-128126.pdf\">http://www.oracle.com/technetwork/database/database-technologies/rdb/0307-identity-columns-128126.pdf",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sequenz",
        "solution": "true"
      },
      {
        "text": "Identity Column",
        "solution": "true"
      },
      {
        "text": "keine von beiden",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3519,
    "category": 13,
    "difficulty": 2,
    "text": "In welchen Triggern sind die Transitionsvariablen :NEW gefüllt?",
    "explanation": ":NEW-Transitionsvariablen sind nur in ROW-Triggern für INSERT und UPDATE gefüllt und unabhängig von AFTER und BEFORE, ebenso wie in INSTEAD-OF-Triggern für diese Ereignisse.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "BEFORE UPDATE FOR EACH STATEMENT",
        "solution": "false"
      },
      {
        "text": "AFTER INSERT ROW",
        "solution": "true"
      },
      {
        "text": "INSTEAD-OF-Trigger",
        "solution": "true"
      },
      {
        "text": "AFTER DELETE ROW",
        "solution": "false"
      },
      {
        "text": "BEFORE UPDATE ROW",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3536,
    "category": 16,
    "difficulty": 1,
    "text": "Wie heißt die Methode, mit der mittels MySQLi eine SQL-Anfrage von PHP zu MySQL geschickt werden kann?",
    "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie den Funktionsnamen kleingeschrieben und ohne Klammern an.",
        "solution": "\r\n    mysqli_query\r"
      }
    ]
  },
  {
    "id": 3539,
    "category": 16,
    "difficulty": 1,
    "text": "Wie heißt die Methode, mit der mittels PDO eine SQL-Anfrage von PHP an MySQL geschickt werden kann?",
    "explanation": "<?php\n\n    function getConnection() {\n\n      $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n      $mysqluser=\"root\"; // MySQL-User angeben\n\n      $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n      $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n      $connection = new PDO(\"mysql:host=$mysqlhost;dbname=$mysqldb\", $mysqluser, $mysqldb); \n\n      $connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n      return $connection;\n\n    }\n\n    ?>\n\n     \n\n    function getApps() {\n\n      $sql = \"select * FROM apps ORDER BY name\";\n\n      try {\n\n      $db = getConnection();\n\n      $stmt = $db->query($sql); \n\n      $data = $stmt->fetchAll(PDO::FETCH_OBJ);\n\n      $db = null;\n\n      return $data;\n\n      } catch(PDOException $e) {\n\n      echo \"{\"error\":{\"text\":\". $e->getApps() .\"}}\";\n\n      }\n\n    }",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie den Funktionsnamen ohne Klammern an.",
        "solution": "\r\n    query\r"
      }
    ]
  },
  {
    "id": 3540,
    "category": 16,
    "difficulty": 1,
    "text": "Wie heißt die Methode, mit der mittels PDO eine Verbindung von PHP zu MySQL aufgebaut werden kann?",
    "explanation": "<?php\n\n    function getConnection() {\n\n      $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n      $mysqluser=\"root\"; // MySQL-User angeben\n\n      $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n      $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n      $connection = new PDO(\"mysql:host=$mysqlhost;dbname=$mysqldb\", $mysqluser, $mysqldb); \n\n      $connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n      return $connection;\n\n    }\n\n    ?>\n\n     \n\n    function getApps() {\n\n      $sql = \"select * FROM apps ORDER BY name\";\n\n      try {\n\n      $db = getConnection();\n\n      $stmt = $db->query($sql); \n\n      $data = $stmt->fetchAll(PDO::FETCH_OBJ);\n\n      $db = null;\n\n      return $data;\n\n      } catch(PDOException $e) {\n\n      echo \"{\"error\":{\"text\":\". $e->getApps() .\"}}\";\n\n      }\n\n    }",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie den Funktionsnamen ohne Klammern an.",
        "solution": "\r\n    PDO\r"
      }
    ]
  },
  {
    "id": 3527,
    "category": 16,
    "difficulty": 2,
    "text": "Ordnen Sie die nachfolgenden Schritte in die richtige Ausführungsreihenfolge (1-6):",
    "explanation": "1. Der Client schickt eine Anfrage für die Ausführung einer .php-Datei über das Internet an den Webserver.  \n\n    2. Der Webserver läd die .php-Datei von der Festplatte.\n\n    3. Der Webserver übergibt die .php-Datei an den PHP-Interpreter.  \n\n    4. Je nach php-Skript erzeugt der PHP-Interpreter eine Ausgabedatei des programmierten Formats, z.B. HTML, PDF, etc.\n\n    5. Der erzeugte Code wird an dem Webserver gegeben.\n\n    6. Der Webserver sendet den erzeugten Code an den Client.",
    "type": "text",
    "answers": [
      {
        "text": "Der Webserver übergibt die .php-Datei an den PHP-Interpreter.",
        "solution": "\r\n    3\r"
      },
      {
        "text": "Der Client schickt eine Anfrage für die Ausführung einer .php-Datei über das Internet an den Webserver.",
        "solution": "\r\n    1\r"
      },
      {
        "text": "Der Webserver sendet den erzeugten Code an den Client.",
        "solution": "\r\n    6\r"
      },
      {
        "text": "Der erzeugte Code wird an dem Webserver gegeben.",
        "solution": "\r\n    5\r"
      },
      {
        "text": "Der Webserver läd die .php-Datei von der Festplatte.",
        "solution": "\r\n    2\r"
      },
      {
        "text": "Je nach php-Skript erzeugt der PHP-Interpreter eine Ausgabedatei des programmierten Formats, z.B. HTML, PDF, etc.",
        "solution": "\r\n    4\r"
      }
    ]
  },
  {
    "id": 3528,
    "category": 16,
    "difficulty": 2,
    "text": "Ordnen Sie die nachfolgenden Schritte in die richtige Ausführungsreihenfolge (1-6):",
    "explanation": "1. Der Client schickt eine Anfrage für die Ausführung einer .php-Datei über das Internet an den Webserver.  \n\n    2. Der Webserver läd die .php-Datei von der Festplatte.\n\n    3. Der Webserver übergibt die .php-Datei an den PHP-Interpreter.  \n\n    4. Je nach php-Skript erzeugt der PHP-Interpreter eine Ausgabedatei des programmierten Formats, z.B. HTML, PDF, etc.\n\n    5. Der erzeugte Code wird an dem Webserver gegeben.\n\n    6. Der Webserver sendet den erzeugten Code an den Client.",
    "type": "text",
    "answers": [
      {
        "text": "Der Webserver übergibt die .php-Datei an den PHP-Interpreter.",
        "solution": "\r\n    3\r"
      },
      {
        "text": "Der Client schickt eine Anfrage für die Ausführung einer .php-Datei über das Internet an den Webserver.",
        "solution": "\r\n    1\r"
      },
      {
        "text": "Der Webserver sendet den erzeugten Code an den Client.",
        "solution": "\r\n    6\r"
      },
      {
        "text": "Der erzeugte Code wird an dem Webserver gegeben.",
        "solution": "\r\n    5\r"
      },
      {
        "text": "Der Webserver läd die .php-Datei von der Festplatte.",
        "solution": "\r\n    2\r"
      },
      {
        "text": "Je nach php-Skript erzeugt der PHP-Interpreter eine Ausgabedatei des programmierten Formats, z.B. HTML, PDF, etc.",
        "solution": "\r\n    4\r"
      }
    ]
  },
  {
    "id": 3550,
    "category": 14,
    "difficulty": 1,
    "text": "Welches Problem kann beim Isolationsgrad SERIALIABLE auftreten?",
    "explanation": "Der Isolationsgrad SERIALIABLE unterbindet jedes der aufgelisteten Probleme.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Keins von allen",
        "solution": "true"
      },
      {
        "text": "PHANTOM",
        "solution": "false"
      },
      {
        "text": "LOST UPDATE",
        "solution": "false"
      },
      {
        "text": "DIRTY READ",
        "solution": "false"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3533,
    "category": 16,
    "difficulty": 1,
    "text": "Wie wird die Rückgabemenge (Datensätze) einer php-Anfrage an eine MySQL-DB genannt?",
    "explanation": "in php: array\n\nin JDBC: result set\n\nin PL/SQL: cursor\n\nRelation werden Tabellen in der DB genannt.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "array",
        "solution": "true"
      },
      {
        "text": "result set",
        "solution": "false"
      },
      {
        "text": "cursor",
        "solution": "false"
      },
      {
        "text": "relation",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3548,
    "category": 4,
    "difficulty": 1,
    "text": "Welche Faktoren spielen bei der physischen Optimierung eine Rolle?",
    "explanation": "Die Anzahl der Relationen spielt für die physische Optimierung keine Rolle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Kardinalität, d.h. Größe der Relationen",
        "solution": "true"
      },
      {
        "text": "Selektivität, d.h. Verteilung der Dateien in den Spalten der Relationen",
        "solution": "true"
      },
      {
        "text": "Anzahl der Relationen eines Datenbankschemas",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3517,
    "category": 13,
    "difficulty": 2,
    "text": "INSTEAD OF-Trigger sind für welche der folgenden DB-Objekte definierbar",
    "explanation": "INSTEAD OF-Trigger sind nur für Sichten definiert. Ggf. sind dann Anwendern die DML-Rechte auf die Tabelle mit REVOKE zu entziehen und auf der Sicht mit GRANT einzuräumen. Trigger sind nie auf andere Trigger definierbar.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Sichten (VIEW)",
        "solution": "true"
      },
      {
        "text": "Tabellen (TABLE)",
        "solution": "false"
      },
      {
        "text": "STATEMENT-Trigger",
        "solution": "false"
      },
      {
        "text": "ROW-Trigger",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3547,
    "category": 4,
    "difficulty": 1,
    "text": "Welche Optimierung ist eine Anwendung der relationalen Algebra?",
    "explanation": "Die logische Optimierung berücksichtigt die Operatoren der relationalen Algebra, die physische Optinierung die Größe der Relationen und  Statistiken.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Logische Optimierung",
        "solution": "true"
      },
      {
        "text": "Physische Optimierung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3521,
    "category": 16,
    "difficulty": 1,
    "text": "Welche Aussagen zu MySQL sind richtig?",
    "explanation": "Während ORACLE den Markt im Enterprise-Segment anführt, führt MySQL im Web. MySQL ist eine etablierte und kostenfreie Alternative für „kleinere“ Datenbankanwendungen. MySQL ist einfach zu installieren und zu administrieren. MySQL gehört seit dem Verkauf von SUN Microsystems auch zum Unternehmen ORACLE, ist aber weiterhin OpenSource.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "MySQL führt den Markt im Web-Segment an.",
        "solution": "true"
      },
      {
        "text": "MySQL ist einfach zu installieren und zu administrieren.",
        "solution": "true"
      },
      {
        "text": "Seid MySQL nun zu Oracle gehört ist die DB auch nur noch kostenpflichtig einsetzbar.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3532,
    "category": 16,
    "difficulty": 2,
    "text": "Mit welchen Schluesselwoertern wird bei mysqli die Feherbehandlung (error handling) programmiert?",
    "explanation": "<?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "on problem(...);",
        "solution": "false"
      },
      {
        "text": "or die ( ... );",
        "solution": "true"
      },
      {
        "text": "catch (...);",
        "solution": "false"
      },
      {
        "text": "on dberror (...);",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3687,
    "category": 14,
    "difficulty": 1,
    "text": "Bei welcher Art von Sperren können Deadlocks entstehen?",
    "explanation": "Siehe http://lwibs01.gm.fh-koeln.de/wikis/wiki_db/index.php?n=Datenbanken.DEADLOCK",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "keine der anderen",
        "solution": "false"
      },
      {
        "text": "Lesesperre",
        "solution": "false"
      },
      {
        "text": "Schreibsperre",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3551,
    "category": 14,
    "difficulty": 1,
    "text": "Welche Isolationsgrade unterstützt Oracle?",
    "explanation": "Oracle unterstützt nur die Isolationsgrade  SERIALIZABLE und READ COMITTED.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Keins von allen",
        "solution": "false"
      },
      {
        "text": "READ UNCOMMITTED",
        "solution": "false"
      },
      {
        "text": "READ COMMITTED",
        "solution": "true"
      },
      {
        "text": "REPEATABLE READ",
        "solution": "false"
      },
      {
        "text": "SERIALIZABLE",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3535,
    "category": 16,
    "difficulty": 2,
    "text": "Die MySQLi-Funktion zum Ausführen von SQL-Befehlen \"mysqli_query\" wird mit welchen Parametern aufgerufen?",
    "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "<CONNECTION>  / Verbindung",
        "solution": "true"
      },
      {
        "text": "<USER>  /  Benutzer",
        "solution": "false"
      },
      {
        "text": "<DATABASE>  /  Datenbankname",
        "solution": "false"
      },
      {
        "text": "<RELATION>  / Tabellenname",
        "solution": "false"
      },
      {
        "text": "<QUERY>  / Anfrage",
        "solution": "true"
      },
      {
        "text": "<HOST> / MySQL-Datenbankserver",
        "solution": "false"
      },
      {
        "text": "/ Passwort",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3546,
    "category": 8,
    "difficulty": 1,
    "text": "Bei welcher Join-Variante wird jedes Element mit jedem verglichen?",
    "explanation": "\n    Das ist die Definition des Nested Loop Joins!",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Merge Join",
        "solution": "false"
      },
      {
        "text": "Hash Join",
        "solution": "false"
      },
      {
        "text": "Nested Loop Join",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3549,
    "category": 14,
    "difficulty": 1,
    "text": "Bei welchem Problem werden nicht freigegebene Änderungen (ohne commit) gelesen?",
    "explanation": "Beim  LOST UPDATE Problem handelt es sich um das Überschreiben von geänderten Daten. Bei allen anderen Problemen werden nicht freigegebene Änderungen in unterschiedlicher Weise verwendet.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "PHANTOM",
        "solution": "true"
      },
      {
        "text": "LOST UPDATE",
        "solution": "false"
      },
      {
        "text": "DIRTY READ",
        "solution": "true"
      },
      {
        "text": "NON REPEATABLE READ",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3530,
    "category": 16,
    "difficulty": 1,
    "text": "Wie heißt die Methode, mit der mittels MySQLi eine Verbindung von PHP zu MySQL aufgebaut werden kann?",
    "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie den Funktionsnamen kleingeschrieben und ohne Klammern an.",
        "solution": "\r\n    mysqli_connect\r"
      }
    ]
  },
  {
    "id": 3531,
    "category": 16,
    "difficulty": 3,
    "text": "Wie heißt die Methode und deren Parameter, mit der mittels MySQLi eine Verbindung von PHP zu MySQL aufgebaut werden kann?",
    "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie den Funktionsnamen kleingeschrieben an. Die Parameter großgeschrieben in spitzen Klammern, alles ohne trennende Leerzeichen und abschließendem Semikolon",
        "solution": "\r\n    mysqli_connect(<HOST>,<USER>,,<DATABASE>)\r"
      }
    ]
  },
  {
    "id": 3534,
    "category": 16,
    "difficulty": 2,
    "text": "Die MySQLi-Funktion zum Verbindungsaufbau \"mysqli_connect\" wird mit welchen Parametern aufgerufen?",
    "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "<USER>  /  Benutzer",
        "solution": "true"
      },
      {
        "text": "<DATABASE>  /  Datenbankname",
        "solution": "true"
      },
      {
        "text": "<RELATION>  / Tabellenname",
        "solution": "false"
      },
      {
        "text": "<QUERY>  / Anfrage",
        "solution": "false"
      },
      {
        "text": "<HOST> / MySQL-Datenbankserver",
        "solution": "true"
      },
      {
        "text": "/ Passwort",
        "solution": "true"
      },
      {
        "text": "<CONNECTION>  / Verbindung",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3768,
    "category": 5,
    "difficulty": 1,
    "text": "Gegeben sei eine Relation R(V, W, X, Y) mit funktionalen Abhängigkeiten V, Y -> W, X und W -> X.  Welche Zerlegung entspricht einer verlustfreien und abhängigkeitstreuen Zerlegung in die 2NF?",
    "explanation": "V und Y sind schon der Primärschlüssel der Relation, da alle anderen Attribute von ihnen abhängen, und W -> X ist eine transitionale FD, womit sich ergibt, dass 1. NF = 2. NF.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "R={V,W,X,Y}",
        "solution": "true"
      },
      {
        "text": "R1(V, Y) und R2(W,X)",
        "solution": "false"
      },
      {
        "text": "R1(V, W,Y) und R2(W,X)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3537,
    "category": 16,
    "difficulty": 1,
    "text": "Wie heißt die Methode, mit der mittels MySQLi eine Ergebnismenge mit Datensätzen aus MySQL in PHP verarbeitet werden kann?",
    "explanation": "<div style=\"margin-left:.38in;\">\n     \n<div style=\"margin-left:.38in;\">\n    // 1. Beispiel:  Verbindungsaufbau mit mysqli:\n\n    $connection = mysqli_connect(\n\n      <HOST>, <USER>, , <DATABASE>);\n\n    $query = mysqli_query($connection, <SQL>);\n\n    while ($data = mysqli_fetch_array($query)){\n\n       // Verarbeitung..\n\n    }\n\n     \n\n    // 2. Beispiel\n\n    <?php\n\n    $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n    $mysqluser=\"root\"; // MySQL-User angeben\n\n    $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n    $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n    $connection=mysqli_connect($mysqlhost, $mysqluser, $mysqlpwd, $mysqldb) or die(\"DB Connection ERROR!\");\n\n    ?>",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie den Funktionsnamen kleingeschrieben und ohne Klammern an.",
        "solution": "\r\n    mysqli_fetch_array\r"
      }
    ]
  },
  {
    "id": 3538,
    "category": 16,
    "difficulty": 1,
    "text": "Wie heißt die Methode, mit der mittels PDO eine Ergebnismenge mit Datensätzen aus MySQL in PHP verarbeitet werden kann?",
    "explanation": "<?php\n\n    function getConnection() {\n\n      $mysqlhost=\"localhost\"; // MySQL-Host angeben\n\n      $mysqluser=\"root\"; // MySQL-User angeben\n\n      $mysqlpwd=\"xxxxxx\"; // Passwort angeben\n\n      $mysqldb=\"myDatabase\"; // Gewuenschte Datenbank angeben\n\n      $connection = new PDO(\"mysql:host=$mysqlhost;dbname=$mysqldb\", $mysqluser, $mysqldb); \n\n      $connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n      return $connection;\n\n    }\n\n    ?>\n\n     \n\n    function getApps() {\n\n      $sql = \"select * FROM apps ORDER BY name\";\n\n      try {\n\n      $db = getConnection();\n\n      $stmt = $db->query($sql); \n\n      $data = $stmt->fetchAll(PDO::FETCH_OBJ);\n\n      $db = null;\n\n      return $data;\n\n      } catch(PDOException $e) {\n\n      echo \"{\"error\":{\"text\":\". $e->getApps() .\"}}\";\n\n      }\n\n    }",
    "type": "text",
    "answers": [
      {
        "text": "Geben Sie den Funktionsnamen ohne Klammern an.",
        "solution": "\r\n    fetchAll\r"
      }
    ]
  },
  {
    "id": 3541,
    "category": 16,
    "difficulty": 1,
    "text": "Welche Aussagen über MySQL-Prozeduren und Trigger sind wahr?",
    "explanation": "<div style=\"margin-left:.38in;\">\n    MySQL 5.1 kennt auch gespeicherte Routinen (Prozeduren und Funktionen).\n<div style=\"margin-left:.38in;\">\n    MySQL verwendet die Syntax für gespeicherte Routinen gemäß dem SQL:2003-Standard. Zwischen der prozeduralen Sprache in MySQL und PL/SQL von Oracle gibt es viele Analogiien, aber doch auch so einige Unterschiede.\n<div style=\"margin-left:.38in;\">\n    Wie bei ORACLE gibt es auch bei MySQL das Cursorkonzept, sogar die Syntax ist diesbezüglich weitestgehend gleich.\n<div style=\"margin-left:.38in;\">\n    Auch Trigger gibt es in MySQL. Nur das in MySQL die Trigger ausschließlich für ein Ereignis definiert werden können, eine OR-Option bei den Events gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wie bei ORACLE gibt es auch bei MySQL das Cursorkonzept, sogar die Syntax ist diesbezüglich weitestgehend gleich.",
        "solution": "true"
      },
      {
        "text": "MySQL-Trigger können nur für ein Ereignis definiert werden (keine OR-Option wie bei Oracle).",
        "solution": "true"
      },
      {
        "text": "In MySQL können auch Trigger, Prozeduren und Funktionen als Datenbankobjekte programmiert werden.",
        "solution": "true"
      },
      {
        "text": "Das Trigger-Konzept ist völlig analog zwischen MySQL und Oracle.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3542,
    "category": 16,
    "difficulty": 1,
    "text": "Welche Aussagen über MySQL-Prozeduren und Trigger sind wahr?",
    "explanation": "<div style=\"margin-left:.38in;\">\n    MySQL 5.1 kennt auch gespeicherte Routinen (Prozeduren und Funktionen).\n<div style=\"margin-left:.38in;\">\n    MySQL verwendet die Syntax für gespeicherte Routinen gemäß dem SQL:2003-Standard. Zwischen der prozeduralen Sprache in MySQL und PL/SQL von Oracle gibt es viele Analogiien, aber doch auch so einige Unterschiede.\n<div style=\"margin-left:.38in;\">\n    Wie bei ORACLE gibt es auch bei MySQL das Cursorkonzept, sogar die Syntax ist diesbezüglich weitestgehend gleich.\n<div style=\"margin-left:.38in;\">\n    Auch Trigger gibt es in MySQL. Nur das in MySQL die Trigger ausschließlich für ein Ereignis definiert werden können, eine OR-Option bei den Events gibt es nicht.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Wie bei ORACLE gibt es auch bei MySQL das Cursorkonzept, sogar die Syntax ist diesbezüglich weitestgehend gleich.",
        "solution": "true"
      },
      {
        "text": "Die prozedurale Datenbankprogrammiersprache von MySQL weist trotz aller Ähnlichkeiten doch auch so einige Unterschiede auf.",
        "solution": "true"
      },
      {
        "text": "In MySQL können auch Trigger, Prozeduren und Funktionen und Packages als Datenbankobjekte programmiert werden.",
        "solution": "false"
      },
      {
        "text": "MySQL-Trigger können für mehrere Ereignisse definiert werden (OR-Option wie bei Oracle).",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3543,
    "category": 16,
    "difficulty": 2,
    "text": "Nummerieren Sie die nachfolgenden Befehle einer Cursor-Verarbeitung in MySQL gemäß ihrer Ausführungsreihenfolge von 1 - 4 durch.",
    "explanation": "CREATE PROCEDURE KundenUpgrade()\n\n    BEGIN\n\n        DECLARE val INT;\n\n        DECLARE finished INT DEFAULT 0;\n\n        DECLARE kundenCursor CURSOR FOR SELECT kunde_id FROM kunden; -- Cursordefinition\n\n        DECLARE CONTINUE HANDLER FOR SQLSTATE \"02000\" SET finished = 1;\n\n        OPEN kundenCursor; -- Cursor öffnen\n\n            REPEAT\n\n               FETCH kundenCursor INTO val;\n\n               IF NOT finished THEN\n\n                   CALL KundenStatusByID(val); -- Ruft für jeden Kunden die Proz. auf\n\n      END IF;\n\n            UNTIL finished END REPEAT;   \n\n            CLOSE kundenCursor; -- Cursor schließen\n\n    END //\n\n    DELIMITER ;",
    "type": "text",
    "answers": [
      {
        "text": "CLOSE cursorname;",
        "solution": "\r\n    4\r"
      },
      {
        "text": "DECLARE cursorname  CURSOR FOR SELECT ...  ;",
        "solution": "\r\n    1\r"
      },
      {
        "text": "OPEN cursorname;",
        "solution": "\r\n    2\r"
      },
      {
        "text": "FETCH cursorname INTO variable;",
        "solution": "\r\n    3\r"
      }
    ]
  },
  {
    "id": 3544,
    "category": 1,
    "difficulty": 1,
    "text": "Welcher Schnittstelle der 5-Schichten-Architektur eines DBMS werden SQL-Befehle übergeben?",
    "explanation": "Das ist die Definition der mengenorientierten Schnittstelle.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Interne Satzschnittstelle",
        "solution": "false"
      },
      {
        "text": "Systempufferschnittstelle",
        "solution": "false"
      },
      {
        "text": "Geräteschnittstelle",
        "solution": "false"
      },
      {
        "text": "Dateischnittstelle",
        "solution": "false"
      },
      {
        "text": "Mengenorientierte Schnittstelle",
        "solution": "true"
      },
      {
        "text": "Satzorientierte Schnittstelle",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3569,
    "category": 12,
    "difficulty": 1,
    "text": "Ein geöffneter CURSOR löst eine EXCEPTION aus, wenn eine FETCH-Anweisung keine Zeilen liefert.",
    "explanation": "Es wird nur die CURSOR%NOTFOUND Variable gesetzt. Eine Exception würde ja bedeuten, dass die Programmausführung abbricht und in die Exception springt",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "stimmt nicht",
        "solution": "true"
      },
      {
        "text": "stimmt",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3645,
    "category": 3,
    "difficulty": 1,
    "text": "Was versteht man unter Spezialisierung im EERM?",
    "explanation": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.\n\n\n    Die abgeleiteten Typen haben dann neben den vom Supertyp ererbten Attributen eigene Attribute, die nur den Subtyp beschreiben.\n\n\n \n\nUnter Generalisierung versteht man den Prozess der Gewinnung eines Supertyps aus mehreren ähnlichen Subtypen.\n\n\n    Der neue Supertyp wird dann durch diejenigen Attribute beschrieben, die den ähnlichen Subtypen gemeinsam sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist der Prozess der Gewinnung eines Supertyps aus mehreren ähnlichen Subtypen.",
        "solution": "false"
      },
      {
        "text": "Keine von beiden Antworten ist korrekt.",
        "solution": "false"
      },
      {
        "text": "Das ist der Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3646,
    "category": 3,
    "difficulty": 1,
    "text": "Was versteht man unter Generalisierung im EERM?",
    "explanation": "Unter einer Spezialisierung versteht man den Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.\n\n    –Die abgeleiteten Typen haben dann neben den vom Supertyp ererbten Attributen eigene Attribute, die nur den Subtyp beschreiben.\n\n     \n\n    Unter Generalisierung versteht man den Prozess der Gewinnung eines Supertyps aus mehreren ähnlichen Subtypen.\n\n    –Der neue Supertyp wird dann durch diejenigen Attribute beschrieben, die den ähnlichen Subtypen gemeinsam sind.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Das ist der Prozess der Gewinnung eines Supertyps aus mehreren ähnlichen Subtypen.",
        "solution": "true"
      },
      {
        "text": "Keine von beiden Antworten ist korrekt.",
        "solution": "false"
      },
      {
        "text": "Das ist der Prozess der Gewinnung von Subtypen aus einem gegebenen Supertyp.",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3688,
    "category": 8,
    "difficulty": 1,
    "text": "Betrachten Sie eine Tabelle test (Nr number primary key, Beschreibung varchar(100)), die 100.000 Datensatze beinhaltet. Welche Abfrage ist schneller?",
    "explanation": "Durch den Primary Key wird ein Index angelegt, der durch die like-Abfrage nicht genutzt werden kann.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "SELECT * from Test where nr = 4711;",
        "solution": "true"
      },
      {
        "text": "SELECT * from TEST where nr like \"4711%\";",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3769,
    "category": 5,
    "difficulty": 1,
    "text": "Gegeben sei eine Relation R(V, W, X, Y) mit funktionalen Abhängigkeiten V, Y -> W, X und\n\nW -> X.   Welche Zerlegung entspricht einer verlustfreien und abhängigkeitstreuen Zerlegung in die 3NF?",
    "explanation": "V und Y sind schon der Primärschlüssel der Relation, da alle anderen Attribute von ihnen abhängen. Außerdem gibt es eine transitive Abhängikeit W -> X.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "R={V,W,X,Y}",
        "solution": "false"
      },
      {
        "text": "R12(V, Y) und R2(W,X)",
        "solution": "false"
      },
      {
        "text": "R12(V, W,Y) und R2(W,X)",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3758,
    "category": 5,
    "difficulty": 1,
    "text": "Es sei eine Relation R(X, Y, Z) gegeben mit einem zusammengesetzten Primärschlüssel auf X, Y und einem eindeutigen Zweitschlüssel auf Z sowie einem gespeicherten Datensatz : (2, \"a\", 9).\n\nWelche weiteren Datensätze lassen sich zu diesem hinzufügen?",
    "explanation": "Bitte beachten Sie die Eindeutigkeit des Primärschlüssels und des Zweitschlüssels! (Unique Key)",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "(5, \"d\", 3)",
        "solution": "true"
      },
      {
        "text": "(2, \"a\", 5)",
        "solution": "false"
      },
      {
        "text": "(2, \"a\", 9)",
        "solution": "false"
      },
      {
        "text": "(2, \"s\", 4)",
        "solution": "true"
      },
      {
        "text": "(9, \"a\", 2)",
        "solution": "true"
      },
      {
        "text": "(4, \"s\", 9)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3770,
    "category": 5,
    "difficulty": 1,
    "text": "Betrachten Sie eine Relation R(X, Y, Z, V, W, T) mit den funktionalen Abhängigkeiten\n\nX, V -> Z   und   Z, Y-> W   und   Y -> V, T.    Welche Attributkombination ist ein (minimaler) eindeutiger Schlüssel?\n\nBitte die Attribute in alphabetischer Reihenfolge durch Kommas getrennt und ohne Klammern aufschreiben!",
    "explanation": "Alle anderen Attribute lassen sich von X und Y ableiten!",
    "type": "text",
    "answers": [
      {
        "text": "Das sind die Attribute:",
        "solution": "X , Y\r"
      }
    ]
  },
  {
    "id": 3773,
    "category": 5,
    "difficulty": 2,
    "text": "Gegeben sei eine Relation R(V, W, X, Y, Z) mit funktionalen Abhängigkeiten V -> W und Y -> X und\n\nV, Y -> Z.   Welche Zerlegung entspricht einer verlustfreien und abhängigkeitstreuen Zerlegung in die 3NF?",
    "explanation": "V und Y sind schon der Primärschlüssel der Relation, da alle anderen Attribute von ihnen abhängen und die ersten zwei FDs sind partielle bzw. die letzte eine volle Abhängikeit vom zusammengestzten Primärschlüssel. Da transitive Abhängigkeiten fehlen, gilt hier 2.NF = 3.NF.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "R={V,W,X,Y, Z}",
        "solution": "false"
      },
      {
        "text": "R1(V, W),   R2(Y,X),   R3(V,Y,Z)",
        "solution": "true"
      },
      {
        "text": "R1(V,Y,Z) und R2(V,W,Y,X)",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3778,
    "category": 3,
    "difficulty": 1,
    "text": "Bei welcher/n Entity-Mengen sind bei m:n-Beziehungen die Fremdschlüssel einzutragen?",
    "explanation": "Bei einer m:n-Beziehung werden dei Fremdschlüssel später in einer Zwischentabelle ausgelagert.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Nur m-Ende",
        "solution": "false"
      },
      {
        "text": "nur n-Ende",
        "solution": "false"
      },
      {
        "text": "Beide Enden",
        "solution": "false"
      },
      {
        "text": "Keine Fremdschlüssel  in den Entity-Mengen",
        "solution": "true"
      }
    ]
  },
  {
    "id": 3779,
    "category": 5,
    "difficulty": 1,
    "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abhängigkeiten:  A-> B, C, E     C -> E  und   D -> F  \n\nWelche Attributkombination ist ein (minimaler) eindeutiger Schlüssel?",
    "explanation": "Von A hängen alle Attribute außer F ab. Daher braucht man neben A noch D für den Primärschlüssel.",
    "type": "text",
    "answers": [
      {
        "text": "Der Primärschlüssel ist:",
        "solution": "AD\r"
      }
    ]
  },
  {
    "id": 3780,
    "category": 5,
    "difficulty": 1,
    "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abhängigkeiten (FD):  A-> B, C, E     C -> E  und   D -> F , sowie dem Primäraschlüssel AD.  Welche davon sind bezogen auf den gefundenen Primärschlüssel transitive FDs?",
    "explanation": "C gehört nicht zum Primärschlüssel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es gibt keine",
        "solution": "false"
      },
      {
        "text": "A -> B, C, E",
        "solution": "false"
      },
      {
        "text": "C -> E",
        "solution": "true"
      },
      {
        "text": "D-> F",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3781,
    "category": 5,
    "difficulty": 1,
    "text": "Betrachten Sie eine RelationR(A, B, C, D, E, F) mit den funktionalen Abhängigkeiten (FD):  A-> B, C, E     C -> E  und   D -> F , sowie dem Primäraschlüssel AD.  Welche davon sind bezogen auf den gefundenen Primärschlüssel partielle FDs?",
    "explanation": "A und D gehören zum Primärschlüssel.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "Es gibt keine",
        "solution": "false"
      },
      {
        "text": "A -> B, C, E",
        "solution": "true"
      },
      {
        "text": "C -> E",
        "solution": "false"
      },
      {
        "text": "D-> F",
        "solution": "false"
      }
    ]
  },
  {
    "id": 3774,
    "category": 5,
    "difficulty": 2,
    "text": "Gegeben sei eine Relation R(V, W, X, Y, Z) mit funktionalen Abhängigkeiten V -> W und Y -> X und\n\nV, Y -> Z.   Welche Zerlegung entspricht einer verlustfreien und abhängigkeitstreuen Zerlegung in die 2NF?",
    "explanation": "V und Y sind schon der Primärschlüssel der Relation, da alle anderen Attribute von ihnen abhängen und die ersten zwei FDs sind partielle bzw. die letzte eine volle Abhängikeit vom zusammengesetztn Primärschlüssel. Da transitive Abhängigkeiten fehlen, gilt hier 2.NF = 3.NF.",
    "type": "multiple-choice",
    "answers": [
      {
        "text": "R={V,W,X,Y, Z}",
        "solution": "false"
      },
      {
        "text": "R1(V, W),   R2(Y,X),   R3(V,Y,Z)",
        "solution": "true"
      },
      {
        "text": "R1(V,Y,Z) und R2(V,W,Y,X)",
        "solution": "false"
      }
    ]
  }
]